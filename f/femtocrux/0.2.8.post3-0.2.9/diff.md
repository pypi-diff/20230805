# Comparing `tmp/femtocrux-0.2.8.post3-py3-none-any.whl.zip` & `tmp/femtocrux-0.2.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,23 @@
-Zip file size: 18632 bytes, number of entries: 21
--rwxr-xr-x  2.0 unx     1389 b- defN 23-Jul-23 00:03 femtocrux/ENV_REQUIREMENTS.sh
--rw-r--r--  2.0 unx      308 b- defN 23-Jul-23 00:03 femtocrux/PY_REQUIREMENTS
--rw-r--r--  2.0 unx        8 b- defN 23-Jul-23 00:03 femtocrux/VERSION
--rw-r--r--  2.0 unx      100 b- defN 23-Jul-23 00:03 femtocrux/__init__.py
--rw-r--r--  2.0 unx      162 b- defN 23-Jul-23 00:03 femtocrux/version.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jul-23 00:03 femtocrux/client/__init__.py
--rw-r--r--  2.0 unx    21138 b- defN 23-Jul-23 00:03 femtocrux/client/client.py
--rw-r--r--  2.0 unx      168 b- defN 23-Jul-23 00:03 femtocrux/grpc/__init__.py
--rw-r--r--  2.0 unx     4340 b- defN 23-Jul-23 00:07 femtocrux/grpc/compiler_service_pb2.py
--rw-r--r--  2.0 unx     7002 b- defN 23-Jul-23 00:07 femtocrux/grpc/compiler_service_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jul-23 00:03 femtocrux/server/__init__.py
--rw-r--r--  2.0 unx      609 b- defN 23-Jul-23 00:03 femtocrux/server/exceptions.py
--rw-r--r--  2.0 unx     1606 b- defN 23-Jul-23 00:03 femtocrux/server/healthcheck.py
--rw-r--r--  2.0 unx     8620 b- defN 23-Jul-23 00:03 femtocrux/server/server.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jul-23 00:03 femtocrux/util/__init__.py
--rw-r--r--  2.0 unx     1086 b- defN 23-Jul-23 00:03 femtocrux/util/utils.py
--rw-r--r--  2.0 unx       36 b- defN 23-Jul-23 00:07 femtocrux-0.2.8.post3.dist-info/LICENSE
--rw-r--r--  2.0 unx     2128 b- defN 23-Jul-23 00:07 femtocrux-0.2.8.post3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-23 00:07 femtocrux-0.2.8.post3.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 23-Jul-23 00:07 femtocrux-0.2.8.post3.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1757 b- defN 23-Jul-23 00:07 femtocrux-0.2.8.post3.dist-info/RECORD
-21 files, 50559 bytes uncompressed, 15742 bytes compressed:  68.9%
+Zip file size: 18454 bytes, number of entries: 21
+-rwxr-xr-x  2.0 unx     1389 b- defN 23-Aug-04 22:56 femtocrux/ENV_REQUIREMENTS.sh
+-rw-r--r--  2.0 unx      308 b- defN 23-Aug-04 22:56 femtocrux/PY_REQUIREMENTS
+-rw-r--r--  2.0 unx        6 b- defN 23-Aug-04 22:56 femtocrux/VERSION
+-rw-r--r--  2.0 unx      271 b- defN 23-Aug-04 22:56 femtocrux/__init__.py
+-rw-r--r--  2.0 unx      164 b- defN 23-Aug-04 22:56 femtocrux/version.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Aug-04 22:56 femtocrux/client/__init__.py
+-rw-r--r--  2.0 unx    21215 b- defN 23-Aug-04 22:56 femtocrux/client/client.py
+-rw-r--r--  2.0 unx      169 b- defN 23-Aug-04 22:56 femtocrux/grpc/__init__.py
+-rw-r--r--  2.0 unx     4340 b- defN 23-Aug-04 23:00 femtocrux/grpc/compiler_service_pb2.py
+-rw-r--r--  2.0 unx     7002 b- defN 23-Aug-04 23:00 femtocrux/grpc/compiler_service_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Aug-04 22:56 femtocrux/server/__init__.py
+-rw-r--r--  2.0 unx      609 b- defN 23-Aug-04 22:56 femtocrux/server/exceptions.py
+-rw-r--r--  2.0 unx     1565 b- defN 23-Aug-04 22:56 femtocrux/server/healthcheck.py
+-rw-r--r--  2.0 unx     7928 b- defN 23-Aug-04 22:56 femtocrux/server/server.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Aug-04 22:56 femtocrux/util/__init__.py
+-rw-r--r--  2.0 unx     1003 b- defN 23-Aug-04 22:56 femtocrux/util/utils.py
+-rw-r--r--  2.0 unx       36 b- defN 23-Aug-04 23:00 femtocrux-0.2.9.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2122 b- defN 23-Aug-04 23:00 femtocrux-0.2.9.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Aug-04 23:00 femtocrux-0.2.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 23-Aug-04 23:00 femtocrux-0.2.9.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1727 b- defN 23-Aug-04 23:00 femtocrux-0.2.9.dist-info/RECORD
+21 files, 49956 bytes uncompressed, 15624 bytes compressed:  68.7%
```

## zipnote {}

```diff
@@ -42,23 +42,23 @@
 
 Filename: femtocrux/util/__init__.py
 Comment: 
 
 Filename: femtocrux/util/utils.py
 Comment: 
 
-Filename: femtocrux-0.2.8.post3.dist-info/LICENSE
+Filename: femtocrux-0.2.9.dist-info/LICENSE
 Comment: 
 
-Filename: femtocrux-0.2.8.post3.dist-info/METADATA
+Filename: femtocrux-0.2.9.dist-info/METADATA
 Comment: 
 
-Filename: femtocrux-0.2.8.post3.dist-info/WHEEL
+Filename: femtocrux-0.2.9.dist-info/WHEEL
 Comment: 
 
-Filename: femtocrux-0.2.8.post3.dist-info/top_level.txt
+Filename: femtocrux-0.2.9.dist-info/top_level.txt
 Comment: 
 
-Filename: femtocrux-0.2.8.post3.dist-info/RECORD
+Filename: femtocrux-0.2.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## femtocrux/VERSION

```diff
@@ -1 +1 @@
-0.2.8-3
+0.2.9
```

## femtocrux/__init__.py

```diff
@@ -1,3 +1,6 @@
 from .client.client import CompilerClient, TFLiteModel, FQIRModel
 from .version import __version__
 
+# PEP 8 definiton of public API
+# https://peps.python.org/pep-0008/#public-and-internal-interfaces
+__all__ = ["CompilerClient", "TFLiteModel", "FQIRModel", "__version__"]
```

## femtocrux/version.py

```diff
@@ -1,5 +1,7 @@
 def _get_dir():
     import pathlib
+
     return pathlib.Path(__file__).parent.resolve()
 
-__version__ = (_get_dir() / 'VERSION').read_text(encoding='utf-8').strip()
+
+__version__ = (_get_dir() / "VERSION").read_text(encoding="utf-8").strip()
```

## femtocrux/client/client.py

```diff
@@ -20,537 +20,578 @@
 # GRPC artifacts
 import femtocrux.grpc.compiler_service_pb2 as cs_pb2
 import femtocrux.grpc.compiler_service_pb2_grpc as cs_pb2_grpc
 
 # Docker info
 __docker_registry__ = "ghcr.io"
 
+
 def __get_docker_image_name__() -> str:
     """
     Returns the docker image name. For testing, override with the
     FEMTOCRUX_SERVER_IMAGE_NAME environment variable.
     """
     try:
         return os.environ["FEMTOCRUX_SERVER_IMAGE_NAME"]
     except KeyError:
         from femtocrux.version import __version__
+
         ORG = "femtosense"
         IMAGE = "femtocrux"
         remote_image_name = "%s/%s/%s:%s" % (
-            __docker_registry__, 
-            ORG, 
-            IMAGE, 
-            __version__
+            __docker_registry__,
+            ORG,
+            IMAGE,
+            __version__,
         )
         return remote_image_name
 
+
 __docker_image_name__ = __get_docker_image_name__()
 
+
 # Set up logging
 def __init_logger__():
-    """ Init a basic logger to stderr. """
+    """Init a basic logger to stderr."""
     logger = logging.getLogger(__name__)
     logger.setLevel(logging.INFO)
     formatter = logging.Formatter()
     handler = logging.StreamHandler()
     handler.setFormatter(formatter)
     logger.addHandler(handler)
     return logger
 
+
 logger = __init_logger__()
 
+
 def __env_var_to_bool__(varname: str, default: bool = False) -> bool:
-    """ Parse an environment varaible as a boolean. """
+    """Parse an environment varaible as a boolean."""
     try:
         value = os.environ[varname]
     except KeyError:
         return default
 
     value_lower = value.lower()
-    if value_lower in {'yes', '1', 'true'}:
+    if value_lower in {"yes", "1", "true"}:
         return True
-    elif value_lower in {'no', '0', 'false'}:
+    elif value_lower in {"no", "0", "false"}:
         return False
     else:
-        raise OSError("Failed to parse value of environment variable %s: '%s'" % (
-            varname, value
-            )
+        raise OSError(
+            "Failed to parse value of environment variable %s: '%s'" % (varname, value)
         )
 
+
 class Model:
-    """ 
-    Base class wrapping any model to be compiled by femtocrux. Should not be instantiated directly. Instead, use one of its child classes like :class:`~femtocrux.client.client.FQIRModel` or :class:`~femtocrux.client.client.TFLiteModel`.
     """
+    Base class wrapping any model to be compiled by femtocrux. Should not be
+    instantiated directly. Instead, use one of its child classes like
+    :class:`~femtocrux.client.client.FQIRModel` or
+    :class:`~femtocrux.client.client.TFLiteModel`.
+    """
+
     def __get_message__(self, options: dict = {}) -> cs_pb2.model:
         # Format the options
         options_struct = google.protobuf.struct_pb2.Struct()
         options_struct.update(options)
 
         # Construct the model with IR
         return cs_pb2.model(
-            **{self.__ir_name__: self.__get_ir__()},
-            options = options_struct
+            **{self.__ir_name__: self.__get_ir__()}, options=options_struct
         )
 
     @property
     def __ir_name__(self) -> str:
         """
-            Subclass overrides this to tell which 'ir' field is being returned.
+        Subclass overrides this to tell which 'ir' field is being returned.
         """
         return NotImplementedError("Subclass must override with IR type.")
 
-
     def __get_ir__(self) -> Tuple[str, Any]:
         """
-            Subclass overrides this to implement the 'ir' field of the model's 
-            grpc message.
+        Subclass overrides this to implement the 'ir' field of the model's
+        grpc message.
         """
         raise NotImplementedError("Must be defined by subclass")
 
+
 @dataclass
 class FQIRModel(Model):
     """
-        Wraps an FQIR model to be compiled by femtocrux.
+    Wraps an FQIR model to be compiled by femtocrux.
 
-        :type graph_proto: fmot.fqir.GraphProto, required
-        :param graph_proto: The traced FQIR model.
+    :type graph_proto: fmot.fqir.GraphProto, required
+    :param graph_proto: The traced FQIR model.
 
-        :type batch_dim: int, optional
-        :param batch_dim: The batch dimension to be squeezed from all inputs.
+    :type batch_dim: int, optional
+    :param batch_dim: The batch dimension to be squeezed from all inputs.
 
-        :type sequence_dim: int, optional
-        :param sequence_dim: The sequence dimension to squeezed from all inputs.
+    :type sequence_dim: int, optional
+    :param sequence_dim: The sequence dimension to squeezed from all inputs.
     """
 
     graph_proto: GraphProto = None
     batch_dim: int = None
     sequence_dim: int = None
 
     @property
     def __ir_name__(self) -> str:
-        return 'fqir'
+        return "fqir"
 
     def __get_ir__(self) -> Any:
         # Serialize FQIR via pickle
         model = pickle.dumps(self.graph_proto)
 
         # Send the serialized model
         return cs_pb2.fqir(
-            model = model,
-            batch_dim = self.batch_dim,
-            sequence_dim = self.sequence_dim,
+            model=model,
+            batch_dim=self.batch_dim,
+            sequence_dim=self.sequence_dim,
         )
 
+
 @dataclass
 class TFLiteModel(Model):
     """
-        Wraps a TFLite model to be compiled by femtocrux.
+    Wraps a TFLite model to be compiled by femtocrux.
 
-        :type flatbuffer: bytes, required
-        :param flatbuffer: The TFLite flatbuffer to be compiled.
+    :type flatbuffer: bytes, required
+    :param flatbuffer: The TFLite flatbuffer to be compiled.
 
-        :type signature_name: str, optional
-        :param signature_name: The name of the TFLite IO signature to be used for input / output metadata. Must be provided if the model contains multiple signatures.
+    :type signature_name: str, optional
+    :param signature_name: The name of the TFLite IO signature to be used for input /
+    output metadata. Must be provided if the model contains multiple signatures.
     """
 
     flatbuffer: bytes = None
     signature_name: str = None
 
     @property
     def __ir_name__(self) -> str:
-        return 'tflite'
+        return "tflite"
 
     def __get_ir__(self) -> Any:
-        return cs_pb2.tflite(
-            model = self.flatbuffer,
-            signature_name = self.signature_name
-        )
+        return cs_pb2.tflite(model=self.flatbuffer, signature_name=self.signature_name)
 
-class Simulator():
+
+class Simulator:
     """
-        Simulates a compiled model's behavior on the SPU.
+    Simulates a compiled model's behavior on the SPU.
     """
-    def __init__(self, client: "CompilerClient", model: Model, 
-        options: dict = {}):
+
+    def __init__(self, client: "CompilerClient", model: Model, options: dict = {}):
         self.client = client
         self.model = model
 
         # Create an event stream fed by a queue
         self.request_queue = queue.SimpleQueue()
-        request_iterator = iter(
-            self.request_queue.get, 
-            self.__request_sentinel__
-        ) 
+        request_iterator = iter(self.request_queue.get, self.__request_sentinel__)
         self.response_iterator = client.__simulate__(request_iterator)
 
         # Compile the model with the first message
         model_msg = model.__get_message__(options)
-        simulation_start_msg = cs_pb2.simulation_input(
-            model = model_msg
-        )
+        simulation_start_msg = cs_pb2.simulation_input(model=model_msg)
         self.__send_request__(simulation_start_msg)
 
         # Check compilation status
         self.__get_response__()
 
     def __del__(self):
-        """ Close any open streams. """
+        """Close any open streams."""
         self.__send_request__(self.__request_sentinel__)
 
     def __send_request__(self, msg):
         self.request_queue.put(msg)
 
     def __get_response__(self):
         response = next(self.response_iterator)
         self.client.__check_status__(response.status)
         return response
 
     @property
     def __request_sentinel__(self) -> Any:
-        """ Sentinel value to close the request queue. """
+        """Sentinel value to close the request queue."""
         return None
 
-    def simulate(self, inputs: Union[np.array, Iterable[np.array]], quantize_inputs: bool = False, dequantize_outputs: bool = False, sim_duration: float = None) -> List[np.array]:
-        """ 
-        Simulates the model on the given inputs. 
+    def simulate(
+        self,
+        inputs: Union[np.array, Iterable[np.array]],
+        quantize_inputs: bool = False,
+        dequantize_outputs: bool = False,
+        sim_duration: float = None,
+    ) -> List[np.array]:
+        """
+        Simulates the model on the given inputs.
 
         :type inputs: array or iterable of arrays, required
         :param inputs: The input tensors.
 
         :type quantize_inputs: bool, optional
-        :param quantize_inputs: If true, quantizes each input from float to integer using its scale :math:`a` and zero point :math:`z`, according to the formula
+        :param quantize_inputs: If true, quantizes each input from float to integer
+        using its scale :math:`a` and zero point :math:`z`, according to the formula
         .. math::
             f(x) = a (x - z)
 
         :type dequantize_outputs: bool, optional
-        :param dequantize_outputs: If true, dequantizes each output from integer to float using its scale :math:`a` and zero point :math:`z`, according to the formula
+        :param dequantize_outputs: If true, dequantizes each output from integer to
+        float using its scale :math:`a` and zero point :math:`z`, according to the
+        formula
         .. math::
             g(x) = \\frac{x}{a} + z.
 
-        :param sim_duration: The total simulation time, in seconds. Used to estimate static power consumption. For example, in a streaming model, this should be the time elapsed between model invocations. By default, this is just the estimated latency of the model.
+        :param sim_duration: The total simulation time, in seconds. Used to estimate
+        static power consumption. For example, in a streaming model, this should be the
+        time elapsed between model invocations. By default, this is just the estimated
+        latency of the model.
         :type sim_duration: float, optional
-        
+
         :rtype: list
         :return: The output tensors.
 
         """
-        #TODO how to handle multiple inputs? What's the proper form for FASMIR? Map inputs to FASMIR indices as in CompilerFrontend?        
+        # FIXME need to handle multiple inputs
         # Convert a single ndarray to a list containing that input.
-        # Otherwise, this will be interpreted as an iterable of (n-1)-d arrays 
+        # Otherwise, this will be interpreted as an iterable of (n-1)-d arrays
         if isinstance(inputs, np.ndarray):
             inputs = [inputs]
 
         simulation_request = cs_pb2.simulation_input(
-            data = cs_pb2.simulation_data(
-                data = [numpy_to_ndarray(x) for x in inputs],
-                quantize_inputs = quantize_inputs,
-                dequantize_outputs = dequantize_outputs,
-                sim_duration = sim_duration
+            data=cs_pb2.simulation_data(
+                data=[numpy_to_ndarray(x) for x in inputs],
+                quantize_inputs=quantize_inputs,
+                dequantize_outputs=dequantize_outputs,
+                sim_duration=sim_duration,
             )
         )
         self.__send_request__(simulation_request)
         response = self.__get_response__()
 
         return [ndarray_to_numpy(x) for x in response.data], response.report
 
+
 class CompilerClientImpl:
-    """ 
-    Internal implementation of CompilerClient, with extra testing options. 
+    """
+    Internal implementation of CompilerClient, with extra testing options.
 
     Allows substituting your own gRPC channel and stub.
     """
+
     def __init__(self, channel, stub):
         self.channel = channel
         self.stub = stub
         self.__check_version__()
 
     def __check_status__(self, status):
-        """ Check a status response, raising an exception if unsuccessful. """
+        """Check a status response, raising an exception if unsuccessful."""
         if not status.success:
-            raise RuntimeError("Client received error from compiler server:\n%s" % status.msg)
+            raise RuntimeError(
+                "Client received error from compiler server:\n%s" % status.msg
+            )
 
     def __check_version__(self):
-        """ Verify the server's version matches the client. """
+        """Verify the server's version matches the client."""
         from femtocrux.version import __version__ as client_version
+
         server_version = self.__server_version__()
-        assert client_version == server_version, """
+        assert (
+            client_version == server_version
+        ), """
         Client-server version mismatch:
             client: %s
             server: %s
-        """ % (client_version, server_version)
+        """ % (
+            client_version,
+            server_version,
+        )
 
-    def compile(self, model: Model, options: dict = {}) -> bytes: 
-        """ 
-        Compile the model to a bitstream. 
+    def compile(self, model: Model, options: dict = {}) -> bytes:
+        """
+        Compile the model to a bitstream.
 
         :type model: Model, required
         :param model: The model to be compiled.
 
-        :type options: dict, optional 
+        :type options: dict, optional
         :param options: Complier options.
 
         :rtype: bytes
         :return: A zip archive of compiler artifacts.
         """
         response = self.stub.compile(model.__get_message__(options))
         self.__check_status__(response.status)
         return response.bitfile
 
     def __ping__(self, message: bytes) -> None:
-        """ Pings the server with a message. """
+        """Pings the server with a message."""
         response = self.stub.ping(cs_pb2.data(data=message))
         if response.data != message:
             raise RuntimeError("Server response does not match request data!")
 
     def __simulate__(self, in_stream: Iterable) -> Iterable:
-        """ Calls the 'simulator' bidirectional streaming RPC. """
+        """Calls the 'simulator' bidirectional streaming RPC."""
         return self.stub.simulate(in_stream)
 
     def simulate(self, model: Model, options: dict = {}) -> Simulator:
-        """ 
-        Get a simulator for the model. 
+        """
+        Get a simulator for the model.
 
         :type model: Model, required
         :param model: The model to be simulated.
 
         :type options: dict, optional
         :param options: Compiler options.
 
         :rtype: Simulator
         :return: A simulator for the model.
         """
         return Simulator(client=self, model=model, options=options)
 
     def __server_version__(self) -> str:
-        """ Queries the femtocrux version running on the server. """
+        """Queries the femtocrux version running on the server."""
         response = self.stub.version(google.protobuf.empty_pb2.Empty())
         return response.version
 
+
 class CompilerClient(CompilerClientImpl):
     """
-    Client which spawns and interacts with the compiler server. This is the main entrypoint for femtocrux.
+    Client which spawns and interacts with the compiler server. This is the main
+    entrypoint for femtocrux.
     """
+
     def __init__(self):
-        self.container = None # For __del__
+        self.container = None  # For __del__
 
         # Start a new docker server
         self.container = self.__create_docker_server__()
         self.__wait_for_server_ready__()
         self.__init_network_info__(self.container)
 
         # Establish a connection to the server
         self.channel = self.__connect__()
 
         # Initialize the client on this channel
         self.stub = cs_pb2_grpc.CompileStub(self.channel)
         super().__init__(self.channel, self.stub)
 
     def __del__(self):
-        """ Reclaim system resources. """
+        """Reclaim system resources."""
         if self.container is not None:
             self.container.kill()
             self.container = None
 
     def __get_docker_api_client__(self):
-        """ Get a client to the Docker daemon. """
+        """Get a client to the Docker daemon."""
         try:
             return docker.from_env()
         except Exception as exc:
-            raise RuntimeError("""Failed to connect to the Docker daemon. 
-                    Please ensure it is installed and running.""") from exc
+            raise RuntimeError(
+                """Failed to connect to the Docker daemon. 
+                    Please ensure it is installed and running."""
+            ) from exc
 
     def __init_network_info__(self, container):
         """
         For local connections only.
 
         Gets the IP address and port of the container.
         """
         # Get container network settings
         container.reload()
-        network_info = container.attrs['NetworkSettings']
+        network_info = container.attrs["NetworkSettings"]
 
         # Search for the host port bound to loopback
-        bound_ports = list(network_info['Ports'].items())
+        bound_ports = list(network_info["Ports"].items())
         num_bound_ports = len(bound_ports)
         if num_bound_ports != 1:
-            raise OSError('Expected exactly one port to be bound to docker container '
-                '\'%s\'.\nFound %d.' % (container.id, num_bound_ports)
+            raise OSError(
+                "Expected exactly one port to be bound to docker container "
+                "'%s'.\nFound %d." % (container.id, num_bound_ports)
             )
 
         # Extract the port number
         bound_port, bound_sockets = bound_ports[0]
-        socket = bound_sockets[0] # In case of multiple, take the first one
-        self.__channel_port__ = socket['HostPort']
+        socket = bound_sockets[0]  # In case of multiple, take the first one
+        self.__channel_port__ = socket["HostPort"]
 
     def __connect__(self) -> Any:
-        """ Establishes a gRPC connection to the server. """
+        """Establishes a gRPC connection to the server."""
 
-        # Open a gRPC channel to the server 
-        sock_name = '%s:%s' % (self.channel_addr, self.channel_port)
+        # Open a gRPC channel to the server
+        sock_name = "%s:%s" % (self.channel_addr, self.channel_port)
         channel = grpc.insecure_channel(
             sock_name,
-            options = get_channel_options(),
+            options=get_channel_options(),
         )
         logger.info("Created gRPC channel at %s" % sock_name)
 
         # Wait for the channel to be ready
         channel_timeout_seconds = 30
         channel_ready = grpc.channel_ready_future(channel)
         logger.info("Waiting to establish a connection...")
         try:
             channel_ready.result(timeout=channel_timeout_seconds)
         except grpc.FutureTimeoutError as exc:
-            raise OSError("Channel timed out after %s seconds. Check that the server is running." % channel_timeout_seconds) from exc
+            raise OSError(
+                "Channel timed out after %s seconds. Check that the server is running."
+                % channel_timeout_seconds
+            ) from exc
         logger.info("Connection successful.")
 
         return channel
 
     @property
     def channel_addr(self) -> str:
-        """ 
-        IP address used for the gRPC channel. 
+        """
+        IP address used for the gRPC channel.
 
         Note that '0.0.0.0' does NOT work on Windows hosts.
         """
-        return 'localhost'
+        return "localhost"
 
     @property
     def channel_port(self) -> int:
         """
         Port used for the gRPC channel.
         """
         return self.__channel_port__
 
     @property
     def __container_port__(self) -> int:
-        """ Port used inside the container. """
+        """Port used inside the container."""
         return 50051
 
     @property
     def __container_label__(self) -> str:
-        """ Label attached to identify containers started by this client. """
-        return 'femtocrux_server'
+        """Label attached to identify containers started by this client."""
+        return "femtocrux_server"
 
     def __get_unused_container_name__(self) -> str:
-        """ Get an unused container name. """
+        """Get an unused container name."""
 
         # Search for an unused name
         client = self.__get_docker_api_client__()
         container_idx = 0
         while True:
-            name = 'femtocrux_server_%d' % container_idx
+            name = "femtocrux_server_%d" % container_idx
             try:
                 client.containers.get(name)
             except docker.errors.NotFound:
                 # If no collision, use this name
                 return name
 
             container_idx += 1
 
     def __pull_docker_image__(self):
-        """ Pull the Docker image from remote. """
+        """Pull the Docker image from remote."""
 
         logger.info(
             """
             Attempting to pull docker image from remote.
 
             Alternatively, you can pull the image yourself with the command:
                 docker pull %s
-            """, 
-            __docker_image_name__
+            """,
+            __docker_image_name__,
         )
-  
+
         # Log in to Github
         client = self.__get_docker_api_client__()
         while True:
             # Get the password
             manual_pass = True
             if "GH_PACKAGE_KEY" in os.environ:
                 password = os.environ["GH_PACKAGE_KEY"]
                 manual_pass = False
             else:
                 # Prompt the user for password entry
                 password = getpass("Please enter your Femtosense-provided key:")
 
             # Log in to the client
             try:
-                resp = client.login("femtodaemon", password, registry="https://" + __docker_registry__)
+                resp = client.login(
+                    "femtodaemon", password, registry="https://" + __docker_registry__
+                )
             except docker.errors.APIError as exc:
-                if 'denied' in exc.explanation:
+                if "denied" in exc.explanation:
                     logger.error("Docker authetication failed.")
                     # Retry password entry
                     if manual_pass:
                         continue
 
                 raise RuntimeError("Docker authentication failed") from exc
 
             # Login successful
-            logger.info(resp['Status'])
+            logger.info(resp["Status"])
             break
 
         def image_not_found_error() -> RuntimeError:
-            """ Return an exception saying the image wasn't found. """
+            """Return an exception saying the image wasn't found."""
             return RuntimeError(
-            """Docker image not found:
+                """Docker image not found:
                 %s
-            Please notify your Femtosense representative.""" % (
-                __docker_image_name__
-                )
+            Please notify your Femtosense representative."""
+                % (__docker_image_name__)
             )
 
         # Download the image
         logger.info("Downloading image. This could take a few minutes...")
         try:
             client.images.pull(__docker_image_name__)
         except docker.errors.ImageNotFound as exc:
             raise image_not_found_error() from exc
         except docker.errors.APIError as exc:
             if exc.explanation == "manifest unknown":
                 logger.error(
-                    "Docker image %s not found on the remote. Check if it is published.", 
-                    __docker_image_name__
+                    "Docker image %s not found on the remote. Check if it is "
+                    "published.",
+                    __docker_image_name__,
                 )
             raise image_not_found_error() from exc
 
         logger.info("Download completed.")
 
     def __create_docker_server__(self) -> docker.models.containers.Container:
         """
         Starts the server in a new Docker container.
         """
         # Get a client for the Docker daemon
         client = self.__get_docker_api_client__()
 
         # Pull the image, if not available
-        existing_image_names = [tag for image in client.images.list() for tag in image.tags]
+        existing_image_names = [
+            tag for image in client.images.list() for tag in image.tags
+        ]
         if __docker_image_name__ not in existing_image_names:
             # Check if we are allowed to pull the image.
             # This is disabled for CI builds.
-            image_not_found_msg = 'Failed to find the docker image %s locally.' % __docker_image_name__
+            image_not_found_msg = (
+                "Failed to find the docker image %s locally." % __docker_image_name__
+            )
             if not __env_var_to_bool__("FS_ALLOW_DOCKER_PULL", default=True):
                 raise RuntimeError(
                     """
                     %s 
                     Docker pull is disabled by the environment.
-                    """ %
-                    image_not_found_msg
+                    """
+                    % image_not_found_msg
                 )
 
             # Pull the image from remote
-            logger.info(image_not_found_msg)    
+            logger.info(image_not_found_msg)
             self.__pull_docker_image__()
 
         # Bind a random port on the host to the container's gRPC port
         port_interface = {self.__container_port__: None}
         command = "--port %s" % self.__container_port__
 
         # Start a container running the server
         container = client.containers.run(
             __docker_image_name__,
-            command=command, # Appends entrypoint with args 
+            command=command,  # Appends entrypoint with args
             detach=True,
             labels=[self.__container_label__],
             stderr=True,
             stdout=True,
             ports=port_interface,
             name=self.__get_unused_container_name__(),
             auto_remove=True,
@@ -563,52 +604,56 @@
         Block until the Docker container is ready to handle requests.
         """
 
         container = self.container
 
         # Block until the container starts
         num_attempts = 5
-        wait_interval = 1.0 # Seconds
-        print('Checking container status...')
+        wait_interval = 1.0  # Seconds
+        print("Checking container status...")
         for attempt in range(num_attempts):
             container.reload()
             status = container.status
-            if status == 'created':
+            if status == "created":
                 # Sleep and try again
-                print('Container starting up. Retrying in %fs...' % wait_interval)
+                print("Container starting up. Retrying in %fs..." % wait_interval)
                 time.sleep(wait_interval)
                 continue
-            elif status == 'running':
-                print('Container started successfully.')
+            elif status == "running":
+                print("Container started successfully.")
                 break
-            elif status == 'exited':
+            elif status == "exited":
                 raise RuntimeError("Container exited! See logs:\n%d" % container.logs())
             else:
                 raise RuntimeError("Unrecognized docker container status: %d" % status)
 
         # Check the final status
         container.reload()
-        if container.status != 'running':
-            raise RuntimeError("Container failed to start after %d attempts" % num_attempts)
+        if container.status != "running":
+            raise RuntimeError(
+                "Container failed to start after %d attempts" % num_attempts
+            )
 
         # Check the container's health
         for attempt in range(num_attempts):
-            exit_code, output = container.exec_run('python3 /femtocrux/femtocrux/server/healthcheck.py')
+            exit_code, output = container.exec_run(
+                "python3 /femtocrux/femtocrux/server/healthcheck.py"
+            )
 
             if exit_code == 0:
-                print('Container passed health check.')
+                print("Container passed health check.")
                 break
 
             time.sleep(wait_interval)
 
         # Check the last return code
         if exit_code != 0:
             raise RuntimeError(
-                "Docker container failed %d health check(s)!\nLast output:\n%s" % (
-                    num_attempts, output.decode('utf-8')
-                )
+                "Docker container failed %d health check(s)!\nLast output:\n%s"
+                % (num_attempts, output.decode("utf-8"))
             )
 
+
 if __name__ == "__main__":
     logging.basicConfig(stream=sys.stdout, level=logging.INFO)
     client = CompilerClient()
-    logger.info('Client started successfully.')
+    logger.info("Client started successfully.")
```

## femtocrux/grpc/__init__.py

```diff
@@ -1,4 +1,5 @@
 # Need to add this dir to PYTHONPATH, or else the imports in generated code won't work
 import os
 import sys
+
 sys.path.append(os.path.abspath(os.path.dirname(__file__)))
```

## femtocrux/server/exceptions.py

```diff
@@ -1,25 +1,26 @@
 """
 Utils for handling exceptions.
 """
 
 import io
 import traceback
 
+
 def format_exception(type, value, tb) -> str:
     """Prints an exception with its traceback."""
     # Format the exception
     msg = ""
     msg += "\t%s: %s\n" % (type, str(value))
 
     # Format the traceback
-    file_like = io.StringIO(newline='\n')
+    file_like = io.StringIO(newline="\n")
     traceback.print_tb(tb, file=file_like)
     msg += "Traceback:\n"
     msg += file_like.getvalue()
 
     return msg
 
+
 def format_exception_from_exc(exc: Exception) -> str:
-    """ Helper to format from an Exception object."""
+    """Helper to format from an Exception object."""
     return format_exception(type(exc), exc, exc.__traceback__)
-
```

## femtocrux/server/healthcheck.py

```diff
@@ -5,55 +5,54 @@
 """
 
 import argparse
 import grpc
 import sys
 
 from femtocrux.server.server import default_port
-from femtocrux.server.exceptions import format_exception, format_exception_from_exc
+from femtocrux.server.exceptions import format_exception
 from femtocrux.util.utils import get_channel_options
 
 # Import GRPC artifacts
 import femtocrux.grpc.compiler_service_pb2 as cs_pb2
 import femtocrux.grpc.compiler_service_pb2_grpc as cs_pb2_grpc
 
 # Health codes
 healthy = 0
 unhealthy = 1
 
+
 def handle_exception(type, value, tb):
-    """ Handle uncaught exceptions. """
+    """Handle uncaught exceptions."""
     print("Healthcheck raised uncaught exception:\n")
     print(format_exception(type, value, tb))
     exit(unhealthy)
 
+
 # Handle exceptions
 sys.excepthook = handle_exception
 
 # Parse arguments
-parser = argparse.ArgumentParser(description='Configures the health check client.')
+parser = argparse.ArgumentParser(description="Configures the health check client.")
 default_port = default_port
 parser.add_argument(
-    '--port', 
-    dest="port", 
+    "--port",
+    dest="port",
     default=default_port,
-    help="the port used for RPCs (default: %s)" % default_port
+    help="the port used for RPCs (default: %s)" % default_port,
 )
 args = parser.parse_args()
 
 # Create a channel on the given port
-sock_name = 'localhost:%s' % args.port 
-channel = grpc.insecure_channel(
-    sock_name,
-    options = get_channel_options()
-)
+sock_name = "localhost:%s" % args.port
+channel = grpc.insecure_channel(sock_name, options=get_channel_options())
 print("Created gRPC channel at %s" % sock_name)
 
 # Ping the server
-message = b'01234'
+message = b"01234"
 stub = cs_pb2_grpc.CompileStub(channel)
 response = stub.ping(cs_pb2.data(data=message))
 
 # Check the data
 if response.data != message:
     print("Ping response doesn't match!")
     exit(unhealthy)
```

## femtocrux/server/server.py

```diff
@@ -1,248 +1,228 @@
 import argparse
 from collections.abc import Iterable
-import concurrent 
+import concurrent
 import google.protobuf
 import grpc
 import logging
 import pickle
 import sys
-from typing import Dict
 
-from femtostack.common import CompilerFrontend, SimIOWrapper, IOConfig
+from femtostack.common import CompilerFrontend
 from femtostack.tflite_api.tflite_frontend import TFLiteCompiler
 from femtostack.torch_api.frontend import TorchCompiler
-from fmot.fqir import GraphProto
 
 from femtocrux.server.exceptions import format_exception, format_exception_from_exc
-from femtocrux.util.utils import numpy_to_ndarray, ndarray_to_numpy, field_or_none, get_channel_options
+from femtocrux.util.utils import (
+    numpy_to_ndarray,
+    ndarray_to_numpy,
+    field_or_none,
+    get_channel_options,
+)
 
 # Import GRPC artifacts
 import femtocrux.grpc.compiler_service_pb2 as cs_pb2
 import femtocrux.grpc.compiler_service_pb2_grpc as cs_pb2_grpc
 
 # Network parameters
 default_port = "50051"
 
+
 class CompileServicer(cs_pb2_grpc.CompileServicer):
     def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)
 
         # Initialize the log
         self.logger = logging.getLogger("CompileServicer")
         self.logger.setLevel(logging.DEBUG)
-        self.logger.info('Starting compile server.')
+        self.logger.info("Starting compile server.")
 
     def __get_fqir_compiler__(self, model: cs_pb2.model) -> CompilerFrontend:
-        """ Get a Torch compiler from an FQIR a model message """
+        """Get a Torch compiler from an FQIR a model message"""
         # Deserialize FQIR
         fqir = model.fqir
         graph_proto = pickle.loads(fqir.model)
 
-
         # Compile the FQIR
         return TorchCompiler(
-            graph_proto, 
-            batch_dim=field_or_none(fqir, 'batch_dim'),
-            seq_dim=field_or_none(fqir, 'sequence_dim')
+            graph_proto,
+            batch_dim=field_or_none(fqir, "batch_dim"),
+            seq_dim=field_or_none(fqir, "sequence_dim"),
         )
 
     def __get_tflite_compiler__(self, model: cs_pb2.model) -> CompilerFrontend:
-        """ Get a TFLite compiler from a model message """
+        """Get a TFLite compiler from a model message"""
         tflite = model.tflite
         return TFLiteCompiler(
-            tflite.model, 
-            signature=field_or_none(tflite, 'signature_name') 
+            tflite.model, signature=field_or_none(tflite, "signature_name")
         )
 
     def __compile_model__(self, model: cs_pb2.model, context) -> CompilerFrontend:
-        """ Compile a model, for simulation or bitfile generation. """
+        """Compile a model, for simulation or bitfile generation."""
         # Get a compiler for the model
         model_type_map = {
-            'fqir': self.__get_fqir_compiler__,
-            'tflite': self.__get_tflite_compiler__
+            "fqir": self.__get_fqir_compiler__,
+            "tflite": self.__get_tflite_compiler__,
         }
-        model_type = model.WhichOneof('ir')
+        model_type = model.WhichOneof("ir")
         compiler = model_type_map[model_type](model)
 
         # Get the compiler options
-        options_struct = field_or_none(model, 'options')
+        options_struct = field_or_none(model, "options")
         if options_struct is None:
             options = {}
-        else: 
+        else:
             options = google.protobuf.json_format.MessageToDict(options_struct)
 
         # Compile the model
-        compiler.compile(options = options) 
+        compiler.compile(options=options)
         assert compiler.is_compiled, "Expected compilation completed"
         return compiler
 
     def compile(self, model, context):
-        """ Compile a model into a bitfile. """
+        """Compile a model into a bitfile."""
 
-        self.logger.debug('Received \'compile\' request.')
+        self.logger.debug("Received 'compile' request.")
 
         # Compile the model
         try:
             compiler = self.__compile_model__(model, context)
             bitfile = compiler.dump_bitfile(encrypt=True)
         except Exception as exc:
-            msg = "Compiler raised exception:\n%s" % (
-                format_exception_from_exc(exc)
-            )
+            msg = "Compiler raised exception:\n%s" % (format_exception_from_exc(exc))
             self.logger.error(msg)
-            return cs_pb2.compiled_artifacts( 
-                status = cs_pb2.status(
-                    success=False, 
-                    msg=msg
-                )
+            return cs_pb2.compiled_artifacts(
+                status=cs_pb2.status(success=False, msg=msg)
             )
 
         # Return the bitfile
-        return cs_pb2.compiled_artifacts( 
-            bitfile = bitfile,
-            status = cs_pb2.status(
-                success=True
-            )
+        return cs_pb2.compiled_artifacts(
+            bitfile=bitfile, status=cs_pb2.status(success=True)
         )
 
     def ping(self, data: cs_pb2.data, context) -> cs_pb2.data:
-        """ Round-trip a message. """
+        """Round-trip a message."""
         return data
 
-    def simulate(self, 
-        request_iterator: Iterable[cs_pb2.simulation_input], 
-        context
-        ) -> Iterable[cs_pb2.simulation_output]:
-        """ Simulate the SPU's behavior on a given model. """
-        self.logger.debug('Received \'simulate\' request.')
+    def simulate(
+        self, request_iterator: Iterable[cs_pb2.simulation_input], context
+    ) -> Iterable[cs_pb2.simulation_output]:
+        """Simulate the SPU's behavior on a given model."""
+        self.logger.debug("Received 'simulate' request.")
 
         # The first request compiles the model
         for model_request in request_iterator:
             # Check that this is a model request
-            if not model_request.WhichOneof('model_or_data') == 'model':
+            if not model_request.WhichOneof("model_or_data") == "model":
                 yield cs_pb2.simulation_output(
-                    status = cs_pb2.status(
-                        success = False,
-                        msg = "Expected model message."
-                    )
+                    status=cs_pb2.status(success=False, msg="Expected model message.")
                 )
                 continue
 
             # Attempt compilation
             try:
                 compiler = self.__compile_model__(model_request.model, context)
             except Exception as exc:
                 msg = "Compiler raised exception:\n%s" % (
                     format_exception_from_exc(exc)
                 )
                 self.logger.error(msg)
-                yield cs_pb2.simulation_output( 
-                    status = cs_pb2.status(
-                        success=False, 
-                        msg=msg
-                    )
+                yield cs_pb2.simulation_output(
+                    status=cs_pb2.status(success=False, msg=msg)
                 )
                 continue
 
             # If successful, move on to data requests
-            yield cs_pb2.simulation_output(
-                status=cs_pb2.status(
-                    success = True
-                )
-            )
+            yield cs_pb2.simulation_output(status=cs_pb2.status(success=True))
             break
 
         # Subsequent requests must be data
         for data_request in request_iterator:
-
             # Check that this is a data message
-            if not data_request.WhichOneof('model_or_data') == 'data':
+            if not data_request.WhichOneof("model_or_data") == "data":
                 yield cs_pb2.simulation_output(
-                    status = cs_pb2.status(
-                        success = False,
-                        msg = "Expected data message."
-                    )
+                    status=cs_pb2.status(success=False, msg="Expected data message.")
                 )
                 continue
 
             # Convert input data
             sim_data = data_request.data
             data = [ndarray_to_numpy(x) for x in sim_data.data]
-            assert len(data) == 1, "Behavioral sim currently only supports 1 input" #FIXME
+            assert (
+                len(data) == 1
+            ), "Behavioral sim currently only supports 1 input"  # FIXME
             data = data[0]
-    
-            sim_duration = None if sim_data.sim_duration == -1 else sim_data.sim_duration
 
             # Simulate the model
             try:
                 outputs, metrics = compiler.run_behavioral_simulator(
                     data,
-                    quantize_inputs = sim_data.quantize_inputs,
-                    dequantize_outputs = sim_data.dequantize_outputs,
-                    input_period = field_or_none(sim_data, 'sim_duration')
+                    quantize_inputs=sim_data.quantize_inputs,
+                    dequantize_outputs=sim_data.dequantize_outputs,
+                    input_period=field_or_none(sim_data, "sim_duration"),
                 )
             except Exception as exc:
                 msg = "Simulator raised exception:\n%s" % (
                     format_exception_from_exc(exc)
                 )
                 self.logger.error(msg)
                 yield cs_pb2.simulation_output(
-                    status = cs_pb2.status(
-                        success = False,
-                        msg = msg
-                    )
+                    status=cs_pb2.status(success=False, msg=msg)
                 )
                 continue
 
             # Respond with output data
             yield cs_pb2.simulation_output(
-                data = [numpy_to_ndarray(x) for x in outputs],
-                report = metrics.performance_report(),
-                status = cs_pb2.status(success=True)
+                data=[numpy_to_ndarray(x) for x in outputs],
+                report=metrics.performance_report(),
+                status=cs_pb2.status(success=True),
             )
 
     def version(self, empty, context) -> cs_pb2.version_info:
-        """ Return the version of femtocrux running in this server. """
+        """Return the version of femtocrux running in this server."""
         from femtocrux.version import __version__
-        return cs_pb2.version_info(version = __version__)
+
+        return cs_pb2.version_info(version=__version__)
+
 
 def handle_exception(type, value, tb):
     """Log an uncaught exception before terminating."""
-    logger.error("Server raised uncaught exception:\n")
-    logger.error(format_exception(type, value, tb))
+    logging.error("Server raised uncaught exception:\n")
+    logging.error(format_exception(type, value, tb))
 
     # Call the default excepthook to terminate the progarm
     sys.__excepthook__(type, value, tb)
 
+
 def serve():
-    """ 
-    Starts the server and blocks the thread, waiting for connections. 
+    """
+    Starts the server and blocks the thread, waiting for connections.
     """
     # Set up logs
     logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
     sys.excepthook = handle_exception
 
     # Parse arguments
-    parser = argparse.ArgumentParser(description='Configures the gRPC server.')
+    parser = argparse.ArgumentParser(description="Configures the gRPC server.")
     parser.add_argument(
-        '--port', 
-        dest="port", 
+        "--port",
+        dest="port",
         default=default_port,
-        help="the port used for RPCs (default: %s)" % default_port
+        help="the port used for RPCs (default: %s)" % default_port,
     )
     args = parser.parse_args()
 
     # Start the server
     server = grpc.server(
         concurrent.futures.ThreadPoolExecutor(max_workers=10),
-        options = get_channel_options()
+        options=get_channel_options(),
     )
 
     cs_pb2_grpc.add_CompileServicer_to_server(CompileServicer(), server)
     server.add_insecure_port("[::]:%s" % args.port)
     server.start()
     logging.info("Server listening on port %s" % args.port)
     server.wait_for_termination()
 
+
 if __name__ == "__main__":
     serve()
```

## femtocrux/util/utils.py

```diff
@@ -1,30 +1,31 @@
 """ Utils for client-server communication. """
 
 import numpy as np
 from typing import Any
 
 import femtocrux.grpc.compiler_service_pb2 as cs_pb2
-import femtocrux.grpc.compiler_service_pb2_grpc as cs_pb2_grpc
+
 
 def numpy_to_ndarray(data: np.array) -> cs_pb2.ndarray:
-    """ Convert a numpy array to an ndarray message. """
-    return cs_pb2.ndarray(
-        data = [float(x) for x in data.ravel()],
-        shape = data.shape
-    )
+    """Convert a numpy array to an ndarray message."""
+    return cs_pb2.ndarray(data=[float(x) for x in data.ravel()], shape=data.shape)
+
 
 def ndarray_to_numpy(data: cs_pb2.ndarray) -> np.array:
-    """ Convert an ndarray message to a numpy array. """
+    """Convert an ndarray message to a numpy array."""
     return np.array(data.data).reshape(data.shape)
 
+
 def field_or_none(message: Any, field_name: str) -> Any:
-    """ Convert empty message fields to None. """
+    """Convert empty message fields to None."""
     return getattr(message, field_name) if message.HasField(field_name) else None
 
+
 def get_channel_options(max_message_mb: int = 32):
     # Set the maximum message size
-    megabyte_size = 2 ** 20
+    megabyte_size = 2**20
     max_message_size = max_message_mb * megabyte_size
-    return [('grpc.max_send_message_length', max_message_size),
-            ('grpc.max_receive_message_length', max_message_size)]
-
+    return [
+        ("grpc.max_send_message_length", max_message_size),
+        ("grpc.max_receive_message_length", max_message_size),
+    ]
```

## Comparing `femtocrux-0.2.8.post3.dist-info/METADATA` & `femtocrux-0.2.9.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: femtocrux
-Version: 0.2.8.post3
+Version: 0.2.9
 Summary: Femtosense Compiler
 Home-page: https://github.com/femtosense/femtocrux
 Author: Femtosense
 Author-email: info@femtosense.ai
 Project-URL: Source, https://github.com/femtosense/femtocrux
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Developers
```

## Comparing `femtocrux-0.2.8.post3.dist-info/RECORD` & `femtocrux-0.2.9.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 femtocrux/ENV_REQUIREMENTS.sh,sha256=t_O1B4hJAMgxvH9gwp1qls6eVFmhSYBJe64KmuK_H-4,1389
 femtocrux/PY_REQUIREMENTS,sha256=dwSA37UvBVgyXrAr-ToLV_eJIaVTgf7cnUClX0mn4rE,308
-femtocrux/VERSION,sha256=yGFJc8SNINnnGNDErSBsxkBO8zDsvkkxmKekFf8coSE,8
-femtocrux/__init__.py,sha256=FISQ-uQRzWFQsUVQ65YrAzS5nFz5kHZahrWzbLegA3U,100
-femtocrux/version.py,sha256=h9UchNl62V-tKFPlf2uyeVqvUBFaSi9yhH15PDy-NaQ,162
+femtocrux/VERSION,sha256=LyszO-iFjLOEEUJRtmi7HJ5FoLuDk2ALetQJPQ6OcvY,6
+femtocrux/__init__.py,sha256=fQdrj_d4a2T4xIcKoTdTLokaZsDP5uAbW7c39YPzkX8,271
+femtocrux/version.py,sha256=uNg2kHxQo6oUN1ah7s9_85rCZVRoTHGPD1GAQPZW4lw,164
 femtocrux/client/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-femtocrux/client/client.py,sha256=_Ax3UKKawQpCUsmRZ-gyWk3XsNQZ1mav8a9rKT092YA,21138
-femtocrux/grpc/__init__.py,sha256=1otI5-T4OaWs68wSUMtwe5IXLAM02Z4hZjIW8kGAVzo,168
+femtocrux/client/client.py,sha256=TI7wo-ocOWuYbnDnbkDtzMNm66GAPTmF1s0ET2f202Y,21215
+femtocrux/grpc/__init__.py,sha256=uiMHQt5I2eAKJqI3Zh0h1Gm7cmPR4PbaGS71nCJQCGw,169
 femtocrux/grpc/compiler_service_pb2.py,sha256=2S0KMAhIn9Dy_KfRHlBHDWSdcWqfUJX7IZ0xMxMYaJk,4340
 femtocrux/grpc/compiler_service_pb2_grpc.py,sha256=L9EQFYMFVACngUrAEmSJDgUTSPSi3rDoG7TERg-pFq4,7002
 femtocrux/server/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-femtocrux/server/exceptions.py,sha256=Kc6HMDRfebZ1k-d_Ij_BDHZO7QgvXnzEqqgO36oM-kc,609
-femtocrux/server/healthcheck.py,sha256=mzQ_-u8xsc4VcelkvsbDTtJgdSlTBTJrDJ8mQkaGuqA,1606
-femtocrux/server/server.py,sha256=eQSDHXz-A0ucylfvti1CeC1BHRM640gKVbpiEC-O1to,8620
+femtocrux/server/exceptions.py,sha256=lI6n471n5QKf5G3aL_1kuBVEItD-jBgithVVpPDwNYc,609
+femtocrux/server/healthcheck.py,sha256=ehqAwnv0D0zpy-AUZAPwv8rp874DZCwUmP8nzdXzZvI,1565
+femtocrux/server/server.py,sha256=KAH6paHEQrdw9PIv7GxSc_O2BBAKQHys3s8Ez5NkY1I,7928
 femtocrux/util/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-femtocrux/util/utils.py,sha256=LVgC8nBx4x8GtndFMyczwQojSEVmLpzDieipZb9IPD4,1086
-femtocrux-0.2.8.post3.dist-info/LICENSE,sha256=eN9ZI1xHjUmFvN3TEeop5kBGXRUBfbsl55KBNBYYFqI,36
-femtocrux-0.2.8.post3.dist-info/METADATA,sha256=cKUSBbDYvN5qMpQTI2lUFbwtBRys8jPLfJffM-eXQEs,2128
-femtocrux-0.2.8.post3.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
-femtocrux-0.2.8.post3.dist-info/top_level.txt,sha256=BkTttlioC3je__8577wxRieZqY3Abu7FOOdMnmYbcNI,10
-femtocrux-0.2.8.post3.dist-info/RECORD,,
+femtocrux/util/utils.py,sha256=FZ8cssDom4B3FDbVU_ew4Cf3wOWjo2w1jwcbnLzoYnM,1003
+femtocrux-0.2.9.dist-info/LICENSE,sha256=eN9ZI1xHjUmFvN3TEeop5kBGXRUBfbsl55KBNBYYFqI,36
+femtocrux-0.2.9.dist-info/METADATA,sha256=qAv5dPALiQZJMD9rxnPCW1-jkOPxJGUPUJdN7TOpRw4,2122
+femtocrux-0.2.9.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
+femtocrux-0.2.9.dist-info/top_level.txt,sha256=BkTttlioC3je__8577wxRieZqY3Abu7FOOdMnmYbcNI,10
+femtocrux-0.2.9.dist-info/RECORD,,
```

