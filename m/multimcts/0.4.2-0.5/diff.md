# Comparing `tmp/multimcts-0.4.2.tar.gz` & `tmp/multimcts-0.5.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "multimcts-0.4.2.tar", last modified: Fri Jul 28 21:14:39 2023, max compression
+gzip compressed data, was "multimcts-0.5.tar", last modified: Sat Aug  5 17:31:22 2023, max compression
```

## Comparing `multimcts-0.4.2.tar` & `multimcts-0.5.tar`

### file list

```diff
@@ -1,17 +1,17 @@
-drwxr-xr-x   0 taylorvance   (501) staff       (20)        0 2023-07-28 21:14:39.109374 multimcts-0.4.2/
--rw-r--r--   0 taylorvance   (501) staff       (20)     1069 2023-07-24 15:25:58.000000 multimcts-0.4.2/LICENSE
--rw-r--r--   0 taylorvance   (501) staff       (20)     2989 2023-07-28 21:14:39.109233 multimcts-0.4.2/PKG-INFO
--rw-r--r--   0 taylorvance   (501) staff       (20)     2673 2023-07-28 21:05:02.000000 multimcts-0.4.2/README.md
-drwxr-xr-x   0 taylorvance   (501) staff       (20)        0 2023-07-28 21:14:39.108433 multimcts-0.4.2/multimcts/
--rw-r--r--   0 taylorvance   (501) staff       (20)       34 2023-07-17 20:09:40.000000 multimcts-0.4.2/multimcts/__init__.py
--rw-r--r--   0 taylorvance   (501) staff       (20)   529256 2023-07-28 21:12:45.000000 multimcts-0.4.2/multimcts/mcts.c
--rw-r--r--   0 taylorvance   (501) staff       (20)   510542 2023-07-28 21:14:39.000000 multimcts-0.4.2/multimcts/mcts.cpp
--rw-r--r--   0 taylorvance   (501) staff       (20)    11225 2023-07-28 21:14:31.000000 multimcts-0.4.2/multimcts/mcts.pyx
-drwxr-xr-x   0 taylorvance   (501) staff       (20)        0 2023-07-28 21:14:39.109021 multimcts-0.4.2/multimcts.egg-info/
--rw-r--r--   0 taylorvance   (501) staff       (20)     2989 2023-07-28 21:14:39.000000 multimcts-0.4.2/multimcts.egg-info/PKG-INFO
--rw-r--r--   0 taylorvance   (501) staff       (20)      250 2023-07-28 21:14:39.000000 multimcts-0.4.2/multimcts.egg-info/SOURCES.txt
--rw-r--r--   0 taylorvance   (501) staff       (20)        1 2023-07-28 21:14:39.000000 multimcts-0.4.2/multimcts.egg-info/dependency_links.txt
--rw-r--r--   0 taylorvance   (501) staff       (20)       10 2023-07-28 21:14:39.000000 multimcts-0.4.2/multimcts.egg-info/top_level.txt
--rw-r--r--   0 taylorvance   (501) staff       (20)      100 2023-07-25 16:22:07.000000 multimcts-0.4.2/pyproject.toml
--rw-r--r--   0 taylorvance   (501) staff       (20)       38 2023-07-28 21:14:39.109420 multimcts-0.4.2/setup.cfg
--rw-r--r--   0 taylorvance   (501) staff       (20)      619 2023-07-28 21:12:40.000000 multimcts-0.4.2/setup.py
+drwxr-xr-x   0 taylorvance   (501) staff       (20)        0 2023-08-05 17:31:22.937054 multimcts-0.5/
+-rw-r--r--   0 taylorvance   (501) staff       (20)     1069 2023-07-24 15:25:58.000000 multimcts-0.5/LICENSE
+-rw-r--r--   0 taylorvance   (501) staff       (20)     2987 2023-08-05 17:31:22.936873 multimcts-0.5/PKG-INFO
+-rw-r--r--   0 taylorvance   (501) staff       (20)     2673 2023-07-28 21:05:02.000000 multimcts-0.5/README.md
+drwxr-xr-x   0 taylorvance   (501) staff       (20)        0 2023-08-05 17:31:22.935516 multimcts-0.5/multimcts/
+-rw-r--r--   0 taylorvance   (501) staff       (20)       34 2023-07-17 20:09:40.000000 multimcts-0.5/multimcts/__init__.py
+-rw-r--r--   0 taylorvance   (501) staff       (20)   611720 2023-08-04 15:20:07.000000 multimcts-0.5/multimcts/mcts.c
+-rw-r--r--   0 taylorvance   (501) staff       (20)   589310 2023-08-05 17:31:22.000000 multimcts-0.5/multimcts/mcts.cpp
+-rw-r--r--   0 taylorvance   (501) staff       (20)    14502 2023-08-05 17:30:13.000000 multimcts-0.5/multimcts/mcts.pyx
+drwxr-xr-x   0 taylorvance   (501) staff       (20)        0 2023-08-05 17:31:22.936597 multimcts-0.5/multimcts.egg-info/
+-rw-r--r--   0 taylorvance   (501) staff       (20)     2987 2023-08-05 17:31:22.000000 multimcts-0.5/multimcts.egg-info/PKG-INFO
+-rw-r--r--   0 taylorvance   (501) staff       (20)      250 2023-08-05 17:31:22.000000 multimcts-0.5/multimcts.egg-info/SOURCES.txt
+-rw-r--r--   0 taylorvance   (501) staff       (20)        1 2023-08-05 17:31:22.000000 multimcts-0.5/multimcts.egg-info/dependency_links.txt
+-rw-r--r--   0 taylorvance   (501) staff       (20)       10 2023-08-05 17:31:22.000000 multimcts-0.5/multimcts.egg-info/top_level.txt
+-rw-r--r--   0 taylorvance   (501) staff       (20)      100 2023-07-25 16:22:07.000000 multimcts-0.5/pyproject.toml
+-rw-r--r--   0 taylorvance   (501) staff       (20)       38 2023-08-05 17:31:22.937142 multimcts-0.5/setup.cfg
+-rw-r--r--   0 taylorvance   (501) staff       (20)      617 2023-08-05 17:28:48.000000 multimcts-0.5/setup.py
```

### Comparing `multimcts-0.4.2/LICENSE` & `multimcts-0.5/LICENSE`

 * *Files identical despite different names*

### Comparing `multimcts-0.4.2/PKG-INFO` & `multimcts-0.5/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: multimcts
-Version: 0.4.2
+Version: 0.5
 Summary: Monte Carlo Tree Search for multiple teams
 Home-page: https://github.com/taylorvance/multimcts
 Author: Taylor Vance
 Author-email: mirrors.cities0w@icloud.com
 License: MIT
 Platform: UNKNOWN
 Description-Content-Type: text/markdown
```

### Comparing `multimcts-0.4.2/README.md` & `multimcts-0.5/README.md`

 * *Files identical despite different names*

### Comparing `multimcts-0.4.2/multimcts/mcts.c` & `multimcts-0.5/multimcts/mcts.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,9 +1,23 @@
 /* Generated by Cython 0.29.36 */
 
+/* BEGIN: Cython Metadata
+{
+    "distutils": {
+        "depends": [],
+        "language": "c++",
+        "name": "multimcts.mcts",
+        "sources": [
+            "multimcts/mcts.pyx"
+        ]
+    },
+    "module_name": "multimcts.mcts"
+}
+END: Cython Metadata */
+
 #ifndef PY_SSIZE_T_CLEAN
 #define PY_SSIZE_T_CLEAN
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
@@ -351,27 +365,41 @@
     #if __apple_build_version__ < 7000000
       #undef  CYTHON_FALLTHROUGH
       #define CYTHON_FALLTHROUGH
     #endif
   #endif
 #endif
 
+#ifndef __cplusplus
+  #error "Cython files generated with the C++ option must be compiled with a C++ compiler."
+#endif
 #ifndef CYTHON_INLINE
   #if defined(__clang__)
     #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
-  #elif defined(__GNUC__)
-    #define CYTHON_INLINE __inline__
-  #elif defined(_MSC_VER)
-    #define CYTHON_INLINE __inline
-  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-    #define CYTHON_INLINE inline
   #else
-    #define CYTHON_INLINE
+    #define CYTHON_INLINE inline
   #endif
 #endif
+template<typename T>
+void __Pyx_call_destructor(T& x) {
+    x.~T();
+}
+template<typename T>
+class __Pyx_FakeReference {
+  public:
+    __Pyx_FakeReference() : ptr(NULL) { }
+    __Pyx_FakeReference(const T& ref) : ptr(const_cast<T*>(&ref)) { }
+    T *operator->() { return ptr; }
+    T *operator&() { return ptr; }
+    operator T&() { return *ptr; }
+    template<typename U> bool operator ==(U other) { return *ptr == other; }
+    template<typename U> bool operator !=(U other) { return *ptr != other; }
+  private:
+    T *ptr;
+};
 
 #define __PYX_BUILD_PY_SSIZE_T "n"
 #define CYTHON_FORMAT_SSIZE_T "z"
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
@@ -980,102 +1008,80 @@
   "multimcts/mcts.pyx",
   "stringsource",
 };
 
 /*--- Type declarations ---*/
 struct __pyx_obj_9multimcts_4mcts_Node;
 struct __pyx_obj_9multimcts_4mcts_MCTS;
-struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate;
 
-/* "multimcts/mcts.pyx":225
- *         return child
- * 
- *     cdef map[string,double] simulate(self, Node node, heuristic=None):             # <<<<<<<<<<<<<<
- *         """Step 3: Simulation (aka playout/rollout)
- *         Play out a game, from the given node to termination, and return the final reward.
- */
-struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate {
-  int __pyx_n;
-  PyObject *heuristic;
-};
-
-/* "multimcts/mcts.pyx":49
+/* "multimcts/mcts.pyx":67
  * 
  * 
  * cdef class Node:             # <<<<<<<<<<<<<<
  *     """Represents a game state node in the MCTS search tree.
  *     Args:
  */
 struct __pyx_obj_9multimcts_4mcts_Node {
   PyObject_HEAD
   struct __pyx_vtabstruct_9multimcts_4mcts_Node *__pyx_vtab;
   PyObject *state;
   PyObject *move;
-  PyObject *team;
-  std::string cteam;
-  struct __pyx_obj_9multimcts_4mcts_Node *parent;
   PyObject *children;
   PyObject *remaining_moves;
+  struct __pyx_obj_9multimcts_4mcts_Node *parent;
+  std::string team;
   std::map<std::string,double>  rewards;
+  std::map<std::string,double>  rave_rewards;
   int visits;
+  int rave_visits;
   int is_terminal;
   int is_fully_expanded;
-  double avg_reward;
   double sqrtlog_visits;
   double invsqrt_visits;
+  double avg_reward;
+  double avg_rave_reward;
 };
 
 
-/* "multimcts/mcts.pyx":134
+/* "multimcts/mcts.pyx":264
  * 
  * 
  * cdef class MCTS:             # <<<<<<<<<<<<<<
- *     cdef double exploration_bias
+ *     cdef double exploration_bias, rave_bias
  * 
  */
 struct __pyx_obj_9multimcts_4mcts_MCTS {
   PyObject_HEAD
-  struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *__pyx_vtab;
   double exploration_bias;
+  double rave_bias;
 };
 
 
 
-/* "multimcts/mcts.pyx":49
+/* "multimcts/mcts.pyx":67
  * 
  * 
  * cdef class Node:             # <<<<<<<<<<<<<<
  *     """Represents a game state node in the MCTS search tree.
  *     Args:
  */
 
 struct __pyx_vtabstruct_9multimcts_4mcts_Node {
-  PyObject *(*apply_rewards)(struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> );
-  double (*ucb)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double);
+  PyObject *(*visit)(struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> , PyObject *);
+  double (*uncertainty)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch);
+  double (*ucb)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch);
+  double (*rave_beta)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch);
+  double (*score)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double, int __pyx_skip_dispatch);
+  struct __pyx_obj_9multimcts_4mcts_Node *(*best_child)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double);
+  struct __pyx_obj_9multimcts_4mcts_Node *(*select)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double);
+  struct __pyx_obj_9multimcts_4mcts_Node *(*expand)(struct __pyx_obj_9multimcts_4mcts_Node *);
+  void (*execute_round)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double);
 };
 static struct __pyx_vtabstruct_9multimcts_4mcts_Node *__pyx_vtabptr_9multimcts_4mcts_Node;
 
-
-/* "multimcts/mcts.pyx":134
- * 
- * 
- * cdef class MCTS:             # <<<<<<<<<<<<<<
- *     cdef double exploration_bias
- * 
- */
-
-struct __pyx_vtabstruct_9multimcts_4mcts_MCTS {
-  struct __pyx_obj_9multimcts_4mcts_Node *(*select)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *);
-  struct __pyx_obj_9multimcts_4mcts_Node *(*expand)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *);
-  std::map<std::string,double>  (*simulate)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *, struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate *__pyx_optional_args);
-  PyObject *(*backpropagate)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> );
-  struct __pyx_obj_9multimcts_4mcts_Node *(*get_best_child)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *);
-};
-static struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *__pyx_vtabptr_9multimcts_4mcts_MCTS;
-
 /* --- Runtime support code (head) --- */
 /* Refnanny.proto */
 #ifndef CYTHON_REFNANNY
   #define CYTHON_REFNANNY 0
 #endif
 #if CYTHON_REFNANNY
   typedef struct {
@@ -1142,14 +1148,21 @@
 #else
 #define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
 #endif
 
 /* GetBuiltinName.proto */
 static PyObject *__Pyx_GetBuiltinName(PyObject *name);
 
+/* PyObjectCall.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
+#else
+#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
+#endif
+
 /* PyThreadStateGet.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
 #define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
 #define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
 #else
 #define __Pyx_PyThreadState_declare
@@ -1178,253 +1191,14 @@
 #define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
 #define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
 #define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
 #define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
 #define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
 #endif
 
-/* Profile.proto */
-#ifndef CYTHON_PROFILE
-#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_PYSTON
-  #define CYTHON_PROFILE 0
-#else
-  #define CYTHON_PROFILE 1
-#endif
-#endif
-#ifndef CYTHON_TRACE_NOGIL
-  #define CYTHON_TRACE_NOGIL 0
-#else
-  #if CYTHON_TRACE_NOGIL && !defined(CYTHON_TRACE)
-    #define CYTHON_TRACE 1
-  #endif
-#endif
-#ifndef CYTHON_TRACE
-  #define CYTHON_TRACE 0
-#endif
-#if CYTHON_TRACE
-  #undef CYTHON_PROFILE_REUSE_FRAME
-#endif
-#ifndef CYTHON_PROFILE_REUSE_FRAME
-  #define CYTHON_PROFILE_REUSE_FRAME 0
-#endif
-#if CYTHON_PROFILE || CYTHON_TRACE
-  #include "compile.h"
-  #include "frameobject.h"
-  #include "traceback.h"
-#if PY_VERSION_HEX >= 0x030b00a6
-  #ifndef Py_BUILD_CORE
-    #define Py_BUILD_CORE 1
-  #endif
-  #include "internal/pycore_frame.h"
-#endif
-  #if CYTHON_PROFILE_REUSE_FRAME
-    #define CYTHON_FRAME_MODIFIER static
-    #define CYTHON_FRAME_DEL(frame)
-  #else
-    #define CYTHON_FRAME_MODIFIER
-    #define CYTHON_FRAME_DEL(frame) Py_CLEAR(frame)
-  #endif
-  #define __Pyx_TraceDeclarations\
-      static PyCodeObject *__pyx_frame_code = NULL;\
-      CYTHON_FRAME_MODIFIER PyFrameObject *__pyx_frame = NULL;\
-      int __Pyx_use_tracing = 0;
-  #define __Pyx_TraceFrameInit(codeobj)\
-      if (codeobj) __pyx_frame_code = (PyCodeObject*) codeobj;
-#if PY_VERSION_HEX >= 0x030b00a2
-  #define __Pyx_IsTracing(tstate, check_tracing, check_funcs)\
-     (unlikely((tstate)->cframe->use_tracing) &&\
-         (!(check_tracing) || !(tstate)->tracing) &&\
-         (!(check_funcs) || (tstate)->c_profilefunc || (CYTHON_TRACE && (tstate)->c_tracefunc)))
-  #define __Pyx_EnterTracing(tstate) PyThreadState_EnterTracing(tstate)
-  #define __Pyx_LeaveTracing(tstate) PyThreadState_LeaveTracing(tstate)
-#elif PY_VERSION_HEX >= 0x030a00b1
-  #define __Pyx_IsTracing(tstate, check_tracing, check_funcs)\
-     (unlikely((tstate)->cframe->use_tracing) &&\
-         (!(check_tracing) || !(tstate)->tracing) &&\
-         (!(check_funcs) || (tstate)->c_profilefunc || (CYTHON_TRACE && (tstate)->c_tracefunc)))
-  #define __Pyx_EnterTracing(tstate)\
-      do { tstate->tracing++; tstate->cframe->use_tracing = 0; } while (0)
-  #define __Pyx_LeaveTracing(tstate)\
-      do {\
-          tstate->tracing--;\
-          tstate->cframe->use_tracing = ((CYTHON_TRACE && tstate->c_tracefunc != NULL)\
-                                 || tstate->c_profilefunc != NULL);\
-      } while (0)
-#else
-  #define __Pyx_IsTracing(tstate, check_tracing, check_funcs)\
-     (unlikely((tstate)->use_tracing) &&\
-         (!(check_tracing) || !(tstate)->tracing) &&\
-         (!(check_funcs) || (tstate)->c_profilefunc || (CYTHON_TRACE && (tstate)->c_tracefunc)))
-  #define __Pyx_EnterTracing(tstate)\
-      do { tstate->tracing++; tstate->use_tracing = 0; } while (0)
-  #define __Pyx_LeaveTracing(tstate)\
-      do {\
-          tstate->tracing--;\
-          tstate->use_tracing = ((CYTHON_TRACE && tstate->c_tracefunc != NULL)\
-                                         || tstate->c_profilefunc != NULL);\
-      } while (0)
-#endif
-  #ifdef WITH_THREAD
-  #define __Pyx_TraceCall(funcname, srcfile, firstlineno, nogil, goto_error)\
-  if (nogil) {\
-      if (CYTHON_TRACE_NOGIL) {\
-          PyThreadState *tstate;\
-          PyGILState_STATE state = PyGILState_Ensure();\
-          tstate = __Pyx_PyThreadState_Current;\
-          if (__Pyx_IsTracing(tstate, 1, 1)) {\
-              __Pyx_use_tracing = __Pyx_TraceSetupAndCall(&__pyx_frame_code, &__pyx_frame, tstate, funcname, srcfile, firstlineno);\
-          }\
-          PyGILState_Release(state);\
-          if (unlikely(__Pyx_use_tracing < 0)) goto_error;\
-      }\
-  } else {\
-      PyThreadState* tstate = PyThreadState_GET();\
-      if (__Pyx_IsTracing(tstate, 1, 1)) {\
-          __Pyx_use_tracing = __Pyx_TraceSetupAndCall(&__pyx_frame_code, &__pyx_frame, tstate, funcname, srcfile, firstlineno);\
-          if (unlikely(__Pyx_use_tracing < 0)) goto_error;\
-      }\
-  }
-  #else
-  #define __Pyx_TraceCall(funcname, srcfile, firstlineno, nogil, goto_error)\
-  {   PyThreadState* tstate = PyThreadState_GET();\
-      if (__Pyx_IsTracing(tstate, 1, 1)) {\
-          __Pyx_use_tracing = __Pyx_TraceSetupAndCall(&__pyx_frame_code, &__pyx_frame, tstate, funcname, srcfile, firstlineno);\
-          if (unlikely(__Pyx_use_tracing < 0)) goto_error;\
-      }\
-  }
-  #endif
-  #define __Pyx_TraceException()\
-  if (likely(!__Pyx_use_tracing)); else {\
-      PyThreadState* tstate = __Pyx_PyThreadState_Current;\
-      if (__Pyx_IsTracing(tstate, 0, 1)) {\
-          __Pyx_EnterTracing(tstate);\
-          PyObject *exc_info = __Pyx_GetExceptionTuple(tstate);\
-          if (exc_info) {\
-              if (CYTHON_TRACE && tstate->c_tracefunc)\
-                  tstate->c_tracefunc(\
-                      tstate->c_traceobj, __pyx_frame, PyTrace_EXCEPTION, exc_info);\
-              tstate->c_profilefunc(\
-                  tstate->c_profileobj, __pyx_frame, PyTrace_EXCEPTION, exc_info);\
-              Py_DECREF(exc_info);\
-          }\
-          __Pyx_LeaveTracing(tstate);\
-      }\
-  }
-  static void __Pyx_call_return_trace_func(PyThreadState *tstate, PyFrameObject *frame, PyObject *result) {
-      PyObject *type, *value, *traceback;
-      __Pyx_ErrFetchInState(tstate, &type, &value, &traceback);
-      __Pyx_EnterTracing(tstate);
-      if (CYTHON_TRACE && tstate->c_tracefunc)
-          tstate->c_tracefunc(tstate->c_traceobj, frame, PyTrace_RETURN, result);
-      if (tstate->c_profilefunc)
-          tstate->c_profilefunc(tstate->c_profileobj, frame, PyTrace_RETURN, result);
-      CYTHON_FRAME_DEL(frame);
-      __Pyx_LeaveTracing(tstate);
-      __Pyx_ErrRestoreInState(tstate, type, value, traceback);
-  }
-  #ifdef WITH_THREAD
-  #define __Pyx_TraceReturn(result, nogil)\
-  if (likely(!__Pyx_use_tracing)); else {\
-      if (nogil) {\
-          if (CYTHON_TRACE_NOGIL) {\
-              PyThreadState *tstate;\
-              PyGILState_STATE state = PyGILState_Ensure();\
-              tstate = __Pyx_PyThreadState_Current;\
-              if (__Pyx_IsTracing(tstate, 0, 0)) {\
-                  __Pyx_call_return_trace_func(tstate, __pyx_frame, (PyObject*)result);\
-              }\
-              PyGILState_Release(state);\
-          }\
-      } else {\
-          PyThreadState* tstate = __Pyx_PyThreadState_Current;\
-          if (__Pyx_IsTracing(tstate, 0, 0)) {\
-              __Pyx_call_return_trace_func(tstate, __pyx_frame, (PyObject*)result);\
-          }\
-      }\
-  }
-  #else
-  #define __Pyx_TraceReturn(result, nogil)\
-  if (likely(!__Pyx_use_tracing)); else {\
-      PyThreadState* tstate = __Pyx_PyThreadState_Current;\
-      if (__Pyx_IsTracing(tstate, 0, 0)) {\
-          __Pyx_call_return_trace_func(tstate, __pyx_frame, (PyObject*)result);\
-      }\
-  }
-  #endif
-  static PyCodeObject *__Pyx_createFrameCodeObject(const char *funcname, const char *srcfile, int firstlineno);
-  static int __Pyx_TraceSetupAndCall(PyCodeObject** code, PyFrameObject** frame, PyThreadState* tstate, const char *funcname, const char *srcfile, int firstlineno);
-#else
-  #define __Pyx_TraceDeclarations
-  #define __Pyx_TraceFrameInit(codeobj)
-  #define __Pyx_TraceCall(funcname, srcfile, firstlineno, nogil, goto_error)   if ((1)); else goto_error;
-  #define __Pyx_TraceException()
-  #define __Pyx_TraceReturn(result, nogil)
-#endif
-#if CYTHON_TRACE
-  static int __Pyx_call_line_trace_func(PyThreadState *tstate, PyFrameObject *frame, int lineno) {
-      int ret;
-      PyObject *type, *value, *traceback;
-      __Pyx_ErrFetchInState(tstate, &type, &value, &traceback);
-      __Pyx_PyFrame_SetLineNumber(frame, lineno);
-      __Pyx_EnterTracing(tstate);
-      ret = tstate->c_tracefunc(tstate->c_traceobj, frame, PyTrace_LINE, NULL);
-      __Pyx_LeaveTracing(tstate);
-      if (likely(!ret)) {
-          __Pyx_ErrRestoreInState(tstate, type, value, traceback);
-      } else {
-          Py_XDECREF(type);
-          Py_XDECREF(value);
-          Py_XDECREF(traceback);
-      }
-      return ret;
-  }
-  #ifdef WITH_THREAD
-  #define __Pyx_TraceLine(lineno, nogil, goto_error)\
-  if (likely(!__Pyx_use_tracing)); else {\
-      if (nogil) {\
-          if (CYTHON_TRACE_NOGIL) {\
-              int ret = 0;\
-              PyThreadState *tstate;\
-              PyGILState_STATE state = PyGILState_Ensure();\
-              tstate = __Pyx_PyThreadState_Current;\
-              if (__Pyx_IsTracing(tstate, 0, 0) && tstate->c_tracefunc && __pyx_frame->f_trace) {\
-                  ret = __Pyx_call_line_trace_func(tstate, __pyx_frame, lineno);\
-              }\
-              PyGILState_Release(state);\
-              if (unlikely(ret)) goto_error;\
-          }\
-      } else {\
-          PyThreadState* tstate = __Pyx_PyThreadState_Current;\
-          if (__Pyx_IsTracing(tstate, 0, 0) && tstate->c_tracefunc && __pyx_frame->f_trace) {\
-              int ret = __Pyx_call_line_trace_func(tstate, __pyx_frame, lineno);\
-              if (unlikely(ret)) goto_error;\
-          }\
-      }\
-  }
-  #else
-  #define __Pyx_TraceLine(lineno, nogil, goto_error)\
-  if (likely(!__Pyx_use_tracing)); else {\
-      PyThreadState* tstate = __Pyx_PyThreadState_Current;\
-      if (__Pyx_IsTracing(tstate, 0, 0) && tstate->c_tracefunc && __pyx_frame->f_trace) {\
-          int ret = __Pyx_call_line_trace_func(tstate, __pyx_frame, lineno);\
-          if (unlikely(ret)) goto_error;\
-      }\
-  }
-  #endif
-#else
-  #define __Pyx_TraceLine(lineno, nogil, goto_error)   if ((1)); else goto_error;
-#endif
-
-/* PyObjectCall.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
-#else
-#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
-#endif
-
 /* RaiseException.proto */
 static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
 
 /* RaiseArgTupleInvalid.proto */
 static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
     Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
 
@@ -1541,82 +1315,105 @@
 #define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
 #endif
 
 /* PyObjectCall2Args.proto */
 static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
 
+/* IncludeCppStringH.proto */
+#include <string>
+
+/* decode_c_string_utf16.proto */
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = 0;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16LE(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = -1;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16BE(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = 1;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+
+/* decode_c_bytes.proto */
+static CYTHON_INLINE PyObject* __Pyx_decode_c_bytes(
+         const char* cstring, Py_ssize_t length, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors));
+
+/* decode_cpp_string.proto */
+static CYTHON_INLINE PyObject* __Pyx_decode_cpp_string(
+         std::string cppstring, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
+    return __Pyx_decode_c_bytes(
+        cppstring.data(), cppstring.size(), start, stop, encoding, errors, decode_func);
+}
+
+/* PySequenceContains.proto */
+static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
+    int result = PySequence_Contains(seq, item);
+    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
+}
+
 /* WriteUnraisableException.proto */
 static void __Pyx_WriteUnraisable(const char *name, int clineno,
                                   int lineno, const char *filename,
                                   int full_traceback, int nogil);
 
-/* PyErrExceptionMatches.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
-#else
-#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
-#endif
-
-/* GetAttr.proto */
-static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);
+/* IterNext.proto */
+#define __Pyx_PyIter_Next(obj) __Pyx_PyIter_Next2(obj, NULL)
+static CYTHON_INLINE PyObject *__Pyx_PyIter_Next2(PyObject *, PyObject *);
 
-/* GetAttr3.proto */
-static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *, PyObject *, PyObject *);
+/* ExtTypeTest.proto */
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
 
-/* pyfrozenset_new.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyFrozenSet_New(PyObject* it);
+/* IterFinish.proto */
+static CYTHON_INLINE int __Pyx_IterFinish(void);
 
-/* PySetContains.proto */
-static CYTHON_INLINE int __Pyx_PySet_ContainsTF(PyObject* key, PyObject* set, int eq);
+/* PyObjectGetMethod.proto */
+static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);
 
-/* PyUnicode_Unicode.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_Unicode(PyObject *obj);
+/* PyObjectCallMethod0.proto */
+static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name);
 
-/* PyObjectFormatSimple.proto */
-#if CYTHON_COMPILING_IN_PYPY
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
-#elif PY_MAJOR_VERSION < 3
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyString_CheckExact(s)) ? PyUnicode_FromEncodedObject(s, NULL, "strict") :\
-        PyObject_Format(s, f))
-#elif CYTHON_USE_TYPE_SLOTS
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyLong_CheckExact(s)) ? PyLong_Type.tp_str(s) :\
-        likely(PyFloat_CheckExact(s)) ? PyFloat_Type.tp_str(s) :\
-        PyObject_Format(s, f))
-#else
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
-#endif
+/* RaiseNeedMoreValuesToUnpack.proto */
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
 
-/* IncludeStringH.proto */
-#include <string.h>
+/* RaiseTooManyValuesToUnpack.proto */
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
 
-/* JoinPyUnicode.proto */
-static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
-                                      Py_UCS4 max_char);
+/* UnpackItemEndCheck.proto */
+static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);
 
-/* BytesEquals.proto */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
+/* RaiseNoneIterError.proto */
+static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
 
-/* UnicodeEquals.proto */
-static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);
+/* UnpackTupleError.proto */
+static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index);
 
-/* PyObjectGetMethod.proto */
-static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);
+/* UnpackTuple2.proto */
+#define __Pyx_unpack_tuple2(tuple, value1, value2, is_tuple, has_known_size, decref_tuple)\
+    (likely(is_tuple || PyTuple_Check(tuple)) ?\
+        (likely(has_known_size || PyTuple_GET_SIZE(tuple) == 2) ?\
+            __Pyx_unpack_tuple2_exact(tuple, value1, value2, decref_tuple) :\
+            (__Pyx_UnpackTupleError(tuple, 2), -1)) :\
+        __Pyx_unpack_tuple2_generic(tuple, value1, value2, has_known_size, decref_tuple))
+static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
+    PyObject* tuple, PyObject** value1, PyObject** value2, int decref_tuple);
+static int __Pyx_unpack_tuple2_generic(
+    PyObject* tuple, PyObject** value1, PyObject** value2, int has_known_size, int decref_tuple);
 
-/* PyObjectCallMethod0.proto */
-static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name);
+/* dict_iter.proto */
+static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* dict, int is_dict, PyObject* method_name,
+                                                   Py_ssize_t* p_orig_length, int* p_is_dict);
+static CYTHON_INLINE int __Pyx_dict_iter_next(PyObject* dict_or_iter, Py_ssize_t orig_length, Py_ssize_t* ppos,
+                                              PyObject** pkey, PyObject** pvalue, PyObject** pitem, int is_dict);
 
 /* pop.proto */
 static CYTHON_INLINE PyObject* __Pyx__PyObject_Pop(PyObject* L);
 #if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
 static CYTHON_INLINE PyObject* __Pyx_PyList_Pop(PyObject* L);
 #define __Pyx_PyObject_Pop(L) (likely(PyList_CheckExact(L)) ?\
     __Pyx_PyList_Pop(L) : __Pyx__PyObject_Pop(L))
@@ -1650,37 +1447,14 @@
                ((cfunc)->flag == METH_VARARGS ?  (*((cfunc)->func))(self, __pyx_empty_tuple) :\
                __Pyx__CallUnboundCMethod0(cfunc, self)))))) :\
         __Pyx__CallUnboundCMethod0(cfunc, self))
 #else
 #define __Pyx_CallUnboundCMethod0(cfunc, self)  __Pyx__CallUnboundCMethod0(cfunc, self)
 #endif
 
-/* ListAppend.proto */
-#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
-static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
-    PyListObject* L = (PyListObject*) list;
-    Py_ssize_t len = Py_SIZE(list);
-    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
-        Py_INCREF(x);
-        PyList_SET_ITEM(list, len, x);
-        __Pyx_SET_SIZE(list, len + 1);
-        return 0;
-    }
-    return PyList_Append(list, x);
-}
-#else
-#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
-#endif
-
-/* PyObjectCallMethod1.proto */
-static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);
-
-/* append.proto */
-static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x);
-
 /* PyIntCompare.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, long intval, long inplace);
 
 /* GetItemInt.proto */
 #define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
     (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
     __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
@@ -1718,67 +1492,52 @@
  PyFloat_AsDouble(obj) : __Pyx__PyObject_AsDouble(obj))
 #else
 #define __Pyx_PyObject_AsDouble(obj)\
 ((likely(PyFloat_CheckExact(obj))) ?\
  PyFloat_AS_DOUBLE(obj) : __Pyx__PyObject_AsDouble(obj))
 #endif
 
-/* ExtTypeTest.proto */
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
-
-/* PySequenceContains.proto */
-static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
-    int result = PySequence_Contains(seq, item);
-    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
-}
-
-/* Import.proto */
-static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
+/* PyErrExceptionMatches.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
+#else
+#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
+#endif
 
-/* ImportFrom.proto */
-static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
+/* GetAttr.proto */
+static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);
 
-/* HasAttr.proto */
-static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
+/* GetAttr3.proto */
+static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *, PyObject *, PyObject *);
 
-/* IterFinish.proto */
-static CYTHON_INLINE int __Pyx_IterFinish(void);
+/* IncludeStringH.proto */
+#include <string.h>
 
-/* RaiseNeedMoreValuesToUnpack.proto */
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
+/* BytesEquals.proto */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
 
-/* RaiseTooManyValuesToUnpack.proto */
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
+/* UnicodeEquals.proto */
+static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);
 
-/* UnpackItemEndCheck.proto */
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);
+/* PyUnicode_Unicode.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_Unicode(PyObject *obj);
 
-/* RaiseNoneIterError.proto */
-static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
+/* JoinPyUnicode.proto */
+static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
+                                      Py_UCS4 max_char);
 
-/* UnpackTupleError.proto */
-static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index);
+/* Import.proto */
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
-/* UnpackTuple2.proto */
-#define __Pyx_unpack_tuple2(tuple, value1, value2, is_tuple, has_known_size, decref_tuple)\
-    (likely(is_tuple || PyTuple_Check(tuple)) ?\
-        (likely(has_known_size || PyTuple_GET_SIZE(tuple) == 2) ?\
-            __Pyx_unpack_tuple2_exact(tuple, value1, value2, decref_tuple) :\
-            (__Pyx_UnpackTupleError(tuple, 2), -1)) :\
-        __Pyx_unpack_tuple2_generic(tuple, value1, value2, has_known_size, decref_tuple))
-static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
-    PyObject* tuple, PyObject** value1, PyObject** value2, int decref_tuple);
-static int __Pyx_unpack_tuple2_generic(
-    PyObject* tuple, PyObject** value1, PyObject** value2, int has_known_size, int decref_tuple);
+/* ImportFrom.proto */
+static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
 
-/* dict_iter.proto */
-static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* dict, int is_dict, PyObject* method_name,
-                                                   Py_ssize_t* p_orig_length, int* p_is_dict);
-static CYTHON_INLINE int __Pyx_dict_iter_next(PyObject* dict_or_iter, Py_ssize_t orig_length, Py_ssize_t* ppos,
-                                              PyObject** pkey, PyObject** pvalue, PyObject** pitem, int is_dict);
+/* HasAttr.proto */
+static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
 
 /* PyObject_GenericGetAttrNoDict.proto */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
 #endif
@@ -1985,155 +1744,171 @@
 
 /* CheckBinaryVersion.proto */
 static int __Pyx_check_binary_version(void);
 
 /* InitStrings.proto */
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);
 
-static PyObject *__pyx_f_9multimcts_4mcts_4Node_apply_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, std::map<std::string,double>  __pyx_v_crewards); /* proto*/
-static double __pyx_f_9multimcts_4mcts_4Node_ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_parent_sqrtlog_visits); /* proto*/
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_select(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node); /* proto*/
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_expand(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node); /* proto*/
-static std::map<std::string,double>  __pyx_f_9multimcts_4mcts_4MCTS_simulate(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node, struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate *__pyx_optional_args); /* proto*/
-static PyObject *__pyx_f_9multimcts_4mcts_4MCTS_backpropagate(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node, std::map<std::string,double>  __pyx_v_crewards); /* proto*/
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_get_best_child(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node); /* proto*/
+static PyObject *__pyx_f_9multimcts_4mcts_4Node_visit(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, std::map<std::string,double>  __pyx_v_crewards, PyObject *__pyx_v_moves); /* proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_uncertainty(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, int __pyx_skip_dispatch); /* proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, int __pyx_skip_dispatch); /* proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_rave_beta(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_b, int __pyx_skip_dispatch); /* proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_score(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias, int __pyx_skip_dispatch); /* proto*/
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_best_child(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias); /* proto*/
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_select(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias); /* proto*/
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_expand(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto*/
+static void __pyx_f_9multimcts_4mcts_4Node_execute_round(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias); /* proto*/
+
+/* Module declarations from 'cython' */
 
 /* Module declarations from 'libc.math' */
 
 /* Module declarations from 'libcpp.utility' */
 
 /* Module declarations from 'libcpp.map' */
 
 /* Module declarations from 'libc.string' */
 
 /* Module declarations from 'libcpp.string' */
 
 /* Module declarations from 'libcpp.pair' */
 
-/* Module declarations from 'cython' */
-
 /* Module declarations from 'multimcts.mcts' */
 static PyTypeObject *__pyx_ptype_9multimcts_4mcts_Node = 0;
 static PyTypeObject *__pyx_ptype_9multimcts_4mcts_MCTS = 0;
+static double __pyx_v_9multimcts_4mcts_SQRTLOG[0x2710];
+static double __pyx_v_9multimcts_4mcts_INVSQRT[0x2710];
+static double __pyx_f_9multimcts_4mcts_sqrtlog(int); /*proto*/
+static double __pyx_f_9multimcts_4mcts_invsqrt(int); /*proto*/
+static void __pyx_f_9multimcts_4mcts_precalc(void); /*proto*/
 static PyObject *__pyx_f_9multimcts_4mcts___pyx_unpickle_Node__set_state(struct __pyx_obj_9multimcts_4mcts_Node *, PyObject *); /*proto*/
 static PyObject *__pyx_f_9multimcts_4mcts___pyx_unpickle_MCTS__set_state(struct __pyx_obj_9multimcts_4mcts_MCTS *, PyObject *); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &); /*proto*/
-static std::string __pyx_convert_string_from_py_std__in_string(PyObject *); /*proto*/
 static PyObject *__pyx_convert_map_to_py_std_3a__3a_string____double(std::map<std::string,double>  const &); /*proto*/
+static std::string __pyx_convert_string_from_py_std__in_string(PyObject *); /*proto*/
 static std::map<std::string,double>  __pyx_convert_map_from_py_std_3a__3a_string__and_double(PyObject *); /*proto*/
 #define __Pyx_MODULE_NAME "multimcts.mcts"
 extern int __pyx_module_is_main_multimcts__mcts;
 int __pyx_module_is_main_multimcts__mcts = 0;
 
 /* Implementation of 'multimcts.mcts' */
 static PyObject *__pyx_builtin_NotImplementedError;
 static PyObject *__pyx_builtin_ValueError;
-static const char __pyx_k_Any[] = "Any";
+static PyObject *__pyx_builtin_range;
 static const char __pyx_k_doc[] = "__doc__";
 static const char __pyx_k_new[] = "__new__";
 static const char __pyx_k_pop[] = "pop";
+static const char __pyx_k_ucb[] = "ucb";
 static const char __pyx_k_Dict[] = "Dict";
 static const char __pyx_k_List[] = "List";
 static const char __pyx_k_MCTS[] = "MCTS";
 static const char __pyx_k_Move[] = "Move";
 static const char __pyx_k_Node[] = "Node";
 static const char __pyx_k_None[] = "None";
 static const char __pyx_k_Team[] = "Team";
 static const char __pyx_k_dict[] = "__dict__";
+static const char __pyx_k_keys[] = "keys";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_move[] = "move";
 static const char __pyx_k_name[] = "__name__";
 static const char __pyx_k_node[] = "node";
 static const char __pyx_k_self[] = "self";
 static const char __pyx_k_test[] = "__test__";
 static const char __pyx_k_time[] = "time";
 static const char __pyx_k_Union[] = "Union";
-static const char __pyx_k_lower[] = "lower";
+static const char __pyx_k_items[] = "items";
+static const char __pyx_k_range[] = "range";
+static const char __pyx_k_score[] = "score";
 static const char __pyx_k_state[] = "state";
-static const char __pyx_k_append[] = "append";
 static const char __pyx_k_choice[] = "choice";
 static const char __pyx_k_import[] = "__import__";
 static const char __pyx_k_module[] = "__module__";
 static const char __pyx_k_parent[] = "parent";
 static const char __pyx_k_pickle[] = "pickle";
 static const char __pyx_k_random[] = "random";
 static const char __pyx_k_reduce[] = "__reduce__";
 static const char __pyx_k_return[] = "return";
 static const char __pyx_k_typing[] = "typing";
 static const char __pyx_k_update[] = "update";
+static const char __pyx_k_values[] = "values";
 static const char __pyx_k_Rewards[] = "Rewards";
 static const char __pyx_k_prepare[] = "__prepare__";
 static const char __pyx_k_shuffle[] = "shuffle";
+static const char __pyx_k_Hashable[] = "Hashable";
 static const char __pyx_k_getstate[] = "__getstate__";
 static const char __pyx_k_max_time[] = "max_time";
 static const char __pyx_k_pyx_type[] = "__pyx_type";
 static const char __pyx_k_qualname[] = "__qualname__";
 static const char __pyx_k_setstate[] = "__setstate__";
 static const char __pyx_k_GameState[] = "GameState";
-static const char __pyx_k_heuristic[] = "heuristic";
 static const char __pyx_k_iteritems[] = "iteritems";
 static const char __pyx_k_make_move[] = "make_move";
 static const char __pyx_k_metaclass[] = "__metaclass__";
 static const char __pyx_k_pyx_state[] = "__pyx_state";
+static const char __pyx_k_rave_beta[] = "rave_beta";
+static const char __pyx_k_rave_bias[] = "rave_bias";
 static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
 static const char __pyx_k_ValueError[] = "ValueError";
 static const char __pyx_k_get_reward[] = "get_reward";
 static const char __pyx_k_pyx_result[] = "__pyx_result";
 static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
 static const char __pyx_k_PickleError[] = "PickleError";
 static const char __pyx_k_is_terminal[] = "is_terminal";
 static const char __pyx_k_return_type[] = "return_type";
+static const char __pyx_k_uncertainty[] = "uncertainty";
 static const char __pyx_k_pyx_checksum[] = "__pyx_checksum";
 static const char __pyx_k_stringsource[] = "stringsource";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
 static const char __pyx_k_max_iterations[] = "max_iterations";
 static const char __pyx_k_multimcts_mcts[] = "multimcts.mcts";
-static const char __pyx_k_must_be_one_of[] = ", must be one of ";
 static const char __pyx_k_get_legal_moves[] = "get_legal_moves";
 static const char __pyx_k_pyx_PickleError[] = "__pyx_PickleError";
 static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
 static const char __pyx_k_exploration_bias[] = "exploration_bias";
 static const char __pyx_k_get_current_team[] = "get_current_team";
 static const char __pyx_k_pyx_unpickle_MCTS[] = "__pyx_unpickle_MCTS";
 static const char __pyx_k_pyx_unpickle_Node[] = "__pyx_unpickle_Node";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_multimcts_mcts_pyx[] = "multimcts/mcts.pyx";
 static const char __pyx_k_GameState_make_move[] = "GameState.make_move";
-static const char __pyx_k_Invalid_return_type[] = "Invalid return type: ";
+static const char __pyx_k_Invalid_return_type[] = "Invalid return_type \"";
 static const char __pyx_k_NotImplementedError[] = "NotImplementedError";
 static const char __pyx_k_GameState_get_reward[] = "GameState.get_reward";
 static const char __pyx_k_GameState_is_terminal[] = "GameState.is_terminal";
 static const char __pyx_k_GameState_get_legal_moves[] = "GameState.get_legal_moves";
 static const char __pyx_k_GameState_get_current_team[] = "GameState.get_current_team";
+static const char __pyx_k_must_be_one_of_state_move_node[] = "\" must be one of {\"state\",\"move\",\"node\"}";
+static const char __pyx_k_Could_not_determine_terminal_tea[] = "Could not determine terminal team during simulation.";
 static const char __pyx_k_GameState_must_implement_get_cur[] = "GameState must implement get_current_team.";
 static const char __pyx_k_GameState_must_implement_get_leg[] = "GameState must implement get_legal_moves.";
 static const char __pyx_k_GameState_must_implement_get_rew[] = "GameState must implement get_reward.";
 static const char __pyx_k_GameState_must_implement_is_term[] = "GameState must implement is_terminal.";
 static const char __pyx_k_GameState_must_implement_make_mo[] = "GameState must implement make_move.";
-static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))";
+static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))";
 static const char __pyx_k_One_or_more_of_max_time_max_iter[] = "One or more of max_time/max_iterations is required.";
-static const char __pyx_k_Incompatible_checksums_0x_x_vs_0_2[] = "Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))";
-static PyObject *__pyx_n_s_Any;
+static const char __pyx_k_Incompatible_checksums_0x_x_vs_0_2[] = "Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))";
+static PyObject *__pyx_kp_u_Could_not_determine_terminal_tea;
 static PyObject *__pyx_n_s_Dict;
 static PyObject *__pyx_n_s_GameState;
 static PyObject *__pyx_n_u_GameState;
 static PyObject *__pyx_n_s_GameState_get_current_team;
 static PyObject *__pyx_n_s_GameState_get_legal_moves;
 static PyObject *__pyx_n_s_GameState_get_reward;
 static PyObject *__pyx_n_s_GameState_is_terminal;
 static PyObject *__pyx_n_s_GameState_make_move;
 static PyObject *__pyx_kp_u_GameState_must_implement_get_cur;
 static PyObject *__pyx_kp_u_GameState_must_implement_get_leg;
 static PyObject *__pyx_kp_u_GameState_must_implement_get_rew;
 static PyObject *__pyx_kp_u_GameState_must_implement_is_term;
 static PyObject *__pyx_kp_u_GameState_must_implement_make_mo;
+static PyObject *__pyx_n_s_Hashable;
 static PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
 static PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0_2;
 static PyObject *__pyx_kp_u_Invalid_return_type;
 static PyObject *__pyx_n_s_List;
 static PyObject *__pyx_n_s_MCTS;
 static PyObject *__pyx_n_s_Move;
 static PyObject *__pyx_n_s_Node;
@@ -2141,40 +1916,39 @@
 static PyObject *__pyx_n_s_NotImplementedError;
 static PyObject *__pyx_kp_u_One_or_more_of_max_time_max_iter;
 static PyObject *__pyx_n_s_PickleError;
 static PyObject *__pyx_n_s_Rewards;
 static PyObject *__pyx_n_s_Team;
 static PyObject *__pyx_n_s_Union;
 static PyObject *__pyx_n_s_ValueError;
-static PyObject *__pyx_n_s_append;
 static PyObject *__pyx_n_s_choice;
 static PyObject *__pyx_n_s_cline_in_traceback;
 static PyObject *__pyx_n_s_dict;
 static PyObject *__pyx_n_s_doc;
 static PyObject *__pyx_n_s_exploration_bias;
 static PyObject *__pyx_n_s_get_current_team;
 static PyObject *__pyx_n_s_get_legal_moves;
 static PyObject *__pyx_n_s_get_reward;
 static PyObject *__pyx_n_s_getstate;
-static PyObject *__pyx_n_s_heuristic;
 static PyObject *__pyx_n_s_import;
 static PyObject *__pyx_n_s_is_terminal;
+static PyObject *__pyx_n_s_items;
 static PyObject *__pyx_n_s_iteritems;
-static PyObject *__pyx_n_s_lower;
+static PyObject *__pyx_n_s_keys;
 static PyObject *__pyx_n_s_main;
 static PyObject *__pyx_n_s_make_move;
 static PyObject *__pyx_n_s_max_iterations;
 static PyObject *__pyx_n_s_max_time;
 static PyObject *__pyx_n_s_metaclass;
 static PyObject *__pyx_n_s_module;
 static PyObject *__pyx_n_s_move;
 static PyObject *__pyx_n_u_move;
 static PyObject *__pyx_n_s_multimcts_mcts;
 static PyObject *__pyx_kp_s_multimcts_mcts_pyx;
-static PyObject *__pyx_kp_u_must_be_one_of;
+static PyObject *__pyx_kp_u_must_be_one_of_state_move_node;
 static PyObject *__pyx_n_s_name;
 static PyObject *__pyx_n_s_new;
 static PyObject *__pyx_n_u_node;
 static PyObject *__pyx_n_s_parent;
 static PyObject *__pyx_n_s_pickle;
 static PyObject *__pyx_n_s_pop;
 static PyObject *__pyx_n_s_prepare;
@@ -2184,79 +1958,101 @@
 static PyObject *__pyx_n_s_pyx_state;
 static PyObject *__pyx_n_s_pyx_type;
 static PyObject *__pyx_n_s_pyx_unpickle_MCTS;
 static PyObject *__pyx_n_s_pyx_unpickle_Node;
 static PyObject *__pyx_n_s_pyx_vtable;
 static PyObject *__pyx_n_s_qualname;
 static PyObject *__pyx_n_s_random;
+static PyObject *__pyx_n_s_range;
+static PyObject *__pyx_n_s_rave_beta;
+static PyObject *__pyx_n_s_rave_bias;
 static PyObject *__pyx_n_s_reduce;
 static PyObject *__pyx_n_s_reduce_cython;
 static PyObject *__pyx_n_s_reduce_ex;
 static PyObject *__pyx_n_s_return;
 static PyObject *__pyx_n_s_return_type;
+static PyObject *__pyx_n_s_score;
 static PyObject *__pyx_n_s_self;
 static PyObject *__pyx_n_s_setstate;
 static PyObject *__pyx_n_s_setstate_cython;
 static PyObject *__pyx_n_s_shuffle;
 static PyObject *__pyx_n_s_state;
 static PyObject *__pyx_n_u_state;
 static PyObject *__pyx_kp_s_stringsource;
 static PyObject *__pyx_n_s_test;
 static PyObject *__pyx_n_s_time;
 static PyObject *__pyx_n_s_typing;
+static PyObject *__pyx_n_s_ucb;
+static PyObject *__pyx_n_s_uncertainty;
 static PyObject *__pyx_n_s_update;
+static PyObject *__pyx_n_s_values;
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_get_current_team(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_2get_legal_moves(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_4make_move(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_move); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_6is_terminal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_8get_reward(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
 static int __pyx_pf_9multimcts_4mcts_4Node___init__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v_state, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_parent, PyObject *__pyx_v_move); /* proto */
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_5state___get__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_7rewards___get__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_2__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_4__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v___pyx_state); /* proto */
-static int __pyx_pf_9multimcts_4mcts_4MCTS___init__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, double __pyx_v_exploration_bias); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_2get_state(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_4get_team(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_6get_move(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_pf_9multimcts_4mcts_4Node_8get_parent(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_10get_children(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_12get_visits(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_14get_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_16get_avg_reward(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_18get_rave_visits(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_20get_rave_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_22get_avg_rave_reward(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_24uncertainty(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_26ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_28rave_beta(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_b); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_30score(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_32__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_34__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v___pyx_state); /* proto */
+static int __pyx_pf_9multimcts_4mcts_4MCTS___init__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_16exploration_bias___get__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_2search(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v_state, PyObject *__pyx_v_max_time, PyObject *__pyx_v_max_iterations, PyObject *__pyx_v_heuristic, PyObject *__pyx_v_return_type); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_9rave_bias___get__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_2search(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v_state, PyObject *__pyx_v_max_time, PyObject *__pyx_v_max_iterations, PyObject *__pyx_v_return_type); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_4__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_6__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts___pyx_unpickle_Node(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_2__pyx_unpickle_MCTS(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_tp_new_9multimcts_4mcts_Node(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_9multimcts_4mcts_MCTS(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static __Pyx_CachedCFunction __pyx_umethod_PyList_Type_pop = {0, &__pyx_n_s_pop, 0, 0, 0};
 static PyObject *__pyx_int_0;
-static PyObject *__pyx_int_56097295;
-static PyObject *__pyx_int_59888949;
-static PyObject *__pyx_int_82662024;
-static PyObject *__pyx_int_99932858;
-static PyObject *__pyx_int_203704333;
-static PyObject *__pyx_int_231097371;
-static PyObject *__pyx_codeobj_;
+static PyObject *__pyx_int_47470116;
+static PyObject *__pyx_int_145648438;
+static PyObject *__pyx_int_160888804;
+static PyObject *__pyx_int_186508213;
+static PyObject *__pyx_int_233936184;
+static PyObject *__pyx_int_254580472;
+static PyObject *__pyx_tuple_;
 static PyObject *__pyx_tuple__2;
+static PyObject *__pyx_tuple__3;
 static PyObject *__pyx_tuple__4;
+static PyObject *__pyx_tuple__5;
 static PyObject *__pyx_tuple__6;
+static PyObject *__pyx_tuple__7;
 static PyObject *__pyx_tuple__8;
+static PyObject *__pyx_tuple__9;
 static PyObject *__pyx_tuple__10;
-static PyObject *__pyx_tuple__11;
-static PyObject *__pyx_tuple__13;
-static PyObject *__pyx_tuple__15;
+static PyObject *__pyx_tuple__12;
+static PyObject *__pyx_tuple__14;
 static PyObject *__pyx_tuple__16;
-static PyObject *__pyx_tuple__17;
 static PyObject *__pyx_tuple__18;
-static PyObject *__pyx_tuple__19;
 static PyObject *__pyx_tuple__20;
-static PyObject *__pyx_tuple__21;
 static PyObject *__pyx_tuple__22;
-static PyObject *__pyx_codeobj__3;
-static PyObject *__pyx_codeobj__5;
-static PyObject *__pyx_codeobj__7;
-static PyObject *__pyx_codeobj__9;
-static PyObject *__pyx_codeobj__12;
-static PyObject *__pyx_codeobj__14;
+static PyObject *__pyx_codeobj__11;
+static PyObject *__pyx_codeobj__13;
+static PyObject *__pyx_codeobj__15;
+static PyObject *__pyx_codeobj__17;
+static PyObject *__pyx_codeobj__19;
+static PyObject *__pyx_codeobj__21;
+static PyObject *__pyx_codeobj__23;
 /* Late includes */
 
 /* "multimcts/mcts.pyx":22
  * 
  * class GameState:
  *     def get_current_team(self) -> Team:             # <<<<<<<<<<<<<<
  *         """The identifier of the current player's team."""
@@ -2276,32 +2072,29 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_get_current_team(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_TraceFrameInit(__pyx_codeobj_)
   __Pyx_RefNannySetupContext("get_current_team", 0);
-  __Pyx_TraceCall("get_current_team", __pyx_f[0], 22, 0, __PYX_ERR(0, 22, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":24
  *     def get_current_team(self) -> Team:
  *         """The identifier of the current player's team."""
  *         raise NotImplementedError("GameState must implement get_current_team.")             # <<<<<<<<<<<<<<
  * 
  *     def get_legal_moves(self) -> List[Move]:
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 24, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 24, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(0, 24, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":22
  * 
@@ -2313,15 +2106,14 @@
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.GameState.get_current_team", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "multimcts/mcts.pyx":26
  *         raise NotImplementedError("GameState must implement get_current_team.")
  * 
@@ -2343,32 +2135,29 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_2get_legal_moves(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_TraceFrameInit(__pyx_codeobj__3)
   __Pyx_RefNannySetupContext("get_legal_moves", 0);
-  __Pyx_TraceCall("get_legal_moves", __pyx_f[0], 26, 0, __PYX_ERR(0, 26, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":28
  *     def get_legal_moves(self) -> List[Move]:
  *         """List of all legal moves from this state."""
  *         raise NotImplementedError("GameState must implement get_legal_moves.")             # <<<<<<<<<<<<<<
  * 
  *     def make_move(self, move:Move) -> 'GameState':
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 28, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 28, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(0, 28, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":26
  *         raise NotImplementedError("GameState must implement get_current_team.")
@@ -2380,15 +2169,14 @@
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.GameState.get_legal_moves", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "multimcts/mcts.pyx":30
  *         raise NotImplementedError("GameState must implement get_legal_moves.")
  * 
@@ -2461,32 +2249,29 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_4make_move(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_move) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_TraceFrameInit(__pyx_codeobj__5)
   __Pyx_RefNannySetupContext("make_move", 0);
-  __Pyx_TraceCall("make_move", __pyx_f[0], 30, 0, __PYX_ERR(0, 30, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":34
  *         Note: The current state (self) should NOT be modified. Rather, modify a copy of it.
  *         """
  *         raise NotImplementedError("GameState must implement make_move.")             # <<<<<<<<<<<<<<
  * 
  *     def is_terminal(self) -> bool:
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(0, 34, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":30
  *         raise NotImplementedError("GameState must implement get_legal_moves.")
@@ -2498,15 +2283,14 @@
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.GameState.make_move", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "multimcts/mcts.pyx":36
  *         raise NotImplementedError("GameState must implement make_move.")
  * 
@@ -2528,32 +2312,29 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_6is_terminal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_TraceFrameInit(__pyx_codeobj__7)
   __Pyx_RefNannySetupContext("is_terminal", 0);
-  __Pyx_TraceCall("is_terminal", __pyx_f[0], 36, 0, __PYX_ERR(0, 36, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":38
  *     def is_terminal(self) -> bool:
  *         """Is the game over?"""
  *         raise NotImplementedError("GameState must implement is_terminal.")             # <<<<<<<<<<<<<<
  * 
  *     def get_reward(self) -> Union[float,Rewards]:
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 38, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 38, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(0, 38, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":36
  *         raise NotImplementedError("GameState must implement make_move.")
@@ -2565,88 +2346,83 @@
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.GameState.is_terminal", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "multimcts/mcts.pyx":40
  *         raise NotImplementedError("GameState must implement is_terminal.")
  * 
  *     def get_reward(self) -> Union[float,Rewards]:             # <<<<<<<<<<<<<<
- *         """The reward earned by the team that played the game-ending move (the "terminal team", or the team from the previous state).
+ *         """The reward earned by the team that played the game-ending move (i.e. the team from the previous state).
  *         Typically 1 for win, -1 for loss, 0 for draw.
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_9multimcts_4mcts_9GameState_9get_reward(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
-static char __pyx_doc_9multimcts_4mcts_9GameState_8get_reward[] = "The reward earned by the team that played the game-ending move (the \"terminal team\", or the team from the previous state).\n        Typically 1 for win, -1 for loss, 0 for draw.\n        Alternatively, returns a dict of teams/rewards: {team1:reward1, team2:reward2, ...}\n        Note: This method is only called on terminal states.\n        ";
+static char __pyx_doc_9multimcts_4mcts_9GameState_8get_reward[] = "The reward earned by the team that played the game-ending move (i.e. the team from the previous state).\n        Typically 1 for win, -1 for loss, 0 for draw.\n        Alternatively, returns a dict of teams/rewards: {team1:reward1, team2:reward2, ...}\n        Note: This method is only called on terminal states.\n        ";
 static PyMethodDef __pyx_mdef_9multimcts_4mcts_9GameState_9get_reward = {"get_reward", (PyCFunction)__pyx_pw_9multimcts_4mcts_9GameState_9get_reward, METH_O, __pyx_doc_9multimcts_4mcts_9GameState_8get_reward};
 static PyObject *__pyx_pw_9multimcts_4mcts_9GameState_9get_reward(PyObject *__pyx_self, PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("get_reward (wrapper)", 0);
   __pyx_r = __pyx_pf_9multimcts_4mcts_9GameState_8get_reward(__pyx_self, ((PyObject *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_8get_reward(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_TraceFrameInit(__pyx_codeobj__9)
   __Pyx_RefNannySetupContext("get_reward", 0);
-  __Pyx_TraceCall("get_reward", __pyx_f[0], 40, 0, __PYX_ERR(0, 40, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":46
  *         Note: This method is only called on terminal states.
  *         """
  *         raise NotImplementedError("GameState must implement get_reward.")             # <<<<<<<<<<<<<<
  * 
- * 
+ *     '''#.WIP
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 46, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 46, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(0, 46, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":40
  *         raise NotImplementedError("GameState must implement is_terminal.")
  * 
  *     def get_reward(self) -> Union[float,Rewards]:             # <<<<<<<<<<<<<<
- *         """The reward earned by the team that played the game-ending move (the "terminal team", or the team from the previous state).
+ *         """The reward earned by the team that played the game-ending move (i.e. the team from the previous state).
  *         Typically 1 for win, -1 for loss, 0 for draw.
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.GameState.get_reward", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":72
- *     cdef double avg_reward, sqrtlog_visits, invsqrt_visits
+/* "multimcts/mcts.pyx":89
+ *     cdef double sqrtlog_visits, invsqrt_visits, avg_reward, avg_rave_reward
  * 
  *     def __init__(self, state:GameState, parent:'Node'=None, move:Move=None):             # <<<<<<<<<<<<<<
  *         self.state = state
  *         self.parent = parent
  */
 
 /* Python wrapper */
@@ -2694,15 +2470,15 @@
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_move);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 72, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 89, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
@@ -2713,363 +2489,391 @@
     }
     __pyx_v_state = values[0];
     __pyx_v_parent = ((struct __pyx_obj_9multimcts_4mcts_Node *)values[1]);
     __pyx_v_move = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 72, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 89, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("multimcts.mcts.Node.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_parent), __pyx_ptype_9multimcts_4mcts_Node, 1, "parent", 0))) __PYX_ERR(0, 72, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_parent), __pyx_ptype_9multimcts_4mcts_Node, 1, "parent", 0))) __PYX_ERR(0, 89, __pyx_L1_error)
   __pyx_r = __pyx_pf_9multimcts_4mcts_4Node___init__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), __pyx_v_state, __pyx_v_parent, __pyx_v_move);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_9multimcts_4mcts_4Node___init__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v_state, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_parent, PyObject *__pyx_v_move) {
   int __pyx_r;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   std::map<std::string,double>  __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_t_5;
   std::string __pyx_t_6;
   int __pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
-  __Pyx_TraceCall("__init__", __pyx_f[0], 72, 0, __PYX_ERR(0, 72, __pyx_L1_error));
 
-  /* "multimcts/mcts.pyx":73
+  /* "multimcts/mcts.pyx":90
  * 
  *     def __init__(self, state:GameState, parent:'Node'=None, move:Move=None):
  *         self.state = state             # <<<<<<<<<<<<<<
  *         self.parent = parent
  *         self.move = move
  */
   __Pyx_INCREF(__pyx_v_state);
   __Pyx_GIVEREF(__pyx_v_state);
   __Pyx_GOTREF(__pyx_v_self->state);
   __Pyx_DECREF(__pyx_v_self->state);
   __pyx_v_self->state = __pyx_v_state;
 
-  /* "multimcts/mcts.pyx":74
+  /* "multimcts/mcts.pyx":91
  *     def __init__(self, state:GameState, parent:'Node'=None, move:Move=None):
  *         self.state = state
  *         self.parent = parent             # <<<<<<<<<<<<<<
  *         self.move = move
  * 
  */
   __Pyx_INCREF(((PyObject *)__pyx_v_parent));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_parent));
   __Pyx_GOTREF(__pyx_v_self->parent);
   __Pyx_DECREF(((PyObject *)__pyx_v_self->parent));
   __pyx_v_self->parent = __pyx_v_parent;
 
-  /* "multimcts/mcts.pyx":75
+  /* "multimcts/mcts.pyx":92
  *         self.state = state
  *         self.parent = parent
  *         self.move = move             # <<<<<<<<<<<<<<
  * 
- *         self.children:List['Node'] = []
+ *         self.children:Dict[Move,'Node'] = {}
  */
   __Pyx_INCREF(__pyx_v_move);
   __Pyx_GIVEREF(__pyx_v_move);
   __Pyx_GOTREF(__pyx_v_self->move);
   __Pyx_DECREF(__pyx_v_self->move);
   __pyx_v_self->move = __pyx_v_move;
 
-  /* "multimcts/mcts.pyx":77
+  /* "multimcts/mcts.pyx":94
  *         self.move = move
  * 
- *         self.children:List['Node'] = []             # <<<<<<<<<<<<<<
+ *         self.children:Dict[Move,'Node'] = {}             # <<<<<<<<<<<<<<
  *         self.visits = 0
- *         self.rewards = map[string,double]()
+ *         self.rave_visits = 0
  */
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 77, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v_self->children);
   __Pyx_DECREF(__pyx_v_self->children);
   __pyx_v_self->children = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "multimcts/mcts.pyx":78
+  /* "multimcts/mcts.pyx":95
  * 
- *         self.children:List['Node'] = []
+ *         self.children:Dict[Move,'Node'] = {}
  *         self.visits = 0             # <<<<<<<<<<<<<<
+ *         self.rave_visits = 0
  *         self.rewards = map[string,double]()
- *         self.is_terminal = self.state.is_terminal()
  */
   __pyx_v_self->visits = 0;
 
-  /* "multimcts/mcts.pyx":79
- *         self.children:List['Node'] = []
+  /* "multimcts/mcts.pyx":96
+ *         self.children:Dict[Move,'Node'] = {}
+ *         self.visits = 0
+ *         self.rave_visits = 0             # <<<<<<<<<<<<<<
+ *         self.rewards = map[string,double]()
+ *         self.rave_rewards = map[string,double]()
+ */
+  __pyx_v_self->rave_visits = 0;
+
+  /* "multimcts/mcts.pyx":97
  *         self.visits = 0
+ *         self.rave_visits = 0
  *         self.rewards = map[string,double]()             # <<<<<<<<<<<<<<
+ *         self.rave_rewards = map[string,double]()
  *         self.is_terminal = self.state.is_terminal()
- *         self.is_fully_expanded = self.is_terminal
  */
   try {
     __pyx_t_2 = std::map<std::string,double> ();
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 79, __pyx_L1_error)
+    __PYX_ERR(0, 97, __pyx_L1_error)
   }
   __pyx_v_self->rewards = __pyx_t_2;
 
-  /* "multimcts/mcts.pyx":80
- *         self.visits = 0
+  /* "multimcts/mcts.pyx":98
+ *         self.rave_visits = 0
+ *         self.rewards = map[string,double]()
+ *         self.rave_rewards = map[string,double]()             # <<<<<<<<<<<<<<
+ *         self.is_terminal = self.state.is_terminal()
+ *         self.is_fully_expanded = self.is_terminal
+ */
+  try {
+    __pyx_t_2 = std::map<std::string,double> ();
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 98, __pyx_L1_error)
+  }
+  __pyx_v_self->rave_rewards = __pyx_t_2;
+
+  /* "multimcts/mcts.pyx":99
  *         self.rewards = map[string,double]()
+ *         self.rave_rewards = map[string,double]()
  *         self.is_terminal = self.state.is_terminal()             # <<<<<<<<<<<<<<
  *         self.is_fully_expanded = self.is_terminal
  *         if self.is_fully_expanded:
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_is_terminal); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 80, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_is_terminal); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 80, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_self->is_terminal = __pyx_t_5;
 
-  /* "multimcts/mcts.pyx":81
- *         self.rewards = map[string,double]()
+  /* "multimcts/mcts.pyx":100
+ *         self.rave_rewards = map[string,double]()
  *         self.is_terminal = self.state.is_terminal()
  *         self.is_fully_expanded = self.is_terminal             # <<<<<<<<<<<<<<
  *         if self.is_fully_expanded:
  *             self.remaining_moves = []
  */
   __pyx_t_5 = __pyx_v_self->is_terminal;
   __pyx_v_self->is_fully_expanded = __pyx_t_5;
 
-  /* "multimcts/mcts.pyx":82
+  /* "multimcts/mcts.pyx":101
  *         self.is_terminal = self.state.is_terminal()
  *         self.is_fully_expanded = self.is_terminal
  *         if self.is_fully_expanded:             # <<<<<<<<<<<<<<
  *             self.remaining_moves = []
  *         else:
  */
   __pyx_t_5 = (__pyx_v_self->is_fully_expanded != 0);
   if (__pyx_t_5) {
 
-    /* "multimcts/mcts.pyx":83
+    /* "multimcts/mcts.pyx":102
  *         self.is_fully_expanded = self.is_terminal
  *         if self.is_fully_expanded:
  *             self.remaining_moves = []             # <<<<<<<<<<<<<<
  *         else:
  *             self.remaining_moves = self.state.get_legal_moves()
  */
-    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 83, __pyx_L1_error)
+    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 102, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_GIVEREF(__pyx_t_1);
     __Pyx_GOTREF(__pyx_v_self->remaining_moves);
     __Pyx_DECREF(__pyx_v_self->remaining_moves);
     __pyx_v_self->remaining_moves = __pyx_t_1;
     __pyx_t_1 = 0;
 
-    /* "multimcts/mcts.pyx":82
+    /* "multimcts/mcts.pyx":101
  *         self.is_terminal = self.state.is_terminal()
  *         self.is_fully_expanded = self.is_terminal
  *         if self.is_fully_expanded:             # <<<<<<<<<<<<<<
  *             self.remaining_moves = []
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "multimcts/mcts.pyx":85
+  /* "multimcts/mcts.pyx":104
  *             self.remaining_moves = []
  *         else:
  *             self.remaining_moves = self.state.get_legal_moves()             # <<<<<<<<<<<<<<
  *             shuffle(self.remaining_moves)
  * 
  */
   /*else*/ {
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_get_legal_moves); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 85, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_get_legal_moves); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 104, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_4 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_4)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 85, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 104, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GIVEREF(__pyx_t_1);
     __Pyx_GOTREF(__pyx_v_self->remaining_moves);
     __Pyx_DECREF(__pyx_v_self->remaining_moves);
     __pyx_v_self->remaining_moves = __pyx_t_1;
     __pyx_t_1 = 0;
 
-    /* "multimcts/mcts.pyx":86
+    /* "multimcts/mcts.pyx":105
  *         else:
  *             self.remaining_moves = self.state.get_legal_moves()
  *             shuffle(self.remaining_moves)             # <<<<<<<<<<<<<<
  * 
  *         # The following are cached for performance.
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_shuffle); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 86, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_shuffle); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 105, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_4 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_4)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_self->remaining_moves) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_self->remaining_moves);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 86, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 105, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   }
   __pyx_L3:;
 
-  /* "multimcts/mcts.pyx":89
+  /* "multimcts/mcts.pyx":108
  * 
  *         # The following are cached for performance.
- *         self.team = self.state.get_current_team()             # <<<<<<<<<<<<<<
- *         self.cteam = str(self.team).encode()
+ *         self.team = str(self.state.get_current_team()).encode()             # <<<<<<<<<<<<<<
  *         if self.parent is not None:
+ *             self.rewards[self.parent.team] = 0
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_get_current_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_get_current_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 108, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 89, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 108, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_GIVEREF(__pyx_t_1);
-  __Pyx_GOTREF(__pyx_v_self->team);
-  __Pyx_DECREF(__pyx_v_self->team);
-  __pyx_v_self->team = __pyx_t_1;
-  __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":90
- *         # The following are cached for performance.
- *         self.team = self.state.get_current_team()
- *         self.cteam = str(self.team).encode()             # <<<<<<<<<<<<<<
- *         if self.parent is not None:
- *             self.rewards[self.parent.cteam] = 0
- */
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_self->team); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 90, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = PyUnicode_AsEncodedString(((PyObject*)__pyx_t_1), NULL, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 90, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 108, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __pyx_convert_string_from_py_std__in_string(__pyx_t_3); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 90, __pyx_L1_error)
+  __pyx_t_1 = PyUnicode_AsEncodedString(((PyObject*)__pyx_t_3), NULL, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 108, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_self->cteam = __pyx_t_6;
+  __pyx_t_6 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 108, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_self->team = __pyx_t_6;
 
-  /* "multimcts/mcts.pyx":91
- *         self.team = self.state.get_current_team()
- *         self.cteam = str(self.team).encode()
+  /* "multimcts/mcts.pyx":109
+ *         # The following are cached for performance.
+ *         self.team = str(self.state.get_current_team()).encode()
  *         if self.parent is not None:             # <<<<<<<<<<<<<<
- *             self.rewards[self.parent.cteam] = 0
- *         self.sqrtlog_visits = 0
+ *             self.rewards[self.parent.team] = 0
+ *             self.rave_rewards[self.parent.team] = 0
  */
   __pyx_t_5 = (((PyObject *)__pyx_v_self->parent) != Py_None);
   __pyx_t_7 = (__pyx_t_5 != 0);
   if (__pyx_t_7) {
 
-    /* "multimcts/mcts.pyx":92
- *         self.cteam = str(self.team).encode()
+    /* "multimcts/mcts.pyx":110
+ *         self.team = str(self.state.get_current_team()).encode()
+ *         if self.parent is not None:
+ *             self.rewards[self.parent.team] = 0             # <<<<<<<<<<<<<<
+ *             self.rave_rewards[self.parent.team] = 0
+ *         self.sqrtlog_visits = 0
+ */
+    (__pyx_v_self->rewards[__pyx_v_self->parent->team]) = 0.0;
+
+    /* "multimcts/mcts.pyx":111
  *         if self.parent is not None:
- *             self.rewards[self.parent.cteam] = 0             # <<<<<<<<<<<<<<
+ *             self.rewards[self.parent.team] = 0
+ *             self.rave_rewards[self.parent.team] = 0             # <<<<<<<<<<<<<<
  *         self.sqrtlog_visits = 0
  *         self.invsqrt_visits = 0
  */
-    (__pyx_v_self->rewards[__pyx_v_self->parent->cteam]) = 0.0;
+    (__pyx_v_self->rave_rewards[__pyx_v_self->parent->team]) = 0.0;
 
-    /* "multimcts/mcts.pyx":91
- *         self.team = self.state.get_current_team()
- *         self.cteam = str(self.team).encode()
+    /* "multimcts/mcts.pyx":109
+ *         # The following are cached for performance.
+ *         self.team = str(self.state.get_current_team()).encode()
  *         if self.parent is not None:             # <<<<<<<<<<<<<<
- *             self.rewards[self.parent.cteam] = 0
- *         self.sqrtlog_visits = 0
+ *             self.rewards[self.parent.team] = 0
+ *             self.rave_rewards[self.parent.team] = 0
  */
   }
 
-  /* "multimcts/mcts.pyx":93
- *         if self.parent is not None:
- *             self.rewards[self.parent.cteam] = 0
+  /* "multimcts/mcts.pyx":112
+ *             self.rewards[self.parent.team] = 0
+ *             self.rave_rewards[self.parent.team] = 0
  *         self.sqrtlog_visits = 0             # <<<<<<<<<<<<<<
  *         self.invsqrt_visits = 0
  *         self.avg_reward = 0
  */
   __pyx_v_self->sqrtlog_visits = 0.0;
 
-  /* "multimcts/mcts.pyx":94
- *             self.rewards[self.parent.cteam] = 0
+  /* "multimcts/mcts.pyx":113
+ *             self.rave_rewards[self.parent.team] = 0
  *         self.sqrtlog_visits = 0
  *         self.invsqrt_visits = 0             # <<<<<<<<<<<<<<
  *         self.avg_reward = 0
- * 
+ *         self.avg_rave_reward = 0
  */
   __pyx_v_self->invsqrt_visits = 0.0;
 
-  /* "multimcts/mcts.pyx":95
+  /* "multimcts/mcts.pyx":114
  *         self.sqrtlog_visits = 0
  *         self.invsqrt_visits = 0
  *         self.avg_reward = 0             # <<<<<<<<<<<<<<
+ *         self.avg_rave_reward = 0
  * 
- *     @property
  */
   __pyx_v_self->avg_reward = 0.0;
 
-  /* "multimcts/mcts.pyx":72
- *     cdef double avg_reward, sqrtlog_visits, invsqrt_visits
+  /* "multimcts/mcts.pyx":115
+ *         self.invsqrt_visits = 0
+ *         self.avg_reward = 0
+ *         self.avg_rave_reward = 0             # <<<<<<<<<<<<<<
+ * 
+ *     def get_state(self) -> GameState: return self.state
+ */
+  __pyx_v_self->avg_rave_reward = 0.0;
+
+  /* "multimcts/mcts.pyx":89
+ *     cdef double sqrtlog_visits, invsqrt_visits, avg_reward, avg_rave_reward
  * 
  *     def __init__(self, state:GameState, parent:'Node'=None, move:Move=None):             # <<<<<<<<<<<<<<
  *         self.state = state
  *         self.parent = parent
  */
 
   /* function exit code */
@@ -3078,654 +2882,3163 @@
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("multimcts.mcts.Node.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
-  __Pyx_TraceReturn(Py_None, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":98
+/* "multimcts/mcts.pyx":117
+ *         self.avg_rave_reward = 0
  * 
- *     @property
- *     def state(self) -> GameState: return self.state             # <<<<<<<<<<<<<<
- *     @property
- *     def rewards(self): return self.rewards
+ *     def get_state(self) -> GameState: return self.state             # <<<<<<<<<<<<<<
+ *     def get_team(self) -> str: return self.team.decode()
+ *     def get_move(self) -> Move: return self.move
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5state_1__get__(PyObject *__pyx_v_self); /*proto*/
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5state_1__get__(PyObject *__pyx_v_self) {
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_3get_state(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_3get_state(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_5state___get__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+  __Pyx_RefNannySetupContext("get_state (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_2get_state(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_2get_state(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_state", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_self->state);
+  __pyx_r = __pyx_v_self->state;
+  goto __pyx_L0;
 
   /* function exit code */
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_5state___get__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+/* "multimcts/mcts.pyx":118
+ * 
+ *     def get_state(self) -> GameState: return self.state
+ *     def get_team(self) -> str: return self.team.decode()             # <<<<<<<<<<<<<<
+ *     def get_move(self) -> Move: return self.move
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5get_team(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5get_team(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_team (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_4get_team(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_4get_team(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__get__", 0);
-  __Pyx_TraceCall("__get__", __pyx_f[0], 98, 0, __PYX_ERR(0, 98, __pyx_L1_error));
+  __Pyx_RefNannySetupContext("get_team", 0);
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF(__pyx_v_self->state);
-  __pyx_r = __pyx_v_self->state;
+  __pyx_t_1 = __Pyx_decode_cpp_string(__pyx_v_self->team, 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 118, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_AddTraceback("multimcts.mcts.Node.state.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_team", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":100
- *     def state(self) -> GameState: return self.state
- *     @property
- *     def rewards(self): return self.rewards             # <<<<<<<<<<<<<<
+/* "multimcts/mcts.pyx":119
+ *     def get_state(self) -> GameState: return self.state
+ *     def get_team(self) -> str: return self.team.decode()
+ *     def get_move(self) -> Move: return self.move             # <<<<<<<<<<<<<<
+ * 
+ *     def get_parent(self) -> 'Node': return self.parent
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_7get_move(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_7get_move(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_move (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_6get_move(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_6get_move(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_move", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_self->move);
+  __pyx_r = __pyx_v_self->move;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":121
+ *     def get_move(self) -> Move: return self.move
+ * 
+ *     def get_parent(self) -> 'Node': return self.parent             # <<<<<<<<<<<<<<
+ *     def get_children(self) -> Dict[Move,'Node']: return self.children
+ * 
+ */
+
+/* Python wrapper */
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_pw_9multimcts_4mcts_4Node_9get_parent(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_pw_9multimcts_4mcts_4Node_9get_parent(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_parent (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_8get_parent(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_pf_9multimcts_4mcts_4Node_8get_parent(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_parent", 0);
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_self->parent));
+  __pyx_r = __pyx_v_self->parent;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L0:;
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":122
+ * 
+ *     def get_parent(self) -> 'Node': return self.parent
+ *     def get_children(self) -> Dict[Move,'Node']: return self.children             # <<<<<<<<<<<<<<
+ * 
+ *     def get_visits(self) -> int: return self.visits
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_11get_children(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_11get_children(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_children (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_10get_children(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_10get_children(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_children", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_self->children);
+  __pyx_r = __pyx_v_self->children;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":124
+ *     def get_children(self) -> Dict[Move,'Node']: return self.children
+ * 
+ *     def get_visits(self) -> int: return self.visits             # <<<<<<<<<<<<<<
+ *     def get_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rewards}
+ *     def get_avg_reward(self) -> double: return self.avg_reward
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_13get_visits(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_13get_visits(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_visits (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_12get_visits(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_12get_visits(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_visits", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->visits); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 124, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_visits", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":125
+ * 
+ *     def get_visits(self) -> int: return self.visits
+ *     def get_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rewards}             # <<<<<<<<<<<<<<
+ *     def get_avg_reward(self) -> double: return self.avg_reward
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_15get_rewards(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_15get_rewards(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_rewards (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_14get_rewards(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_14get_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  std::pair<std::string,double>  __pyx_7genexpr__pyx_v_item;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  std::map<std::string,double> ::iterator __pyx_t_2;
+  std::map<std::string,double>  *__pyx_t_3;
+  std::pair<std::string,double>  __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_rewards", 0);
+  __Pyx_XDECREF(__pyx_r);
+  { /* enter inner scope */
+    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 125, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = &__pyx_v_self->rewards;
+    __pyx_t_2 = __pyx_t_3->begin();
+    for (;;) {
+      if (!(__pyx_t_2 != __pyx_t_3->end())) break;
+      __pyx_t_4 = *__pyx_t_2;
+      ++__pyx_t_2;
+      __pyx_7genexpr__pyx_v_item = __pyx_t_4;
+      __pyx_t_5 = __Pyx_decode_cpp_string(__pyx_7genexpr__pyx_v_item.first, 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 125, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_6 = PyFloat_FromDouble(__pyx_7genexpr__pyx_v_item.second); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 125, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      if (unlikely(PyDict_SetItem(__pyx_t_1, (PyObject*)__pyx_t_5, (PyObject*)__pyx_t_6))) __PYX_ERR(0, 125, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    }
+  } /* exit inner scope */
+  __pyx_r = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_rewards", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":126
+ *     def get_visits(self) -> int: return self.visits
+ *     def get_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rewards}
+ *     def get_avg_reward(self) -> double: return self.avg_reward             # <<<<<<<<<<<<<<
+ * 
+ *     def get_rave_visits(self) -> int: return self.rave_visits
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_17get_avg_reward(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_17get_avg_reward(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_avg_reward (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_16get_avg_reward(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_16get_avg_reward(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_avg_reward", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->avg_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 126, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_avg_reward", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":128
+ *     def get_avg_reward(self) -> double: return self.avg_reward
+ * 
+ *     def get_rave_visits(self) -> int: return self.rave_visits             # <<<<<<<<<<<<<<
+ *     def get_rave_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rave_rewards}
+ *     def get_avg_rave_reward(self) -> double: return self.avg_rave_reward
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_19get_rave_visits(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_19get_rave_visits(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_rave_visits (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_18get_rave_visits(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_18get_rave_visits(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_rave_visits", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->rave_visits); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_rave_visits", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":129
+ * 
+ *     def get_rave_visits(self) -> int: return self.rave_visits
+ *     def get_rave_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rave_rewards}             # <<<<<<<<<<<<<<
+ *     def get_avg_rave_reward(self) -> double: return self.avg_rave_reward
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_21get_rave_rewards(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_21get_rave_rewards(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_rave_rewards (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_20get_rave_rewards(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_20get_rave_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  std::pair<std::string,double>  __pyx_8genexpr1__pyx_v_item;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  std::map<std::string,double> ::iterator __pyx_t_2;
+  std::map<std::string,double>  *__pyx_t_3;
+  std::pair<std::string,double>  __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_rave_rewards", 0);
+  __Pyx_XDECREF(__pyx_r);
+  { /* enter inner scope */
+    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = &__pyx_v_self->rave_rewards;
+    __pyx_t_2 = __pyx_t_3->begin();
+    for (;;) {
+      if (!(__pyx_t_2 != __pyx_t_3->end())) break;
+      __pyx_t_4 = *__pyx_t_2;
+      ++__pyx_t_2;
+      __pyx_8genexpr1__pyx_v_item = __pyx_t_4;
+      __pyx_t_5 = __Pyx_decode_cpp_string(__pyx_8genexpr1__pyx_v_item.first, 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_6 = PyFloat_FromDouble(__pyx_8genexpr1__pyx_v_item.second); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      if (unlikely(PyDict_SetItem(__pyx_t_1, (PyObject*)__pyx_t_5, (PyObject*)__pyx_t_6))) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    }
+  } /* exit inner scope */
+  __pyx_r = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_rave_rewards", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":130
+ *     def get_rave_visits(self) -> int: return self.rave_visits
+ *     def get_rave_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rave_rewards}
+ *     def get_avg_rave_reward(self) -> double: return self.avg_rave_reward             # <<<<<<<<<<<<<<
  * 
  *     @cython.cdivision(True)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_7rewards_1__get__(PyObject *__pyx_v_self); /*proto*/
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_7rewards_1__get__(PyObject *__pyx_v_self) {
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_23get_avg_rave_reward(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_23get_avg_rave_reward(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_7rewards___get__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+  __Pyx_RefNannySetupContext("get_avg_rave_reward (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_22get_avg_rave_reward(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_7rewards___get__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_22get_avg_rave_reward(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__get__", 0);
-  __Pyx_TraceCall("__get__", __pyx_f[0], 100, 0, __PYX_ERR(0, 100, __pyx_L1_error));
+  __Pyx_RefNannySetupContext("get_avg_rave_reward", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_convert_map_to_py_std_3a__3a_string____double(__pyx_v_self->rewards); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 100, __pyx_L1_error)
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->avg_rave_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("multimcts.mcts.Node.rewards.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_avg_rave_reward", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":103
+/* "multimcts/mcts.pyx":133
  * 
  *     @cython.cdivision(True)
- *     cdef apply_rewards(self, map[string,double] crewards):             # <<<<<<<<<<<<<<
+ *     cdef visit(self, map[string,double] crewards, moves):             # <<<<<<<<<<<<<<
  *         """Update this node's visits and rewards, and cache some variables for more efficient UCB calculation."""
  *         self.visits += 1
  */
 
-static PyObject *__pyx_f_9multimcts_4mcts_4Node_apply_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, std::map<std::string,double>  __pyx_v_crewards) {
+static PyObject *__pyx_f_9multimcts_4mcts_4Node_visit(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, std::map<std::string,double>  __pyx_v_crewards, PyObject *__pyx_v_moves) {
   std::pair<std::string,double>  __pyx_v_item;
-  double __pyx_v_total_rewards;
+  double __pyx_v_total_reward;
+  int __pyx_v_rave_visits;
+  double __pyx_v_total_rave_reward;
+  PyObject *__pyx_v_move = NULL;
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   std::map<std::string,double> ::iterator __pyx_t_1;
   std::pair<std::string,double>  __pyx_t_2;
   int __pyx_t_3;
   std::string __pyx_t_4;
   int __pyx_t_5;
+  PyObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  Py_ssize_t __pyx_t_9;
+  PyObject *(*__pyx_t_10)(PyObject *);
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("apply_rewards", 0);
-  __Pyx_TraceCall("apply_rewards", __pyx_f[0], 103, 0, __PYX_ERR(0, 103, __pyx_L1_error));
+  __Pyx_RefNannySetupContext("visit", 0);
 
-  /* "multimcts/mcts.pyx":105
- *     cdef apply_rewards(self, map[string,double] crewards):
+  /* "multimcts/mcts.pyx":135
+ *     cdef visit(self, map[string,double] crewards, moves):
  *         """Update this node's visits and rewards, and cache some variables for more efficient UCB calculation."""
  *         self.visits += 1             # <<<<<<<<<<<<<<
  * 
- *         self.sqrtlog_visits = sqrt(log(self.visits))
+ *         self.sqrtlog_visits = sqrtlog(self.visits)
  */
   __pyx_v_self->visits = (__pyx_v_self->visits + 1);
 
-  /* "multimcts/mcts.pyx":107
+  /* "multimcts/mcts.pyx":137
  *         self.visits += 1
  * 
- *         self.sqrtlog_visits = sqrt(log(self.visits))             # <<<<<<<<<<<<<<
- *         self.invsqrt_visits = 1 / sqrt(self.visits)
+ *         self.sqrtlog_visits = sqrtlog(self.visits)             # <<<<<<<<<<<<<<
+ *         self.invsqrt_visits = invsqrt(self.visits)
  * 
  */
-  __pyx_v_self->sqrtlog_visits = sqrt(log(__pyx_v_self->visits));
+  __pyx_v_self->sqrtlog_visits = __pyx_f_9multimcts_4mcts_sqrtlog(__pyx_v_self->visits);
 
-  /* "multimcts/mcts.pyx":108
+  /* "multimcts/mcts.pyx":138
  * 
- *         self.sqrtlog_visits = sqrt(log(self.visits))
- *         self.invsqrt_visits = 1 / sqrt(self.visits)             # <<<<<<<<<<<<<<
+ *         self.sqrtlog_visits = sqrtlog(self.visits)
+ *         self.invsqrt_visits = invsqrt(self.visits)             # <<<<<<<<<<<<<<
  * 
- *         cdef pair[string,double] item
+ *         # Update regular rewards.
  */
-  __pyx_v_self->invsqrt_visits = (1.0 / sqrt(__pyx_v_self->visits));
+  __pyx_v_self->invsqrt_visits = __pyx_f_9multimcts_4mcts_invsqrt(__pyx_v_self->visits);
 
-  /* "multimcts/mcts.pyx":111
- * 
+  /* "multimcts/mcts.pyx":142
+ *         # Update regular rewards.
  *         cdef pair[string,double] item
- *         cdef double total_rewards = 0             # <<<<<<<<<<<<<<
+ *         cdef double total_reward = 0             # <<<<<<<<<<<<<<
  *         for item in crewards:
  *             if self.rewards.count(item.first) == 0:
  */
-  __pyx_v_total_rewards = 0.0;
+  __pyx_v_total_reward = 0.0;
 
-  /* "multimcts/mcts.pyx":112
+  /* "multimcts/mcts.pyx":143
  *         cdef pair[string,double] item
- *         cdef double total_rewards = 0
+ *         cdef double total_reward = 0
  *         for item in crewards:             # <<<<<<<<<<<<<<
  *             if self.rewards.count(item.first) == 0:
  *                 self.rewards[item.first] = 0
  */
   __pyx_t_1 = __pyx_v_crewards.begin();
   for (;;) {
     if (!(__pyx_t_1 != __pyx_v_crewards.end())) break;
     __pyx_t_2 = *__pyx_t_1;
     ++__pyx_t_1;
     __pyx_v_item = __pyx_t_2;
 
-    /* "multimcts/mcts.pyx":113
- *         cdef double total_rewards = 0
+    /* "multimcts/mcts.pyx":144
+ *         cdef double total_reward = 0
  *         for item in crewards:
  *             if self.rewards.count(item.first) == 0:             # <<<<<<<<<<<<<<
  *                 self.rewards[item.first] = 0
  *             self.rewards[item.first] += item.second
  */
     __pyx_t_3 = ((__pyx_v_self->rewards.count(__pyx_v_item.first) == 0) != 0);
     if (__pyx_t_3) {
 
-      /* "multimcts/mcts.pyx":114
+      /* "multimcts/mcts.pyx":145
  *         for item in crewards:
  *             if self.rewards.count(item.first) == 0:
  *                 self.rewards[item.first] = 0             # <<<<<<<<<<<<<<
  *             self.rewards[item.first] += item.second
- *             total_rewards += self.rewards[item.first]
+ *             total_reward += self.rewards[item.first]
  */
       (__pyx_v_self->rewards[__pyx_v_item.first]) = 0.0;
 
-      /* "multimcts/mcts.pyx":113
- *         cdef double total_rewards = 0
+      /* "multimcts/mcts.pyx":144
+ *         cdef double total_reward = 0
  *         for item in crewards:
  *             if self.rewards.count(item.first) == 0:             # <<<<<<<<<<<<<<
  *                 self.rewards[item.first] = 0
  *             self.rewards[item.first] += item.second
  */
     }
 
-    /* "multimcts/mcts.pyx":115
+    /* "multimcts/mcts.pyx":146
  *             if self.rewards.count(item.first) == 0:
  *                 self.rewards[item.first] = 0
  *             self.rewards[item.first] += item.second             # <<<<<<<<<<<<<<
- *             total_rewards += self.rewards[item.first]
- * 
+ *             total_reward += self.rewards[item.first]
+ *         if self.parent is not None:
  */
     __pyx_t_4 = __pyx_v_item.first;
     (__pyx_v_self->rewards[__pyx_t_4]) = ((__pyx_v_self->rewards[__pyx_t_4]) + __pyx_v_item.second);
 
-    /* "multimcts/mcts.pyx":116
+    /* "multimcts/mcts.pyx":147
  *                 self.rewards[item.first] = 0
  *             self.rewards[item.first] += item.second
- *             total_rewards += self.rewards[item.first]             # <<<<<<<<<<<<<<
- * 
+ *             total_reward += self.rewards[item.first]             # <<<<<<<<<<<<<<
  *         if self.parent is not None:
+ *             # Average reward: (reward for my parent's team - rewards for all other teams) / num visits to this node
  */
-    __pyx_v_total_rewards = (__pyx_v_total_rewards + (__pyx_v_self->rewards[__pyx_v_item.first]));
+    __pyx_v_total_reward = (__pyx_v_total_reward + (__pyx_v_self->rewards[__pyx_v_item.first]));
 
-    /* "multimcts/mcts.pyx":112
+    /* "multimcts/mcts.pyx":143
  *         cdef pair[string,double] item
- *         cdef double total_rewards = 0
+ *         cdef double total_reward = 0
  *         for item in crewards:             # <<<<<<<<<<<<<<
  *             if self.rewards.count(item.first) == 0:
  *                 self.rewards[item.first] = 0
  */
   }
 
-  /* "multimcts/mcts.pyx":118
- *             total_rewards += self.rewards[item.first]
- * 
+  /* "multimcts/mcts.pyx":148
+ *             self.rewards[item.first] += item.second
+ *             total_reward += self.rewards[item.first]
  *         if self.parent is not None:             # <<<<<<<<<<<<<<
- *             # Average reward is (reward for my parent's team - rewards for all other teams) / num visits to this node.
- *             self.avg_reward = ((2 * self.rewards[self.parent.cteam]) - total_rewards) / self.visits
+ *             # Average reward: (reward for my parent's team - rewards for all other teams) / num visits to this node
+ *             self.avg_reward = ((2*self.rewards[self.parent.team]) - total_reward) / self.visits
  */
   __pyx_t_3 = (((PyObject *)__pyx_v_self->parent) != Py_None);
   __pyx_t_5 = (__pyx_t_3 != 0);
   if (__pyx_t_5) {
 
-    /* "multimcts/mcts.pyx":120
+    /* "multimcts/mcts.pyx":150
  *         if self.parent is not None:
- *             # Average reward is (reward for my parent's team - rewards for all other teams) / num visits to this node.
- *             self.avg_reward = ((2 * self.rewards[self.parent.cteam]) - total_rewards) / self.visits             # <<<<<<<<<<<<<<
+ *             # Average reward: (reward for my parent's team - rewards for all other teams) / num visits to this node
+ *             self.avg_reward = ((2*self.rewards[self.parent.team]) - total_reward) / self.visits             # <<<<<<<<<<<<<<
  * 
- *     cdef double ucb(self, double exploration_bias, double parent_sqrtlog_visits):
+ *         # Update RAVE rewards.
  */
-    __pyx_v_self->avg_reward = (((2.0 * (__pyx_v_self->rewards[__pyx_v_self->parent->cteam])) - __pyx_v_total_rewards) / ((double)__pyx_v_self->visits));
+    __pyx_v_self->avg_reward = (((2.0 * (__pyx_v_self->rewards[__pyx_v_self->parent->team])) - __pyx_v_total_reward) / ((double)__pyx_v_self->visits));
 
-    /* "multimcts/mcts.pyx":118
- *             total_rewards += self.rewards[item.first]
- * 
+    /* "multimcts/mcts.pyx":148
+ *             self.rewards[item.first] += item.second
+ *             total_reward += self.rewards[item.first]
  *         if self.parent is not None:             # <<<<<<<<<<<<<<
- *             # Average reward is (reward for my parent's team - rewards for all other teams) / num visits to this node.
- *             self.avg_reward = ((2 * self.rewards[self.parent.cteam]) - total_rewards) / self.visits
+ *             # Average reward: (reward for my parent's team - rewards for all other teams) / num visits to this node
+ *             self.avg_reward = ((2*self.rewards[self.parent.team]) - total_reward) / self.visits
+ */
+  }
+
+  /* "multimcts/mcts.pyx":153
+ * 
+ *         # Update RAVE rewards.
+ *         cdef int rave_visits = 0             # <<<<<<<<<<<<<<
+ *         cdef double total_rave_reward = 0
+ *         for move in list(self.children.keys()) + self.remaining_moves:
+ */
+  __pyx_v_rave_visits = 0;
+
+  /* "multimcts/mcts.pyx":154
+ *         # Update RAVE rewards.
+ *         cdef int rave_visits = 0
+ *         cdef double total_rave_reward = 0             # <<<<<<<<<<<<<<
+ *         for move in list(self.children.keys()) + self.remaining_moves:
+ *             if move in moves:
+ */
+  __pyx_v_total_rave_reward = 0.0;
+
+  /* "multimcts/mcts.pyx":155
+ *         cdef int rave_visits = 0
+ *         cdef double total_rave_reward = 0
+ *         for move in list(self.children.keys()) + self.remaining_moves:             # <<<<<<<<<<<<<<
+ *             if move in moves:
+ *                 rave_visits += 1
+ */
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->children, __pyx_n_s_keys); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 155, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_8 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
+    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
+    if (likely(__pyx_t_8)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
+      __Pyx_INCREF(__pyx_t_8);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_7, function);
+    }
+  }
+  __pyx_t_6 = (__pyx_t_8) ? __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_8) : __Pyx_PyObject_CallNoArg(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+  if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 155, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_7 = PySequence_List(__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 155, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_6 = PyNumber_Add(__pyx_t_7, __pyx_v_self->remaining_moves); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 155, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  if (likely(PyList_CheckExact(__pyx_t_6)) || PyTuple_CheckExact(__pyx_t_6)) {
+    __pyx_t_7 = __pyx_t_6; __Pyx_INCREF(__pyx_t_7); __pyx_t_9 = 0;
+    __pyx_t_10 = NULL;
+  } else {
+    __pyx_t_9 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 155, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __pyx_t_10 = Py_TYPE(__pyx_t_7)->tp_iternext; if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 155, __pyx_L1_error)
+  }
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  for (;;) {
+    if (likely(!__pyx_t_10)) {
+      if (likely(PyList_CheckExact(__pyx_t_7))) {
+        if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_7)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_6 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_9); __Pyx_INCREF(__pyx_t_6); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 155, __pyx_L1_error)
+        #else
+        __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 155, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_6);
+        #endif
+      } else {
+        if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_6 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_9); __Pyx_INCREF(__pyx_t_6); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 155, __pyx_L1_error)
+        #else
+        __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 155, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_6);
+        #endif
+      }
+    } else {
+      __pyx_t_6 = __pyx_t_10(__pyx_t_7);
+      if (unlikely(!__pyx_t_6)) {
+        PyObject* exc_type = PyErr_Occurred();
+        if (exc_type) {
+          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+          else __PYX_ERR(0, 155, __pyx_L1_error)
+        }
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_6);
+    }
+    __Pyx_XDECREF_SET(__pyx_v_move, __pyx_t_6);
+    __pyx_t_6 = 0;
+
+    /* "multimcts/mcts.pyx":156
+ *         cdef double total_rave_reward = 0
+ *         for move in list(self.children.keys()) + self.remaining_moves:
+ *             if move in moves:             # <<<<<<<<<<<<<<
+ *                 rave_visits += 1
+ *         if rave_visits > 0:
+ */
+    __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_v_move, __pyx_v_moves, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 156, __pyx_L1_error)
+    __pyx_t_3 = (__pyx_t_5 != 0);
+    if (__pyx_t_3) {
+
+      /* "multimcts/mcts.pyx":157
+ *         for move in list(self.children.keys()) + self.remaining_moves:
+ *             if move in moves:
+ *                 rave_visits += 1             # <<<<<<<<<<<<<<
+ *         if rave_visits > 0:
+ *             self.rave_visits += rave_visits
+ */
+      __pyx_v_rave_visits = (__pyx_v_rave_visits + 1);
+
+      /* "multimcts/mcts.pyx":156
+ *         cdef double total_rave_reward = 0
+ *         for move in list(self.children.keys()) + self.remaining_moves:
+ *             if move in moves:             # <<<<<<<<<<<<<<
+ *                 rave_visits += 1
+ *         if rave_visits > 0:
+ */
+    }
+
+    /* "multimcts/mcts.pyx":155
+ *         cdef int rave_visits = 0
+ *         cdef double total_rave_reward = 0
+ *         for move in list(self.children.keys()) + self.remaining_moves:             # <<<<<<<<<<<<<<
+ *             if move in moves:
+ *                 rave_visits += 1
+ */
+  }
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+
+  /* "multimcts/mcts.pyx":158
+ *             if move in moves:
+ *                 rave_visits += 1
+ *         if rave_visits > 0:             # <<<<<<<<<<<<<<
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:
+ */
+  __pyx_t_3 = ((__pyx_v_rave_visits > 0) != 0);
+  if (__pyx_t_3) {
+
+    /* "multimcts/mcts.pyx":159
+ *                 rave_visits += 1
+ *         if rave_visits > 0:
+ *             self.rave_visits += rave_visits             # <<<<<<<<<<<<<<
+ *             for item in crewards:
+ *                 if self.rave_rewards.count(item.first) == 0:
+ */
+    __pyx_v_self->rave_visits = (__pyx_v_self->rave_visits + __pyx_v_rave_visits);
+
+    /* "multimcts/mcts.pyx":160
+ *         if rave_visits > 0:
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:             # <<<<<<<<<<<<<<
+ *                 if self.rave_rewards.count(item.first) == 0:
+ *                     self.rave_rewards[item.first] = 0
+ */
+    __pyx_t_1 = __pyx_v_crewards.begin();
+    for (;;) {
+      if (!(__pyx_t_1 != __pyx_v_crewards.end())) break;
+      __pyx_t_2 = *__pyx_t_1;
+      ++__pyx_t_1;
+      __pyx_v_item = __pyx_t_2;
+
+      /* "multimcts/mcts.pyx":161
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:
+ *                 if self.rave_rewards.count(item.first) == 0:             # <<<<<<<<<<<<<<
+ *                     self.rave_rewards[item.first] = 0
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ */
+      __pyx_t_3 = ((__pyx_v_self->rave_rewards.count(__pyx_v_item.first) == 0) != 0);
+      if (__pyx_t_3) {
+
+        /* "multimcts/mcts.pyx":162
+ *             for item in crewards:
+ *                 if self.rave_rewards.count(item.first) == 0:
+ *                     self.rave_rewards[item.first] = 0             # <<<<<<<<<<<<<<
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ *                 total_rave_reward += self.rave_rewards[item.first]
+ */
+        (__pyx_v_self->rave_rewards[__pyx_v_item.first]) = 0.0;
+
+        /* "multimcts/mcts.pyx":161
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:
+ *                 if self.rave_rewards.count(item.first) == 0:             # <<<<<<<<<<<<<<
+ *                     self.rave_rewards[item.first] = 0
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ */
+      }
+
+      /* "multimcts/mcts.pyx":163
+ *                 if self.rave_rewards.count(item.first) == 0:
+ *                     self.rave_rewards[item.first] = 0
+ *                 self.rave_rewards[item.first] += rave_visits * item.second             # <<<<<<<<<<<<<<
+ *                 total_rave_reward += self.rave_rewards[item.first]
+ *             if self.parent is not None:
+ */
+      __pyx_t_4 = __pyx_v_item.first;
+      (__pyx_v_self->rave_rewards[__pyx_t_4]) = ((__pyx_v_self->rave_rewards[__pyx_t_4]) + (__pyx_v_rave_visits * __pyx_v_item.second));
+
+      /* "multimcts/mcts.pyx":164
+ *                     self.rave_rewards[item.first] = 0
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ *                 total_rave_reward += self.rave_rewards[item.first]             # <<<<<<<<<<<<<<
+ *             if self.parent is not None:
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits
+ */
+      __pyx_v_total_rave_reward = (__pyx_v_total_rave_reward + (__pyx_v_self->rave_rewards[__pyx_v_item.first]));
+
+      /* "multimcts/mcts.pyx":160
+ *         if rave_visits > 0:
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:             # <<<<<<<<<<<<<<
+ *                 if self.rave_rewards.count(item.first) == 0:
+ *                     self.rave_rewards[item.first] = 0
+ */
+    }
+
+    /* "multimcts/mcts.pyx":165
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ *                 total_rave_reward += self.rave_rewards[item.first]
+ *             if self.parent is not None:             # <<<<<<<<<<<<<<
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits
+ * 
+ */
+    __pyx_t_3 = (((PyObject *)__pyx_v_self->parent) != Py_None);
+    __pyx_t_5 = (__pyx_t_3 != 0);
+    if (__pyx_t_5) {
+
+      /* "multimcts/mcts.pyx":166
+ *                 total_rave_reward += self.rave_rewards[item.first]
+ *             if self.parent is not None:
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef double uncertainty(self, double exploration_bias):
+ */
+      __pyx_v_self->avg_rave_reward = (((2.0 * (__pyx_v_self->rave_rewards[__pyx_v_self->parent->team])) - __pyx_v_total_rave_reward) / ((double)__pyx_v_self->rave_visits));
+
+      /* "multimcts/mcts.pyx":165
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ *                 total_rave_reward += self.rave_rewards[item.first]
+ *             if self.parent is not None:             # <<<<<<<<<<<<<<
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits
+ * 
+ */
+    }
+
+    /* "multimcts/mcts.pyx":158
+ *             if move in moves:
+ *                 rave_visits += 1
+ *         if rave_visits > 0:             # <<<<<<<<<<<<<<
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:
  */
   }
 
-  /* "multimcts/mcts.pyx":103
+  /* "multimcts/mcts.pyx":133
  * 
  *     @cython.cdivision(True)
- *     cdef apply_rewards(self, map[string,double] crewards):             # <<<<<<<<<<<<<<
+ *     cdef visit(self, map[string,double] crewards, moves):             # <<<<<<<<<<<<<<
  *         """Update this node's visits and rewards, and cache some variables for more efficient UCB calculation."""
  *         self.visits += 1
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_AddTraceback("multimcts.mcts.Node.apply_rewards", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_AddTraceback("multimcts.mcts.Node.visit", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_move);
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":122
- *             self.avg_reward = ((2 * self.rewards[self.parent.cteam]) - total_rewards) / self.visits
+/* "multimcts/mcts.pyx":168
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits
+ * 
+ *     cpdef double uncertainty(self, double exploration_bias):             # <<<<<<<<<<<<<<
+ *         return exploration_bias * self.parent.sqrtlog_visits * self.invsqrt_visits
+ * 
+ */
+
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_25uncertainty(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias); /*proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_uncertainty(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, int __pyx_skip_dispatch) {
+  double __pyx_r;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  double __pyx_t_6;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("uncertainty", 0);
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_uncertainty); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_9multimcts_4mcts_4Node_25uncertainty)) {
+        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_exploration_bias); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 168, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
+          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+          if (likely(__pyx_t_5)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+            __Pyx_INCREF(__pyx_t_5);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_4, function);
+          }
+        }
+        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
+        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 168, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 168, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __pyx_r = __pyx_t_6;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
+      }
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+      }
+      #endif
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    }
+    #endif
+  }
+
+  /* "multimcts/mcts.pyx":169
+ * 
+ *     cpdef double uncertainty(self, double exploration_bias):
+ *         return exploration_bias * self.parent.sqrtlog_visits * self.invsqrt_visits             # <<<<<<<<<<<<<<
  * 
- *     cdef double ucb(self, double exploration_bias, double parent_sqrtlog_visits):             # <<<<<<<<<<<<<<
+ *     cpdef double ucb(self, double exploration_bias):
+ */
+  __pyx_r = ((__pyx_v_exploration_bias * __pyx_v_self->parent->sqrtlog_visits) * __pyx_v_self->invsqrt_visits);
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":168
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits
+ * 
+ *     cpdef double uncertainty(self, double exploration_bias):             # <<<<<<<<<<<<<<
+ *         return exploration_bias * self.parent.sqrtlog_visits * self.invsqrt_visits
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_WriteUnraisable("multimcts.mcts.Node.uncertainty", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_25uncertainty(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_25uncertainty(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias) {
+  double __pyx_v_exploration_bias;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("uncertainty (wrapper)", 0);
+  assert(__pyx_arg_exploration_bias); {
+    __pyx_v_exploration_bias = __pyx_PyFloat_AsDouble(__pyx_arg_exploration_bias); if (unlikely((__pyx_v_exploration_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 168, __pyx_L3_error)
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.uncertainty", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_24uncertainty(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), ((double)__pyx_v_exploration_bias));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_24uncertainty(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("uncertainty", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_9multimcts_4mcts_4Node_uncertainty(__pyx_v_self, __pyx_v_exploration_bias, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.uncertainty", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":171
+ *         return exploration_bias * self.parent.sqrtlog_visits * self.invsqrt_visits
+ * 
+ *     cpdef double ucb(self, double exploration_bias):             # <<<<<<<<<<<<<<
  *         """Upper Confidence Bound
  *         ucb = (x / n) + C * sqrt(ln(N) / n)
  */
 
-static double __pyx_f_9multimcts_4mcts_4Node_ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_parent_sqrtlog_visits) {
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_27ucb(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias); /*proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, int __pyx_skip_dispatch) {
   double __pyx_r;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  double __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("ucb", 0);
-  __Pyx_TraceCall("ucb", __pyx_f[0], 122, 0, __PYX_ERR(0, 122, __pyx_L1_error));
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_ucb); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_9multimcts_4mcts_4Node_27ucb)) {
+        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_exploration_bias); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 171, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
+          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+          if (likely(__pyx_t_5)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+            __Pyx_INCREF(__pyx_t_5);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_4, function);
+          }
+        }
+        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
+        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 171, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 171, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __pyx_r = __pyx_t_6;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
+      }
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+      }
+      #endif
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    }
+    #endif
+  }
 
-  /* "multimcts/mcts.pyx":131
+  /* "multimcts/mcts.pyx":179
+ *         C=exploration bias
  *         """
- *         # ucb = avgR + C * sqrt(ln(N)) * (1/sqrt(n))
- *         return self.avg_reward + exploration_bias * parent_sqrtlog_visits * self.invsqrt_visits             # <<<<<<<<<<<<<<
- * 
+ *         return self.avg_reward + self.uncertainty(exploration_bias)             # <<<<<<<<<<<<<<
  * 
+ *     @cython.cdivision(True)
  */
-  __pyx_r = (__pyx_v_self->avg_reward + ((__pyx_v_exploration_bias * __pyx_v_parent_sqrtlog_visits) * __pyx_v_self->invsqrt_visits));
+  __pyx_r = (__pyx_v_self->avg_reward + ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_self->__pyx_vtab)->uncertainty(__pyx_v_self, __pyx_v_exploration_bias, 0));
   goto __pyx_L0;
 
-  /* "multimcts/mcts.pyx":122
- *             self.avg_reward = ((2 * self.rewards[self.parent.cteam]) - total_rewards) / self.visits
+  /* "multimcts/mcts.pyx":171
+ *         return exploration_bias * self.parent.sqrtlog_visits * self.invsqrt_visits
  * 
- *     cdef double ucb(self, double exploration_bias, double parent_sqrtlog_visits):             # <<<<<<<<<<<<<<
+ *     cpdef double ucb(self, double exploration_bias):             # <<<<<<<<<<<<<<
  *         """Upper Confidence Bound
  *         ucb = (x / n) + C * sqrt(ln(N) / n)
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_WriteUnraisable("multimcts.mcts.Node.ucb", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
   __pyx_r = 0;
   __pyx_L0:;
-  __Pyx_TraceReturn(Py_None, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_27ucb(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias); /*proto*/
+static char __pyx_doc_9multimcts_4mcts_4Node_26ucb[] = "Upper Confidence Bound\n        ucb = (x / n) + C * sqrt(ln(N) / n)\n        x=reward for this node\n        n=number of simulations for this node\n        N=number of simulations for parent node\n        C=exploration bias\n        ";
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_27ucb(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias) {
+  double __pyx_v_exploration_bias;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("ucb (wrapper)", 0);
+  assert(__pyx_arg_exploration_bias); {
+    __pyx_v_exploration_bias = __pyx_PyFloat_AsDouble(__pyx_arg_exploration_bias); if (unlikely((__pyx_v_exploration_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 171, __pyx_L3_error)
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.ucb", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_26ucb(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), ((double)__pyx_v_exploration_bias));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_26ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("ucb", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_9multimcts_4mcts_4Node_ucb(__pyx_v_self, __pyx_v_exploration_bias, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.ucb", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":182
+ * 
+ *     @cython.cdivision(True)
+ *     cpdef double rave_beta(self, double b):             # <<<<<<<<<<<<<<
+ *         """Determines the relative weight of RAVE rewards in the final score calculation.
+ *         As this node is visited more times, the RAVE effect diminishes.
+ */
+
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_29rave_beta(PyObject *__pyx_v_self, PyObject *__pyx_arg_b); /*proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_rave_beta(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_b, int __pyx_skip_dispatch) {
+  int __pyx_v_n1;
+  int __pyx_v_n2;
+  double __pyx_r;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  double __pyx_t_6;
+  int __pyx_t_7;
+  int __pyx_t_8;
+  int __pyx_t_9;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("rave_beta", 0);
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_rave_beta); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 182, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_9multimcts_4mcts_4Node_29rave_beta)) {
+        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_b); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 182, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
+          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+          if (likely(__pyx_t_5)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+            __Pyx_INCREF(__pyx_t_5);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_4, function);
+          }
+        }
+        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
+        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 182, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 182, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __pyx_r = __pyx_t_6;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
+      }
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+      }
+      #endif
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    }
+    #endif
+  }
+
+  /* "multimcts/mcts.pyx":188
+ *         https://www.desmos.com/calculator/drlccftt6a
+ *         """
+ *         if self.rave_visits == 0 or b == 0:             # <<<<<<<<<<<<<<
+ *             return 0
+ *         elif self.visits == 0:
+ */
+  __pyx_t_8 = ((__pyx_v_self->rave_visits == 0) != 0);
+  if (!__pyx_t_8) {
+  } else {
+    __pyx_t_7 = __pyx_t_8;
+    goto __pyx_L4_bool_binop_done;
+  }
+  __pyx_t_8 = ((__pyx_v_b == 0.0) != 0);
+  __pyx_t_7 = __pyx_t_8;
+  __pyx_L4_bool_binop_done:;
+  if (__pyx_t_7) {
+
+    /* "multimcts/mcts.pyx":189
+ *         """
+ *         if self.rave_visits == 0 or b == 0:
+ *             return 0             # <<<<<<<<<<<<<<
+ *         elif self.visits == 0:
+ *             return 1
+ */
+    __pyx_r = 0.0;
+    goto __pyx_L0;
+
+    /* "multimcts/mcts.pyx":188
+ *         https://www.desmos.com/calculator/drlccftt6a
+ *         """
+ *         if self.rave_visits == 0 or b == 0:             # <<<<<<<<<<<<<<
+ *             return 0
+ *         elif self.visits == 0:
+ */
+  }
+
+  /* "multimcts/mcts.pyx":190
+ *         if self.rave_visits == 0 or b == 0:
+ *             return 0
+ *         elif self.visits == 0:             # <<<<<<<<<<<<<<
+ *             return 1
+ *         cdef int n1 = self.visits, n2 = self.rave_visits
+ */
+  __pyx_t_7 = ((__pyx_v_self->visits == 0) != 0);
+  if (__pyx_t_7) {
+
+    /* "multimcts/mcts.pyx":191
+ *             return 0
+ *         elif self.visits == 0:
+ *             return 1             # <<<<<<<<<<<<<<
+ *         cdef int n1 = self.visits, n2 = self.rave_visits
+ *         return n2 / (n1 + n2 + 4*n1*n2/(b**2))
+ */
+    __pyx_r = 1.0;
+    goto __pyx_L0;
+
+    /* "multimcts/mcts.pyx":190
+ *         if self.rave_visits == 0 or b == 0:
+ *             return 0
+ *         elif self.visits == 0:             # <<<<<<<<<<<<<<
+ *             return 1
+ *         cdef int n1 = self.visits, n2 = self.rave_visits
+ */
+  }
+
+  /* "multimcts/mcts.pyx":192
+ *         elif self.visits == 0:
+ *             return 1
+ *         cdef int n1 = self.visits, n2 = self.rave_visits             # <<<<<<<<<<<<<<
+ *         return n2 / (n1 + n2 + 4*n1*n2/(b**2))
+ * 
+ */
+  __pyx_t_9 = __pyx_v_self->visits;
+  __pyx_v_n1 = __pyx_t_9;
+  __pyx_t_9 = __pyx_v_self->rave_visits;
+  __pyx_v_n2 = __pyx_t_9;
+
+  /* "multimcts/mcts.pyx":193
+ *             return 1
+ *         cdef int n1 = self.visits, n2 = self.rave_visits
+ *         return n2 / (n1 + n2 + 4*n1*n2/(b**2))             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef double score(self, double exploration_bias, double rave_bias):
+ */
+  __pyx_r = (((double)__pyx_v_n2) / ((__pyx_v_n1 + __pyx_v_n2) + (((double)((4 * __pyx_v_n1) * __pyx_v_n2)) / pow(__pyx_v_b, 2.0))));
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":182
+ * 
+ *     @cython.cdivision(True)
+ *     cpdef double rave_beta(self, double b):             # <<<<<<<<<<<<<<
+ *         """Determines the relative weight of RAVE rewards in the final score calculation.
+ *         As this node is visited more times, the RAVE effect diminishes.
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_WriteUnraisable("multimcts.mcts.Node.rave_beta", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_29rave_beta(PyObject *__pyx_v_self, PyObject *__pyx_arg_b); /*proto*/
+static char __pyx_doc_9multimcts_4mcts_4Node_28rave_beta[] = "Determines the relative weight of RAVE rewards in the final score calculation.\n        As this node is visited more times, the RAVE effect diminishes.\n        The number of RAVE visits has little bearing on this value (the function's curve looks the same for all large values of rave_visits).\n        https://www.desmos.com/calculator/drlccftt6a\n        ";
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_29rave_beta(PyObject *__pyx_v_self, PyObject *__pyx_arg_b) {
+  double __pyx_v_b;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("rave_beta (wrapper)", 0);
+  assert(__pyx_arg_b); {
+    __pyx_v_b = __pyx_PyFloat_AsDouble(__pyx_arg_b); if (unlikely((__pyx_v_b == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 182, __pyx_L3_error)
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.rave_beta", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_28rave_beta(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), ((double)__pyx_v_b));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_28rave_beta(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_b) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("rave_beta", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_9multimcts_4mcts_4Node_rave_beta(__pyx_v_self, __pyx_v_b, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 182, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.rave_beta", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":195
+ *         return n2 / (n1 + n2 + 4*n1*n2/(b**2))
+ * 
+ *     cpdef double score(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef double rave_beta = self.rave_beta(rave_bias)
+ *         return (rave_beta * self.avg_rave_reward) + ((1-rave_beta) * self.avg_reward) + self.uncertainty(exploration_bias)
+ */
+
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_31score(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_score(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias, int __pyx_skip_dispatch) {
+  double __pyx_v_rave_beta;
+  double __pyx_r;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
+  double __pyx_t_9;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("score", 0);
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_score); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_9multimcts_4mcts_4Node_31score)) {
+        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_exploration_bias); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 195, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __pyx_t_4 = PyFloat_FromDouble(__pyx_v_rave_bias); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 195, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_4);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_5 = __pyx_t_1; __pyx_t_6 = NULL;
+        __pyx_t_7 = 0;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
+          __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
+          if (likely(__pyx_t_6)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+            __Pyx_INCREF(__pyx_t_6);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_5, function);
+            __pyx_t_7 = 1;
+          }
+        }
+        #if CYTHON_FAST_PYCALL
+        if (PyFunction_Check(__pyx_t_5)) {
+          PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_3, __pyx_t_4};
+          __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 195, __pyx_L1_error)
+          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        } else
+        #endif
+        #if CYTHON_FAST_PYCCALL
+        if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
+          PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_3, __pyx_t_4};
+          __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 195, __pyx_L1_error)
+          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        } else
+        #endif
+        {
+          __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 195, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_8);
+          if (__pyx_t_6) {
+            __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
+          }
+          __Pyx_GIVEREF(__pyx_t_3);
+          PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_3);
+          __Pyx_GIVEREF(__pyx_t_4);
+          PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_4);
+          __pyx_t_3 = 0;
+          __pyx_t_4 = 0;
+          __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 195, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        }
+        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __pyx_t_9 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_9 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 195, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __pyx_r = __pyx_t_9;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
+      }
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+      }
+      #endif
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    }
+    #endif
+  }
+
+  /* "multimcts/mcts.pyx":196
+ * 
+ *     cpdef double score(self, double exploration_bias, double rave_bias):
+ *         cdef double rave_beta = self.rave_beta(rave_bias)             # <<<<<<<<<<<<<<
+ *         return (rave_beta * self.avg_rave_reward) + ((1-rave_beta) * self.avg_reward) + self.uncertainty(exploration_bias)
+ * 
+ */
+  __pyx_v_rave_beta = ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_self->__pyx_vtab)->rave_beta(__pyx_v_self, __pyx_v_rave_bias, 0);
+
+  /* "multimcts/mcts.pyx":197
+ *     cpdef double score(self, double exploration_bias, double rave_bias):
+ *         cdef double rave_beta = self.rave_beta(rave_bias)
+ *         return (rave_beta * self.avg_rave_reward) + ((1-rave_beta) * self.avg_reward) + self.uncertainty(exploration_bias)             # <<<<<<<<<<<<<<
+ * 
+ *     @cython.wraparound(False)
+ */
+  __pyx_r = (((__pyx_v_rave_beta * __pyx_v_self->avg_rave_reward) + ((1.0 - __pyx_v_rave_beta) * __pyx_v_self->avg_reward)) + ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_self->__pyx_vtab)->uncertainty(__pyx_v_self, __pyx_v_exploration_bias, 0));
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":195
+ *         return n2 / (n1 + n2 + 4*n1*n2/(b**2))
+ * 
+ *     cpdef double score(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef double rave_beta = self.rave_beta(rave_bias)
+ *         return (rave_beta * self.avg_rave_reward) + ((1-rave_beta) * self.avg_reward) + self.uncertainty(exploration_bias)
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_WriteUnraisable("multimcts.mcts.Node.score", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_31score(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_31score(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  double __pyx_v_exploration_bias;
+  double __pyx_v_rave_bias;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("score (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_exploration_bias,&__pyx_n_s_rave_bias,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_exploration_bias)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rave_bias)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("score", 1, 2, 2, 1); __PYX_ERR(0, 195, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "score") < 0)) __PYX_ERR(0, 195, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_exploration_bias = __pyx_PyFloat_AsDouble(values[0]); if (unlikely((__pyx_v_exploration_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 195, __pyx_L3_error)
+    __pyx_v_rave_bias = __pyx_PyFloat_AsDouble(values[1]); if (unlikely((__pyx_v_rave_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 195, __pyx_L3_error)
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("score", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 195, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.score", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_30score(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), __pyx_v_exploration_bias, __pyx_v_rave_bias);
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_30score(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("score", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_9multimcts_4mcts_4Node_score(__pyx_v_self, __pyx_v_exploration_bias, __pyx_v_rave_bias, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.score", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":201
+ *     @cython.wraparound(False)
+ *     @cython.boundscheck(False)
+ *     cdef Node best_child(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef Node child, best_child = next(iter(self.children.values()))
+ *         cdef double score, best_score = -INFINITY
+ */
+
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_best_child(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias) {
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_child = 0;
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_best_child = 0;
+  double __pyx_v_score;
+  double __pyx_v_best_score;
+  CYTHON_UNUSED PyObject *__pyx_v_move = NULL;
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  Py_ssize_t __pyx_t_4;
+  Py_ssize_t __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  int __pyx_t_8;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("best_child", 0);
+
+  /* "multimcts/mcts.pyx":202
+ *     @cython.boundscheck(False)
+ *     cdef Node best_child(self, double exploration_bias, double rave_bias):
+ *         cdef Node child, best_child = next(iter(self.children.values()))             # <<<<<<<<<<<<<<
+ *         cdef double score, best_score = -INFINITY
+ *         for move, child in self.children.items():
+ */
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->children, __pyx_n_s_values); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_3);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyIter_Next(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_9multimcts_4mcts_Node))))) __PYX_ERR(0, 202, __pyx_L1_error)
+  __pyx_v_best_child = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":203
+ *     cdef Node best_child(self, double exploration_bias, double rave_bias):
+ *         cdef Node child, best_child = next(iter(self.children.values()))
+ *         cdef double score, best_score = -INFINITY             # <<<<<<<<<<<<<<
+ *         for move, child in self.children.items():
+ *             score = child.score(exploration_bias, rave_bias)
+ */
+  __pyx_v_best_score = (-INFINITY);
+
+  /* "multimcts/mcts.pyx":204
+ *         cdef Node child, best_child = next(iter(self.children.values()))
+ *         cdef double score, best_score = -INFINITY
+ *         for move, child in self.children.items():             # <<<<<<<<<<<<<<
+ *             score = child.score(exploration_bias, rave_bias)
+ *             if score > best_score:
+ */
+  __pyx_t_4 = 0;
+  if (unlikely(__pyx_v_self->children == Py_None)) {
+    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "items");
+    __PYX_ERR(0, 204, __pyx_L1_error)
+  }
+  __pyx_t_2 = __Pyx_dict_iterator(__pyx_v_self->children, 0, __pyx_n_s_items, (&__pyx_t_5), (&__pyx_t_6)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 204, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_1);
+  __pyx_t_1 = __pyx_t_2;
+  __pyx_t_2 = 0;
+  while (1) {
+    __pyx_t_7 = __Pyx_dict_iter_next(__pyx_t_1, __pyx_t_5, &__pyx_t_4, &__pyx_t_2, &__pyx_t_3, NULL, __pyx_t_6);
+    if (unlikely(__pyx_t_7 == 0)) break;
+    if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 204, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_GOTREF(__pyx_t_3);
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_9multimcts_4mcts_Node))))) __PYX_ERR(0, 204, __pyx_L1_error)
+    __Pyx_XDECREF_SET(__pyx_v_move, __pyx_t_2);
+    __pyx_t_2 = 0;
+    __Pyx_XDECREF_SET(__pyx_v_child, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_3));
+    __pyx_t_3 = 0;
+
+    /* "multimcts/mcts.pyx":205
+ *         cdef double score, best_score = -INFINITY
+ *         for move, child in self.children.items():
+ *             score = child.score(exploration_bias, rave_bias)             # <<<<<<<<<<<<<<
+ *             if score > best_score:
+ *                 best_score = score
+ */
+    __pyx_v_score = ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_child->__pyx_vtab)->score(__pyx_v_child, __pyx_v_exploration_bias, __pyx_v_rave_bias, 0);
+
+    /* "multimcts/mcts.pyx":206
+ *         for move, child in self.children.items():
+ *             score = child.score(exploration_bias, rave_bias)
+ *             if score > best_score:             # <<<<<<<<<<<<<<
+ *                 best_score = score
+ *                 best_child = child
+ */
+    __pyx_t_8 = ((__pyx_v_score > __pyx_v_best_score) != 0);
+    if (__pyx_t_8) {
+
+      /* "multimcts/mcts.pyx":207
+ *             score = child.score(exploration_bias, rave_bias)
+ *             if score > best_score:
+ *                 best_score = score             # <<<<<<<<<<<<<<
+ *                 best_child = child
+ *         return best_child
+ */
+      __pyx_v_best_score = __pyx_v_score;
+
+      /* "multimcts/mcts.pyx":208
+ *             if score > best_score:
+ *                 best_score = score
+ *                 best_child = child             # <<<<<<<<<<<<<<
+ *         return best_child
+ * 
+ */
+      __Pyx_INCREF(((PyObject *)__pyx_v_child));
+      __Pyx_DECREF_SET(__pyx_v_best_child, __pyx_v_child);
+
+      /* "multimcts/mcts.pyx":206
+ *         for move, child in self.children.items():
+ *             score = child.score(exploration_bias, rave_bias)
+ *             if score > best_score:             # <<<<<<<<<<<<<<
+ *                 best_score = score
+ *                 best_child = child
+ */
+    }
+  }
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":209
+ *                 best_score = score
+ *                 best_child = child
+ *         return best_child             # <<<<<<<<<<<<<<
+ * 
+ *     cdef Node select(self, double exploration_bias, double rave_bias):
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_best_child));
+  __pyx_r = __pyx_v_best_child;
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":201
+ *     @cython.wraparound(False)
+ *     @cython.boundscheck(False)
+ *     cdef Node best_child(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef Node child, best_child = next(iter(self.children.values()))
+ *         cdef double score, best_score = -INFINITY
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("multimcts.mcts.Node.best_child", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_child);
+  __Pyx_XDECREF((PyObject *)__pyx_v_best_child);
+  __Pyx_XDECREF(__pyx_v_move);
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":211
+ *         return best_child
+ * 
+ *     cdef Node select(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef Node node = self
+ *         while not node.is_terminal:
+ */
+
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_select(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias) {
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node = 0;
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("select", 0);
+
+  /* "multimcts/mcts.pyx":212
+ * 
+ *     cdef Node select(self, double exploration_bias, double rave_bias):
+ *         cdef Node node = self             # <<<<<<<<<<<<<<
+ *         while not node.is_terminal:
+ *             if node.is_fully_expanded:
+ */
+  __Pyx_INCREF(((PyObject *)__pyx_v_self));
+  __pyx_v_node = __pyx_v_self;
+
+  /* "multimcts/mcts.pyx":213
+ *     cdef Node select(self, double exploration_bias, double rave_bias):
+ *         cdef Node node = self
+ *         while not node.is_terminal:             # <<<<<<<<<<<<<<
+ *             if node.is_fully_expanded:
+ *                 node = node.best_child(exploration_bias, rave_bias)
+ */
+  while (1) {
+    __pyx_t_1 = ((!(__pyx_v_node->is_terminal != 0)) != 0);
+    if (!__pyx_t_1) break;
+
+    /* "multimcts/mcts.pyx":214
+ *         cdef Node node = self
+ *         while not node.is_terminal:
+ *             if node.is_fully_expanded:             # <<<<<<<<<<<<<<
+ *                 node = node.best_child(exploration_bias, rave_bias)
+ *             else:
+ */
+    __pyx_t_1 = (__pyx_v_node->is_fully_expanded != 0);
+    if (__pyx_t_1) {
+
+      /* "multimcts/mcts.pyx":215
+ *         while not node.is_terminal:
+ *             if node.is_fully_expanded:
+ *                 node = node.best_child(exploration_bias, rave_bias)             # <<<<<<<<<<<<<<
+ *             else:
+ *                 return node.expand()
+ */
+      __pyx_t_2 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->best_child(__pyx_v_node, __pyx_v_exploration_bias, __pyx_v_rave_bias)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 215, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF_SET(__pyx_v_node, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2));
+      __pyx_t_2 = 0;
+
+      /* "multimcts/mcts.pyx":214
+ *         cdef Node node = self
+ *         while not node.is_terminal:
+ *             if node.is_fully_expanded:             # <<<<<<<<<<<<<<
+ *                 node = node.best_child(exploration_bias, rave_bias)
+ *             else:
+ */
+      goto __pyx_L5;
+    }
+
+    /* "multimcts/mcts.pyx":217
+ *                 node = node.best_child(exploration_bias, rave_bias)
+ *             else:
+ *                 return node.expand()             # <<<<<<<<<<<<<<
+ *         return node
+ * 
+ */
+    /*else*/ {
+      __Pyx_XDECREF(((PyObject *)__pyx_r));
+      __pyx_t_2 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->expand(__pyx_v_node)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 217, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_r = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2);
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+    }
+    __pyx_L5:;
+  }
+
+  /* "multimcts/mcts.pyx":218
+ *             else:
+ *                 return node.expand()
+ *         return node             # <<<<<<<<<<<<<<
+ * 
+ *     cdef Node expand(self):
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_node));
+  __pyx_r = __pyx_v_node;
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":211
+ *         return best_child
+ * 
+ *     cdef Node select(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef Node node = self
+ *         while not node.is_terminal:
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("multimcts.mcts.Node.select", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_node);
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":220
+ *         return node
+ * 
+ *     cdef Node expand(self):             # <<<<<<<<<<<<<<
+ *         move = self.remaining_moves.pop()
+ *         if len(self.remaining_moves) == 0:
+ */
+
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_expand(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_v_move = NULL;
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_child = 0;
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  Py_ssize_t __pyx_t_2;
+  int __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("expand", 0);
+
+  /* "multimcts/mcts.pyx":221
+ * 
+ *     cdef Node expand(self):
+ *         move = self.remaining_moves.pop()             # <<<<<<<<<<<<<<
+ *         if len(self.remaining_moves) == 0:
+ *             self.is_fully_expanded = True
+ */
+  __pyx_t_1 = __Pyx_PyObject_Pop(__pyx_v_self->remaining_moves); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 221, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_move = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":222
+ *     cdef Node expand(self):
+ *         move = self.remaining_moves.pop()
+ *         if len(self.remaining_moves) == 0:             # <<<<<<<<<<<<<<
+ *             self.is_fully_expanded = True
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)
+ */
+  __pyx_t_1 = __pyx_v_self->remaining_moves;
+  __Pyx_INCREF(__pyx_t_1);
+  __pyx_t_2 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 222, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_3 = ((__pyx_t_2 == 0) != 0);
+  if (__pyx_t_3) {
+
+    /* "multimcts/mcts.pyx":223
+ *         move = self.remaining_moves.pop()
+ *         if len(self.remaining_moves) == 0:
+ *             self.is_fully_expanded = True             # <<<<<<<<<<<<<<
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)
+ *         self.children[move] = child
+ */
+    __pyx_v_self->is_fully_expanded = 1;
+
+    /* "multimcts/mcts.pyx":222
+ *     cdef Node expand(self):
+ *         move = self.remaining_moves.pop()
+ *         if len(self.remaining_moves) == 0:             # <<<<<<<<<<<<<<
+ *             self.is_fully_expanded = True
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)
+ */
+  }
+
+  /* "multimcts/mcts.pyx":224
+ *         if len(self.remaining_moves) == 0:
+ *             self.is_fully_expanded = True
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)             # <<<<<<<<<<<<<<
+ *         self.children[move] = child
+ *         return child
+ */
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 224, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_make_move); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 224, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_6 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
+    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
+    if (likely(__pyx_t_6)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+      __Pyx_INCREF(__pyx_t_6);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_5, function);
+    }
+  }
+  __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_move) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_move);
+  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 224, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_state, __pyx_t_4) < 0) __PYX_ERR(0, 224, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_parent, ((PyObject *)__pyx_v_self)) < 0) __PYX_ERR(0, 224, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_move, __pyx_v_move) < 0) __PYX_ERR(0, 224, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_9multimcts_4mcts_Node), __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 224, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_child = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "multimcts/mcts.pyx":225
+ *             self.is_fully_expanded = True
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)
+ *         self.children[move] = child             # <<<<<<<<<<<<<<
+ *         return child
+ * 
+ */
+  if (unlikely(PyObject_SetItem(__pyx_v_self->children, __pyx_v_move, ((PyObject *)__pyx_v_child)) < 0)) __PYX_ERR(0, 225, __pyx_L1_error)
+
+  /* "multimcts/mcts.pyx":226
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)
+ *         self.children[move] = child
+ *         return child             # <<<<<<<<<<<<<<
+ * 
+ *     cdef void execute_round(self, double exploration_bias, double rave_bias):
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_child));
+  __pyx_r = __pyx_v_child;
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":220
+ *         return node
+ * 
+ *     cdef Node expand(self):             # <<<<<<<<<<<<<<
+ *         move = self.remaining_moves.pop()
+ *         if len(self.remaining_moves) == 0:
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("multimcts.mcts.Node.expand", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_move);
+  __Pyx_XDECREF((PyObject *)__pyx_v_child);
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":228
+ *         return child
+ * 
+ *     cdef void execute_round(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         """Step 1,2: Selection,Expansion"""
+ *         cdef Node node = self.select(exploration_bias, rave_bias)
+ */
+
+static void __pyx_f_9multimcts_4mcts_4Node_execute_round(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias) {
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node = 0;
+  PyObject *__pyx_v_state = NULL;
+  PyObject *__pyx_v_prev_state = NULL;
+  PyObject *__pyx_v_moves = NULL;
+  PyObject *__pyx_v_move = NULL;
+  PyObject *__pyx_v_reward = NULL;
+  PyObject *__pyx_v_terminal_team = NULL;
+  std::map<std::string,double>  __pyx_v_crewards;
+  PyObject *__pyx_v_team = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  PyObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  int __pyx_t_8;
+  std::map<std::string,double>  __pyx_t_9;
+  Py_ssize_t __pyx_t_10;
+  PyObject *(*__pyx_t_11)(PyObject *);
+  double __pyx_t_12;
+  std::string __pyx_t_13;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("execute_round", 0);
+
+  /* "multimcts/mcts.pyx":230
+ *     cdef void execute_round(self, double exploration_bias, double rave_bias):
+ *         """Step 1,2: Selection,Expansion"""
+ *         cdef Node node = self.select(exploration_bias, rave_bias)             # <<<<<<<<<<<<<<
+ * 
+ *         """Step 3: Simulation"""
+ */
+  __pyx_t_1 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_self->__pyx_vtab)->select(__pyx_v_self, __pyx_v_exploration_bias, __pyx_v_rave_bias)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 230, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_node = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":233
+ * 
+ *         """Step 3: Simulation"""
+ *         state = node.state             # <<<<<<<<<<<<<<
+ *         prev_state = None
+ *         moves = set()
+ */
+  __pyx_t_1 = __pyx_v_node->state;
+  __Pyx_INCREF(__pyx_t_1);
+  __pyx_v_state = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":234
+ *         """Step 3: Simulation"""
+ *         state = node.state
+ *         prev_state = None             # <<<<<<<<<<<<<<
+ *         moves = set()
+ *         if not node.is_terminal:
+ */
+  __Pyx_INCREF(Py_None);
+  __pyx_v_prev_state = Py_None;
+
+  /* "multimcts/mcts.pyx":235
+ *         state = node.state
+ *         prev_state = None
+ *         moves = set()             # <<<<<<<<<<<<<<
+ *         if not node.is_terminal:
+ *             while not state.is_terminal():
+ */
+  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 235, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_moves = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":236
+ *         prev_state = None
+ *         moves = set()
+ *         if not node.is_terminal:             # <<<<<<<<<<<<<<
+ *             while not state.is_terminal():
+ *                 prev_state = state
+ */
+  __pyx_t_2 = ((!(__pyx_v_node->is_terminal != 0)) != 0);
+  if (__pyx_t_2) {
+
+    /* "multimcts/mcts.pyx":237
+ *         moves = set()
+ *         if not node.is_terminal:
+ *             while not state.is_terminal():             # <<<<<<<<<<<<<<
+ *                 prev_state = state
+ *                 move = choice(state.get_legal_moves())
+ */
+    while (1) {
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_is_terminal); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 237, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 237, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 237, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_5 = ((!__pyx_t_2) != 0);
+      if (!__pyx_t_5) break;
+
+      /* "multimcts/mcts.pyx":238
+ *         if not node.is_terminal:
+ *             while not state.is_terminal():
+ *                 prev_state = state             # <<<<<<<<<<<<<<
+ *                 move = choice(state.get_legal_moves())
+ *                 moves.add(move)
+ */
+      __Pyx_INCREF(__pyx_v_state);
+      __Pyx_DECREF_SET(__pyx_v_prev_state, __pyx_v_state);
+
+      /* "multimcts/mcts.pyx":239
+ *             while not state.is_terminal():
+ *                 prev_state = state
+ *                 move = choice(state.get_legal_moves())             # <<<<<<<<<<<<<<
+ *                 moves.add(move)
+ *                 state = state.make_move(move)
+ */
+      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_choice); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 239, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_get_legal_moves); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 239, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __pyx_t_7 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
+        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
+        if (likely(__pyx_t_7)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
+          __Pyx_INCREF(__pyx_t_7);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_6, function);
+        }
+      }
+      __pyx_t_4 = (__pyx_t_7) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
+      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 239, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __pyx_t_6 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_6)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_6);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_XDECREF_SET(__pyx_v_move, __pyx_t_1);
+      __pyx_t_1 = 0;
+
+      /* "multimcts/mcts.pyx":240
+ *                 prev_state = state
+ *                 move = choice(state.get_legal_moves())
+ *                 moves.add(move)             # <<<<<<<<<<<<<<
+ *                 state = state.make_move(move)
+ *         reward = state.get_reward()
+ */
+      __pyx_t_8 = PySet_Add(__pyx_v_moves, __pyx_v_move); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 240, __pyx_L1_error)
+
+      /* "multimcts/mcts.pyx":241
+ *                 move = choice(state.get_legal_moves())
+ *                 moves.add(move)
+ *                 state = state.make_move(move)             # <<<<<<<<<<<<<<
+ *         reward = state.get_reward()
+ *         if not isinstance(reward, dict):
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_make_move); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 241, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_move) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_move);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 241, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF_SET(__pyx_v_state, __pyx_t_1);
+      __pyx_t_1 = 0;
+    }
+
+    /* "multimcts/mcts.pyx":236
+ *         prev_state = None
+ *         moves = set()
+ *         if not node.is_terminal:             # <<<<<<<<<<<<<<
+ *             while not state.is_terminal():
+ *                 prev_state = state
+ */
+  }
+
+  /* "multimcts/mcts.pyx":242
+ *                 moves.add(move)
+ *                 state = state.make_move(move)
+ *         reward = state.get_reward()             # <<<<<<<<<<<<<<
+ *         if not isinstance(reward, dict):
+ *             terminal_team = None
+ */
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_get_reward); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 242, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 242, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_v_reward = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":243
+ *                 state = state.make_move(move)
+ *         reward = state.get_reward()
+ *         if not isinstance(reward, dict):             # <<<<<<<<<<<<<<
+ *             terminal_team = None
+ *             if node.is_terminal:
+ */
+  __pyx_t_5 = PyDict_Check(__pyx_v_reward); 
+  __pyx_t_2 = ((!(__pyx_t_5 != 0)) != 0);
+  if (__pyx_t_2) {
+
+    /* "multimcts/mcts.pyx":244
+ *         reward = state.get_reward()
+ *         if not isinstance(reward, dict):
+ *             terminal_team = None             # <<<<<<<<<<<<<<
+ *             if node.is_terminal:
+ *                 terminal_team = node.parent.state.get_current_team()
+ */
+    __Pyx_INCREF(Py_None);
+    __pyx_v_terminal_team = Py_None;
+
+    /* "multimcts/mcts.pyx":245
+ *         if not isinstance(reward, dict):
+ *             terminal_team = None
+ *             if node.is_terminal:             # <<<<<<<<<<<<<<
+ *                 terminal_team = node.parent.state.get_current_team()
+ *             elif prev_state is not None:
+ */
+    __pyx_t_2 = (__pyx_v_node->is_terminal != 0);
+    if (__pyx_t_2) {
+
+      /* "multimcts/mcts.pyx":246
+ *             terminal_team = None
+ *             if node.is_terminal:
+ *                 terminal_team = node.parent.state.get_current_team()             # <<<<<<<<<<<<<<
+ *             elif prev_state is not None:
+ *                 terminal_team = prev_state.get_current_team()
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_node->parent->state, __pyx_n_s_get_current_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 246, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 246, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF_SET(__pyx_v_terminal_team, __pyx_t_1);
+      __pyx_t_1 = 0;
+
+      /* "multimcts/mcts.pyx":245
+ *         if not isinstance(reward, dict):
+ *             terminal_team = None
+ *             if node.is_terminal:             # <<<<<<<<<<<<<<
+ *                 terminal_team = node.parent.state.get_current_team()
+ *             elif prev_state is not None:
+ */
+      goto __pyx_L7;
+    }
+
+    /* "multimcts/mcts.pyx":247
+ *             if node.is_terminal:
+ *                 terminal_team = node.parent.state.get_current_team()
+ *             elif prev_state is not None:             # <<<<<<<<<<<<<<
+ *                 terminal_team = prev_state.get_current_team()
+ *             else:
+ */
+    __pyx_t_2 = (__pyx_v_prev_state != Py_None);
+    __pyx_t_5 = (__pyx_t_2 != 0);
+    if (likely(__pyx_t_5)) {
+
+      /* "multimcts/mcts.pyx":248
+ *                 terminal_team = node.parent.state.get_current_team()
+ *             elif prev_state is not None:
+ *                 terminal_team = prev_state.get_current_team()             # <<<<<<<<<<<<<<
+ *             else:
+ *                 raise ValueError("Could not determine terminal team during simulation.")
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_prev_state, __pyx_n_s_get_current_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 248, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 248, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF_SET(__pyx_v_terminal_team, __pyx_t_1);
+      __pyx_t_1 = 0;
+
+      /* "multimcts/mcts.pyx":247
+ *             if node.is_terminal:
+ *                 terminal_team = node.parent.state.get_current_team()
+ *             elif prev_state is not None:             # <<<<<<<<<<<<<<
+ *                 terminal_team = prev_state.get_current_team()
+ *             else:
+ */
+      goto __pyx_L7;
+    }
+
+    /* "multimcts/mcts.pyx":250
+ *                 terminal_team = prev_state.get_current_team()
+ *             else:
+ *                 raise ValueError("Could not determine terminal team during simulation.")             # <<<<<<<<<<<<<<
+ *             reward = {terminal_team: reward}
+ *         cdef map[string,double] crewards = map[string,double]()
+ */
+    /*else*/ {
+      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 250, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __PYX_ERR(0, 250, __pyx_L1_error)
+    }
+    __pyx_L7:;
+
+    /* "multimcts/mcts.pyx":251
+ *             else:
+ *                 raise ValueError("Could not determine terminal team during simulation.")
+ *             reward = {terminal_team: reward}             # <<<<<<<<<<<<<<
+ *         cdef map[string,double] crewards = map[string,double]()
+ *         for team in reward:
+ */
+    __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 251, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    if (PyDict_SetItem(__pyx_t_1, __pyx_v_terminal_team, __pyx_v_reward) < 0) __PYX_ERR(0, 251, __pyx_L1_error)
+    __Pyx_DECREF_SET(__pyx_v_reward, __pyx_t_1);
+    __pyx_t_1 = 0;
+
+    /* "multimcts/mcts.pyx":243
+ *                 state = state.make_move(move)
+ *         reward = state.get_reward()
+ *         if not isinstance(reward, dict):             # <<<<<<<<<<<<<<
+ *             terminal_team = None
+ *             if node.is_terminal:
+ */
+  }
+
+  /* "multimcts/mcts.pyx":252
+ *                 raise ValueError("Could not determine terminal team during simulation.")
+ *             reward = {terminal_team: reward}
+ *         cdef map[string,double] crewards = map[string,double]()             # <<<<<<<<<<<<<<
+ *         for team in reward:
+ *             if reward[team] == 0:
+ */
+  try {
+    __pyx_t_9 = std::map<std::string,double> ();
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 252, __pyx_L1_error)
+  }
+  __pyx_v_crewards = __pyx_t_9;
+
+  /* "multimcts/mcts.pyx":253
+ *             reward = {terminal_team: reward}
+ *         cdef map[string,double] crewards = map[string,double]()
+ *         for team in reward:             # <<<<<<<<<<<<<<
+ *             if reward[team] == 0:
+ *                 continue
+ */
+  if (likely(PyList_CheckExact(__pyx_v_reward)) || PyTuple_CheckExact(__pyx_v_reward)) {
+    __pyx_t_1 = __pyx_v_reward; __Pyx_INCREF(__pyx_t_1); __pyx_t_10 = 0;
+    __pyx_t_11 = NULL;
+  } else {
+    __pyx_t_10 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 253, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_11 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 253, __pyx_L1_error)
+  }
+  for (;;) {
+    if (likely(!__pyx_t_11)) {
+      if (likely(PyList_CheckExact(__pyx_t_1))) {
+        if (__pyx_t_10 >= PyList_GET_SIZE(__pyx_t_1)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_10); __Pyx_INCREF(__pyx_t_3); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 253, __pyx_L1_error)
+        #else
+        __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 253, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        #endif
+      } else {
+        if (__pyx_t_10 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_10); __Pyx_INCREF(__pyx_t_3); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 253, __pyx_L1_error)
+        #else
+        __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 253, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        #endif
+      }
+    } else {
+      __pyx_t_3 = __pyx_t_11(__pyx_t_1);
+      if (unlikely(!__pyx_t_3)) {
+        PyObject* exc_type = PyErr_Occurred();
+        if (exc_type) {
+          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+          else __PYX_ERR(0, 253, __pyx_L1_error)
+        }
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_3);
+    }
+    __Pyx_XDECREF_SET(__pyx_v_team, __pyx_t_3);
+    __pyx_t_3 = 0;
+
+    /* "multimcts/mcts.pyx":254
+ *         cdef map[string,double] crewards = map[string,double]()
+ *         for team in reward:
+ *             if reward[team] == 0:             # <<<<<<<<<<<<<<
+ *                 continue
+ *             crewards[str(team).encode()] = float(reward[team])
+ */
+    __pyx_t_3 = __Pyx_PyObject_GetItem(__pyx_v_reward, __pyx_v_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 254, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = __Pyx_PyInt_EqObjC(__pyx_t_3, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 254, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 254, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (__pyx_t_5) {
+
+      /* "multimcts/mcts.pyx":255
+ *         for team in reward:
+ *             if reward[team] == 0:
+ *                 continue             # <<<<<<<<<<<<<<
+ *             crewards[str(team).encode()] = float(reward[team])
+ * 
+ */
+      goto __pyx_L8_continue;
+
+      /* "multimcts/mcts.pyx":254
+ *         cdef map[string,double] crewards = map[string,double]()
+ *         for team in reward:
+ *             if reward[team] == 0:             # <<<<<<<<<<<<<<
+ *                 continue
+ *             crewards[str(team).encode()] = float(reward[team])
+ */
+    }
+
+    /* "multimcts/mcts.pyx":256
+ *             if reward[team] == 0:
+ *                 continue
+ *             crewards[str(team).encode()] = float(reward[team])             # <<<<<<<<<<<<<<
+ * 
+ *         """Step 4: Backpropagation"""
+ */
+    __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_reward, __pyx_v_team); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 256, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_12 = __Pyx_PyObject_AsDouble(__pyx_t_4); if (unlikely(__pyx_t_12 == ((double)((double)-1)) && PyErr_Occurred())) __PYX_ERR(0, 256, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_team); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 256, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_3 = PyUnicode_AsEncodedString(((PyObject*)__pyx_t_4), NULL, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 256, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_13 = __pyx_convert_string_from_py_std__in_string(__pyx_t_3); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 256, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    (__pyx_v_crewards[__pyx_t_13]) = __pyx_t_12;
+
+    /* "multimcts/mcts.pyx":253
+ *             reward = {terminal_team: reward}
+ *         cdef map[string,double] crewards = map[string,double]()
+ *         for team in reward:             # <<<<<<<<<<<<<<
+ *             if reward[team] == 0:
+ *                 continue
+ */
+    __pyx_L8_continue:;
+  }
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":259
+ * 
+ *         """Step 4: Backpropagation"""
+ *         while node is not None:             # <<<<<<<<<<<<<<
+ *             node.visit(crewards, moves)
+ *             node = node.parent
+ */
+  while (1) {
+    __pyx_t_5 = (((PyObject *)__pyx_v_node) != Py_None);
+    __pyx_t_2 = (__pyx_t_5 != 0);
+    if (!__pyx_t_2) break;
+
+    /* "multimcts/mcts.pyx":260
+ *         """Step 4: Backpropagation"""
+ *         while node is not None:
+ *             node.visit(crewards, moves)             # <<<<<<<<<<<<<<
+ *             node = node.parent
+ * 
+ */
+    __pyx_t_1 = ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->visit(__pyx_v_node, __pyx_v_crewards, __pyx_v_moves); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 260, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+    /* "multimcts/mcts.pyx":261
+ *         while node is not None:
+ *             node.visit(crewards, moves)
+ *             node = node.parent             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+    __pyx_t_1 = ((PyObject *)__pyx_v_node->parent);
+    __Pyx_INCREF(__pyx_t_1);
+    __Pyx_DECREF_SET(__pyx_v_node, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_1));
+    __pyx_t_1 = 0;
+  }
+
+  /* "multimcts/mcts.pyx":228
+ *         return child
+ * 
+ *     cdef void execute_round(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         """Step 1,2: Selection,Expansion"""
+ *         cdef Node node = self.select(exploration_bias, rave_bias)
+ */
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_WriteUnraisable("multimcts.mcts.Node.execute_round", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_L0:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_node);
+  __Pyx_XDECREF(__pyx_v_state);
+  __Pyx_XDECREF(__pyx_v_prev_state);
+  __Pyx_XDECREF(__pyx_v_moves);
+  __Pyx_XDECREF(__pyx_v_move);
+  __Pyx_XDECREF(__pyx_v_reward);
+  __Pyx_XDECREF(__pyx_v_terminal_team);
+  __Pyx_XDECREF(__pyx_v_team);
+  __Pyx_RefNannyFinishContext();
+}
+
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
  *     cdef object _dict
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_33__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_33__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_2__reduce_cython__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_32__reduce_cython__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_2__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_32__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
   PyObject *__pyx_v_state = 0;
   PyObject *__pyx_v__dict = 0;
   int __pyx_v_use_setstate;
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   PyObject *__pyx_t_9 = NULL;
-  int __pyx_t_10;
-  int __pyx_t_11;
-  int __pyx_t_12;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  int __pyx_t_13;
+  int __pyx_t_14;
+  int __pyx_t_15;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
-  __Pyx_TraceCall("__reduce_cython__", __pyx_f[1], 1, 0, __PYX_ERR(1, 1, __pyx_L1_error));
 
   /* "(tree fragment)":5
  *     cdef object _dict
  *     cdef bint use_setstate
- *     state = (self.avg_reward, self.children, self.cteam, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)             # <<<<<<<<<<<<<<
+ *     state = (self.avg_rave_reward, self.avg_reward, self.children, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.rave_rewards, self.rave_visits, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)             # <<<<<<<<<<<<<<
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  */
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->avg_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->avg_rave_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_v_self->cteam); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_self->avg_reward); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = PyFloat_FromDouble(__pyx_v_self->invsqrt_visits); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->is_fully_expanded); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = __Pyx_PyBool_FromLong(__pyx_v_self->is_terminal); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_6 = __pyx_convert_map_to_py_std_3a__3a_string____double(__pyx_v_self->rewards); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_6 = __pyx_convert_map_to_py_std_3a__3a_string____double(__pyx_v_self->rave_rewards); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_7 = PyFloat_FromDouble(__pyx_v_self->sqrtlog_visits); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_self->rave_visits); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_8 = __Pyx_PyInt_From_int(__pyx_v_self->visits); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_8 = __pyx_convert_map_to_py_std_3a__3a_string____double(__pyx_v_self->rewards); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_9 = PyTuple_New(14); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_9 = PyFloat_FromDouble(__pyx_v_self->sqrtlog_visits); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
+  __pyx_t_10 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_v_self->team); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_10);
+  __pyx_t_11 = __Pyx_PyInt_From_int(__pyx_v_self->visits); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_11);
+  __pyx_t_12 = PyTuple_New(16); if (unlikely(!__pyx_t_12)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_12);
   __Pyx_GIVEREF(__pyx_t_1);
-  PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_1);
+  PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_12, 1, __pyx_t_2);
   __Pyx_INCREF(__pyx_v_self->children);
   __Pyx_GIVEREF(__pyx_v_self->children);
-  PyTuple_SET_ITEM(__pyx_t_9, 1, __pyx_v_self->children);
-  __Pyx_GIVEREF(__pyx_t_2);
-  PyTuple_SET_ITEM(__pyx_t_9, 2, __pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_12, 2, __pyx_v_self->children);
   __Pyx_GIVEREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_9, 3, __pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_12, 3, __pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_4);
-  PyTuple_SET_ITEM(__pyx_t_9, 4, __pyx_t_4);
+  PyTuple_SET_ITEM(__pyx_t_12, 4, __pyx_t_4);
   __Pyx_GIVEREF(__pyx_t_5);
-  PyTuple_SET_ITEM(__pyx_t_9, 5, __pyx_t_5);
+  PyTuple_SET_ITEM(__pyx_t_12, 5, __pyx_t_5);
   __Pyx_INCREF(__pyx_v_self->move);
   __Pyx_GIVEREF(__pyx_v_self->move);
-  PyTuple_SET_ITEM(__pyx_t_9, 6, __pyx_v_self->move);
+  PyTuple_SET_ITEM(__pyx_t_12, 6, __pyx_v_self->move);
   __Pyx_INCREF(((PyObject *)__pyx_v_self->parent));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self->parent));
-  PyTuple_SET_ITEM(__pyx_t_9, 7, ((PyObject *)__pyx_v_self->parent));
-  __Pyx_INCREF(__pyx_v_self->remaining_moves);
-  __Pyx_GIVEREF(__pyx_v_self->remaining_moves);
-  PyTuple_SET_ITEM(__pyx_t_9, 8, __pyx_v_self->remaining_moves);
+  PyTuple_SET_ITEM(__pyx_t_12, 7, ((PyObject *)__pyx_v_self->parent));
   __Pyx_GIVEREF(__pyx_t_6);
-  PyTuple_SET_ITEM(__pyx_t_9, 9, __pyx_t_6);
+  PyTuple_SET_ITEM(__pyx_t_12, 8, __pyx_t_6);
   __Pyx_GIVEREF(__pyx_t_7);
-  PyTuple_SET_ITEM(__pyx_t_9, 10, __pyx_t_7);
+  PyTuple_SET_ITEM(__pyx_t_12, 9, __pyx_t_7);
+  __Pyx_INCREF(__pyx_v_self->remaining_moves);
+  __Pyx_GIVEREF(__pyx_v_self->remaining_moves);
+  PyTuple_SET_ITEM(__pyx_t_12, 10, __pyx_v_self->remaining_moves);
+  __Pyx_GIVEREF(__pyx_t_8);
+  PyTuple_SET_ITEM(__pyx_t_12, 11, __pyx_t_8);
+  __Pyx_GIVEREF(__pyx_t_9);
+  PyTuple_SET_ITEM(__pyx_t_12, 12, __pyx_t_9);
   __Pyx_INCREF(__pyx_v_self->state);
   __Pyx_GIVEREF(__pyx_v_self->state);
-  PyTuple_SET_ITEM(__pyx_t_9, 11, __pyx_v_self->state);
-  __Pyx_INCREF(__pyx_v_self->team);
-  __Pyx_GIVEREF(__pyx_v_self->team);
-  PyTuple_SET_ITEM(__pyx_t_9, 12, __pyx_v_self->team);
-  __Pyx_GIVEREF(__pyx_t_8);
-  PyTuple_SET_ITEM(__pyx_t_9, 13, __pyx_t_8);
+  PyTuple_SET_ITEM(__pyx_t_12, 13, __pyx_v_self->state);
+  __Pyx_GIVEREF(__pyx_t_10);
+  PyTuple_SET_ITEM(__pyx_t_12, 14, __pyx_t_10);
+  __Pyx_GIVEREF(__pyx_t_11);
+  PyTuple_SET_ITEM(__pyx_t_12, 15, __pyx_t_11);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
   __pyx_t_3 = 0;
   __pyx_t_4 = 0;
   __pyx_t_5 = 0;
   __pyx_t_6 = 0;
   __pyx_t_7 = 0;
   __pyx_t_8 = 0;
-  __pyx_v_state = ((PyObject*)__pyx_t_9);
   __pyx_t_9 = 0;
+  __pyx_t_10 = 0;
+  __pyx_t_11 = 0;
+  __pyx_v_state = ((PyObject*)__pyx_t_12);
+  __pyx_t_12 = 0;
 
   /* "(tree fragment)":6
  *     cdef bint use_setstate
- *     state = (self.avg_reward, self.children, self.cteam, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
+ *     state = (self.avg_rave_reward, self.avg_reward, self.children, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.rave_rewards, self.rave_visits, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
  *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<
  *     if _dict is not None:
  *         state += (_dict,)
  */
-  __pyx_t_9 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 6, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_9);
-  __pyx_v__dict = __pyx_t_9;
-  __pyx_t_9 = 0;
+  __pyx_t_12 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_12)) __PYX_ERR(1, 6, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_12);
+  __pyx_v__dict = __pyx_t_12;
+  __pyx_t_12 = 0;
 
   /* "(tree fragment)":7
- *     state = (self.avg_reward, self.children, self.cteam, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
+ *     state = (self.avg_rave_reward, self.avg_reward, self.children, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.rave_rewards, self.rave_visits, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
-  __pyx_t_10 = (__pyx_v__dict != Py_None);
-  __pyx_t_11 = (__pyx_t_10 != 0);
-  if (__pyx_t_11) {
+  __pyx_t_13 = (__pyx_v__dict != Py_None);
+  __pyx_t_14 = (__pyx_t_13 != 0);
+  if (__pyx_t_14) {
 
     /* "(tree fragment)":8
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  *         state += (_dict,)             # <<<<<<<<<<<<<<
  *         use_setstate = True
  *     else:
  */
-    __pyx_t_9 = PyTuple_New(1); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 8, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_9);
+    __pyx_t_12 = PyTuple_New(1); if (unlikely(!__pyx_t_12)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_12);
     __Pyx_INCREF(__pyx_v__dict);
     __Pyx_GIVEREF(__pyx_v__dict);
-    PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_v__dict);
-    __pyx_t_8 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_9); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 8, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_8);
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_8));
-    __pyx_t_8 = 0;
+    PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_v__dict);
+    __pyx_t_11 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_12); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_11);
+    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
+    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_11));
+    __pyx_t_11 = 0;
 
     /* "(tree fragment)":9
  *     if _dict is not None:
  *         state += (_dict,)
  *         use_setstate = True             # <<<<<<<<<<<<<<
  *     else:
- *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None or self.team is not None
+ *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None
  */
     __pyx_v_use_setstate = 1;
 
     /* "(tree fragment)":7
- *     state = (self.avg_reward, self.children, self.cteam, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
+ *     state = (self.avg_rave_reward, self.avg_reward, self.children, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.rave_rewards, self.rave_visits, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
     goto __pyx_L3;
   }
 
   /* "(tree fragment)":11
  *         use_setstate = True
  *     else:
- *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None or self.team is not None             # <<<<<<<<<<<<<<
+ *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None             # <<<<<<<<<<<<<<
  *     if use_setstate:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, None), state
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, None), state
  */
   /*else*/ {
-    __pyx_t_10 = (__pyx_v_self->children != Py_None);
-    __pyx_t_12 = (__pyx_t_10 != 0);
-    if (!__pyx_t_12) {
-    } else {
-      __pyx_t_11 = __pyx_t_12;
-      goto __pyx_L4_bool_binop_done;
-    }
-    __pyx_t_12 = (__pyx_v_self->move != Py_None);
-    __pyx_t_10 = (__pyx_t_12 != 0);
-    if (!__pyx_t_10) {
+    __pyx_t_13 = (__pyx_v_self->children != Py_None);
+    __pyx_t_15 = (__pyx_t_13 != 0);
+    if (!__pyx_t_15) {
     } else {
-      __pyx_t_11 = __pyx_t_10;
+      __pyx_t_14 = __pyx_t_15;
       goto __pyx_L4_bool_binop_done;
     }
-    __pyx_t_10 = (((PyObject *)__pyx_v_self->parent) != Py_None);
-    __pyx_t_12 = (__pyx_t_10 != 0);
-    if (!__pyx_t_12) {
+    __pyx_t_15 = (__pyx_v_self->move != Py_None);
+    __pyx_t_13 = (__pyx_t_15 != 0);
+    if (!__pyx_t_13) {
     } else {
-      __pyx_t_11 = __pyx_t_12;
+      __pyx_t_14 = __pyx_t_13;
       goto __pyx_L4_bool_binop_done;
     }
-    __pyx_t_12 = (__pyx_v_self->remaining_moves != Py_None);
-    __pyx_t_10 = (__pyx_t_12 != 0);
-    if (!__pyx_t_10) {
+    __pyx_t_13 = (((PyObject *)__pyx_v_self->parent) != Py_None);
+    __pyx_t_15 = (__pyx_t_13 != 0);
+    if (!__pyx_t_15) {
     } else {
-      __pyx_t_11 = __pyx_t_10;
+      __pyx_t_14 = __pyx_t_15;
       goto __pyx_L4_bool_binop_done;
     }
-    __pyx_t_10 = (__pyx_v_self->state != Py_None);
-    __pyx_t_12 = (__pyx_t_10 != 0);
-    if (!__pyx_t_12) {
+    __pyx_t_15 = (__pyx_v_self->remaining_moves != Py_None);
+    __pyx_t_13 = (__pyx_t_15 != 0);
+    if (!__pyx_t_13) {
     } else {
-      __pyx_t_11 = __pyx_t_12;
+      __pyx_t_14 = __pyx_t_13;
       goto __pyx_L4_bool_binop_done;
     }
-    __pyx_t_12 = (__pyx_v_self->team != Py_None);
-    __pyx_t_10 = (__pyx_t_12 != 0);
-    __pyx_t_11 = __pyx_t_10;
+    __pyx_t_13 = (__pyx_v_self->state != Py_None);
+    __pyx_t_15 = (__pyx_t_13 != 0);
+    __pyx_t_14 = __pyx_t_15;
     __pyx_L4_bool_binop_done:;
-    __pyx_v_use_setstate = __pyx_t_11;
+    __pyx_v_use_setstate = __pyx_t_14;
   }
   __pyx_L3:;
 
   /* "(tree fragment)":12
  *     else:
- *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None or self.team is not None
+ *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, None), state
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, None), state
  *     else:
  */
-  __pyx_t_11 = (__pyx_v_use_setstate != 0);
-  if (__pyx_t_11) {
+  __pyx_t_14 = (__pyx_v_use_setstate != 0);
+  if (__pyx_t_14) {
 
     /* "(tree fragment)":13
- *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None or self.team is not None
+ *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None
  *     if use_setstate:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, None), state             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, None), state             # <<<<<<<<<<<<<<
  *     else:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, state)
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, state)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_pyx_unpickle_Node); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_8);
-    __pyx_t_9 = PyTuple_New(3); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_9);
+    __Pyx_GetModuleGlobalName(__pyx_t_11, __pyx_n_s_pyx_unpickle_Node); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_11);
+    __pyx_t_12 = PyTuple_New(3); if (unlikely(!__pyx_t_12)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_12);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    PyTuple_SET_ITEM(__pyx_t_9, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_56097295);
-    __Pyx_GIVEREF(__pyx_int_56097295);
-    PyTuple_SET_ITEM(__pyx_t_9, 1, __pyx_int_56097295);
+    PyTuple_SET_ITEM(__pyx_t_12, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
+    __Pyx_INCREF(__pyx_int_254580472);
+    __Pyx_GIVEREF(__pyx_int_254580472);
+    PyTuple_SET_ITEM(__pyx_t_12, 1, __pyx_int_254580472);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
-    PyTuple_SET_ITEM(__pyx_t_9, 2, Py_None);
-    __pyx_t_7 = PyTuple_New(3); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __Pyx_GIVEREF(__pyx_t_8);
-    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_8);
-    __Pyx_GIVEREF(__pyx_t_9);
-    PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_9);
+    PyTuple_SET_ITEM(__pyx_t_12, 2, Py_None);
+    __pyx_t_10 = PyTuple_New(3); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_10);
+    __Pyx_GIVEREF(__pyx_t_11);
+    PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_11);
+    __Pyx_GIVEREF(__pyx_t_12);
+    PyTuple_SET_ITEM(__pyx_t_10, 1, __pyx_t_12);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
-    PyTuple_SET_ITEM(__pyx_t_7, 2, __pyx_v_state);
-    __pyx_t_8 = 0;
-    __pyx_t_9 = 0;
-    __pyx_r = __pyx_t_7;
-    __pyx_t_7 = 0;
+    PyTuple_SET_ITEM(__pyx_t_10, 2, __pyx_v_state);
+    __pyx_t_11 = 0;
+    __pyx_t_12 = 0;
+    __pyx_r = __pyx_t_10;
+    __pyx_t_10 = 0;
     goto __pyx_L0;
 
     /* "(tree fragment)":12
  *     else:
- *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None or self.team is not None
+ *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, None), state
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, None), state
  *     else:
  */
   }
 
   /* "(tree fragment)":15
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, None), state
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, None), state
  *     else:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, state)             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, state)             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Node__set_state(self, __pyx_state)
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_pyx_unpickle_Node); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_9 = PyTuple_New(3); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_9);
+    __Pyx_GetModuleGlobalName(__pyx_t_10, __pyx_n_s_pyx_unpickle_Node); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_10);
+    __pyx_t_12 = PyTuple_New(3); if (unlikely(!__pyx_t_12)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_12);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    PyTuple_SET_ITEM(__pyx_t_9, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_56097295);
-    __Pyx_GIVEREF(__pyx_int_56097295);
-    PyTuple_SET_ITEM(__pyx_t_9, 1, __pyx_int_56097295);
+    PyTuple_SET_ITEM(__pyx_t_12, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
+    __Pyx_INCREF(__pyx_int_254580472);
+    __Pyx_GIVEREF(__pyx_int_254580472);
+    PyTuple_SET_ITEM(__pyx_t_12, 1, __pyx_int_254580472);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
-    PyTuple_SET_ITEM(__pyx_t_9, 2, __pyx_v_state);
-    __pyx_t_8 = PyTuple_New(2); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_8);
-    __Pyx_GIVEREF(__pyx_t_7);
-    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7);
-    __Pyx_GIVEREF(__pyx_t_9);
-    PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_9);
-    __pyx_t_7 = 0;
-    __pyx_t_9 = 0;
-    __pyx_r = __pyx_t_8;
-    __pyx_t_8 = 0;
+    PyTuple_SET_ITEM(__pyx_t_12, 2, __pyx_v_state);
+    __pyx_t_11 = PyTuple_New(2); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_11);
+    __Pyx_GIVEREF(__pyx_t_10);
+    PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_10);
+    __Pyx_GIVEREF(__pyx_t_12);
+    PyTuple_SET_ITEM(__pyx_t_11, 1, __pyx_t_12);
+    __pyx_t_10 = 0;
+    __pyx_t_12 = 0;
+    __pyx_r = __pyx_t_11;
+    __pyx_t_11 = 0;
     goto __pyx_L0;
   }
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
  *     cdef object _dict
@@ -3738,206 +6051,219 @@
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_7);
   __Pyx_XDECREF(__pyx_t_8);
   __Pyx_XDECREF(__pyx_t_9);
+  __Pyx_XDECREF(__pyx_t_10);
+  __Pyx_XDECREF(__pyx_t_11);
+  __Pyx_XDECREF(__pyx_t_12);
   __Pyx_AddTraceback("multimcts.mcts.Node.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_state);
   __Pyx_XDECREF(__pyx_v__dict);
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, state)
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_Node__set_state(self, __pyx_state)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_35__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_35__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_4__setstate_cython__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_34__setstate_cython__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_4__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_34__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
-  __Pyx_TraceCall("__setstate_cython__", __pyx_f[1], 16, 0, __PYX_ERR(1, 16, __pyx_L1_error));
 
   /* "(tree fragment)":17
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, state)
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, state)
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Node__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<
  */
   if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
   __pyx_t_1 = __pyx_f_9multimcts_4mcts___pyx_unpickle_Node__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, state)
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_Node__set_state(self, __pyx_state)
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.Node.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":137
- *     cdef double exploration_bias
+/* "multimcts/mcts.pyx":267
+ *     cdef double exploration_bias, rave_bias
  * 
- *     def __init__(self, exploration_bias:float=1.414):             # <<<<<<<<<<<<<<
+ *     def __init__(self, exploration_bias:float=1.414, rave_bias:float=0):             # <<<<<<<<<<<<<<
  *         """Initializes an MCTS agent.
  *         Args:
  */
 
 /* Python wrapper */
 static int __pyx_pw_9multimcts_4mcts_4MCTS_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static char __pyx_doc_9multimcts_4mcts_4MCTS___init__[] = "Initializes an MCTS agent.\n        Args:\n            exploration_bias (float): The exploration bias, which balances exploration (favoring untested moves) and exploitation (favoring good moves).\n                The default \342\210\2322 is often used in practice. However, the optimal value depends on the game and is usually found by experimentation.\n        ";
 #if CYTHON_UPDATE_DESCRIPTOR_DOC
 struct wrapperbase __pyx_wrapperbase_9multimcts_4mcts_4MCTS___init__;
 #endif
 static int __pyx_pw_9multimcts_4mcts_4MCTS_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   double __pyx_v_exploration_bias;
+  double __pyx_v_rave_bias;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_exploration_bias,0};
-    PyObject* values[1] = {0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_exploration_bias,&__pyx_n_s_rave_bias,0};
+    PyObject* values[2] = {0,0};
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
       const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
       switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_exploration_bias);
           if (value) { values[0] = value; kw_args--; }
         }
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (kw_args > 0) {
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rave_bias);
+          if (value) { values[1] = value; kw_args--; }
+        }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 137, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 267, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     if (values[0]) {
-      __pyx_v_exploration_bias = __pyx_PyFloat_AsDouble(values[0]); if (unlikely((__pyx_v_exploration_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 137, __pyx_L3_error)
+      __pyx_v_exploration_bias = __pyx_PyFloat_AsDouble(values[0]); if (unlikely((__pyx_v_exploration_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 267, __pyx_L3_error)
     } else {
       __pyx_v_exploration_bias = ((double)1.414);
     }
+    if (values[1]) {
+      __pyx_v_rave_bias = __pyx_PyFloat_AsDouble(values[1]); if (unlikely((__pyx_v_rave_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 267, __pyx_L3_error)
+    } else {
+      __pyx_v_rave_bias = ((double)0.0);
+    }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 137, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 267, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("multimcts.mcts.MCTS.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4MCTS___init__(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v_self), __pyx_v_exploration_bias);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4MCTS___init__(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v_self), __pyx_v_exploration_bias, __pyx_v_rave_bias);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static int __pyx_pf_9multimcts_4mcts_4MCTS___init__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, double __pyx_v_exploration_bias) {
+static int __pyx_pf_9multimcts_4mcts_4MCTS___init__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias) {
   int __pyx_r;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
-  __Pyx_TraceCall("__init__", __pyx_f[0], 137, 0, __PYX_ERR(0, 137, __pyx_L1_error));
 
-  /* "multimcts/mcts.pyx":143
+  /* "multimcts/mcts.pyx":273
  *                 The default 2 is often used in practice. However, the optimal value depends on the game and is usually found by experimentation.
  *         """
  *         self.exploration_bias = exploration_bias             # <<<<<<<<<<<<<<
+ *         self.rave_bias = rave_bias
  * 
- *     @property
  */
   __pyx_v_self->exploration_bias = __pyx_v_exploration_bias;
 
-  /* "multimcts/mcts.pyx":137
- *     cdef double exploration_bias
+  /* "multimcts/mcts.pyx":274
+ *         """
+ *         self.exploration_bias = exploration_bias
+ *         self.rave_bias = rave_bias             # <<<<<<<<<<<<<<
+ * 
+ *     @property
+ */
+  __pyx_v_self->rave_bias = __pyx_v_rave_bias;
+
+  /* "multimcts/mcts.pyx":267
+ *     cdef double exploration_bias, rave_bias
  * 
- *     def __init__(self, exploration_bias:float=1.414):             # <<<<<<<<<<<<<<
+ *     def __init__(self, exploration_bias:float=1.414, rave_bias:float=0):             # <<<<<<<<<<<<<<
  *         """Initializes an MCTS agent.
  *         Args:
  */
 
   /* function exit code */
   __pyx_r = 0;
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("multimcts.mcts.MCTS.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = -1;
-  __pyx_L0:;
-  __Pyx_TraceReturn(Py_None, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":146
+/* "multimcts/mcts.pyx":277
  * 
  *     @property
  *     def exploration_bias(self) -> float: return self.exploration_bias             # <<<<<<<<<<<<<<
- * 
- *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, heuristic=None, return_type:str="state") -> Union[GameState,Move,Node]:
+ *     @property
+ *     def rave_bias(self) -> float: return self.rave_bias
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_16exploration_bias_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_16exploration_bias_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -3947,71 +6273,113 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_16exploration_bias___get__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
-  __Pyx_TraceCall("__get__", __pyx_f[0], 146, 0, __PYX_ERR(0, 146, __pyx_L1_error));
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->exploration_bias); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->exploration_bias); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 277, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.MCTS.exploration_bias.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":148
+/* "multimcts/mcts.pyx":279
  *     def exploration_bias(self) -> float: return self.exploration_bias
+ *     @property
+ *     def rave_bias(self) -> float: return self.rave_bias             # <<<<<<<<<<<<<<
+ * 
+ *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, return_type:str="state") -> Union[GameState,Move,Node]:
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_9rave_bias_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_9rave_bias_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4MCTS_9rave_bias___get__(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_9rave_bias___get__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->rave_bias); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 279, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.MCTS.rave_bias.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":281
+ *     def rave_bias(self) -> float: return self.rave_bias
  * 
- *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, heuristic=None, return_type:str="state") -> Union[GameState,Move,Node]:             # <<<<<<<<<<<<<<
+ *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, return_type:str="state") -> Union[GameState,Move,Node]:             # <<<<<<<<<<<<<<
  *         """Searches for this state's best move until some limit has been reached.
  *         Args:
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_3search(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_9multimcts_4mcts_4MCTS_2search[] = "Searches for this state's best move until some limit has been reached.\n        Args:\n            state (GameState): The game state for which to find the best move.\n            max_time (int|float): The maximum time to search, in seconds.\n            max_iterations (int): The maximum number of selections/simulations to perform.\n            heuristic (callable): A function that takes a state and returns a move. See simulate() for more information.\n            return_type (str): One of \"state\", \"move\", or \"node\".\n        Returns:\n            GameState: A new game state which is the result of applying the best move to the given state.\n        ";
+static char __pyx_doc_9multimcts_4mcts_4MCTS_2search[] = "Searches for this state's best move until some limit has been reached.\n        Args:\n            state (GameState): The game state for which to find the best move.\n            max_time (int|float): The maximum time to search, in seconds.\n            max_iterations (int): The maximum number of selections/simulations to perform.\n            return_type (str): One of \"state\", \"move\", or \"node\".\n        Returns:\n            GameState: A new game state which is the result of applying the best move to the given state.\n        ";
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_3search(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_state = 0;
   PyObject *__pyx_v_max_time = 0;
   PyObject *__pyx_v_max_iterations = 0;
-  PyObject *__pyx_v_heuristic = 0;
   PyObject *__pyx_v_return_type = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("search (wrapper)", 0);
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_state,&__pyx_n_s_max_time,&__pyx_n_s_max_iterations,&__pyx_n_s_heuristic,&__pyx_n_s_return_type,0};
-    PyObject* values[5] = {0,0,0,0,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_state,&__pyx_n_s_max_time,&__pyx_n_s_max_iterations,&__pyx_n_s_return_type,0};
+    PyObject* values[4] = {0,0,0,0};
     values[1] = ((PyObject *)Py_None);
     values[2] = ((PyObject *)Py_None);
-    values[3] = ((PyObject *)Py_None);
-    values[4] = ((PyObject*)__pyx_n_u_state);
+    values[3] = ((PyObject*)__pyx_n_u_state);
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
       const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
       switch (pos_args) {
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
@@ -4019,1710 +6387,549 @@
       }
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_state)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
-      if (kw_args > 0 && likely(kw_args <= 4)) {
+      if (kw_args > 0 && likely(kw_args <= 3)) {
         Py_ssize_t index;
-        for (index = 1; index < 5 && kw_args > 0; index++) {
+        for (index = 1; index < 4 && kw_args > 0; index++) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
           if (value) { values[index] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "search") < 0)) __PYX_ERR(0, 148, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "search") < 0)) __PYX_ERR(0, 281, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_state = values[0];
     __pyx_v_max_time = values[1];
     __pyx_v_max_iterations = values[2];
-    __pyx_v_heuristic = values[3];
-    __pyx_v_return_type = ((PyObject*)values[4]);
+    __pyx_v_return_type = ((PyObject*)values[3]);
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("search", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 148, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("search", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 281, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("multimcts.mcts.MCTS.search", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_return_type), (&PyUnicode_Type), 1, "return_type", 1))) __PYX_ERR(0, 148, __pyx_L1_error)
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4MCTS_2search(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v_self), __pyx_v_state, __pyx_v_max_time, __pyx_v_max_iterations, __pyx_v_heuristic, __pyx_v_return_type);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_return_type), (&PyUnicode_Type), 1, "return_type", 1))) __PYX_ERR(0, 281, __pyx_L1_error)
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4MCTS_2search(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v_self), __pyx_v_state, __pyx_v_max_time, __pyx_v_max_iterations, __pyx_v_return_type);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_2search(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v_state, PyObject *__pyx_v_max_time, PyObject *__pyx_v_max_iterations, PyObject *__pyx_v_heuristic, PyObject *__pyx_v_return_type) {
-  PyObject *__pyx_v_VALID_RETURN_TYPES = NULL;
+static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_2search(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v_state, PyObject *__pyx_v_max_time, PyObject *__pyx_v_max_iterations, PyObject *__pyx_v_return_type) {
   struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node = NULL;
   double __pyx_v_end_time;
   int __pyx_v_i;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_child = NULL;
-  std::map<std::string,double>  __pyx_v_rewards;
   struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_best = 0;
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  int __pyx_t_4;
-  int __pyx_t_5;
+  int __pyx_t_1;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
   Py_ssize_t __pyx_t_6;
   Py_UCS4 __pyx_t_7;
-  int __pyx_t_8;
-  double __pyx_t_9;
-  std::map<std::string,double>  __pyx_t_10;
-  struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate __pyx_t_11;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_9 = NULL;
+  double __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("search", 0);
-  __Pyx_TraceCall("search", __pyx_f[0], 148, 0, __PYX_ERR(0, 148, __pyx_L1_error));
-  __Pyx_INCREF(__pyx_v_return_type);
 
-  /* "multimcts/mcts.pyx":159
+  /* "multimcts/mcts.pyx":291
  *             GameState: A new game state which is the result of applying the best move to the given state.
  *         """
- *         return_type = return_type.lower()             # <<<<<<<<<<<<<<
- *         VALID_RETURN_TYPES = {"state","move","node"}
- *         if return_type not in VALID_RETURN_TYPES:
+ *         if max_time is None and max_iterations is None:             # <<<<<<<<<<<<<<
+ *             raise ValueError('One or more of max_time/max_iterations is required.')
+ * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_return_type, __pyx_n_s_lower); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 159, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_3)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_3);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-    }
+  __pyx_t_2 = (__pyx_v_max_time == Py_None);
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
+  } else {
+    __pyx_t_1 = __pyx_t_3;
+    goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 159, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (!(likely(PyUnicode_CheckExact(__pyx_t_1))||((__pyx_t_1) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "unicode", Py_TYPE(__pyx_t_1)->tp_name), 0))) __PYX_ERR(0, 159, __pyx_L1_error)
-  __Pyx_DECREF_SET(__pyx_v_return_type, ((PyObject*)__pyx_t_1));
-  __pyx_t_1 = 0;
+  __pyx_t_3 = (__pyx_v_max_iterations == Py_None);
+  __pyx_t_2 = (__pyx_t_3 != 0);
+  __pyx_t_1 = __pyx_t_2;
+  __pyx_L4_bool_binop_done:;
+  if (unlikely(__pyx_t_1)) {
 
-  /* "multimcts/mcts.pyx":160
+    /* "multimcts/mcts.pyx":292
  *         """
- *         return_type = return_type.lower()
- *         VALID_RETURN_TYPES = {"state","move","node"}             # <<<<<<<<<<<<<<
- *         if return_type not in VALID_RETURN_TYPES:
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')
- */
-  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 160, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PySet_Add(__pyx_t_1, __pyx_n_u_state) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_1, __pyx_n_u_move) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_1, __pyx_n_u_node) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
-  __pyx_v_VALID_RETURN_TYPES = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":161
- *         return_type = return_type.lower()
- *         VALID_RETURN_TYPES = {"state","move","node"}
- *         if return_type not in VALID_RETURN_TYPES:             # <<<<<<<<<<<<<<
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')
- * 
- */
-  __pyx_t_4 = (__Pyx_PySet_ContainsTF(__pyx_v_return_type, __pyx_v_VALID_RETURN_TYPES, Py_NE)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 161, __pyx_L1_error)
-  __pyx_t_5 = (__pyx_t_4 != 0);
-  if (unlikely(__pyx_t_5)) {
-
-    /* "multimcts/mcts.pyx":162
- *         VALID_RETURN_TYPES = {"state","move","node"}
- *         if return_type not in VALID_RETURN_TYPES:
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')             # <<<<<<<<<<<<<<
- * 
  *         if max_time is None and max_iterations is None:
+ *             raise ValueError('One or more of max_time/max_iterations is required.')             # <<<<<<<<<<<<<<
+ * 
+ *         if return_type not in {'state','move','node'}:
  */
-    __pyx_t_1 = PyTuple_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_6 = 0;
-    __pyx_t_7 = 127;
-    __Pyx_INCREF(__pyx_kp_u_Invalid_return_type);
-    __pyx_t_6 += 21;
-    __Pyx_GIVEREF(__pyx_kp_u_Invalid_return_type);
-    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Invalid_return_type);
-    __pyx_t_2 = __Pyx_PyUnicode_Unicode(__pyx_v_return_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_7;
-    __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
-    __pyx_t_2 = 0;
-    __Pyx_INCREF(__pyx_kp_u_must_be_one_of);
-    __pyx_t_6 += 17;
-    __Pyx_GIVEREF(__pyx_kp_u_must_be_one_of);
-    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_must_be_one_of);
-    __pyx_t_2 = __Pyx_PyObject_FormatSimple(__pyx_v_VALID_RETURN_TYPES, __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_7;
-    __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_2);
-    __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_PyUnicode_Join(__pyx_t_1, 4, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 162, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 292, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __PYX_ERR(0, 292, __pyx_L1_error)
 
-    /* "multimcts/mcts.pyx":161
- *         return_type = return_type.lower()
- *         VALID_RETURN_TYPES = {"state","move","node"}
- *         if return_type not in VALID_RETURN_TYPES:             # <<<<<<<<<<<<<<
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')
+    /* "multimcts/mcts.pyx":291
+ *             GameState: A new game state which is the result of applying the best move to the given state.
+ *         """
+ *         if max_time is None and max_iterations is None:             # <<<<<<<<<<<<<<
+ *             raise ValueError('One or more of max_time/max_iterations is required.')
  * 
  */
   }
 
-  /* "multimcts/mcts.pyx":164
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')
+  /* "multimcts/mcts.pyx":294
+ *             raise ValueError('One or more of max_time/max_iterations is required.')
  * 
- *         if max_time is None and max_iterations is None:             # <<<<<<<<<<<<<<
- *             raise ValueError("One or more of max_time/max_iterations is required.")
+ *         if return_type not in {'state','move','node'}:             # <<<<<<<<<<<<<<
+ *             raise ValueError(f'Invalid return_type "{return_type}" must be one of {{"state","move","node"}}')
  * 
  */
-  __pyx_t_4 = (__pyx_v_max_time == Py_None);
-  __pyx_t_8 = (__pyx_t_4 != 0);
-  if (__pyx_t_8) {
+  __Pyx_INCREF(__pyx_v_return_type);
+  __pyx_t_5 = __pyx_v_return_type;
+  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_n_u_state, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 294, __pyx_L1_error)
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
   } else {
-    __pyx_t_5 = __pyx_t_8;
-    goto __pyx_L5_bool_binop_done;
+    __pyx_t_1 = __pyx_t_3;
+    goto __pyx_L7_bool_binop_done;
   }
-  __pyx_t_8 = (__pyx_v_max_iterations == Py_None);
-  __pyx_t_4 = (__pyx_t_8 != 0);
-  __pyx_t_5 = __pyx_t_4;
-  __pyx_L5_bool_binop_done:;
-  if (unlikely(__pyx_t_5)) {
+  __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_n_u_move, Py_NE)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 294, __pyx_L1_error)
+  __pyx_t_2 = (__pyx_t_3 != 0);
+  if (__pyx_t_2) {
+  } else {
+    __pyx_t_1 = __pyx_t_2;
+    goto __pyx_L7_bool_binop_done;
+  }
+  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_n_u_node, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 294, __pyx_L1_error)
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  __pyx_t_1 = __pyx_t_3;
+  __pyx_L7_bool_binop_done:;
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_t_3 = (__pyx_t_1 != 0);
+  if (unlikely(__pyx_t_3)) {
 
-    /* "multimcts/mcts.pyx":165
+    /* "multimcts/mcts.pyx":295
  * 
- *         if max_time is None and max_iterations is None:
- *             raise ValueError("One or more of max_time/max_iterations is required.")             # <<<<<<<<<<<<<<
+ *         if return_type not in {'state','move','node'}:
+ *             raise ValueError(f'Invalid return_type "{return_type}" must be one of {{"state","move","node"}}')             # <<<<<<<<<<<<<<
  * 
  *         node = Node(state)
  */
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 165, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 165, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 295, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_6 = 0;
+    __pyx_t_7 = 127;
+    __Pyx_INCREF(__pyx_kp_u_Invalid_return_type);
+    __pyx_t_6 += 21;
+    __Pyx_GIVEREF(__pyx_kp_u_Invalid_return_type);
+    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_u_Invalid_return_type);
+    __pyx_t_8 = __Pyx_PyUnicode_Unicode(__pyx_v_return_type); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 295, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) : __pyx_t_7;
+    __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_8);
+    __Pyx_GIVEREF(__pyx_t_8);
+    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_8);
+    __pyx_t_8 = 0;
+    __Pyx_INCREF(__pyx_kp_u_must_be_one_of_state_move_node);
+    __pyx_t_6 += 40;
+    __Pyx_GIVEREF(__pyx_kp_u_must_be_one_of_state_move_node);
+    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_kp_u_must_be_one_of_state_move_node);
+    __pyx_t_8 = __Pyx_PyUnicode_Join(__pyx_t_4, 3, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 295, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 295, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __PYX_ERR(0, 295, __pyx_L1_error)
 
-    /* "multimcts/mcts.pyx":164
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')
+    /* "multimcts/mcts.pyx":294
+ *             raise ValueError('One or more of max_time/max_iterations is required.')
  * 
- *         if max_time is None and max_iterations is None:             # <<<<<<<<<<<<<<
- *             raise ValueError("One or more of max_time/max_iterations is required.")
+ *         if return_type not in {'state','move','node'}:             # <<<<<<<<<<<<<<
+ *             raise ValueError(f'Invalid return_type "{return_type}" must be one of {{"state","move","node"}}')
  * 
  */
   }
 
-  /* "multimcts/mcts.pyx":167
- *             raise ValueError("One or more of max_time/max_iterations is required.")
+  /* "multimcts/mcts.pyx":297
+ *             raise ValueError(f'Invalid return_type "{return_type}" must be one of {{"state","move","node"}}')
  * 
  *         node = Node(state)             # <<<<<<<<<<<<<<
  * 
  *         cdef double end_time
  */
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_9multimcts_4mcts_Node), __pyx_v_state); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 167, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_node = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_1);
-  __pyx_t_1 = 0;
+  __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_9multimcts_4mcts_Node), __pyx_v_state); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 297, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_v_node = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_4);
+  __pyx_t_4 = 0;
 
-  /* "multimcts/mcts.pyx":170
+  /* "multimcts/mcts.pyx":300
  * 
  *         cdef double end_time
  *         cdef int i = 0             # <<<<<<<<<<<<<<
  *         if max_time is not None:
  *             end_time = time() + max_time
  */
   __pyx_v_i = 0;
 
-  /* "multimcts/mcts.pyx":171
+  /* "multimcts/mcts.pyx":301
  *         cdef double end_time
  *         cdef int i = 0
  *         if max_time is not None:             # <<<<<<<<<<<<<<
  *             end_time = time() + max_time
  * 
  */
-  __pyx_t_5 = (__pyx_v_max_time != Py_None);
-  __pyx_t_4 = (__pyx_t_5 != 0);
-  if (__pyx_t_4) {
+  __pyx_t_3 = (__pyx_v_max_time != Py_None);
+  __pyx_t_1 = (__pyx_t_3 != 0);
+  if (__pyx_t_1) {
 
-    /* "multimcts/mcts.pyx":172
+    /* "multimcts/mcts.pyx":302
  *         cdef int i = 0
  *         if max_time is not None:
  *             end_time = time() + max_time             # <<<<<<<<<<<<<<
  * 
  *         while True:
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_time); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 172, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = NULL;
-    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_3)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_3);
+    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_time); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 302, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_t_9 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
+      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);
+      if (likely(__pyx_t_9)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
+        __Pyx_INCREF(__pyx_t_9);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __Pyx_DECREF_SET(__pyx_t_8, function);
       }
     }
-    __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 172, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = PyNumber_Add(__pyx_t_1, __pyx_v_max_time); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 172, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_9 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_9 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 172, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_v_end_time = __pyx_t_9;
+    __pyx_t_4 = (__pyx_t_9) ? __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_9) : __Pyx_PyObject_CallNoArg(__pyx_t_8);
+    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
+    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 302, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __pyx_t_8 = PyNumber_Add(__pyx_t_4, __pyx_v_max_time); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 302, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_10 = __pyx_PyFloat_AsDouble(__pyx_t_8); if (unlikely((__pyx_t_10 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 302, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __pyx_v_end_time = __pyx_t_10;
 
-    /* "multimcts/mcts.pyx":171
+    /* "multimcts/mcts.pyx":301
  *         cdef double end_time
  *         cdef int i = 0
  *         if max_time is not None:             # <<<<<<<<<<<<<<
  *             end_time = time() + max_time
  * 
  */
   }
 
-  /* "multimcts/mcts.pyx":174
+  /* "multimcts/mcts.pyx":304
  *             end_time = time() + max_time
  * 
  *         while True:             # <<<<<<<<<<<<<<
- *             child = self.select(node)
- *             rewards = self.simulate(child, heuristic=heuristic)
+ *             node.execute_round(self.exploration_bias, self.rave_bias)
+ * 
  */
   while (1) {
 
-    /* "multimcts/mcts.pyx":175
+    /* "multimcts/mcts.pyx":305
  * 
  *         while True:
- *             child = self.select(node)             # <<<<<<<<<<<<<<
- *             rewards = self.simulate(child, heuristic=heuristic)
- *             self.backpropagate(child, rewards)
- */
-    __pyx_t_2 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->select(__pyx_v_self, __pyx_v_node)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 175, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_XDECREF_SET(__pyx_v_child, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2));
-    __pyx_t_2 = 0;
-
-    /* "multimcts/mcts.pyx":176
- *         while True:
- *             child = self.select(node)
- *             rewards = self.simulate(child, heuristic=heuristic)             # <<<<<<<<<<<<<<
- *             self.backpropagate(child, rewards)
- * 
- */
-    __pyx_t_11.__pyx_n = 1;
-    __pyx_t_11.heuristic = __pyx_v_heuristic;
-    __pyx_t_10 = ((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->simulate(__pyx_v_self, __pyx_v_child, &__pyx_t_11); 
-    __pyx_v_rewards = __pyx_t_10;
-
-    /* "multimcts/mcts.pyx":177
- *             child = self.select(node)
- *             rewards = self.simulate(child, heuristic=heuristic)
- *             self.backpropagate(child, rewards)             # <<<<<<<<<<<<<<
- * 
- *             # If there is only one legal move, we don't need to search.
- */
-    __pyx_t_2 = ((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->backpropagate(__pyx_v_self, __pyx_v_child, __pyx_v_rewards); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 177, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-    /* "multimcts/mcts.pyx":180
- * 
- *             # If there is only one legal move, we don't need to search.
- *             if node.is_fully_expanded and len(node.children) == 1:             # <<<<<<<<<<<<<<
- *                 break
- * 
- */
-    __pyx_t_5 = (__pyx_v_node->is_fully_expanded != 0);
-    if (__pyx_t_5) {
-    } else {
-      __pyx_t_4 = __pyx_t_5;
-      goto __pyx_L11_bool_binop_done;
-    }
-    __pyx_t_2 = __pyx_v_node->children;
-    __Pyx_INCREF(__pyx_t_2);
-    __pyx_t_6 = PyObject_Length(__pyx_t_2); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 180, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_5 = ((__pyx_t_6 == 1) != 0);
-    __pyx_t_4 = __pyx_t_5;
-    __pyx_L11_bool_binop_done:;
-    if (__pyx_t_4) {
-
-      /* "multimcts/mcts.pyx":181
- *             # If there is only one legal move, we don't need to search.
- *             if node.is_fully_expanded and len(node.children) == 1:
- *                 break             # <<<<<<<<<<<<<<
+ *             node.execute_round(self.exploration_bias, self.rave_bias)             # <<<<<<<<<<<<<<
  * 
  *             if max_time is not None:
  */
-      goto __pyx_L9_break;
-
-      /* "multimcts/mcts.pyx":180
- * 
- *             # If there is only one legal move, we don't need to search.
- *             if node.is_fully_expanded and len(node.children) == 1:             # <<<<<<<<<<<<<<
- *                 break
- * 
- */
-    }
+    ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->execute_round(__pyx_v_node, __pyx_v_self->exploration_bias, __pyx_v_self->rave_bias);
 
-    /* "multimcts/mcts.pyx":183
- *                 break
+    /* "multimcts/mcts.pyx":307
+ *             node.execute_round(self.exploration_bias, self.rave_bias)
  * 
  *             if max_time is not None:             # <<<<<<<<<<<<<<
  *                 if time() >= end_time:
  *                     break
  */
-    __pyx_t_4 = (__pyx_v_max_time != Py_None);
-    __pyx_t_5 = (__pyx_t_4 != 0);
-    if (__pyx_t_5) {
+    __pyx_t_1 = (__pyx_v_max_time != Py_None);
+    __pyx_t_3 = (__pyx_t_1 != 0);
+    if (__pyx_t_3) {
 
-      /* "multimcts/mcts.pyx":184
+      /* "multimcts/mcts.pyx":308
  * 
  *             if max_time is not None:
  *                 if time() >= end_time:             # <<<<<<<<<<<<<<
  *                     break
  *             if max_iterations is not None:
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_time); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 184, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = NULL;
-      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
-        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
-        if (likely(__pyx_t_3)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-          __Pyx_INCREF(__pyx_t_3);
+      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_time); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 308, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_9 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
+        __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_4);
+        if (likely(__pyx_t_9)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+          __Pyx_INCREF(__pyx_t_9);
           __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_1, function);
+          __Pyx_DECREF_SET(__pyx_t_4, function);
         }
       }
-      __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_1);
-      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 184, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_1 = PyFloat_FromDouble(__pyx_v_end_time); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 184, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, __pyx_t_1, Py_GE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 184, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 184, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (__pyx_t_5) {
+      __pyx_t_8 = (__pyx_t_9) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_9) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
+      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
+      if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 308, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_4 = PyFloat_FromDouble(__pyx_v_end_time); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 308, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_9 = PyObject_RichCompare(__pyx_t_8, __pyx_t_4, Py_GE); __Pyx_XGOTREF(__pyx_t_9); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 308, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 308, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+      if (__pyx_t_3) {
 
-        /* "multimcts/mcts.pyx":185
+        /* "multimcts/mcts.pyx":309
  *             if max_time is not None:
  *                 if time() >= end_time:
  *                     break             # <<<<<<<<<<<<<<
  *             if max_iterations is not None:
  *                 i += 1
  */
-        goto __pyx_L9_break;
+        goto __pyx_L12_break;
 
-        /* "multimcts/mcts.pyx":184
+        /* "multimcts/mcts.pyx":308
  * 
  *             if max_time is not None:
  *                 if time() >= end_time:             # <<<<<<<<<<<<<<
  *                     break
  *             if max_iterations is not None:
  */
       }
 
-      /* "multimcts/mcts.pyx":183
- *                 break
+      /* "multimcts/mcts.pyx":307
+ *             node.execute_round(self.exploration_bias, self.rave_bias)
  * 
  *             if max_time is not None:             # <<<<<<<<<<<<<<
  *                 if time() >= end_time:
  *                     break
  */
     }
 
-    /* "multimcts/mcts.pyx":186
+    /* "multimcts/mcts.pyx":310
  *                 if time() >= end_time:
  *                     break
  *             if max_iterations is not None:             # <<<<<<<<<<<<<<
  *                 i += 1
  *                 if i >= max_iterations:
  */
-    __pyx_t_5 = (__pyx_v_max_iterations != Py_None);
-    __pyx_t_4 = (__pyx_t_5 != 0);
-    if (__pyx_t_4) {
+    __pyx_t_3 = (__pyx_v_max_iterations != Py_None);
+    __pyx_t_1 = (__pyx_t_3 != 0);
+    if (__pyx_t_1) {
 
-      /* "multimcts/mcts.pyx":187
+      /* "multimcts/mcts.pyx":311
  *                     break
  *             if max_iterations is not None:
  *                 i += 1             # <<<<<<<<<<<<<<
  *                 if i >= max_iterations:
  *                     break
  */
       __pyx_v_i = (__pyx_v_i + 1);
 
-      /* "multimcts/mcts.pyx":188
+      /* "multimcts/mcts.pyx":312
  *             if max_iterations is not None:
  *                 i += 1
  *                 if i >= max_iterations:             # <<<<<<<<<<<<<<
  *                     break
  * 
  */
-      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 188, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_1 = PyObject_RichCompare(__pyx_t_3, __pyx_v_max_iterations, Py_GE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 188, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 188, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      if (__pyx_t_4) {
+      __pyx_t_9 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 312, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_t_9, __pyx_v_max_iterations, Py_GE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 312, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 312, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_1) {
 
-        /* "multimcts/mcts.pyx":189
+        /* "multimcts/mcts.pyx":313
  *                 i += 1
  *                 if i >= max_iterations:
  *                     break             # <<<<<<<<<<<<<<
  * 
- *         cdef Node best = self.get_best_child(node)
+ *         # We've performed the full search above using the desired biases.
  */
-        goto __pyx_L9_break;
+        goto __pyx_L12_break;
 
-        /* "multimcts/mcts.pyx":188
+        /* "multimcts/mcts.pyx":312
  *             if max_iterations is not None:
  *                 i += 1
  *                 if i >= max_iterations:             # <<<<<<<<<<<<<<
  *                     break
  * 
  */
       }
 
-      /* "multimcts/mcts.pyx":186
+      /* "multimcts/mcts.pyx":310
  *                 if time() >= end_time:
  *                     break
  *             if max_iterations is not None:             # <<<<<<<<<<<<<<
  *                 i += 1
  *                 if i >= max_iterations:
  */
     }
   }
-  __pyx_L9_break:;
+  __pyx_L12_break:;
 
-  /* "multimcts/mcts.pyx":191
- *                     break
- * 
- *         cdef Node best = self.get_best_child(node)             # <<<<<<<<<<<<<<
+  /* "multimcts/mcts.pyx":317
+ *         # We've performed the full search above using the desired biases.
+ *         # For the final pick we will be a bit more exploitative and a bit less RAVEy.
+ *         cdef Node best = node.best_child(self.exploration_bias*0.9, self.rave_bias*0.9)             # <<<<<<<<<<<<<<
  * 
  *         if return_type == "state":
  */
-  __pyx_t_1 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->get_best_child(__pyx_v_self, __pyx_v_node)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_best = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_1);
-  __pyx_t_1 = 0;
+  __pyx_t_4 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->best_child(__pyx_v_node, (__pyx_v_self->exploration_bias * 0.9), (__pyx_v_self->rave_bias * 0.9))); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 317, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_v_best = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_4);
+  __pyx_t_4 = 0;
 
-  /* "multimcts/mcts.pyx":193
- *         cdef Node best = self.get_best_child(node)
+  /* "multimcts/mcts.pyx":319
+ *         cdef Node best = node.best_child(self.exploration_bias*0.9, self.rave_bias*0.9)
  * 
  *         if return_type == "state":             # <<<<<<<<<<<<<<
  *             return best.state
  *         elif return_type == "move":
  */
-  __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_state, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 193, __pyx_L1_error)
-  __pyx_t_5 = (__pyx_t_4 != 0);
-  if (__pyx_t_5) {
+  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_state, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 319, __pyx_L1_error)
+  __pyx_t_3 = (__pyx_t_1 != 0);
+  if (__pyx_t_3) {
 
-    /* "multimcts/mcts.pyx":194
+    /* "multimcts/mcts.pyx":320
  * 
  *         if return_type == "state":
  *             return best.state             # <<<<<<<<<<<<<<
  *         elif return_type == "move":
  *             return best.move
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_v_best->state);
     __pyx_r = __pyx_v_best->state;
     goto __pyx_L0;
 
-    /* "multimcts/mcts.pyx":193
- *         cdef Node best = self.get_best_child(node)
+    /* "multimcts/mcts.pyx":319
+ *         cdef Node best = node.best_child(self.exploration_bias*0.9, self.rave_bias*0.9)
  * 
  *         if return_type == "state":             # <<<<<<<<<<<<<<
  *             return best.state
  *         elif return_type == "move":
  */
   }
 
-  /* "multimcts/mcts.pyx":195
+  /* "multimcts/mcts.pyx":321
  *         if return_type == "state":
  *             return best.state
  *         elif return_type == "move":             # <<<<<<<<<<<<<<
  *             return best.move
  *         elif return_type == "node":
  */
-  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_move, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 195, __pyx_L1_error)
-  __pyx_t_4 = (__pyx_t_5 != 0);
-  if (__pyx_t_4) {
+  __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_move, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 321, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_3 != 0);
+  if (__pyx_t_1) {
 
-    /* "multimcts/mcts.pyx":196
+    /* "multimcts/mcts.pyx":322
  *             return best.state
  *         elif return_type == "move":
  *             return best.move             # <<<<<<<<<<<<<<
  *         elif return_type == "node":
  *             return best
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_v_best->move);
     __pyx_r = __pyx_v_best->move;
     goto __pyx_L0;
 
-    /* "multimcts/mcts.pyx":195
+    /* "multimcts/mcts.pyx":321
  *         if return_type == "state":
  *             return best.state
  *         elif return_type == "move":             # <<<<<<<<<<<<<<
  *             return best.move
  *         elif return_type == "node":
  */
   }
 
-  /* "multimcts/mcts.pyx":197
+  /* "multimcts/mcts.pyx":323
  *         elif return_type == "move":
  *             return best.move
  *         elif return_type == "node":             # <<<<<<<<<<<<<<
  *             return best
  * 
  */
-  __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_node, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 197, __pyx_L1_error)
-  __pyx_t_5 = (__pyx_t_4 != 0);
-  if (__pyx_t_5) {
+  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_node, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 323, __pyx_L1_error)
+  __pyx_t_3 = (__pyx_t_1 != 0);
+  if (__pyx_t_3) {
 
-    /* "multimcts/mcts.pyx":198
+    /* "multimcts/mcts.pyx":324
  *             return best.move
  *         elif return_type == "node":
  *             return best             # <<<<<<<<<<<<<<
  * 
- *     cdef Node select(self, Node node):
+ * 
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject *)__pyx_v_best));
     __pyx_r = ((PyObject *)__pyx_v_best);
     goto __pyx_L0;
 
-    /* "multimcts/mcts.pyx":197
+    /* "multimcts/mcts.pyx":323
  *         elif return_type == "move":
  *             return best.move
  *         elif return_type == "node":             # <<<<<<<<<<<<<<
  *             return best
  * 
  */
   }
 
-  /* "multimcts/mcts.pyx":148
- *     def exploration_bias(self) -> float: return self.exploration_bias
+  /* "multimcts/mcts.pyx":281
+ *     def rave_bias(self) -> float: return self.rave_bias
  * 
- *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, heuristic=None, return_type:str="state") -> Union[GameState,Move,Node]:             # <<<<<<<<<<<<<<
+ *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, return_type:str="state") -> Union[GameState,Move,Node]:             # <<<<<<<<<<<<<<
  *         """Searches for this state's best move until some limit has been reached.
  *         Args:
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_XDECREF(__pyx_t_9);
   __Pyx_AddTraceback("multimcts.mcts.MCTS.search", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_VALID_RETURN_TYPES);
   __Pyx_XDECREF((PyObject *)__pyx_v_node);
-  __Pyx_XDECREF((PyObject *)__pyx_v_child);
   __Pyx_XDECREF((PyObject *)__pyx_v_best);
-  __Pyx_XDECREF(__pyx_v_return_type);
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "multimcts/mcts.pyx":200
- *             return best
- * 
- *     cdef Node select(self, Node node):             # <<<<<<<<<<<<<<
- *         """Step 1: Selection
- *         Traverse the tree for the node we most want to simulate.
- */
-
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_select(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node) {
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("select", 0);
-  __Pyx_TraceCall("select", __pyx_f[0], 200, 0, __PYX_ERR(0, 200, __pyx_L1_error));
-  __Pyx_INCREF((PyObject *)__pyx_v_node);
-
-  /* "multimcts/mcts.pyx":205
- *         Looks for an unexplored child of this node's best child's best child's...best child.
- *         """
- *         while not node.is_terminal:             # <<<<<<<<<<<<<<
- *             if not node.is_fully_expanded:
- *                 return self.expand(node)
- */
-  while (1) {
-    __pyx_t_1 = ((!(__pyx_v_node->is_terminal != 0)) != 0);
-    if (!__pyx_t_1) break;
-
-    /* "multimcts/mcts.pyx":206
- *         """
- *         while not node.is_terminal:
- *             if not node.is_fully_expanded:             # <<<<<<<<<<<<<<
- *                 return self.expand(node)
- *             else:
- */
-    __pyx_t_1 = ((!(__pyx_v_node->is_fully_expanded != 0)) != 0);
-    if (__pyx_t_1) {
-
-      /* "multimcts/mcts.pyx":207
- *         while not node.is_terminal:
- *             if not node.is_fully_expanded:
- *                 return self.expand(node)             # <<<<<<<<<<<<<<
- *             else:
- *                 node = self.get_best_child(node)
- */
-      __Pyx_XDECREF(((PyObject *)__pyx_r));
-      __pyx_t_2 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->expand(__pyx_v_self, __pyx_v_node)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 207, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __pyx_r = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2);
-      __pyx_t_2 = 0;
-      goto __pyx_L0;
-
-      /* "multimcts/mcts.pyx":206
- *         """
- *         while not node.is_terminal:
- *             if not node.is_fully_expanded:             # <<<<<<<<<<<<<<
- *                 return self.expand(node)
- *             else:
- */
-    }
-
-    /* "multimcts/mcts.pyx":209
- *                 return self.expand(node)
- *             else:
- *                 node = self.get_best_child(node)             # <<<<<<<<<<<<<<
- *         return node
- * 
- */
-    /*else*/ {
-      __pyx_t_2 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->get_best_child(__pyx_v_self, __pyx_v_node)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 209, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF_SET(__pyx_v_node, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2));
-      __pyx_t_2 = 0;
-    }
-  }
-
-  /* "multimcts/mcts.pyx":210
- *             else:
- *                 node = self.get_best_child(node)
- *         return node             # <<<<<<<<<<<<<<
- * 
- *     cdef Node expand(self, Node node):
- */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_INCREF(((PyObject *)__pyx_v_node));
-  __pyx_r = __pyx_v_node;
-  goto __pyx_L0;
-
-  /* "multimcts/mcts.pyx":200
- *             return best
- * 
- *     cdef Node select(self, Node node):             # <<<<<<<<<<<<<<
- *         """Step 1: Selection
- *         Traverse the tree for the node we most want to simulate.
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_AddTraceback("multimcts.mcts.MCTS.select", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_node);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "multimcts/mcts.pyx":212
- *         return node
- * 
- *     cdef Node expand(self, Node node):             # <<<<<<<<<<<<<<
- *         """Step 2: Expansion
- *         Add a new child to this node.
- */
-
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_expand(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node) {
-  PyObject *__pyx_v_move = NULL;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_child = 0;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  Py_ssize_t __pyx_t_2;
-  int __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  int __pyx_t_7;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("expand", 0);
-  __Pyx_TraceCall("expand", __pyx_f[0], 212, 0, __PYX_ERR(0, 212, __pyx_L1_error));
-
-  /* "multimcts/mcts.pyx":216
- *         Add a new child to this node.
- *         """
- *         move = node.remaining_moves.pop()             # <<<<<<<<<<<<<<
- *         if len(node.remaining_moves) == 0:
- *             node.is_fully_expanded = True
- */
-  __pyx_t_1 = __Pyx_PyObject_Pop(__pyx_v_node->remaining_moves); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 216, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_move = __pyx_t_1;
-  __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":217
- *         """
- *         move = node.remaining_moves.pop()
- *         if len(node.remaining_moves) == 0:             # <<<<<<<<<<<<<<
- *             node.is_fully_expanded = True
- * 
- */
-  __pyx_t_1 = __pyx_v_node->remaining_moves;
-  __Pyx_INCREF(__pyx_t_1);
-  __pyx_t_2 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 217, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = ((__pyx_t_2 == 0) != 0);
-  if (__pyx_t_3) {
-
-    /* "multimcts/mcts.pyx":218
- *         move = node.remaining_moves.pop()
- *         if len(node.remaining_moves) == 0:
- *             node.is_fully_expanded = True             # <<<<<<<<<<<<<<
- * 
- *         cdef Node child = Node(state=node.state.make_move(move), parent=node, move=move)
- */
-    __pyx_v_node->is_fully_expanded = 1;
-
-    /* "multimcts/mcts.pyx":217
- *         """
- *         move = node.remaining_moves.pop()
- *         if len(node.remaining_moves) == 0:             # <<<<<<<<<<<<<<
- *             node.is_fully_expanded = True
- * 
- */
-  }
-
-  /* "multimcts/mcts.pyx":220
- *             node.is_fully_expanded = True
- * 
- *         cdef Node child = Node(state=node.state.make_move(move), parent=node, move=move)             # <<<<<<<<<<<<<<
- *         node.children.append(child)
- * 
- */
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 220, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_node->state, __pyx_n_s_make_move); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 220, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_6 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
-    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
-    if (likely(__pyx_t_6)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-      __Pyx_INCREF(__pyx_t_6);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_5, function);
-    }
-  }
-  __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_move) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_move);
-  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 220, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_state, __pyx_t_4) < 0) __PYX_ERR(0, 220, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_parent, ((PyObject *)__pyx_v_node)) < 0) __PYX_ERR(0, 220, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_move, __pyx_v_move) < 0) __PYX_ERR(0, 220, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_9multimcts_4mcts_Node), __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 220, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v_child = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_4);
-  __pyx_t_4 = 0;
-
-  /* "multimcts/mcts.pyx":221
- * 
- *         cdef Node child = Node(state=node.state.make_move(move), parent=node, move=move)
- *         node.children.append(child)             # <<<<<<<<<<<<<<
- * 
- *         return child
- */
-  __pyx_t_7 = __Pyx_PyObject_Append(__pyx_v_node->children, ((PyObject *)__pyx_v_child)); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 221, __pyx_L1_error)
-
-  /* "multimcts/mcts.pyx":223
- *         node.children.append(child)
- * 
- *         return child             # <<<<<<<<<<<<<<
- * 
- *     cdef map[string,double] simulate(self, Node node, heuristic=None):
- */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_INCREF(((PyObject *)__pyx_v_child));
-  __pyx_r = __pyx_v_child;
-  goto __pyx_L0;
-
-  /* "multimcts/mcts.pyx":212
- *         return node
- * 
- *     cdef Node expand(self, Node node):             # <<<<<<<<<<<<<<
- *         """Step 2: Expansion
- *         Add a new child to this node.
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_AddTraceback("multimcts.mcts.MCTS.expand", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_move);
-  __Pyx_XDECREF((PyObject *)__pyx_v_child);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "multimcts/mcts.pyx":225
- *         return child
- * 
- *     cdef map[string,double] simulate(self, Node node, heuristic=None):             # <<<<<<<<<<<<<<
- *         """Step 3: Simulation (aka playout/rollout)
- *         Play out a game, from the given node to termination, and return the final reward.
- */
-
-static std::map<std::string,double>  __pyx_f_9multimcts_4mcts_4MCTS_simulate(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node, struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate *__pyx_optional_args) {
-  PyObject *__pyx_v_heuristic = ((PyObject *)Py_None);
-  PyObject *__pyx_v_state = NULL;
-  PyObject *__pyx_v_terminal_team = NULL;
-  PyObject *__pyx_v_move = NULL;
-  PyObject *__pyx_v_reward = NULL;
-  std::map<std::string,double>  __pyx_v_crewards;
-  PyObject *__pyx_v_team = NULL;
-  std::map<std::string,double>  __pyx_r;
-  __Pyx_TraceDeclarations
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  int __pyx_t_5;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  std::map<std::string,double>  __pyx_t_8;
-  Py_ssize_t __pyx_t_9;
-  PyObject *(*__pyx_t_10)(PyObject *);
-  double __pyx_t_11;
-  std::string __pyx_t_12;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("simulate", 0);
-  __Pyx_TraceCall("simulate", __pyx_f[0], 225, 0, __PYX_ERR(0, 225, __pyx_L1_error));
-  if (__pyx_optional_args) {
-    if (__pyx_optional_args->__pyx_n > 0) {
-      __pyx_v_heuristic = __pyx_optional_args->heuristic;
-    }
-  }
-
-  /* "multimcts/mcts.pyx":233
- *             heuristic (callable): A function that takes a state and returns a move.
- *         """
- *         state = node.state             # <<<<<<<<<<<<<<
- * 
- *         terminal_team = None
- */
-  __pyx_t_1 = __pyx_v_node->state;
-  __Pyx_INCREF(__pyx_t_1);
-  __pyx_v_state = __pyx_t_1;
-  __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":235
- *         state = node.state
- * 
- *         terminal_team = None             # <<<<<<<<<<<<<<
- *         if node.is_terminal:
- *             terminal_team = node.parent.team
- */
-  __Pyx_INCREF(Py_None);
-  __pyx_v_terminal_team = Py_None;
-
-  /* "multimcts/mcts.pyx":236
- * 
- *         terminal_team = None
- *         if node.is_terminal:             # <<<<<<<<<<<<<<
- *             terminal_team = node.parent.team
- *         else:
- */
-  __pyx_t_2 = (__pyx_v_node->is_terminal != 0);
-  if (__pyx_t_2) {
-
-    /* "multimcts/mcts.pyx":237
- *         terminal_team = None
- *         if node.is_terminal:
- *             terminal_team = node.parent.team             # <<<<<<<<<<<<<<
- *         else:
- *             while not state.is_terminal():
- */
-    __pyx_t_1 = __pyx_v_node->parent->team;
-    __Pyx_INCREF(__pyx_t_1);
-    __Pyx_DECREF_SET(__pyx_v_terminal_team, __pyx_t_1);
-    __pyx_t_1 = 0;
-
-    /* "multimcts/mcts.pyx":236
- * 
- *         terminal_team = None
- *         if node.is_terminal:             # <<<<<<<<<<<<<<
- *             terminal_team = node.parent.team
- *         else:
- */
-    goto __pyx_L3;
-  }
-
-  /* "multimcts/mcts.pyx":239
- *             terminal_team = node.parent.team
- *         else:
- *             while not state.is_terminal():             # <<<<<<<<<<<<<<
- *                 terminal_team = state.get_current_team()
- *                 if heuristic is not None:
- */
-  /*else*/ {
-    while (1) {
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_is_terminal); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 239, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = NULL;
-      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-        if (likely(__pyx_t_4)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-          __Pyx_INCREF(__pyx_t_4);
-          __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_3, function);
-        }
-      }
-      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
-      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 239, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_5 = ((!__pyx_t_2) != 0);
-      if (!__pyx_t_5) break;
-
-      /* "multimcts/mcts.pyx":240
- *         else:
- *             while not state.is_terminal():
- *                 terminal_team = state.get_current_team()             # <<<<<<<<<<<<<<
- *                 if heuristic is not None:
- *                     move = heuristic(state)
- */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_get_current_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 240, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = NULL;
-      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-        if (likely(__pyx_t_4)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-          __Pyx_INCREF(__pyx_t_4);
-          __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_3, function);
-        }
-      }
-      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
-      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 240, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_DECREF_SET(__pyx_v_terminal_team, __pyx_t_1);
-      __pyx_t_1 = 0;
-
-      /* "multimcts/mcts.pyx":241
- *             while not state.is_terminal():
- *                 terminal_team = state.get_current_team()
- *                 if heuristic is not None:             # <<<<<<<<<<<<<<
- *                     move = heuristic(state)
- *                 else:
- */
-      __pyx_t_5 = (__pyx_v_heuristic != Py_None);
-      __pyx_t_2 = (__pyx_t_5 != 0);
-      if (__pyx_t_2) {
-
-        /* "multimcts/mcts.pyx":242
- *                 terminal_team = state.get_current_team()
- *                 if heuristic is not None:
- *                     move = heuristic(state)             # <<<<<<<<<<<<<<
- *                 else:
- *                     move = choice(state.get_legal_moves())
- */
-        __Pyx_INCREF(__pyx_v_heuristic);
-        __pyx_t_3 = __pyx_v_heuristic; __pyx_t_4 = NULL;
-        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-          if (likely(__pyx_t_4)) {
-            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-            __Pyx_INCREF(__pyx_t_4);
-            __Pyx_INCREF(function);
-            __Pyx_DECREF_SET(__pyx_t_3, function);
-          }
-        }
-        __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_state) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_state);
-        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 242, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __Pyx_XDECREF_SET(__pyx_v_move, __pyx_t_1);
-        __pyx_t_1 = 0;
-
-        /* "multimcts/mcts.pyx":241
- *             while not state.is_terminal():
- *                 terminal_team = state.get_current_team()
- *                 if heuristic is not None:             # <<<<<<<<<<<<<<
- *                     move = heuristic(state)
- *                 else:
- */
-        goto __pyx_L6;
-      }
-
-      /* "multimcts/mcts.pyx":244
- *                     move = heuristic(state)
- *                 else:
- *                     move = choice(state.get_legal_moves())             # <<<<<<<<<<<<<<
- *                 state = state.make_move(move)
- * 
- */
-      /*else*/ {
-        __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_choice); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 244, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_get_legal_moves); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 244, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_6);
-        __pyx_t_7 = NULL;
-        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
-          __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
-          if (likely(__pyx_t_7)) {
-            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
-            __Pyx_INCREF(__pyx_t_7);
-            __Pyx_INCREF(function);
-            __Pyx_DECREF_SET(__pyx_t_6, function);
-          }
-        }
-        __pyx_t_4 = (__pyx_t_7) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
-        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-        if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 244, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-        __pyx_t_6 = NULL;
-        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-          __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
-          if (likely(__pyx_t_6)) {
-            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-            __Pyx_INCREF(__pyx_t_6);
-            __Pyx_INCREF(function);
-            __Pyx_DECREF_SET(__pyx_t_3, function);
-          }
-        }
-        __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
-        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 244, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __Pyx_XDECREF_SET(__pyx_v_move, __pyx_t_1);
-        __pyx_t_1 = 0;
-      }
-      __pyx_L6:;
-
-      /* "multimcts/mcts.pyx":245
- *                 else:
- *                     move = choice(state.get_legal_moves())
- *                 state = state.make_move(move)             # <<<<<<<<<<<<<<
- * 
- *         reward = state.get_reward()
- */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_make_move); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 245, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = NULL;
-      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-        if (likely(__pyx_t_4)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-          __Pyx_INCREF(__pyx_t_4);
-          __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_3, function);
-        }
-      }
-      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_move) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_move);
-      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 245, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_DECREF_SET(__pyx_v_state, __pyx_t_1);
-      __pyx_t_1 = 0;
-    }
-  }
-  __pyx_L3:;
-
-  /* "multimcts/mcts.pyx":247
- *                 state = state.make_move(move)
- * 
- *         reward = state.get_reward()             # <<<<<<<<<<<<<<
- *         if not isinstance(reward, dict):
- *             reward = {terminal_team: reward}
- */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_get_reward); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 247, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_4);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-    }
-  }
-  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 247, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_reward = __pyx_t_1;
-  __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":248
- * 
- *         reward = state.get_reward()
- *         if not isinstance(reward, dict):             # <<<<<<<<<<<<<<
- *             reward = {terminal_team: reward}
- * 
- */
-  __pyx_t_2 = PyDict_Check(__pyx_v_reward); 
-  __pyx_t_5 = ((!(__pyx_t_2 != 0)) != 0);
-  if (__pyx_t_5) {
-
-    /* "multimcts/mcts.pyx":249
- *         reward = state.get_reward()
- *         if not isinstance(reward, dict):
- *             reward = {terminal_team: reward}             # <<<<<<<<<<<<<<
- * 
- *         cdef map[string,double] crewards = map[string,double]()
- */
-    __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 249, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    if (PyDict_SetItem(__pyx_t_1, __pyx_v_terminal_team, __pyx_v_reward) < 0) __PYX_ERR(0, 249, __pyx_L1_error)
-    __Pyx_DECREF_SET(__pyx_v_reward, __pyx_t_1);
-    __pyx_t_1 = 0;
-
-    /* "multimcts/mcts.pyx":248
- * 
- *         reward = state.get_reward()
- *         if not isinstance(reward, dict):             # <<<<<<<<<<<<<<
- *             reward = {terminal_team: reward}
- * 
- */
-  }
-
-  /* "multimcts/mcts.pyx":251
- *             reward = {terminal_team: reward}
- * 
- *         cdef map[string,double] crewards = map[string,double]()             # <<<<<<<<<<<<<<
- *         for team in reward:
- *             if reward[team] == 0:
- */
-  try {
-    __pyx_t_8 = std::map<std::string,double> ();
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 251, __pyx_L1_error)
-  }
-  __pyx_v_crewards = __pyx_t_8;
-
-  /* "multimcts/mcts.pyx":252
- * 
- *         cdef map[string,double] crewards = map[string,double]()
- *         for team in reward:             # <<<<<<<<<<<<<<
- *             if reward[team] == 0:
- *                 continue
- */
-  if (likely(PyList_CheckExact(__pyx_v_reward)) || PyTuple_CheckExact(__pyx_v_reward)) {
-    __pyx_t_1 = __pyx_v_reward; __Pyx_INCREF(__pyx_t_1); __pyx_t_9 = 0;
-    __pyx_t_10 = NULL;
-  } else {
-    __pyx_t_9 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 252, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_10 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 252, __pyx_L1_error)
-  }
-  for (;;) {
-    if (likely(!__pyx_t_10)) {
-      if (likely(PyList_CheckExact(__pyx_t_1))) {
-        if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_1)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_9); __Pyx_INCREF(__pyx_t_3); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 252, __pyx_L1_error)
-        #else
-        __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 252, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        #endif
-      } else {
-        if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_9); __Pyx_INCREF(__pyx_t_3); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 252, __pyx_L1_error)
-        #else
-        __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 252, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        #endif
-      }
-    } else {
-      __pyx_t_3 = __pyx_t_10(__pyx_t_1);
-      if (unlikely(!__pyx_t_3)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 252, __pyx_L1_error)
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_3);
-    }
-    __Pyx_XDECREF_SET(__pyx_v_team, __pyx_t_3);
-    __pyx_t_3 = 0;
-
-    /* "multimcts/mcts.pyx":253
- *         cdef map[string,double] crewards = map[string,double]()
- *         for team in reward:
- *             if reward[team] == 0:             # <<<<<<<<<<<<<<
- *                 continue
- *             crewards[str(team).encode()] = float(reward[team])
- */
-    __pyx_t_3 = __Pyx_PyObject_GetItem(__pyx_v_reward, __pyx_v_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 253, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyInt_EqObjC(__pyx_t_3, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 253, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 253, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (__pyx_t_5) {
-
-      /* "multimcts/mcts.pyx":254
- *         for team in reward:
- *             if reward[team] == 0:
- *                 continue             # <<<<<<<<<<<<<<
- *             crewards[str(team).encode()] = float(reward[team])
- * 
- */
-      goto __pyx_L8_continue;
-
-      /* "multimcts/mcts.pyx":253
- *         cdef map[string,double] crewards = map[string,double]()
- *         for team in reward:
- *             if reward[team] == 0:             # <<<<<<<<<<<<<<
- *                 continue
- *             crewards[str(team).encode()] = float(reward[team])
- */
-    }
-
-    /* "multimcts/mcts.pyx":255
- *             if reward[team] == 0:
- *                 continue
- *             crewards[str(team).encode()] = float(reward[team])             # <<<<<<<<<<<<<<
- * 
- *         return crewards
- */
-    __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_reward, __pyx_v_team); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 255, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_11 = __Pyx_PyObject_AsDouble(__pyx_t_4); if (unlikely(__pyx_t_11 == ((double)((double)-1)) && PyErr_Occurred())) __PYX_ERR(0, 255, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_team); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 255, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = PyUnicode_AsEncodedString(((PyObject*)__pyx_t_4), NULL, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 255, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_12 = __pyx_convert_string_from_py_std__in_string(__pyx_t_3); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 255, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    (__pyx_v_crewards[__pyx_t_12]) = __pyx_t_11;
-
-    /* "multimcts/mcts.pyx":252
- * 
- *         cdef map[string,double] crewards = map[string,double]()
- *         for team in reward:             # <<<<<<<<<<<<<<
- *             if reward[team] == 0:
- *                 continue
- */
-    __pyx_L8_continue:;
-  }
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":257
- *             crewards[str(team).encode()] = float(reward[team])
- * 
- *         return crewards             # <<<<<<<<<<<<<<
- * 
- *     cdef backpropagate(self, Node node, map[string,double] crewards):
- */
-  __pyx_r = __pyx_v_crewards;
-  goto __pyx_L0;
-
-  /* "multimcts/mcts.pyx":225
- *         return child
- * 
- *     cdef map[string,double] simulate(self, Node node, heuristic=None):             # <<<<<<<<<<<<<<
- *         """Step 3: Simulation (aka playout/rollout)
- *         Play out a game, from the given node to termination, and return the final reward.
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_WriteUnraisable("multimcts.mcts.MCTS.simulate", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
-  __Pyx_pretend_to_initialize(&__pyx_r);
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_state);
-  __Pyx_XDECREF(__pyx_v_terminal_team);
-  __Pyx_XDECREF(__pyx_v_move);
-  __Pyx_XDECREF(__pyx_v_reward);
-  __Pyx_XDECREF(__pyx_v_team);
-  __Pyx_TraceReturn(Py_None, 0);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "multimcts/mcts.pyx":259
- *         return crewards
- * 
- *     cdef backpropagate(self, Node node, map[string,double] crewards):             # <<<<<<<<<<<<<<
- *         """Step 4: Backpropagation
- *         Update all ancestors with the reward from this terminal node.
- */
-
-static PyObject *__pyx_f_9multimcts_4mcts_4MCTS_backpropagate(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node, std::map<std::string,double>  __pyx_v_crewards) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("backpropagate", 0);
-  __Pyx_TraceCall("backpropagate", __pyx_f[0], 259, 0, __PYX_ERR(0, 259, __pyx_L1_error));
-  __Pyx_INCREF((PyObject *)__pyx_v_node);
-
-  /* "multimcts/mcts.pyx":263
- *         Update all ancestors with the reward from this terminal node.
- *         """
- *         while node is not None:             # <<<<<<<<<<<<<<
- *             node.apply_rewards(crewards)
- *             node = node.parent
- */
-  while (1) {
-    __pyx_t_1 = (((PyObject *)__pyx_v_node) != Py_None);
-    __pyx_t_2 = (__pyx_t_1 != 0);
-    if (!__pyx_t_2) break;
-
-    /* "multimcts/mcts.pyx":264
- *         """
- *         while node is not None:
- *             node.apply_rewards(crewards)             # <<<<<<<<<<<<<<
- *             node = node.parent
- * 
- */
-    __pyx_t_3 = ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->apply_rewards(__pyx_v_node, __pyx_v_crewards); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 264, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-
-    /* "multimcts/mcts.pyx":265
- *         while node is not None:
- *             node.apply_rewards(crewards)
- *             node = node.parent             # <<<<<<<<<<<<<<
- * 
- *     cdef Node get_best_child(self, Node node):
- */
-    __pyx_t_3 = ((PyObject *)__pyx_v_node->parent);
-    __Pyx_INCREF(__pyx_t_3);
-    __Pyx_DECREF_SET(__pyx_v_node, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_3));
-    __pyx_t_3 = 0;
-  }
-
-  /* "multimcts/mcts.pyx":259
- *         return crewards
- * 
- *     cdef backpropagate(self, Node node, map[string,double] crewards):             # <<<<<<<<<<<<<<
- *         """Step 4: Backpropagation
- *         Update all ancestors with the reward from this terminal node.
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("multimcts.mcts.MCTS.backpropagate", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_node);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "multimcts/mcts.pyx":267
- *             node = node.parent
- * 
- *     cdef Node get_best_child(self, Node node):             # <<<<<<<<<<<<<<
- *         """Find the child with the highest Upper Confidence Bound (UCB)."""
- *         cdef double parent_sqrtlog_visits = node.sqrtlog_visits
- */
-
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_get_best_child(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node) {
-  double __pyx_v_parent_sqrtlog_visits;
-  double __pyx_v_best_score;
-  double __pyx_v_ucb;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_child = 0;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_best_child = 0;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
-  __Pyx_RefNannyDeclarations
-  double __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  Py_ssize_t __pyx_t_3;
-  PyObject *(*__pyx_t_4)(PyObject *);
-  PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("get_best_child", 0);
-  __Pyx_TraceCall("get_best_child", __pyx_f[0], 267, 0, __PYX_ERR(0, 267, __pyx_L1_error));
-
-  /* "multimcts/mcts.pyx":269
- *     cdef Node get_best_child(self, Node node):
- *         """Find the child with the highest Upper Confidence Bound (UCB)."""
- *         cdef double parent_sqrtlog_visits = node.sqrtlog_visits             # <<<<<<<<<<<<<<
- *         cdef double best_score = -INFINITY
- *         cdef double ucb
- */
-  __pyx_t_1 = __pyx_v_node->sqrtlog_visits;
-  __pyx_v_parent_sqrtlog_visits = __pyx_t_1;
-
-  /* "multimcts/mcts.pyx":270
- *         """Find the child with the highest Upper Confidence Bound (UCB)."""
- *         cdef double parent_sqrtlog_visits = node.sqrtlog_visits
- *         cdef double best_score = -INFINITY             # <<<<<<<<<<<<<<
- *         cdef double ucb
- *         cdef Node child, best_child = node.children[0]
- */
-  __pyx_v_best_score = (-INFINITY);
-
-  /* "multimcts/mcts.pyx":272
- *         cdef double best_score = -INFINITY
- *         cdef double ucb
- *         cdef Node child, best_child = node.children[0]             # <<<<<<<<<<<<<<
- *         cdef pair[string,double] item
- * 
- */
-  __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_node->children, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 272, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_9multimcts_4mcts_Node))))) __PYX_ERR(0, 272, __pyx_L1_error)
-  __pyx_v_best_child = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2);
-  __pyx_t_2 = 0;
-
-  /* "multimcts/mcts.pyx":275
- *         cdef pair[string,double] item
- * 
- *         for child in node.children:             # <<<<<<<<<<<<<<
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)
- *             if ucb > best_score:
- */
-  if (likely(PyList_CheckExact(__pyx_v_node->children)) || PyTuple_CheckExact(__pyx_v_node->children)) {
-    __pyx_t_2 = __pyx_v_node->children; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
-    __pyx_t_4 = NULL;
-  } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_node->children); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 275, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 275, __pyx_L1_error)
-  }
-  for (;;) {
-    if (likely(!__pyx_t_4)) {
-      if (likely(PyList_CheckExact(__pyx_t_2))) {
-        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 275, __pyx_L1_error)
-        #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 275, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        #endif
-      } else {
-        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 275, __pyx_L1_error)
-        #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 275, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        #endif
-      }
-    } else {
-      __pyx_t_5 = __pyx_t_4(__pyx_t_2);
-      if (unlikely(!__pyx_t_5)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 275, __pyx_L1_error)
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_5);
-    }
-    if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_9multimcts_4mcts_Node))))) __PYX_ERR(0, 275, __pyx_L1_error)
-    __Pyx_XDECREF_SET(__pyx_v_child, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_5));
-    __pyx_t_5 = 0;
-
-    /* "multimcts/mcts.pyx":276
- * 
- *         for child in node.children:
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)             # <<<<<<<<<<<<<<
- *             if ucb > best_score:
- *                 best_score = ucb
- */
-    __pyx_v_ucb = ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_child->__pyx_vtab)->ucb(__pyx_v_child, __pyx_v_self->exploration_bias, __pyx_v_parent_sqrtlog_visits);
-
-    /* "multimcts/mcts.pyx":277
- *         for child in node.children:
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)
- *             if ucb > best_score:             # <<<<<<<<<<<<<<
- *                 best_score = ucb
- *                 best_child = child
- */
-    __pyx_t_6 = ((__pyx_v_ucb > __pyx_v_best_score) != 0);
-    if (__pyx_t_6) {
-
-      /* "multimcts/mcts.pyx":278
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)
- *             if ucb > best_score:
- *                 best_score = ucb             # <<<<<<<<<<<<<<
- *                 best_child = child
- * 
- */
-      __pyx_v_best_score = __pyx_v_ucb;
-
-      /* "multimcts/mcts.pyx":279
- *             if ucb > best_score:
- *                 best_score = ucb
- *                 best_child = child             # <<<<<<<<<<<<<<
- * 
- *         return best_child
- */
-      __Pyx_INCREF(((PyObject *)__pyx_v_child));
-      __Pyx_DECREF_SET(__pyx_v_best_child, __pyx_v_child);
-
-      /* "multimcts/mcts.pyx":277
- *         for child in node.children:
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)
- *             if ucb > best_score:             # <<<<<<<<<<<<<<
- *                 best_score = ucb
- *                 best_child = child
- */
-    }
-
-    /* "multimcts/mcts.pyx":275
- *         cdef pair[string,double] item
- * 
- *         for child in node.children:             # <<<<<<<<<<<<<<
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)
- *             if ucb > best_score:
- */
-  }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "multimcts/mcts.pyx":281
- *                 best_child = child
- * 
- *         return best_child             # <<<<<<<<<<<<<<
- */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_INCREF(((PyObject *)__pyx_v_best_child));
-  __pyx_r = __pyx_v_best_child;
-  goto __pyx_L0;
-
-  /* "multimcts/mcts.pyx":267
- *             node = node.parent
- * 
- *     cdef Node get_best_child(self, Node node):             # <<<<<<<<<<<<<<
- *         """Find the child with the highest Upper Confidence Bound (UCB)."""
- *         cdef double parent_sqrtlog_visits = node.sqrtlog_visits
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_AddTraceback("multimcts.mcts.MCTS.get_best_child", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_child);
-  __Pyx_XDECREF((PyObject *)__pyx_v_best_child);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
@@ -5743,231 +6950,233 @@
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_4__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self) {
   PyObject *__pyx_v_state = 0;
   PyObject *__pyx_v__dict = 0;
   int __pyx_v_use_setstate;
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
-  int __pyx_t_3;
+  PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
-  __Pyx_TraceCall("__reduce_cython__", __pyx_f[1], 1, 0, __PYX_ERR(1, 1, __pyx_L1_error));
 
   /* "(tree fragment)":5
  *     cdef object _dict
  *     cdef bint use_setstate
- *     state = (self.exploration_bias,)             # <<<<<<<<<<<<<<
+ *     state = (self.exploration_bias, self.rave_bias)             # <<<<<<<<<<<<<<
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  */
   __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->exploration_bias); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_self->rave_bias); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_1);
-  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
   __pyx_t_1 = 0;
-  __pyx_v_state = ((PyObject*)__pyx_t_2);
   __pyx_t_2 = 0;
+  __pyx_v_state = ((PyObject*)__pyx_t_3);
+  __pyx_t_3 = 0;
 
   /* "(tree fragment)":6
  *     cdef bint use_setstate
- *     state = (self.exploration_bias,)
+ *     state = (self.exploration_bias, self.rave_bias)
  *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<
  *     if _dict is not None:
  *         state += (_dict,)
  */
-  __pyx_t_2 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_v__dict = __pyx_t_2;
-  __pyx_t_2 = 0;
+  __pyx_t_3 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_v__dict = __pyx_t_3;
+  __pyx_t_3 = 0;
 
   /* "(tree fragment)":7
- *     state = (self.exploration_bias,)
+ *     state = (self.exploration_bias, self.rave_bias)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
-  __pyx_t_3 = (__pyx_v__dict != Py_None);
-  __pyx_t_4 = (__pyx_t_3 != 0);
-  if (__pyx_t_4) {
+  __pyx_t_4 = (__pyx_v__dict != Py_None);
+  __pyx_t_5 = (__pyx_t_4 != 0);
+  if (__pyx_t_5) {
 
     /* "(tree fragment)":8
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  *         state += (_dict,)             # <<<<<<<<<<<<<<
  *         use_setstate = True
  *     else:
  */
-    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 8, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v__dict);
     __Pyx_GIVEREF(__pyx_v__dict);
-    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v__dict);
-    __pyx_t_1 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 8, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_1));
-    __pyx_t_1 = 0;
+    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v__dict);
+    __pyx_t_2 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_2));
+    __pyx_t_2 = 0;
 
     /* "(tree fragment)":9
  *     if _dict is not None:
  *         state += (_dict,)
  *         use_setstate = True             # <<<<<<<<<<<<<<
  *     else:
  *         use_setstate = False
  */
     __pyx_v_use_setstate = 1;
 
     /* "(tree fragment)":7
- *     state = (self.exploration_bias,)
+ *     state = (self.exploration_bias, self.rave_bias)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
     goto __pyx_L3;
   }
 
   /* "(tree fragment)":11
  *         use_setstate = True
  *     else:
  *         use_setstate = False             # <<<<<<<<<<<<<<
  *     if use_setstate:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, None), state
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, None), state
  */
   /*else*/ {
     __pyx_v_use_setstate = 0;
   }
   __pyx_L3:;
 
   /* "(tree fragment)":12
  *     else:
  *         use_setstate = False
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, None), state
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, None), state
  *     else:
  */
-  __pyx_t_4 = (__pyx_v_use_setstate != 0);
-  if (__pyx_t_4) {
+  __pyx_t_5 = (__pyx_v_use_setstate != 0);
+  if (__pyx_t_5) {
 
     /* "(tree fragment)":13
  *         use_setstate = False
  *     if use_setstate:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, None), state             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, None), state             # <<<<<<<<<<<<<<
  *     else:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, state)
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, state)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pyx_unpickle_MCTS); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pyx_unpickle_MCTS); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 13, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_203704333);
-    __Pyx_GIVEREF(__pyx_int_203704333);
-    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_int_203704333);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
+    __Pyx_INCREF(__pyx_int_145648438);
+    __Pyx_GIVEREF(__pyx_int_145648438);
+    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_145648438);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
-    PyTuple_SET_ITEM(__pyx_t_2, 2, Py_None);
-    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_GIVEREF(__pyx_t_1);
-    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_3, 2, Py_None);
+    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
     __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
+    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);
+    __Pyx_GIVEREF(__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
-    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_v_state);
-    __pyx_t_1 = 0;
+    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_state);
     __pyx_t_2 = 0;
-    __pyx_r = __pyx_t_5;
-    __pyx_t_5 = 0;
+    __pyx_t_3 = 0;
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
     goto __pyx_L0;
 
     /* "(tree fragment)":12
  *     else:
  *         use_setstate = False
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, None), state
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, None), state
  *     else:
  */
   }
 
   /* "(tree fragment)":15
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, None), state
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, None), state
  *     else:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, state)             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, state)             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_MCTS__set_state(self, __pyx_state)
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_pyx_unpickle_MCTS); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pyx_unpickle_MCTS); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_203704333);
-    __Pyx_GIVEREF(__pyx_int_203704333);
-    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_int_203704333);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
+    __Pyx_INCREF(__pyx_int_145648438);
+    __Pyx_GIVEREF(__pyx_int_145648438);
+    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_145648438);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
-    PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_v_state);
-    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_GIVEREF(__pyx_t_5);
-    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_5);
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
-    __pyx_t_5 = 0;
-    __pyx_t_2 = 0;
-    __pyx_r = __pyx_t_1;
+    PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_v_state);
+    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_GIVEREF(__pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
+    __Pyx_GIVEREF(__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);
     __pyx_t_1 = 0;
+    __pyx_t_3 = 0;
+    __pyx_r = __pyx_t_2;
+    __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
  *     cdef object _dict
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("multimcts.mcts.MCTS.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_state);
   __Pyx_XDECREF(__pyx_v__dict);
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, state)
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_MCTS__set_state(self, __pyx_state)
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_7__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_7__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
@@ -5979,54 +7188,228 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_6__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
-  __Pyx_TraceCall("__setstate_cython__", __pyx_f[1], 16, 0, __PYX_ERR(1, 16, __pyx_L1_error));
 
   /* "(tree fragment)":17
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, state)
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, state)
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_MCTS__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<
  */
   if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
   __pyx_t_1 = __pyx_f_9multimcts_4mcts___pyx_unpickle_MCTS__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, state)
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_MCTS__set_state(self, __pyx_state)
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.MCTS.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
+/* "multimcts/mcts.pyx":333
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef double sqrtlog(int x):             # <<<<<<<<<<<<<<
+ *     return SQRTLOG[x] if 0 <= x < 10000 else sqrt(log(x))
+ * @cython.cdivision(True)
+ */
+
+static double __pyx_f_9multimcts_4mcts_sqrtlog(int __pyx_v_x) {
+  double __pyx_r;
+  __Pyx_RefNannyDeclarations
+  double __pyx_t_1;
+  int __pyx_t_2;
+  __Pyx_RefNannySetupContext("sqrtlog", 0);
+
+  /* "multimcts/mcts.pyx":334
+ * @cython.wraparound(False)
+ * cdef double sqrtlog(int x):
+ *     return SQRTLOG[x] if 0 <= x < 10000 else sqrt(log(x))             # <<<<<<<<<<<<<<
+ * @cython.cdivision(True)
+ * @cython.boundscheck(False)
+ */
+  __pyx_t_2 = (0 <= __pyx_v_x);
+  if (__pyx_t_2) {
+    __pyx_t_2 = (__pyx_v_x < 0x2710);
+  }
+  if ((__pyx_t_2 != 0)) {
+    __pyx_t_1 = (__pyx_v_9multimcts_4mcts_SQRTLOG[__pyx_v_x]);
+  } else {
+    __pyx_t_1 = sqrt(log(__pyx_v_x));
+  }
+  __pyx_r = __pyx_t_1;
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":333
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef double sqrtlog(int x):             # <<<<<<<<<<<<<<
+ *     return SQRTLOG[x] if 0 <= x < 10000 else sqrt(log(x))
+ * @cython.cdivision(True)
+ */
+
+  /* function exit code */
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":338
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef double invsqrt(int x):             # <<<<<<<<<<<<<<
+ *     return INVSQRT[x] if 0 <= x < 10000 else 1 / sqrt(x)
+ * 
+ */
+
+static double __pyx_f_9multimcts_4mcts_invsqrt(int __pyx_v_x) {
+  double __pyx_r;
+  __Pyx_RefNannyDeclarations
+  double __pyx_t_1;
+  int __pyx_t_2;
+  __Pyx_RefNannySetupContext("invsqrt", 0);
+
+  /* "multimcts/mcts.pyx":339
+ * @cython.wraparound(False)
+ * cdef double invsqrt(int x):
+ *     return INVSQRT[x] if 0 <= x < 10000 else 1 / sqrt(x)             # <<<<<<<<<<<<<<
+ * 
+ * @cython.cdivision(True)
+ */
+  __pyx_t_2 = (0 <= __pyx_v_x);
+  if (__pyx_t_2) {
+    __pyx_t_2 = (__pyx_v_x < 0x2710);
+  }
+  if ((__pyx_t_2 != 0)) {
+    __pyx_t_1 = (__pyx_v_9multimcts_4mcts_INVSQRT[__pyx_v_x]);
+  } else {
+    __pyx_t_1 = (1.0 / sqrt(__pyx_v_x));
+  }
+  __pyx_r = __pyx_t_1;
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":338
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef double invsqrt(int x):             # <<<<<<<<<<<<<<
+ *     return INVSQRT[x] if 0 <= x < 10000 else 1 / sqrt(x)
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":344
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef void precalc():             # <<<<<<<<<<<<<<
+ *     SQRTLOG[0] = 0
+ *     INVSQRT[0] = 0
+ */
+
+static void __pyx_f_9multimcts_4mcts_precalc(void) {
+  int __pyx_v_x;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  __Pyx_RefNannySetupContext("precalc", 0);
+
+  /* "multimcts/mcts.pyx":345
+ * @cython.wraparound(False)
+ * cdef void precalc():
+ *     SQRTLOG[0] = 0             # <<<<<<<<<<<<<<
+ *     INVSQRT[0] = 0
+ *     cdef int x = 0
+ */
+  (__pyx_v_9multimcts_4mcts_SQRTLOG[0]) = 0.0;
+
+  /* "multimcts/mcts.pyx":346
+ * cdef void precalc():
+ *     SQRTLOG[0] = 0
+ *     INVSQRT[0] = 0             # <<<<<<<<<<<<<<
+ *     cdef int x = 0
+ *     for x in range(1,10000):
+ */
+  (__pyx_v_9multimcts_4mcts_INVSQRT[0]) = 0.0;
+
+  /* "multimcts/mcts.pyx":347
+ *     SQRTLOG[0] = 0
+ *     INVSQRT[0] = 0
+ *     cdef int x = 0             # <<<<<<<<<<<<<<
+ *     for x in range(1,10000):
+ *         SQRTLOG[x] = sqrt(log(x))
+ */
+  __pyx_v_x = 0;
+
+  /* "multimcts/mcts.pyx":348
+ *     INVSQRT[0] = 0
+ *     cdef int x = 0
+ *     for x in range(1,10000):             # <<<<<<<<<<<<<<
+ *         SQRTLOG[x] = sqrt(log(x))
+ *         INVSQRT[x] = 1 / sqrt(x)
+ */
+  for (__pyx_t_1 = 1; __pyx_t_1 < 0x2710; __pyx_t_1+=1) {
+    __pyx_v_x = __pyx_t_1;
+
+    /* "multimcts/mcts.pyx":349
+ *     cdef int x = 0
+ *     for x in range(1,10000):
+ *         SQRTLOG[x] = sqrt(log(x))             # <<<<<<<<<<<<<<
+ *         INVSQRT[x] = 1 / sqrt(x)
+ * precalc()
+ */
+    (__pyx_v_9multimcts_4mcts_SQRTLOG[__pyx_v_x]) = sqrt(log(__pyx_v_x));
+
+    /* "multimcts/mcts.pyx":350
+ *     for x in range(1,10000):
+ *         SQRTLOG[x] = sqrt(log(x))
+ *         INVSQRT[x] = 1 / sqrt(x)             # <<<<<<<<<<<<<<
+ * precalc()
+ */
+    (__pyx_v_9multimcts_4mcts_INVSQRT[__pyx_v_x]) = (1.0 / sqrt(__pyx_v_x));
+  }
+
+  /* "multimcts/mcts.pyx":344
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef void precalc():             # <<<<<<<<<<<<<<
+ *     SQRTLOG[0] = 0
+ *     INVSQRT[0] = 0
+ */
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+}
+
 /* "(tree fragment)":1
  * def __pyx_unpickle_Node(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
 
 /* Python wrapper */
@@ -6105,48 +7488,45 @@
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts___pyx_unpickle_Node(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_v___pyx_PickleError = 0;
   PyObject *__pyx_v___pyx_result = 0;
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_TraceFrameInit(__pyx_codeobj__12)
   __Pyx_RefNannySetupContext("__pyx_unpickle_Node", 0);
-  __Pyx_TraceCall("__pyx_unpickle_Node", __pyx_f[1], 1, 0, __PYX_ERR(1, 1, __pyx_L1_error));
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x357fa0f, 0x5f4daba, 0x391d535):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0xf2c96f8, 0x996f7e4, 0x2d45624):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  */
   __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__13, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__8, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
     /* "(tree fragment)":5
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x357fa0f, 0x5f4daba, 0x391d535):
+ *     if __pyx_checksum not in (0xf2c96f8, 0x996f7e4, 0x2d45624):
  *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  *     __pyx_result = Node.__new__(__pyx_type)
  */
     __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_n_s_PickleError);
     __Pyx_GIVEREF(__pyx_n_s_PickleError);
     PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_PickleError);
@@ -6157,17 +7537,17 @@
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_t_1);
     __pyx_v___pyx_PickleError = __pyx_t_1;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
     /* "(tree fragment)":6
- *     if __pyx_checksum not in (0x357fa0f, 0x5f4daba, 0x391d535):
+ *     if __pyx_checksum not in (0xf2c96f8, 0x996f7e4, 0x2d45624):
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)             # <<<<<<<<<<<<<<
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)             # <<<<<<<<<<<<<<
  *     __pyx_result = Node.__new__(__pyx_type)
  *     if __pyx_state is not None:
  */
     __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
@@ -6192,23 +7572,23 @@
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __PYX_ERR(1, 6, __pyx_L1_error)
 
     /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x357fa0f, 0x5f4daba, 0x391d535):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0xf2c96f8, 0x996f7e4, 0x2d45624):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  */
   }
 
   /* "(tree fragment)":7
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  *     __pyx_result = Node.__new__(__pyx_type)             # <<<<<<<<<<<<<<
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  */
   __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_9multimcts_4mcts_Node), __pyx_n_s_new); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_5 = NULL;
@@ -6226,15 +7606,15 @@
   if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v___pyx_result = __pyx_t_4;
   __pyx_t_4 = 0;
 
   /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  *     __pyx_result = Node.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   __pyx_t_3 = (__pyx_v___pyx_state != Py_None);
   __pyx_t_2 = (__pyx_t_3 != 0);
@@ -6249,28 +7629,28 @@
  */
     if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
     __pyx_t_4 = __pyx_f_9multimcts_4mcts___pyx_unpickle_Node__set_state(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 9, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
     /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  *     __pyx_result = Node.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   }
 
   /* "(tree fragment)":10
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result             # <<<<<<<<<<<<<<
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v___pyx_result);
   __pyx_r = __pyx_v___pyx_result;
   goto __pyx_L0;
 
   /* "(tree fragment)":1
@@ -6287,85 +7667,82 @@
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("multimcts.mcts.__pyx_unpickle_Node", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v___pyx_PickleError);
   __Pyx_XDECREF(__pyx_v___pyx_result);
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":11
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):
  */
 
 static PyObject *__pyx_f_9multimcts_4mcts___pyx_unpickle_Node__set_state(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   double __pyx_t_2;
-  std::string __pyx_t_3;
-  int __pyx_t_4;
-  std::map<std::string,double>  __pyx_t_5;
-  int __pyx_t_6;
+  int __pyx_t_3;
+  std::map<std::string,double>  __pyx_t_4;
+  int __pyx_t_5;
+  std::string __pyx_t_6;
   Py_ssize_t __pyx_t_7;
   int __pyx_t_8;
   int __pyx_t_9;
   PyObject *__pyx_t_10 = NULL;
   PyObject *__pyx_t_11 = NULL;
   PyObject *__pyx_t_12 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_unpickle_Node__set_state", 0);
-  __Pyx_TraceCall("__pyx_unpickle_Node__set_state", __pyx_f[1], 11, 0, __PYX_ERR(1, 11, __pyx_L1_error));
 
   /* "(tree fragment)":12
  *     return __pyx_result
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]             # <<<<<<<<<<<<<<
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):
- *         __pyx_result.__dict__.update(__pyx_state[14])
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]             # <<<<<<<<<<<<<<
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):
+ *         __pyx_result.__dict__.update(__pyx_state[16])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->avg_reward = __pyx_t_2;
+  __pyx_v___pyx_result->avg_rave_reward = __pyx_t_2;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_1);
-  __Pyx_GOTREF(__pyx_v___pyx_result->children);
-  __Pyx_DECREF(__pyx_v___pyx_result->children);
-  __pyx_v___pyx_result->children = __pyx_t_1;
-  __pyx_t_1 = 0;
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v___pyx_result->avg_reward = __pyx_t_2;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->cteam = __pyx_t_3;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __Pyx_GOTREF(__pyx_v___pyx_result->children);
+  __Pyx_DECREF(__pyx_v___pyx_result->children);
+  __pyx_v___pyx_result->children = __pyx_t_1;
+  __pyx_t_1 = 0;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
@@ -6373,26 +7750,26 @@
   __pyx_v___pyx_result->invsqrt_visits = __pyx_t_2;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 4, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->is_fully_expanded = __pyx_t_4;
+  __pyx_v___pyx_result->is_fully_expanded = __pyx_t_3;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 5, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->is_terminal = __pyx_t_4;
+  __pyx_v___pyx_result->is_terminal = __pyx_t_3;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 6, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
@@ -6414,107 +7791,123 @@
   __pyx_t_1 = 0;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 8, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_4 = __pyx_convert_map_from_py_std_3a__3a_string__and_double(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v___pyx_result->rave_rewards = __pyx_t_4;
+  if (unlikely(__pyx_v___pyx_state == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
+    __PYX_ERR(1, 12, __pyx_L1_error)
+  }
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 9, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v___pyx_result->rave_visits = __pyx_t_5;
+  if (unlikely(__pyx_v___pyx_state == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
+    __PYX_ERR(1, 12, __pyx_L1_error)
+  }
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 10, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v___pyx_result->remaining_moves);
   __Pyx_DECREF(__pyx_v___pyx_result->remaining_moves);
   __pyx_v___pyx_result->remaining_moves = __pyx_t_1;
   __pyx_t_1 = 0;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 9, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 11, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __pyx_convert_map_from_py_std_3a__3a_string__and_double(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_4 = __pyx_convert_map_from_py_std_3a__3a_string__and_double(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->rewards = __pyx_t_5;
+  __pyx_v___pyx_result->rewards = __pyx_t_4;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 10, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 12, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v___pyx_result->sqrtlog_visits = __pyx_t_2;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 11, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 13, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v___pyx_result->state);
   __Pyx_DECREF(__pyx_v___pyx_result->state);
   __pyx_v___pyx_result->state = __pyx_t_1;
   __pyx_t_1 = 0;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 12, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 14, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_1);
-  __Pyx_GOTREF(__pyx_v___pyx_result->team);
-  __Pyx_DECREF(__pyx_v___pyx_result->team);
-  __pyx_v___pyx_result->team = __pyx_t_1;
-  __pyx_t_1 = 0;
+  __pyx_t_6 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v___pyx_result->team = __pyx_t_6;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 13, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 15, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->visits = __pyx_t_6;
+  __pyx_v___pyx_result->visits = __pyx_t_5;
 
   /* "(tree fragment)":13
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
- *         __pyx_result.__dict__.update(__pyx_state[14])
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
+ *         __pyx_result.__dict__.update(__pyx_state[16])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
     __PYX_ERR(1, 13, __pyx_L1_error)
   }
   __pyx_t_7 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
-  __pyx_t_8 = ((__pyx_t_7 > 14) != 0);
+  __pyx_t_8 = ((__pyx_t_7 > 16) != 0);
   if (__pyx_t_8) {
   } else {
-    __pyx_t_4 = __pyx_t_8;
+    __pyx_t_3 = __pyx_t_8;
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_8 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
   __pyx_t_9 = (__pyx_t_8 != 0);
-  __pyx_t_4 = __pyx_t_9;
+  __pyx_t_3 = __pyx_t_9;
   __pyx_L4_bool_binop_done:;
-  if (__pyx_t_4) {
+  if (__pyx_t_3) {
 
     /* "(tree fragment)":14
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):
- *         __pyx_result.__dict__.update(__pyx_state[14])             # <<<<<<<<<<<<<<
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):
+ *         __pyx_result.__dict__.update(__pyx_state[16])             # <<<<<<<<<<<<<<
  */
     __pyx_t_10 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_update); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_11);
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
     if (unlikely(__pyx_v___pyx_state == Py_None)) {
       PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
       __PYX_ERR(1, 14, __pyx_L1_error)
     }
-    __pyx_t_10 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 14, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 16, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __pyx_t_12 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_11))) {
       __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_11);
       if (likely(__pyx_t_12)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
         __Pyx_INCREF(__pyx_t_12);
@@ -6528,41 +7921,40 @@
     if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
     /* "(tree fragment)":13
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
- *         __pyx_result.__dict__.update(__pyx_state[14])
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
+ *         __pyx_result.__dict__.update(__pyx_state[16])
  */
   }
 
   /* "(tree fragment)":11
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_10);
   __Pyx_XDECREF(__pyx_t_11);
   __Pyx_XDECREF(__pyx_t_12);
   __Pyx_AddTraceback("multimcts.mcts.__pyx_unpickle_Node__set_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __pyx_unpickle_MCTS(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
@@ -6645,48 +8037,45 @@
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_2__pyx_unpickle_MCTS(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_v___pyx_PickleError = 0;
   PyObject *__pyx_v___pyx_result = 0;
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_TraceFrameInit(__pyx_codeobj__14)
   __Pyx_RefNannySetupContext("__pyx_unpickle_MCTS", 0);
-  __Pyx_TraceCall("__pyx_unpickle_MCTS", __pyx_f[1], 1, 0, __PYX_ERR(1, 1, __pyx_L1_error));
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xc24480d, 0xdc6441b, 0x4ed5288):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0x8ae6b36, 0xb1de3b5, 0xdf19538):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  */
   __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__15, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__9, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
     /* "(tree fragment)":5
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xc24480d, 0xdc6441b, 0x4ed5288):
+ *     if __pyx_checksum not in (0x8ae6b36, 0xb1de3b5, 0xdf19538):
  *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  *     __pyx_result = MCTS.__new__(__pyx_type)
  */
     __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_n_s_PickleError);
     __Pyx_GIVEREF(__pyx_n_s_PickleError);
     PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_PickleError);
@@ -6697,17 +8086,17 @@
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_t_1);
     __pyx_v___pyx_PickleError = __pyx_t_1;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
     /* "(tree fragment)":6
- *     if __pyx_checksum not in (0xc24480d, 0xdc6441b, 0x4ed5288):
+ *     if __pyx_checksum not in (0x8ae6b36, 0xb1de3b5, 0xdf19538):
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)             # <<<<<<<<<<<<<<
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)             # <<<<<<<<<<<<<<
  *     __pyx_result = MCTS.__new__(__pyx_type)
  *     if __pyx_state is not None:
  */
     __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_0x_x_vs_0_2, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
@@ -6732,23 +8121,23 @@
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __PYX_ERR(1, 6, __pyx_L1_error)
 
     /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xc24480d, 0xdc6441b, 0x4ed5288):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0x8ae6b36, 0xb1de3b5, 0xdf19538):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  */
   }
 
   /* "(tree fragment)":7
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  *     __pyx_result = MCTS.__new__(__pyx_type)             # <<<<<<<<<<<<<<
  *     if __pyx_state is not None:
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  */
   __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_9multimcts_4mcts_MCTS), __pyx_n_s_new); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_5 = NULL;
@@ -6766,15 +8155,15 @@
   if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v___pyx_result = __pyx_t_4;
   __pyx_t_4 = 0;
 
   /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  *     __pyx_result = MCTS.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   __pyx_t_3 = (__pyx_v___pyx_state != Py_None);
   __pyx_t_2 = (__pyx_t_3 != 0);
@@ -6789,28 +8178,28 @@
  */
     if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
     __pyx_t_4 = __pyx_f_9multimcts_4mcts___pyx_unpickle_MCTS__set_state(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 9, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
     /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  *     __pyx_result = MCTS.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   }
 
   /* "(tree fragment)":10
  *     if __pyx_state is not None:
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  *     return __pyx_result             # <<<<<<<<<<<<<<
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):
- *     __pyx_result.exploration_bias = __pyx_state[0]
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v___pyx_result);
   __pyx_r = __pyx_v___pyx_result;
   goto __pyx_L0;
 
   /* "(tree fragment)":1
@@ -6827,101 +8216,107 @@
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("multimcts.mcts.__pyx_unpickle_MCTS", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v___pyx_PickleError);
   __Pyx_XDECREF(__pyx_v___pyx_result);
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":11
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
- *     __pyx_result.exploration_bias = __pyx_state[0]
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):
  */
 
 static PyObject *__pyx_f_9multimcts_4mcts___pyx_unpickle_MCTS__set_state(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   double __pyx_t_2;
   int __pyx_t_3;
   Py_ssize_t __pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   PyObject *__pyx_t_9 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_unpickle_MCTS__set_state", 0);
-  __Pyx_TraceCall("__pyx_unpickle_MCTS__set_state", __pyx_f[1], 11, 0, __PYX_ERR(1, 11, __pyx_L1_error));
 
   /* "(tree fragment)":12
  *     return __pyx_result
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):
- *     __pyx_result.exploration_bias = __pyx_state[0]             # <<<<<<<<<<<<<<
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
- *         __pyx_result.__dict__.update(__pyx_state[1])
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]             # <<<<<<<<<<<<<<
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):
+ *         __pyx_result.__dict__.update(__pyx_state[2])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v___pyx_result->exploration_bias = __pyx_t_2;
+  if (unlikely(__pyx_v___pyx_state == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
+    __PYX_ERR(1, 12, __pyx_L1_error)
+  }
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v___pyx_result->rave_bias = __pyx_t_2;
 
   /* "(tree fragment)":13
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):
- *     __pyx_result.exploration_bias = __pyx_state[0]
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
- *         __pyx_result.__dict__.update(__pyx_state[1])
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
+ *         __pyx_result.__dict__.update(__pyx_state[2])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
     __PYX_ERR(1, 13, __pyx_L1_error)
   }
   __pyx_t_4 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
-  __pyx_t_5 = ((__pyx_t_4 > 1) != 0);
+  __pyx_t_5 = ((__pyx_t_4 > 2) != 0);
   if (__pyx_t_5) {
   } else {
     __pyx_t_3 = __pyx_t_5;
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_5 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
   __pyx_t_6 = (__pyx_t_5 != 0);
   __pyx_t_3 = __pyx_t_6;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_3) {
 
     /* "(tree fragment)":14
- *     __pyx_result.exploration_bias = __pyx_state[0]
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
- *         __pyx_result.__dict__.update(__pyx_state[1])             # <<<<<<<<<<<<<<
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):
+ *         __pyx_result.__dict__.update(__pyx_state[2])             # <<<<<<<<<<<<<<
  */
     __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_update); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     if (unlikely(__pyx_v___pyx_state == Py_None)) {
       PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
       __PYX_ERR(1, 14, __pyx_L1_error)
     }
-    __pyx_t_7 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __pyx_t_9 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {
       __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);
       if (likely(__pyx_t_9)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
         __Pyx_INCREF(__pyx_t_9);
@@ -6935,63 +8330,60 @@
     if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
     /* "(tree fragment)":13
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):
- *     __pyx_result.exploration_bias = __pyx_state[0]
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
- *         __pyx_result.__dict__.update(__pyx_state[1])
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
+ *         __pyx_result.__dict__.update(__pyx_state[2])
  */
   }
 
   /* "(tree fragment)":11
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
- *     __pyx_result.exploration_bias = __pyx_state[0]
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_7);
   __Pyx_XDECREF(__pyx_t_8);
   __Pyx_XDECREF(__pyx_t_9);
   __Pyx_AddTraceback("multimcts.mcts.__pyx_unpickle_MCTS__set_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "string.to_py":31
  * 
  * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
  *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
  * cdef extern from *:
  */
 
 static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &__pyx_v_s) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_PyObject_string_to_py_std__in_string", 0);
-  __Pyx_TraceCall("__pyx_convert_PyObject_string_to_py_std__in_string", __pyx_f[1], 31, 0, __PYX_ERR(1, 31, __pyx_L1_error));
 
   /* "string.to_py":32
  * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):
  *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
  * cdef extern from *:
  *     cdef object __Pyx_PyUnicode_FromStringAndSize(const char*, size_t)
@@ -7014,37 +8406,34 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("string.to_py.__pyx_convert_PyObject_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "string.to_py":37
  * 
  * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
  *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
  * cdef extern from *:
  */
 
 static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &__pyx_v_s) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_PyUnicode_string_to_py_std__in_string", 0);
-  __Pyx_TraceCall("__pyx_convert_PyUnicode_string_to_py_std__in_string", __pyx_f[1], 37, 0, __PYX_ERR(1, 37, __pyx_L1_error));
 
   /* "string.to_py":38
  * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):
  *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
  * cdef extern from *:
  *     cdef object __Pyx_PyStr_FromStringAndSize(const char*, size_t)
@@ -7067,37 +8456,34 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("string.to_py.__pyx_convert_PyUnicode_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "string.to_py":43
  * 
  * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
  *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
  * cdef extern from *:
  */
 
 static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &__pyx_v_s) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_PyStr_string_to_py_std__in_string", 0);
-  __Pyx_TraceCall("__pyx_convert_PyStr_string_to_py_std__in_string", __pyx_f[1], 43, 0, __PYX_ERR(1, 43, __pyx_L1_error));
 
   /* "string.to_py":44
  * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):
  *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
  * cdef extern from *:
  *     cdef object __Pyx_PyBytes_FromStringAndSize(const char*, size_t)
@@ -7120,37 +8506,34 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("string.to_py.__pyx_convert_PyStr_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "string.to_py":49
  * 
  * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
  *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
  * cdef extern from *:
  */
 
 static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &__pyx_v_s) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_PyBytes_string_to_py_std__in_string", 0);
-  __Pyx_TraceCall("__pyx_convert_PyBytes_string_to_py_std__in_string", __pyx_f[1], 49, 0, __PYX_ERR(1, 49, __pyx_L1_error));
 
   /* "string.to_py":50
  * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):
  *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
  * cdef extern from *:
  *     cdef object __Pyx_PyByteArray_FromStringAndSize(const char*, size_t)
@@ -7173,37 +8556,34 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("string.to_py.__pyx_convert_PyBytes_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "string.to_py":55
  * 
  * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
  *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &__pyx_v_s) {
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_PyByteArray_string_to_py_std__in_string", 0);
-  __Pyx_TraceCall("__pyx_convert_PyByteArray_string_to_py_std__in_string", __pyx_f[1], 55, 0, __PYX_ERR(1, 55, __pyx_L1_error));
 
   /* "string.to_py":56
  * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):
  *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
  * 
  */
@@ -7225,83 +8605,14 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("string.to_py.__pyx_convert_PyByteArray_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "string.from_py":13
- * 
- * @cname("__pyx_convert_string_from_py_std__in_string")
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- */
-
-static std::string __pyx_convert_string_from_py_std__in_string(PyObject *__pyx_v_o) {
-  Py_ssize_t __pyx_v_length;
-  char const *__pyx_v_data;
-  std::string __pyx_r;
-  __Pyx_TraceDeclarations
-  __Pyx_RefNannyDeclarations
-  char const *__pyx_t_1;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_string_from_py_std__in_string", 0);
-  __Pyx_TraceCall("__pyx_convert_string_from_py_std__in_string", __pyx_f[1], 13, 0, __PYX_ERR(1, 13, __pyx_L1_error));
-
-  /* "string.from_py":14
- * @cname("__pyx_convert_string_from_py_std__in_string")
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
- *     cdef Py_ssize_t length = 0             # <<<<<<<<<<<<<<
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- *     return string(data, length)
- */
-  __pyx_v_length = 0;
-
-  /* "string.from_py":15
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
- *     return string(data, length)
- * 
- */
-  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == ((char const *)NULL))) __PYX_ERR(1, 15, __pyx_L1_error)
-  __pyx_v_data = __pyx_t_1;
-
-  /* "string.from_py":16
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- *     return string(data, length)             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __pyx_r = std::string(__pyx_v_data, __pyx_v_length);
-  goto __pyx_L0;
-
-  /* "string.from_py":13
- * 
- * @cname("__pyx_convert_string_from_py_std__in_string")
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("string.from_py.__pyx_convert_string_from_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_pretend_to_initialize(&__pyx_r);
-  __pyx_L0:;
-  __Pyx_TraceReturn(Py_None, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "map.to_py":201
  * 
  * @cname("__pyx_convert_map_to_py_std_3a__3a_string____double")
@@ -7311,24 +8622,22 @@
  */
 
 static PyObject *__pyx_convert_map_to_py_std_3a__3a_string____double(std::map<std::string,double>  const &__pyx_v_s) {
   PyObject *__pyx_v_o = NULL;
   std::map<std::string,double> ::value_type const *__pyx_v_key_value;
   std::map<std::string,double> ::const_iterator __pyx_v_iter;
   PyObject *__pyx_r = NULL;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_map_to_py_std_3a__3a_string____double", 0);
-  __Pyx_TraceCall("__pyx_convert_map_to_py_std_3a__3a_string____double", __pyx_f[1], 201, 0, __PYX_ERR(1, 201, __pyx_L1_error));
 
   /* "map.to_py":202
  * @cname("__pyx_convert_map_to_py_std_3a__3a_string____double")
  * cdef object __pyx_convert_map_to_py_std_3a__3a_string____double(const map[X,Y]& s):
  *     o = {}             # <<<<<<<<<<<<<<
  *     cdef const map[X,Y].value_type *key_value
  *     cdef map[X,Y].const_iterator iter = s.begin()
@@ -7417,15 +8726,79 @@
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("map.to_py.__pyx_convert_map_to_py_std_3a__3a_string____double", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_o);
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "string.from_py":13
+ * 
+ * @cname("__pyx_convert_string_from_py_std__in_string")
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ */
+
+static std::string __pyx_convert_string_from_py_std__in_string(PyObject *__pyx_v_o) {
+  Py_ssize_t __pyx_v_length;
+  char const *__pyx_v_data;
+  std::string __pyx_r;
+  __Pyx_RefNannyDeclarations
+  char const *__pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__pyx_convert_string_from_py_std__in_string", 0);
+
+  /* "string.from_py":14
+ * @cname("__pyx_convert_string_from_py_std__in_string")
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
+ *     cdef Py_ssize_t length = 0             # <<<<<<<<<<<<<<
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ *     return string(data, length)
+ */
+  __pyx_v_length = 0;
+
+  /* "string.from_py":15
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
+ *     return string(data, length)
+ * 
+ */
+  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == ((char const *)NULL))) __PYX_ERR(1, 15, __pyx_L1_error)
+  __pyx_v_data = __pyx_t_1;
+
+  /* "string.from_py":16
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ *     return string(data, length)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = std::string(__pyx_v_data, __pyx_v_length);
+  goto __pyx_L0;
+
+  /* "string.from_py":13
+ * 
+ * @cname("__pyx_convert_string_from_py_std__in_string")
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("string.from_py.__pyx_convert_string_from_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_pretend_to_initialize(&__pyx_r);
+  __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "map.from_py":174
  * 
  * @cname("__pyx_convert_map_from_py_std_3a__3a_string__and_double")
@@ -7436,30 +8809,28 @@
 
 static std::map<std::string,double>  __pyx_convert_map_from_py_std_3a__3a_string__and_double(PyObject *__pyx_v_o) {
   PyObject *__pyx_v_d = 0;
   std::map<std::string,double>  __pyx_v_m;
   PyObject *__pyx_v_key = NULL;
   PyObject *__pyx_v_value = NULL;
   std::map<std::string,double>  __pyx_r;
-  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_t_7;
   std::string __pyx_t_8;
   double __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_map_from_py_std_3a__3a_string__and_double", 0);
-  __Pyx_TraceCall("__pyx_convert_map_from_py_std_3a__3a_string__and_double", __pyx_f[1], 174, 0, __PYX_ERR(1, 174, __pyx_L1_error));
 
   /* "map.from_py":175
  * @cname("__pyx_convert_map_from_py_std_3a__3a_string__and_double")
  * cdef map[X,Y] __pyx_convert_map_from_py_std_3a__3a_string__and_double(object o) except *:
  *     cdef dict d = o             # <<<<<<<<<<<<<<
  *     cdef map[X,Y] m
  *     for key, value in d.iteritems():
@@ -7536,15 +8907,14 @@
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("map.from_py.__pyx_convert_map_from_py_std_3a__3a_string__and_double", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_pretend_to_initialize(&__pyx_r);
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_d);
   __Pyx_XDECREF(__pyx_v_key);
   __Pyx_XDECREF(__pyx_v_value);
-  __Pyx_TraceReturn(Py_None, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 static struct __pyx_vtabstruct_9multimcts_4mcts_Node __pyx_vtable_9multimcts_4mcts_Node;
 
 static PyObject *__pyx_tp_new_9multimcts_4mcts_Node(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_obj_9multimcts_4mcts_Node *p;
@@ -7553,112 +8923,107 @@
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
   p = ((struct __pyx_obj_9multimcts_4mcts_Node *)o);
   p->__pyx_vtab = __pyx_vtabptr_9multimcts_4mcts_Node;
-  new((void*)&(p->cteam)) std::string();
+  new((void*)&(p->team)) std::string();
   new((void*)&(p->rewards)) std::map<std::string,double> ();
+  new((void*)&(p->rave_rewards)) std::map<std::string,double> ();
   p->state = Py_None; Py_INCREF(Py_None);
   p->move = Py_None; Py_INCREF(Py_None);
-  p->team = Py_None; Py_INCREF(Py_None);
-  p->parent = ((struct __pyx_obj_9multimcts_4mcts_Node *)Py_None); Py_INCREF(Py_None);
   p->children = Py_None; Py_INCREF(Py_None);
   p->remaining_moves = Py_None; Py_INCREF(Py_None);
+  p->parent = ((struct __pyx_obj_9multimcts_4mcts_Node *)Py_None); Py_INCREF(Py_None);
   return o;
 }
 
 static void __pyx_tp_dealloc_9multimcts_4mcts_Node(PyObject *o) {
   struct __pyx_obj_9multimcts_4mcts_Node *p = (struct __pyx_obj_9multimcts_4mcts_Node *)o;
   #if CYTHON_USE_TP_FINALIZE
   if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !__Pyx_PyObject_GC_IsFinalized(o)) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
-  __Pyx_call_destructor(p->cteam);
+  __Pyx_call_destructor(p->team);
   __Pyx_call_destructor(p->rewards);
+  __Pyx_call_destructor(p->rave_rewards);
   Py_CLEAR(p->state);
   Py_CLEAR(p->move);
-  Py_CLEAR(p->team);
-  Py_CLEAR(p->parent);
   Py_CLEAR(p->children);
   Py_CLEAR(p->remaining_moves);
+  Py_CLEAR(p->parent);
   (*Py_TYPE(o)->tp_free)(o);
 }
 
 static int __pyx_tp_traverse_9multimcts_4mcts_Node(PyObject *o, visitproc v, void *a) {
   int e;
   struct __pyx_obj_9multimcts_4mcts_Node *p = (struct __pyx_obj_9multimcts_4mcts_Node *)o;
   if (p->state) {
     e = (*v)(p->state, a); if (e) return e;
   }
   if (p->move) {
     e = (*v)(p->move, a); if (e) return e;
   }
-  if (p->team) {
-    e = (*v)(p->team, a); if (e) return e;
-  }
-  if (p->parent) {
-    e = (*v)(((PyObject *)p->parent), a); if (e) return e;
-  }
   if (p->children) {
     e = (*v)(p->children, a); if (e) return e;
   }
   if (p->remaining_moves) {
     e = (*v)(p->remaining_moves, a); if (e) return e;
   }
+  if (p->parent) {
+    e = (*v)(((PyObject *)p->parent), a); if (e) return e;
+  }
   return 0;
 }
 
 static int __pyx_tp_clear_9multimcts_4mcts_Node(PyObject *o) {
   PyObject* tmp;
   struct __pyx_obj_9multimcts_4mcts_Node *p = (struct __pyx_obj_9multimcts_4mcts_Node *)o;
   tmp = ((PyObject*)p->state);
   p->state = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
   tmp = ((PyObject*)p->move);
   p->move = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
-  tmp = ((PyObject*)p->team);
-  p->team = Py_None; Py_INCREF(Py_None);
-  Py_XDECREF(tmp);
-  tmp = ((PyObject*)p->parent);
-  p->parent = ((struct __pyx_obj_9multimcts_4mcts_Node *)Py_None); Py_INCREF(Py_None);
-  Py_XDECREF(tmp);
   tmp = ((PyObject*)p->children);
   p->children = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
   tmp = ((PyObject*)p->remaining_moves);
   p->remaining_moves = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
+  tmp = ((PyObject*)p->parent);
+  p->parent = ((struct __pyx_obj_9multimcts_4mcts_Node *)Py_None); Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
   return 0;
 }
 
-static PyObject *__pyx_getprop_9multimcts_4mcts_4Node_state(PyObject *o, CYTHON_UNUSED void *x) {
-  return __pyx_pw_9multimcts_4mcts_4Node_5state_1__get__(o);
-}
-
-static PyObject *__pyx_getprop_9multimcts_4mcts_4Node_rewards(PyObject *o, CYTHON_UNUSED void *x) {
-  return __pyx_pw_9multimcts_4mcts_4Node_7rewards_1__get__(o);
-}
-
 static PyMethodDef __pyx_methods_9multimcts_4mcts_Node[] = {
-  {"__reduce_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_3__reduce_cython__, METH_NOARGS, 0},
-  {"__setstate_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_5__setstate_cython__, METH_O, 0},
+  {"get_state", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_3get_state, METH_NOARGS, 0},
+  {"get_team", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_5get_team, METH_NOARGS, 0},
+  {"get_move", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_7get_move, METH_NOARGS, 0},
+  {"get_parent", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_9get_parent, METH_NOARGS, 0},
+  {"get_children", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_11get_children, METH_NOARGS, 0},
+  {"get_visits", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_13get_visits, METH_NOARGS, 0},
+  {"get_rewards", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_15get_rewards, METH_NOARGS, 0},
+  {"get_avg_reward", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_17get_avg_reward, METH_NOARGS, 0},
+  {"get_rave_visits", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_19get_rave_visits, METH_NOARGS, 0},
+  {"get_rave_rewards", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_21get_rave_rewards, METH_NOARGS, 0},
+  {"get_avg_rave_reward", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_23get_avg_rave_reward, METH_NOARGS, 0},
+  {"uncertainty", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_25uncertainty, METH_O, 0},
+  {"ucb", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_27ucb, METH_O, __pyx_doc_9multimcts_4mcts_4Node_26ucb},
+  {"rave_beta", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_29rave_beta, METH_O, __pyx_doc_9multimcts_4mcts_4Node_28rave_beta},
+  {"score", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9multimcts_4mcts_4Node_31score, METH_VARARGS|METH_KEYWORDS, 0},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_33__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_35__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
-static struct PyGetSetDef __pyx_getsets_9multimcts_4mcts_Node[] = {
-  {(char *)"state", __pyx_getprop_9multimcts_4mcts_4Node_state, 0, (char *)0, 0},
-  {(char *)"rewards", __pyx_getprop_9multimcts_4mcts_4Node_rewards, 0, (char *)0, 0},
-  {0, 0, 0, 0, 0}
-};
-
 static PyTypeObject __pyx_type_9multimcts_4mcts_Node = {
   PyVarObject_HEAD_INIT(0, 0)
   "multimcts.mcts.Node", /*tp_name*/
   sizeof(struct __pyx_obj_9multimcts_4mcts_Node), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_9multimcts_4mcts_Node, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
@@ -7682,24 +9047,24 @@
   0, /*tp_hash*/
   0, /*tp_call*/
   0, /*tp_str*/
   0, /*tp_getattro*/
   0, /*tp_setattro*/
   0, /*tp_as_buffer*/
   Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
-  "Represents a game state node in the MCTS search tree.\n    Args:\n        state (GameState): The game state at the current node.\n        parent (Node): The parent of the current node in the search tree.\n        move (Move): The move that was played from the parent node to get to this node.\n    Attributes:\n        children (List[Node]): The child nodes of the current node. These represent legal moves that have been visited.\n        visits (int): The number of times the node has been visited.\n        rewards (dict): All teams' rewards obtained from simulations through the node. Keys are teams; values are rewards.\n        is_terminal (bool): Whether the node represents a terminal state.\n        is_fully_expanded (bool): Whether all children of the node have been visited.\n        remaining_moves (list): A list of moves that have not yet been tried.\n    ", /*tp_doc*/
+  "Represents a game state node in the MCTS search tree.\n    Args:\n        state (GameState): The game state at the current node.\n        parent (Node): The parent of the current node in the search tree.\n        move (Move): The move that was played from the parent node to get to this node.\n    Attributes:\n        children (Dict[Move,Node]): The child nodes of the current node. These represent legal moves that have been visited.\n        visits (int): The number of times the node has been visited.\n        rewards (dict): All teams' rewards obtained from simulations through the node. Keys are teams; values are rewards.\n        is_terminal (bool): Whether the node represents a terminal state.\n        is_fully_expanded (bool): Whether all children of the node have been visited.\n        remaining_moves (list): A list of moves that have not yet been tried.\n    ", /*tp_doc*/
   __pyx_tp_traverse_9multimcts_4mcts_Node, /*tp_traverse*/
   __pyx_tp_clear_9multimcts_4mcts_Node, /*tp_clear*/
   0, /*tp_richcompare*/
   0, /*tp_weaklistoffset*/
   0, /*tp_iter*/
   0, /*tp_iternext*/
   __pyx_methods_9multimcts_4mcts_Node, /*tp_methods*/
   0, /*tp_members*/
-  __pyx_getsets_9multimcts_4mcts_Node, /*tp_getset*/
+  0, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
   0, /*tp_dictoffset*/
   __pyx_pw_9multimcts_4mcts_4Node_1__init__, /*tp_init*/
   0, /*tp_alloc*/
@@ -7722,27 +9087,23 @@
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
   #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
-static struct __pyx_vtabstruct_9multimcts_4mcts_MCTS __pyx_vtable_9multimcts_4mcts_MCTS;
 
 static PyObject *__pyx_tp_new_9multimcts_4mcts_MCTS(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
-  struct __pyx_obj_9multimcts_4mcts_MCTS *p;
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  p = ((struct __pyx_obj_9multimcts_4mcts_MCTS *)o);
-  p->__pyx_vtab = __pyx_vtabptr_9multimcts_4mcts_MCTS;
   return o;
 }
 
 static void __pyx_tp_dealloc_9multimcts_4mcts_MCTS(PyObject *o) {
   #if CYTHON_USE_TP_FINALIZE
   if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !__Pyx_PyObject_GC_IsFinalized(o))) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
@@ -7751,23 +9112,28 @@
   (*Py_TYPE(o)->tp_free)(o);
 }
 
 static PyObject *__pyx_getprop_9multimcts_4mcts_4MCTS_exploration_bias(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_9multimcts_4mcts_4MCTS_16exploration_bias_1__get__(o);
 }
 
+static PyObject *__pyx_getprop_9multimcts_4mcts_4MCTS_rave_bias(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_9multimcts_4mcts_4MCTS_9rave_bias_1__get__(o);
+}
+
 static PyMethodDef __pyx_methods_9multimcts_4mcts_MCTS[] = {
   {"search", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9multimcts_4mcts_4MCTS_3search, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9multimcts_4mcts_4MCTS_2search},
   {"__reduce_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4MCTS_5__reduce_cython__, METH_NOARGS, 0},
   {"__setstate_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4MCTS_7__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_9multimcts_4mcts_MCTS[] = {
   {(char *)"exploration_bias", __pyx_getprop_9multimcts_4mcts_4MCTS_exploration_bias, 0, (char *)0, 0},
+  {(char *)"rave_bias", __pyx_getprop_9multimcts_4mcts_4MCTS_rave_bias, 0, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type_9multimcts_4mcts_MCTS = {
   PyVarObject_HEAD_INIT(0, 0)
   "multimcts.mcts.MCTS", /*tp_name*/
   sizeof(struct __pyx_obj_9multimcts_4mcts_MCTS), /*tp_basicsize*/
@@ -7881,28 +9247,29 @@
     #define CYTHON_SMALL_CODE __attribute__((cold))
 #else
     #define CYTHON_SMALL_CODE
 #endif
 #endif
 
 static __Pyx_StringTabEntry __pyx_string_tab[] = {
-  {&__pyx_n_s_Any, __pyx_k_Any, sizeof(__pyx_k_Any), 0, 0, 1, 1},
+  {&__pyx_kp_u_Could_not_determine_terminal_tea, __pyx_k_Could_not_determine_terminal_tea, sizeof(__pyx_k_Could_not_determine_terminal_tea), 0, 1, 0, 0},
   {&__pyx_n_s_Dict, __pyx_k_Dict, sizeof(__pyx_k_Dict), 0, 0, 1, 1},
   {&__pyx_n_s_GameState, __pyx_k_GameState, sizeof(__pyx_k_GameState), 0, 0, 1, 1},
   {&__pyx_n_u_GameState, __pyx_k_GameState, sizeof(__pyx_k_GameState), 0, 1, 0, 1},
   {&__pyx_n_s_GameState_get_current_team, __pyx_k_GameState_get_current_team, sizeof(__pyx_k_GameState_get_current_team), 0, 0, 1, 1},
   {&__pyx_n_s_GameState_get_legal_moves, __pyx_k_GameState_get_legal_moves, sizeof(__pyx_k_GameState_get_legal_moves), 0, 0, 1, 1},
   {&__pyx_n_s_GameState_get_reward, __pyx_k_GameState_get_reward, sizeof(__pyx_k_GameState_get_reward), 0, 0, 1, 1},
   {&__pyx_n_s_GameState_is_terminal, __pyx_k_GameState_is_terminal, sizeof(__pyx_k_GameState_is_terminal), 0, 0, 1, 1},
   {&__pyx_n_s_GameState_make_move, __pyx_k_GameState_make_move, sizeof(__pyx_k_GameState_make_move), 0, 0, 1, 1},
   {&__pyx_kp_u_GameState_must_implement_get_cur, __pyx_k_GameState_must_implement_get_cur, sizeof(__pyx_k_GameState_must_implement_get_cur), 0, 1, 0, 0},
   {&__pyx_kp_u_GameState_must_implement_get_leg, __pyx_k_GameState_must_implement_get_leg, sizeof(__pyx_k_GameState_must_implement_get_leg), 0, 1, 0, 0},
   {&__pyx_kp_u_GameState_must_implement_get_rew, __pyx_k_GameState_must_implement_get_rew, sizeof(__pyx_k_GameState_must_implement_get_rew), 0, 1, 0, 0},
   {&__pyx_kp_u_GameState_must_implement_is_term, __pyx_k_GameState_must_implement_is_term, sizeof(__pyx_k_GameState_must_implement_is_term), 0, 1, 0, 0},
   {&__pyx_kp_u_GameState_must_implement_make_mo, __pyx_k_GameState_must_implement_make_mo, sizeof(__pyx_k_GameState_must_implement_make_mo), 0, 1, 0, 0},
+  {&__pyx_n_s_Hashable, __pyx_k_Hashable, sizeof(__pyx_k_Hashable), 0, 0, 1, 1},
   {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
   {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0_2, __pyx_k_Incompatible_checksums_0x_x_vs_0_2, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0_2), 0, 0, 1, 0},
   {&__pyx_kp_u_Invalid_return_type, __pyx_k_Invalid_return_type, sizeof(__pyx_k_Invalid_return_type), 0, 1, 0, 0},
   {&__pyx_n_s_List, __pyx_k_List, sizeof(__pyx_k_List), 0, 0, 1, 1},
   {&__pyx_n_s_MCTS, __pyx_k_MCTS, sizeof(__pyx_k_MCTS), 0, 0, 1, 1},
   {&__pyx_n_s_Move, __pyx_k_Move, sizeof(__pyx_k_Move), 0, 0, 1, 1},
   {&__pyx_n_s_Node, __pyx_k_Node, sizeof(__pyx_k_Node), 0, 0, 1, 1},
@@ -7910,40 +9277,39 @@
   {&__pyx_n_s_NotImplementedError, __pyx_k_NotImplementedError, sizeof(__pyx_k_NotImplementedError), 0, 0, 1, 1},
   {&__pyx_kp_u_One_or_more_of_max_time_max_iter, __pyx_k_One_or_more_of_max_time_max_iter, sizeof(__pyx_k_One_or_more_of_max_time_max_iter), 0, 1, 0, 0},
   {&__pyx_n_s_PickleError, __pyx_k_PickleError, sizeof(__pyx_k_PickleError), 0, 0, 1, 1},
   {&__pyx_n_s_Rewards, __pyx_k_Rewards, sizeof(__pyx_k_Rewards), 0, 0, 1, 1},
   {&__pyx_n_s_Team, __pyx_k_Team, sizeof(__pyx_k_Team), 0, 0, 1, 1},
   {&__pyx_n_s_Union, __pyx_k_Union, sizeof(__pyx_k_Union), 0, 0, 1, 1},
   {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
-  {&__pyx_n_s_append, __pyx_k_append, sizeof(__pyx_k_append), 0, 0, 1, 1},
   {&__pyx_n_s_choice, __pyx_k_choice, sizeof(__pyx_k_choice), 0, 0, 1, 1},
   {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
   {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
   {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
   {&__pyx_n_s_exploration_bias, __pyx_k_exploration_bias, sizeof(__pyx_k_exploration_bias), 0, 0, 1, 1},
   {&__pyx_n_s_get_current_team, __pyx_k_get_current_team, sizeof(__pyx_k_get_current_team), 0, 0, 1, 1},
   {&__pyx_n_s_get_legal_moves, __pyx_k_get_legal_moves, sizeof(__pyx_k_get_legal_moves), 0, 0, 1, 1},
   {&__pyx_n_s_get_reward, __pyx_k_get_reward, sizeof(__pyx_k_get_reward), 0, 0, 1, 1},
   {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
-  {&__pyx_n_s_heuristic, __pyx_k_heuristic, sizeof(__pyx_k_heuristic), 0, 0, 1, 1},
   {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
   {&__pyx_n_s_is_terminal, __pyx_k_is_terminal, sizeof(__pyx_k_is_terminal), 0, 0, 1, 1},
+  {&__pyx_n_s_items, __pyx_k_items, sizeof(__pyx_k_items), 0, 0, 1, 1},
   {&__pyx_n_s_iteritems, __pyx_k_iteritems, sizeof(__pyx_k_iteritems), 0, 0, 1, 1},
-  {&__pyx_n_s_lower, __pyx_k_lower, sizeof(__pyx_k_lower), 0, 0, 1, 1},
+  {&__pyx_n_s_keys, __pyx_k_keys, sizeof(__pyx_k_keys), 0, 0, 1, 1},
   {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
   {&__pyx_n_s_make_move, __pyx_k_make_move, sizeof(__pyx_k_make_move), 0, 0, 1, 1},
   {&__pyx_n_s_max_iterations, __pyx_k_max_iterations, sizeof(__pyx_k_max_iterations), 0, 0, 1, 1},
   {&__pyx_n_s_max_time, __pyx_k_max_time, sizeof(__pyx_k_max_time), 0, 0, 1, 1},
   {&__pyx_n_s_metaclass, __pyx_k_metaclass, sizeof(__pyx_k_metaclass), 0, 0, 1, 1},
   {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
   {&__pyx_n_s_move, __pyx_k_move, sizeof(__pyx_k_move), 0, 0, 1, 1},
   {&__pyx_n_u_move, __pyx_k_move, sizeof(__pyx_k_move), 0, 1, 0, 1},
   {&__pyx_n_s_multimcts_mcts, __pyx_k_multimcts_mcts, sizeof(__pyx_k_multimcts_mcts), 0, 0, 1, 1},
   {&__pyx_kp_s_multimcts_mcts_pyx, __pyx_k_multimcts_mcts_pyx, sizeof(__pyx_k_multimcts_mcts_pyx), 0, 0, 1, 0},
-  {&__pyx_kp_u_must_be_one_of, __pyx_k_must_be_one_of, sizeof(__pyx_k_must_be_one_of), 0, 1, 0, 0},
+  {&__pyx_kp_u_must_be_one_of_state_move_node, __pyx_k_must_be_one_of_state_move_node, sizeof(__pyx_k_must_be_one_of_state_move_node), 0, 1, 0, 0},
   {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
   {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
   {&__pyx_n_u_node, __pyx_k_node, sizeof(__pyx_k_node), 0, 1, 0, 1},
   {&__pyx_n_s_parent, __pyx_k_parent, sizeof(__pyx_k_parent), 0, 0, 1, 1},
   {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
   {&__pyx_n_s_pop, __pyx_k_pop, sizeof(__pyx_k_pop), 0, 0, 1, 1},
   {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
@@ -7953,35 +9319,43 @@
   {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_unpickle_MCTS, __pyx_k_pyx_unpickle_MCTS, sizeof(__pyx_k_pyx_unpickle_MCTS), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_unpickle_Node, __pyx_k_pyx_unpickle_Node, sizeof(__pyx_k_pyx_unpickle_Node), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
   {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
   {&__pyx_n_s_random, __pyx_k_random, sizeof(__pyx_k_random), 0, 0, 1, 1},
+  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
+  {&__pyx_n_s_rave_beta, __pyx_k_rave_beta, sizeof(__pyx_k_rave_beta), 0, 0, 1, 1},
+  {&__pyx_n_s_rave_bias, __pyx_k_rave_bias, sizeof(__pyx_k_rave_bias), 0, 0, 1, 1},
   {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
   {&__pyx_n_s_return, __pyx_k_return, sizeof(__pyx_k_return), 0, 0, 1, 1},
   {&__pyx_n_s_return_type, __pyx_k_return_type, sizeof(__pyx_k_return_type), 0, 0, 1, 1},
+  {&__pyx_n_s_score, __pyx_k_score, sizeof(__pyx_k_score), 0, 0, 1, 1},
   {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
   {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
   {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
   {&__pyx_n_s_shuffle, __pyx_k_shuffle, sizeof(__pyx_k_shuffle), 0, 0, 1, 1},
   {&__pyx_n_s_state, __pyx_k_state, sizeof(__pyx_k_state), 0, 0, 1, 1},
   {&__pyx_n_u_state, __pyx_k_state, sizeof(__pyx_k_state), 0, 1, 0, 1},
   {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
   {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
   {&__pyx_n_s_time, __pyx_k_time, sizeof(__pyx_k_time), 0, 0, 1, 1},
   {&__pyx_n_s_typing, __pyx_k_typing, sizeof(__pyx_k_typing), 0, 0, 1, 1},
+  {&__pyx_n_s_ucb, __pyx_k_ucb, sizeof(__pyx_k_ucb), 0, 0, 1, 1},
+  {&__pyx_n_s_uncertainty, __pyx_k_uncertainty, sizeof(__pyx_k_uncertainty), 0, 0, 1, 1},
   {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
+  {&__pyx_n_s_values, __pyx_k_values, sizeof(__pyx_k_values), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
   __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s_NotImplementedError); if (!__pyx_builtin_NotImplementedError) __PYX_ERR(0, 24, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 162, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 250, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 348, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
@@ -7990,177 +9364,188 @@
   /* "multimcts/mcts.pyx":24
  *     def get_current_team(self) -> Team:
  *         """The identifier of the current player's team."""
  *         raise NotImplementedError("GameState must implement get_current_team.")             # <<<<<<<<<<<<<<
  * 
  *     def get_legal_moves(self) -> List[Move]:
  */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_cur); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 24, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__2);
-  __Pyx_GIVEREF(__pyx_tuple__2);
+  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_cur); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 24, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple_);
+  __Pyx_GIVEREF(__pyx_tuple_);
 
   /* "multimcts/mcts.pyx":28
  *     def get_legal_moves(self) -> List[Move]:
  *         """List of all legal moves from this state."""
  *         raise NotImplementedError("GameState must implement get_legal_moves.")             # <<<<<<<<<<<<<<
  * 
  *     def make_move(self, move:Move) -> 'GameState':
  */
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_leg); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 28, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__4);
-  __Pyx_GIVEREF(__pyx_tuple__4);
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_leg); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 28, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__2);
+  __Pyx_GIVEREF(__pyx_tuple__2);
 
   /* "multimcts/mcts.pyx":34
  *         Note: The current state (self) should NOT be modified. Rather, modify a copy of it.
  *         """
  *         raise NotImplementedError("GameState must implement make_move.")             # <<<<<<<<<<<<<<
  * 
  *     def is_terminal(self) -> bool:
  */
-  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_make_mo); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 34, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__6);
-  __Pyx_GIVEREF(__pyx_tuple__6);
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_make_mo); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 34, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__3);
+  __Pyx_GIVEREF(__pyx_tuple__3);
 
   /* "multimcts/mcts.pyx":38
  *     def is_terminal(self) -> bool:
  *         """Is the game over?"""
  *         raise NotImplementedError("GameState must implement is_terminal.")             # <<<<<<<<<<<<<<
  * 
  *     def get_reward(self) -> Union[float,Rewards]:
  */
-  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_is_term); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 38, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__8);
-  __Pyx_GIVEREF(__pyx_tuple__8);
+  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_is_term); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 38, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__4);
+  __Pyx_GIVEREF(__pyx_tuple__4);
 
   /* "multimcts/mcts.pyx":46
  *         Note: This method is only called on terminal states.
  *         """
  *         raise NotImplementedError("GameState must implement get_reward.")             # <<<<<<<<<<<<<<
  * 
- * 
+ *     '''#.WIP
  */
-  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_rew); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 46, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__10);
-  __Pyx_GIVEREF(__pyx_tuple__10);
+  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_rew); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 46, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__5);
+  __Pyx_GIVEREF(__pyx_tuple__5);
 
-  /* "multimcts/mcts.pyx":165
- * 
+  /* "multimcts/mcts.pyx":250
+ *                 terminal_team = prev_state.get_current_team()
+ *             else:
+ *                 raise ValueError("Could not determine terminal team during simulation.")             # <<<<<<<<<<<<<<
+ *             reward = {terminal_team: reward}
+ *         cdef map[string,double] crewards = map[string,double]()
+ */
+  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_u_Could_not_determine_terminal_tea); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 250, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__6);
+  __Pyx_GIVEREF(__pyx_tuple__6);
+
+  /* "multimcts/mcts.pyx":292
+ *         """
  *         if max_time is None and max_iterations is None:
- *             raise ValueError("One or more of max_time/max_iterations is required.")             # <<<<<<<<<<<<<<
+ *             raise ValueError('One or more of max_time/max_iterations is required.')             # <<<<<<<<<<<<<<
  * 
- *         node = Node(state)
+ *         if return_type not in {'state','move','node'}:
  */
-  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_u_One_or_more_of_max_time_max_iter); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 165, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__11);
-  __Pyx_GIVEREF(__pyx_tuple__11);
+  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_u_One_or_more_of_max_time_max_iter); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(0, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__7);
+  __Pyx_GIVEREF(__pyx_tuple__7);
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x357fa0f, 0x5f4daba, 0x391d535):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0xf2c96f8, 0x996f7e4, 0x2d45624):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  */
-  __pyx_tuple__13 = PyTuple_Pack(3, __pyx_int_56097295, __pyx_int_99932858, __pyx_int_59888949); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__13);
-  __Pyx_GIVEREF(__pyx_tuple__13);
-  __pyx_tuple__15 = PyTuple_Pack(3, __pyx_int_203704333, __pyx_int_231097371, __pyx_int_82662024); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__15);
-  __Pyx_GIVEREF(__pyx_tuple__15);
+  __pyx_tuple__8 = PyTuple_Pack(3, __pyx_int_254580472, __pyx_int_160888804, __pyx_int_47470116); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__8);
+  __Pyx_GIVEREF(__pyx_tuple__8);
+  __pyx_tuple__9 = PyTuple_Pack(3, __pyx_int_145648438, __pyx_int_186508213, __pyx_int_233936184); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__9);
+  __Pyx_GIVEREF(__pyx_tuple__9);
 
   /* "multimcts/mcts.pyx":22
  * 
  * class GameState:
  *     def get_current_team(self) -> Team:             # <<<<<<<<<<<<<<
  *         """The identifier of the current player's team."""
  *         raise NotImplementedError("GameState must implement get_current_team.")
  */
-  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 22, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__16);
-  __Pyx_GIVEREF(__pyx_tuple__16);
-  __pyx_codeobj_ = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_current_team, 22, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj_)) __PYX_ERR(0, 22, __pyx_L1_error)
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 22, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__10);
+  __Pyx_GIVEREF(__pyx_tuple__10);
+  __pyx_codeobj__11 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__10, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_current_team, 22, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__11)) __PYX_ERR(0, 22, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":26
  *         raise NotImplementedError("GameState must implement get_current_team.")
  * 
  *     def get_legal_moves(self) -> List[Move]:             # <<<<<<<<<<<<<<
  *         """List of all legal moves from this state."""
  *         raise NotImplementedError("GameState must implement get_legal_moves.")
  */
-  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(0, 26, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__17);
-  __Pyx_GIVEREF(__pyx_tuple__17);
-  __pyx_codeobj__3 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__17, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_legal_moves, 26, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__3)) __PYX_ERR(0, 26, __pyx_L1_error)
+  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 26, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__12);
+  __Pyx_GIVEREF(__pyx_tuple__12);
+  __pyx_codeobj__13 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__12, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_legal_moves, 26, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__13)) __PYX_ERR(0, 26, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":30
  *         raise NotImplementedError("GameState must implement get_legal_moves.")
  * 
  *     def make_move(self, move:Move) -> 'GameState':             # <<<<<<<<<<<<<<
  *         """A new GameState--the result of applying the given move to this state.
  *         Note: The current state (self) should NOT be modified. Rather, modify a copy of it.
  */
-  __pyx_tuple__18 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_move); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 30, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__18);
-  __Pyx_GIVEREF(__pyx_tuple__18);
-  __pyx_codeobj__5 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__18, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_make_move, 30, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__5)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __pyx_tuple__14 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_move); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__14);
+  __Pyx_GIVEREF(__pyx_tuple__14);
+  __pyx_codeobj__15 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__14, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_make_move, 30, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__15)) __PYX_ERR(0, 30, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":36
  *         raise NotImplementedError("GameState must implement make_move.")
  * 
  *     def is_terminal(self) -> bool:             # <<<<<<<<<<<<<<
  *         """Is the game over?"""
  *         raise NotImplementedError("GameState must implement is_terminal.")
  */
-  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(0, 36, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__19);
-  __Pyx_GIVEREF(__pyx_tuple__19);
-  __pyx_codeobj__7 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__19, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_is_terminal, 36, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__7)) __PYX_ERR(0, 36, __pyx_L1_error)
+  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 36, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__16);
+  __Pyx_GIVEREF(__pyx_tuple__16);
+  __pyx_codeobj__17 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_is_terminal, 36, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__17)) __PYX_ERR(0, 36, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":40
  *         raise NotImplementedError("GameState must implement is_terminal.")
  * 
  *     def get_reward(self) -> Union[float,Rewards]:             # <<<<<<<<<<<<<<
- *         """The reward earned by the team that played the game-ending move (the "terminal team", or the team from the previous state).
+ *         """The reward earned by the team that played the game-ending move (i.e. the team from the previous state).
  *         Typically 1 for win, -1 for loss, 0 for draw.
  */
-  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 40, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__20);
-  __Pyx_GIVEREF(__pyx_tuple__20);
-  __pyx_codeobj__9 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__20, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_reward, 40, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__9)) __PYX_ERR(0, 40, __pyx_L1_error)
+  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 40, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__18);
+  __Pyx_GIVEREF(__pyx_tuple__18);
+  __pyx_codeobj__19 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__18, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_reward, 40, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__19)) __PYX_ERR(0, 40, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Node(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_tuple__21 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__21);
-  __Pyx_GIVEREF(__pyx_tuple__21);
-  __pyx_codeobj__12 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Node, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__12)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_tuple__20 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__20);
+  __Pyx_GIVEREF(__pyx_tuple__20);
+  __pyx_codeobj__21 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__20, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Node, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__21)) __PYX_ERR(1, 1, __pyx_L1_error)
   __pyx_tuple__22 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__22);
   __Pyx_GIVEREF(__pyx_tuple__22);
-  __pyx_codeobj__14 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__22, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_MCTS, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__14)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_codeobj__23 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__22, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_MCTS, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__23)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
   __pyx_umethod_PyList_Type_pop.type = (PyObject*)&PyList_Type;
   if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_56097295 = PyInt_FromLong(56097295L); if (unlikely(!__pyx_int_56097295)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_59888949 = PyInt_FromLong(59888949L); if (unlikely(!__pyx_int_59888949)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_82662024 = PyInt_FromLong(82662024L); if (unlikely(!__pyx_int_82662024)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_99932858 = PyInt_FromLong(99932858L); if (unlikely(!__pyx_int_99932858)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_203704333 = PyInt_FromLong(203704333L); if (unlikely(!__pyx_int_203704333)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_231097371 = PyInt_FromLong(231097371L); if (unlikely(!__pyx_int_231097371)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_47470116 = PyInt_FromLong(47470116L); if (unlikely(!__pyx_int_47470116)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_145648438 = PyInt_FromLong(145648438L); if (unlikely(!__pyx_int_145648438)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_160888804 = PyInt_FromLong(160888804L); if (unlikely(!__pyx_int_160888804)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_186508213 = PyInt_FromLong(186508213L); if (unlikely(!__pyx_int_186508213)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_233936184 = PyInt_FromLong(233936184L); if (unlikely(!__pyx_int_233936184)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_254580472 = PyInt_FromLong(254580472L); if (unlikely(!__pyx_int_254580472)) __PYX_ERR(0, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
@@ -8198,53 +9583,53 @@
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
   __pyx_vtabptr_9multimcts_4mcts_Node = &__pyx_vtable_9multimcts_4mcts_Node;
-  __pyx_vtable_9multimcts_4mcts_Node.apply_rewards = (PyObject *(*)(struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> ))__pyx_f_9multimcts_4mcts_4Node_apply_rewards;
-  __pyx_vtable_9multimcts_4mcts_Node.ucb = (double (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double))__pyx_f_9multimcts_4mcts_4Node_ucb;
-  if (PyType_Ready(&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
+  __pyx_vtable_9multimcts_4mcts_Node.visit = (PyObject *(*)(struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> , PyObject *))__pyx_f_9multimcts_4mcts_4Node_visit;
+  __pyx_vtable_9multimcts_4mcts_Node.uncertainty = (double (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch))__pyx_f_9multimcts_4mcts_4Node_uncertainty;
+  __pyx_vtable_9multimcts_4mcts_Node.ucb = (double (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch))__pyx_f_9multimcts_4mcts_4Node_ucb;
+  __pyx_vtable_9multimcts_4mcts_Node.rave_beta = (double (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch))__pyx_f_9multimcts_4mcts_4Node_rave_beta;
+  __pyx_vtable_9multimcts_4mcts_Node.score = (double (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double, int __pyx_skip_dispatch))__pyx_f_9multimcts_4mcts_4Node_score;
+  __pyx_vtable_9multimcts_4mcts_Node.best_child = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double))__pyx_f_9multimcts_4mcts_4Node_best_child;
+  __pyx_vtable_9multimcts_4mcts_Node.select = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double))__pyx_f_9multimcts_4mcts_4Node_select;
+  __pyx_vtable_9multimcts_4mcts_Node.expand = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_Node *))__pyx_f_9multimcts_4mcts_4Node_expand;
+  __pyx_vtable_9multimcts_4mcts_Node.execute_round = (void (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double))__pyx_f_9multimcts_4mcts_4Node_execute_round;
+  if (PyType_Ready(&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_9multimcts_4mcts_Node.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9multimcts_4mcts_Node.tp_dictoffset && __pyx_type_9multimcts_4mcts_Node.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_9multimcts_4mcts_Node.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type_9multimcts_4mcts_Node.tp_dict, __pyx_vtabptr_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Node, (PyObject *)&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type_9multimcts_4mcts_Node.tp_dict, __pyx_vtabptr_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Node, (PyObject *)&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
   __pyx_ptype_9multimcts_4mcts_Node = &__pyx_type_9multimcts_4mcts_Node;
-  __pyx_vtabptr_9multimcts_4mcts_MCTS = &__pyx_vtable_9multimcts_4mcts_MCTS;
-  __pyx_vtable_9multimcts_4mcts_MCTS.select = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *))__pyx_f_9multimcts_4mcts_4MCTS_select;
-  __pyx_vtable_9multimcts_4mcts_MCTS.expand = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *))__pyx_f_9multimcts_4mcts_4MCTS_expand;
-  __pyx_vtable_9multimcts_4mcts_MCTS.simulate = (std::map<std::string,double>  (*)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *, struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate *__pyx_optional_args))__pyx_f_9multimcts_4mcts_4MCTS_simulate;
-  __pyx_vtable_9multimcts_4mcts_MCTS.backpropagate = (PyObject *(*)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> ))__pyx_f_9multimcts_4mcts_4MCTS_backpropagate;
-  __pyx_vtable_9multimcts_4mcts_MCTS.get_best_child = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *))__pyx_f_9multimcts_4mcts_4MCTS_get_best_child;
-  if (PyType_Ready(&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 134, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 264, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_9multimcts_4mcts_MCTS.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9multimcts_4mcts_MCTS.tp_dictoffset && __pyx_type_9multimcts_4mcts_MCTS.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_9multimcts_4mcts_MCTS.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
   #if CYTHON_UPDATE_DESCRIPTOR_DOC
   {
-    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_9multimcts_4mcts_MCTS, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 134, __pyx_L1_error)
+    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_9multimcts_4mcts_MCTS, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 264, __pyx_L1_error)
     if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
       __pyx_wrapperbase_9multimcts_4mcts_4MCTS___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
       __pyx_wrapperbase_9multimcts_4mcts_4MCTS___init__.doc = __pyx_doc_9multimcts_4mcts_4MCTS___init__;
       ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_9multimcts_4mcts_4MCTS___init__;
     }
   }
   #endif
-  if (__Pyx_SetVtable(__pyx_type_9multimcts_4mcts_MCTS.tp_dict, __pyx_vtabptr_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 134, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_MCTS, (PyObject *)&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 134, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 134, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_MCTS, (PyObject *)&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 264, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 264, __pyx_L1_error)
   __pyx_ptype_9multimcts_4mcts_MCTS = &__pyx_type_9multimcts_4mcts_MCTS;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
@@ -8363,15 +9748,14 @@
 }
 
 
 static CYTHON_SMALL_CODE int __pyx_pymod_exec_mcts(PyObject *__pyx_pyinit_module)
 #endif
 #endif
 {
-  __Pyx_TraceDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
@@ -8473,22 +9857,21 @@
   (void)__Pyx_modinit_type_import_code();
   (void)__Pyx_modinit_variable_import_code();
   (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
-  __Pyx_TraceCall("__Pyx_PyMODINIT_FUNC PyInit_mcts(void)", __pyx_f[0], 1, 0, __PYX_ERR(0, 1, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":5
- * # cython: profile=True
+ * # cython: profile=False
  * 
  * from time import time             # <<<<<<<<<<<<<<
  * from random import shuffle, choice
- * from typing import Union, Dict, List, Any
+ * from typing import Union, Dict, List, Hashable
  */
   __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_n_s_time);
   __Pyx_GIVEREF(__pyx_n_s_time);
   PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_time);
   __pyx_t_2 = __Pyx_Import(__pyx_n_s_time, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5, __pyx_L1_error)
@@ -8500,15 +9883,15 @@
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "multimcts/mcts.pyx":6
  * 
  * from time import time
  * from random import shuffle, choice             # <<<<<<<<<<<<<<
- * from typing import Union, Dict, List, Any
+ * from typing import Union, Dict, List, Hashable
  * 
  */
   __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 6, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_shuffle);
   __Pyx_GIVEREF(__pyx_n_s_shuffle);
   PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_shuffle);
@@ -8527,32 +9910,32 @@
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_choice, __pyx_t_2) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "multimcts/mcts.pyx":7
  * from time import time
  * from random import shuffle, choice
- * from typing import Union, Dict, List, Any             # <<<<<<<<<<<<<<
+ * from typing import Union, Dict, List, Hashable             # <<<<<<<<<<<<<<
  * 
- * from libc.math cimport log, sqrt, INFINITY
+ * cimport cython
  */
   __pyx_t_1 = PyList_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_n_s_Union);
   __Pyx_GIVEREF(__pyx_n_s_Union);
   PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_Union);
   __Pyx_INCREF(__pyx_n_s_Dict);
   __Pyx_GIVEREF(__pyx_n_s_Dict);
   PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_Dict);
   __Pyx_INCREF(__pyx_n_s_List);
   __Pyx_GIVEREF(__pyx_n_s_List);
   PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_s_List);
-  __Pyx_INCREF(__pyx_n_s_Any);
-  __Pyx_GIVEREF(__pyx_n_s_Any);
-  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_n_s_Any);
+  __Pyx_INCREF(__pyx_n_s_Hashable);
+  __Pyx_GIVEREF(__pyx_n_s_Hashable);
+  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_n_s_Hashable);
   __pyx_t_2 = __Pyx_Import(__pyx_n_s_typing, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Union); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_Union, __pyx_t_1) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
@@ -8560,35 +9943,35 @@
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_Dict, __pyx_t_1) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_List); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_List, __pyx_t_1) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Any); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Hashable); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Any, __pyx_t_1) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Hashable, __pyx_t_1) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "multimcts/mcts.pyx":16
  * 
  * 
- * Move = Any # MCTS does not care about the contents of a move; it merely passes the output of get_legal_moves() to make_move(), both of which are handled by the user.             # <<<<<<<<<<<<<<
+ * Move = Hashable # Moves can be any type, as long as they can be added to a set and used as dict keys.             # <<<<<<<<<<<<<<
  * Team = Union[int,str]
  * Rewards = Dict[Team,float]
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_Any); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 16, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_Hashable); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 16, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_Move, __pyx_t_2) < 0) __PYX_ERR(0, 16, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "multimcts/mcts.pyx":17
  * 
- * Move = Any # MCTS does not care about the contents of a move; it merely passes the output of get_legal_moves() to make_move(), both of which are handled by the user.
+ * Move = Hashable # Moves can be any type, as long as they can be added to a set and used as dict keys.
  * Team = Union[int,str]             # <<<<<<<<<<<<<<
  * Rewards = Dict[Team,float]
  * 
  */
   __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_Union); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 17, __pyx_L1_error)
@@ -8603,15 +9986,15 @@
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_Team, __pyx_t_3) < 0) __PYX_ERR(0, 17, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "multimcts/mcts.pyx":18
- * Move = Any # MCTS does not care about the contents of a move; it merely passes the output of get_legal_moves() to make_move(), both of which are handled by the user.
+ * Move = Hashable # Moves can be any type, as long as they can be added to a set and used as dict keys.
  * Team = Union[int,str]
  * Rewards = Dict[Team,float]             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Dict); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
@@ -8651,15 +10034,15 @@
  */
   __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_return, __pyx_t_3) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_1get_current_team, 0, __pyx_n_s_GameState_get_current_team, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj_)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 22, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_1get_current_team, 0, __pyx_n_s_GameState_get_current_team, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__11)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_3, __pyx_t_2);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_get_current_team, __pyx_t_3) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "multimcts/mcts.pyx":26
@@ -8677,15 +10060,15 @@
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 26, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_return, __pyx_t_5) < 0) __PYX_ERR(0, 26, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_3get_legal_moves, 0, __pyx_n_s_GameState_get_legal_moves, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__3)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 26, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_3get_legal_moves, 0, __pyx_n_s_GameState_get_legal_moves, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__13)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 26, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_5, __pyx_t_3);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_get_legal_moves, __pyx_t_5) < 0) __PYX_ERR(0, 26, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
   /* "multimcts/mcts.pyx":30
@@ -8698,15 +10081,15 @@
   __pyx_t_5 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Move); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_move, __pyx_t_3) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_return, __pyx_n_u_GameState) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_5make_move, 0, __pyx_n_s_GameState_make_move, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__5)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_5make_move, 0, __pyx_n_s_GameState_make_move, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__15)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_3, __pyx_t_5);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_make_move, __pyx_t_3) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "multimcts/mcts.pyx":36
@@ -8715,26 +10098,26 @@
  *     def is_terminal(self) -> bool:             # <<<<<<<<<<<<<<
  *         """Is the game over?"""
  *         raise NotImplementedError("GameState must implement is_terminal.")
  */
   __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 36, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_return, ((PyObject*)&PyBool_Type)) < 0) __PYX_ERR(0, 36, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_7is_terminal, 0, __pyx_n_s_GameState_is_terminal, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__7)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 36, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_7is_terminal, 0, __pyx_n_s_GameState_is_terminal, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__17)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 36, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_5, __pyx_t_3);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_is_terminal, __pyx_t_5) < 0) __PYX_ERR(0, 36, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
   /* "multimcts/mcts.pyx":40
  *         raise NotImplementedError("GameState must implement is_terminal.")
  * 
  *     def get_reward(self) -> Union[float,Rewards]:             # <<<<<<<<<<<<<<
- *         """The reward earned by the team that played the game-ending move (the "terminal team", or the team from the previous state).
+ *         """The reward earned by the team that played the game-ending move (i.e. the team from the previous state).
  *         Typically 1 for win, -1 for loss, 0 for draw.
  */
   __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Union); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_Rewards); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
@@ -8749,15 +10132,15 @@
   __pyx_t_4 = 0;
   __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_return, __pyx_t_4) < 0) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_9get_reward, 0, __pyx_n_s_GameState_get_reward, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__9)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_9get_reward, 0, __pyx_n_s_GameState_get_reward, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__19)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_5);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_get_reward, __pyx_t_4) < 0) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
   /* "multimcts/mcts.pyx":21
@@ -8769,54 +10152,60 @@
  */
   __pyx_t_4 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_GameState, __pyx_empty_tuple, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 21, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_GameState, __pyx_t_4) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
+  /* "multimcts/mcts.pyx":351
+ *         SQRTLOG[x] = sqrt(log(x))
+ *         INVSQRT[x] = 1 / sqrt(x)
+ * precalc()             # <<<<<<<<<<<<<<
+ */
+  __pyx_f_9multimcts_4mcts_precalc();
+
   /* "(tree fragment)":1
  * def __pyx_unpickle_Node(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
   __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9multimcts_4mcts_1__pyx_unpickle_Node, NULL, __pyx_n_s_multimcts_mcts); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Node, __pyx_t_1) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":11
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):
  */
   __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9multimcts_4mcts_3__pyx_unpickle_MCTS, NULL, __pyx_n_s_multimcts_mcts); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_MCTS, __pyx_t_1) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "multimcts/mcts.pyx":1
  * # distutils: language=c++             # <<<<<<<<<<<<<<
  * # cython: language_level=3
- * # cython: profile=True
+ * # cython: profile=False
  */
   __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "map.from_py":174
  * 
  * @cname("__pyx_convert_map_from_py_std_3a__3a_string__and_double")
  * cdef map[X,Y] __pyx_convert_map_from_py_std_3a__3a_string__and_double(object o) except *:             # <<<<<<<<<<<<<<
  *     cdef dict d = o
  *     cdef map[X,Y] m
  */
-  __Pyx_TraceReturn(Py_None, 0);
 
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
@@ -8884,14 +10273,34 @@
 #else
             "name '%.200s' is not defined", PyString_AS_STRING(name));
 #endif
     }
     return result;
 }
 
+/* PyObjectCall */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+    PyObject *result;
+    ternaryfunc call = Py_TYPE(func)->tp_call;
+    if (unlikely(!call))
+        return PyObject_Call(func, arg, kw);
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    result = (*call)(func, arg, kw);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
+    }
+    return result;
+}
+#endif
+
 /* PyErrFetchRestore */
 #if CYTHON_FAST_THREAD_STATE
 static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
     PyObject *tmp_type, *tmp_value, *tmp_tb;
     tmp_type = tstate->curexc_type;
     tmp_value = tstate->curexc_value;
     tmp_tb = tstate->curexc_traceback;
@@ -8908,124 +10317,14 @@
     *tb = tstate->curexc_traceback;
     tstate->curexc_type = 0;
     tstate->curexc_value = 0;
     tstate->curexc_traceback = 0;
 }
 #endif
 
-/* Profile */
-#if CYTHON_PROFILE
-static int __Pyx_TraceSetupAndCall(PyCodeObject** code,
-                                   PyFrameObject** frame,
-                                   PyThreadState* tstate,
-                                   const char *funcname,
-                                   const char *srcfile,
-                                   int firstlineno) {
-    PyObject *type, *value, *traceback;
-    int retval;
-    if (*frame == NULL || !CYTHON_PROFILE_REUSE_FRAME) {
-        if (*code == NULL) {
-            *code = __Pyx_createFrameCodeObject(funcname, srcfile, firstlineno);
-            if (*code == NULL) return 0;
-        }
-        *frame = PyFrame_New(
-            tstate,                          /*PyThreadState *tstate*/
-            *code,                           /*PyCodeObject *code*/
-            __pyx_d,                  /*PyObject *globals*/
-            0                                /*PyObject *locals*/
-        );
-        if (*frame == NULL) return 0;
-        if (CYTHON_TRACE && (*frame)->f_trace == NULL) {
-            Py_INCREF(Py_None);
-            (*frame)->f_trace = Py_None;
-        }
-#if PY_VERSION_HEX < 0x030400B1
-    } else {
-        (*frame)->f_tstate = tstate;
-#endif
-    }
-    __Pyx_PyFrame_SetLineNumber(*frame, firstlineno);
-    retval = 1;
-    __Pyx_EnterTracing(tstate);
-    __Pyx_ErrFetchInState(tstate, &type, &value, &traceback);
-    #if CYTHON_TRACE
-    if (tstate->c_tracefunc)
-        retval = tstate->c_tracefunc(tstate->c_traceobj, *frame, PyTrace_CALL, NULL) == 0;
-    if (retval && tstate->c_profilefunc)
-    #endif
-        retval = tstate->c_profilefunc(tstate->c_profileobj, *frame, PyTrace_CALL, NULL) == 0;
-    __Pyx_LeaveTracing(tstate);
-    if (retval) {
-        __Pyx_ErrRestoreInState(tstate, type, value, traceback);
-        return __Pyx_IsTracing(tstate, 0, 0) && retval;
-    } else {
-        Py_XDECREF(type);
-        Py_XDECREF(value);
-        Py_XDECREF(traceback);
-        return -1;
-    }
-}
-static PyCodeObject *__Pyx_createFrameCodeObject(const char *funcname, const char *srcfile, int firstlineno) {
-    PyCodeObject *py_code = 0;
-#if PY_MAJOR_VERSION >= 3
-    py_code = PyCode_NewEmpty(srcfile, funcname, firstlineno);
-    if (likely(py_code)) {
-        py_code->co_flags |= CO_OPTIMIZED | CO_NEWLOCALS;
-    }
-#else
-    PyObject *py_srcfile = 0;
-    PyObject *py_funcname = 0;
-    py_funcname = PyString_FromString(funcname);
-    if (unlikely(!py_funcname)) goto bad;
-    py_srcfile = PyString_FromString(srcfile);
-    if (unlikely(!py_srcfile)) goto bad;
-    py_code = PyCode_New(
-        0,
-        0,
-        0,
-        CO_OPTIMIZED | CO_NEWLOCALS,
-        __pyx_empty_bytes,     /*PyObject *code,*/
-        __pyx_empty_tuple,     /*PyObject *consts,*/
-        __pyx_empty_tuple,     /*PyObject *names,*/
-        __pyx_empty_tuple,     /*PyObject *varnames,*/
-        __pyx_empty_tuple,     /*PyObject *freevars,*/
-        __pyx_empty_tuple,     /*PyObject *cellvars,*/
-        py_srcfile,       /*PyObject *filename,*/
-        py_funcname,      /*PyObject *name,*/
-        firstlineno,
-        __pyx_empty_bytes      /*PyObject *lnotab*/
-    );
-bad:
-    Py_XDECREF(py_srcfile);
-    Py_XDECREF(py_funcname);
-#endif
-    return py_code;
-}
-#endif
-
-/* PyObjectCall */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
-    PyObject *result;
-    ternaryfunc call = Py_TYPE(func)->tp_call;
-    if (unlikely(!call))
-        return PyObject_Call(func, arg, kw);
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
-        return NULL;
-    result = (*call)(func, arg, kw);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
-    }
-    return result;
-}
-#endif
-
 /* RaiseException */
 #if PY_MAJOR_VERSION < 3
 static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                         CYTHON_UNUSED PyObject *cause) {
     __Pyx_PyThreadState_declare
     Py_XINCREF(type);
     if (!value || value == Py_None)
@@ -9654,14 +10953,41 @@
     result = __Pyx_PyObject_Call(function, args, NULL);
     Py_DECREF(args);
     Py_DECREF(function);
 done:
     return result;
 }
 
+/* decode_c_bytes */
+static CYTHON_INLINE PyObject* __Pyx_decode_c_bytes(
+         const char* cstring, Py_ssize_t length, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
+    if (unlikely((start < 0) | (stop < 0))) {
+        if (start < 0) {
+            start += length;
+            if (start < 0)
+                start = 0;
+        }
+        if (stop < 0)
+            stop += length;
+    }
+    if (stop > length)
+        stop = length;
+    if (unlikely(stop <= start))
+        return __Pyx_NewRef(__pyx_empty_unicode);
+    length = stop - start;
+    cstring += start;
+    if (decode_func) {
+        return decode_func(cstring, length, errors);
+    } else {
+        return PyUnicode_Decode(cstring, length, encoding, errors);
+    }
+}
+
 /* WriteUnraisableException */
 static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                   CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                   int full_traceback, CYTHON_UNUSED int nogil) {
     PyObject *old_exc, *old_val, *old_tb;
     PyObject *ctx;
     __Pyx_PyThreadState_declare
@@ -9694,336 +11020,114 @@
     }
 #ifdef WITH_THREAD
     if (nogil)
         PyGILState_Release(state);
 #endif
 }
 
-/* PyErrExceptionMatches */
-#if CYTHON_FAST_THREAD_STATE
-static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
-    Py_ssize_t i, n;
-    n = PyTuple_GET_SIZE(tuple);
-#if PY_MAJOR_VERSION >= 3
-    for (i=0; i<n; i++) {
-        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
-    }
-#endif
-    for (i=0; i<n; i++) {
-        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
-    }
-    return 0;
-}
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
-    PyObject *exc_type = tstate->curexc_type;
-    if (exc_type == err) return 1;
-    if (unlikely(!exc_type)) return 0;
-    if (unlikely(PyTuple_Check(err)))
-        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
-    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
-}
-#endif
-
-/* GetAttr */
-static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
-#if CYTHON_USE_TYPE_SLOTS
-#if PY_MAJOR_VERSION >= 3
-    if (likely(PyUnicode_Check(n)))
-#else
-    if (likely(PyString_Check(n)))
-#endif
-        return __Pyx_PyObject_GetAttrStr(o, n);
-#endif
-    return PyObject_GetAttr(o, n);
-}
-
-/* GetAttr3 */
-static PyObject *__Pyx_GetAttr3Default(PyObject *d) {
+/* IterNext */
+static PyObject *__Pyx_PyIter_Next2Default(PyObject* defval) {
+    PyObject* exc_type;
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
-    if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
-        return NULL;
-    __Pyx_PyErr_Clear();
-    Py_INCREF(d);
-    return d;
+    exc_type = __Pyx_PyErr_Occurred();
+    if (unlikely(exc_type)) {
+        if (!defval || unlikely(!__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)))
+            return NULL;
+        __Pyx_PyErr_Clear();
+        Py_INCREF(defval);
+        return defval;
+    }
+    if (defval) {
+        Py_INCREF(defval);
+        return defval;
+    }
+    __Pyx_PyErr_SetNone(PyExc_StopIteration);
+    return NULL;
 }
-static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *o, PyObject *n, PyObject *d) {
-    PyObject *r = __Pyx_GetAttr(o, n);
-    return (likely(r)) ? r : __Pyx_GetAttr3Default(d);
+static void __Pyx_PyIter_Next_ErrorNoIterator(PyObject *iterator) {
+    PyErr_Format(PyExc_TypeError,
+        "%.200s object is not an iterator", Py_TYPE(iterator)->tp_name);
 }
-
-/* pyfrozenset_new */
-static CYTHON_INLINE PyObject* __Pyx_PyFrozenSet_New(PyObject* it) {
-    if (it) {
-        PyObject* result;
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject* args;
-        args = PyTuple_Pack(1, it);
-        if (unlikely(!args))
+static CYTHON_INLINE PyObject *__Pyx_PyIter_Next2(PyObject* iterator, PyObject* defval) {
+    PyObject* next;
+    iternextfunc iternext = Py_TYPE(iterator)->tp_iternext;
+    if (likely(iternext)) {
+#if CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY
+        next = iternext(iterator);
+        if (likely(next))
+            return next;
+        #if PY_VERSION_HEX >= 0x02070000 && CYTHON_COMPILING_IN_CPYTHON
+        if (unlikely(iternext == &_PyObject_NextNotImplemented))
             return NULL;
-        result = PyObject_Call((PyObject*)&PyFrozenSet_Type, args, NULL);
-        Py_DECREF(args);
-        return result;
+        #endif
 #else
-        if (PyFrozenSet_CheckExact(it)) {
-            Py_INCREF(it);
-            return it;
-        }
-        result = PyFrozenSet_New(it);
-        if (unlikely(!result))
-            return NULL;
-        if ((PY_VERSION_HEX >= 0x031000A1) || likely(PySet_GET_SIZE(result)))
-            return result;
-        Py_DECREF(result);
+        next = PyIter_Next(iterator);
+        if (likely(next))
+            return next;
 #endif
+    } else if (CYTHON_USE_TYPE_SLOTS || unlikely(!PyIter_Check(iterator))) {
+        __Pyx_PyIter_Next_ErrorNoIterator(iterator);
+        return NULL;
+    }
+#if !CYTHON_USE_TYPE_SLOTS
+    else {
+        next = PyIter_Next(iterator);
+        if (likely(next))
+            return next;
     }
-#if CYTHON_USE_TYPE_SLOTS
-    return PyFrozenSet_Type.tp_new(&PyFrozenSet_Type, __pyx_empty_tuple, NULL);
-#else
-    return PyObject_Call((PyObject*)&PyFrozenSet_Type, __pyx_empty_tuple, NULL);
 #endif
+    return __Pyx_PyIter_Next2Default(defval);
 }
 
-/* PySetContains */
-static int __Pyx_PySet_ContainsUnhashable(PyObject *set, PyObject *key) {
-    int result = -1;
-    if (PySet_Check(key) && PyErr_ExceptionMatches(PyExc_TypeError)) {
-        PyObject *tmpkey;
-        PyErr_Clear();
-        tmpkey = __Pyx_PyFrozenSet_New(key);
-        if (tmpkey != NULL) {
-            result = PySet_Contains(set, tmpkey);
-            Py_DECREF(tmpkey);
-        }
-    }
-    return result;
-}
-static CYTHON_INLINE int __Pyx_PySet_ContainsTF(PyObject* key, PyObject* set, int eq) {
-    int result = PySet_Contains(set, key);
-    if (unlikely(result < 0)) {
-        result = __Pyx_PySet_ContainsUnhashable(set, key);
+/* ExtTypeTest */
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
+    if (unlikely(!type)) {
+        PyErr_SetString(PyExc_SystemError, "Missing type object");
+        return 0;
     }
-    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
-}
-
-/* PyUnicode_Unicode */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_Unicode(PyObject *obj) {
-    if (unlikely(obj == Py_None))
-        obj = __pyx_kp_u_None;
-    return __Pyx_NewRef(obj);
+    if (likely(__Pyx_TypeCheck(obj, type)))
+        return 1;
+    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
+                 Py_TYPE(obj)->tp_name, type->tp_name);
+    return 0;
 }
 
-/* JoinPyUnicode */
-static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
-                                      CYTHON_UNUSED Py_UCS4 max_char) {
-#if CYTHON_USE_UNICODE_INTERNALS && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    PyObject *result_uval;
-    int result_ukind;
-    Py_ssize_t i, char_pos;
-    void *result_udata;
-#if CYTHON_PEP393_ENABLED
-    result_uval = PyUnicode_New(result_ulength, max_char);
-    if (unlikely(!result_uval)) return NULL;
-    result_ukind = (max_char <= 255) ? PyUnicode_1BYTE_KIND : (max_char <= 65535) ? PyUnicode_2BYTE_KIND : PyUnicode_4BYTE_KIND;
-    result_udata = PyUnicode_DATA(result_uval);
-#else
-    result_uval = PyUnicode_FromUnicode(NULL, result_ulength);
-    if (unlikely(!result_uval)) return NULL;
-    result_ukind = sizeof(Py_UNICODE);
-    result_udata = PyUnicode_AS_UNICODE(result_uval);
-#endif
-    char_pos = 0;
-    for (i=0; i < value_count; i++) {
-        int ukind;
-        Py_ssize_t ulength;
-        void *udata;
-        PyObject *uval = PyTuple_GET_ITEM(value_tuple, i);
-        if (unlikely(__Pyx_PyUnicode_READY(uval)))
-            goto bad;
-        ulength = __Pyx_PyUnicode_GET_LENGTH(uval);
-        if (unlikely(!ulength))
-            continue;
-        if (unlikely(char_pos + ulength < 0))
-            goto overflow;
-        ukind = __Pyx_PyUnicode_KIND(uval);
-        udata = __Pyx_PyUnicode_DATA(uval);
-        if (!CYTHON_PEP393_ENABLED || ukind == result_ukind) {
-            memcpy((char *)result_udata + char_pos * result_ukind, udata, (size_t) (ulength * result_ukind));
+/* IterFinish */
+static CYTHON_INLINE int __Pyx_IterFinish(void) {
+#if CYTHON_FAST_THREAD_STATE
+    PyThreadState *tstate = __Pyx_PyThreadState_Current;
+    PyObject* exc_type = tstate->curexc_type;
+    if (unlikely(exc_type)) {
+        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
+            PyObject *exc_value, *exc_tb;
+            exc_value = tstate->curexc_value;
+            exc_tb = tstate->curexc_traceback;
+            tstate->curexc_type = 0;
+            tstate->curexc_value = 0;
+            tstate->curexc_traceback = 0;
+            Py_DECREF(exc_type);
+            Py_XDECREF(exc_value);
+            Py_XDECREF(exc_tb);
+            return 0;
         } else {
-            #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030300F0 || defined(_PyUnicode_FastCopyCharacters)
-            _PyUnicode_FastCopyCharacters(result_uval, char_pos, uval, 0, ulength);
-            #else
-            Py_ssize_t j;
-            for (j=0; j < ulength; j++) {
-                Py_UCS4 uchar = __Pyx_PyUnicode_READ(ukind, udata, j);
-                __Pyx_PyUnicode_WRITE(result_ukind, result_udata, char_pos+j, uchar);
-            }
-            #endif
+            return -1;
         }
-        char_pos += ulength;
     }
-    return result_uval;
-overflow:
-    PyErr_SetString(PyExc_OverflowError, "join() result is too long for a Python string");
-bad:
-    Py_DECREF(result_uval);
-    return NULL;
-#else
-    result_ulength++;
-    value_count++;
-    return PyUnicode_Join(__pyx_empty_unicode, value_tuple);
-#endif
-}
-
-/* BytesEquals */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
-#if CYTHON_COMPILING_IN_PYPY
-    return PyObject_RichCompareBool(s1, s2, equals);
+    return 0;
 #else
-    if (s1 == s2) {
-        return (equals == Py_EQ);
-    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
-        const char *ps1, *ps2;
-        Py_ssize_t length = PyBytes_GET_SIZE(s1);
-        if (length != PyBytes_GET_SIZE(s2))
-            return (equals == Py_NE);
-        ps1 = PyBytes_AS_STRING(s1);
-        ps2 = PyBytes_AS_STRING(s2);
-        if (ps1[0] != ps2[0]) {
-            return (equals == Py_NE);
-        } else if (length == 1) {
-            return (equals == Py_EQ);
+    if (unlikely(PyErr_Occurred())) {
+        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
+            PyErr_Clear();
+            return 0;
         } else {
-            int result;
-#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
-            Py_hash_t hash1, hash2;
-            hash1 = ((PyBytesObject*)s1)->ob_shash;
-            hash2 = ((PyBytesObject*)s2)->ob_shash;
-            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
-                return (equals == Py_NE);
-            }
-#endif
-            result = memcmp(ps1, ps2, (size_t)length);
-            return (equals == Py_EQ) ? (result == 0) : (result != 0);
-        }
-    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
-        return (equals == Py_NE);
-    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
-        return (equals == Py_NE);
-    } else {
-        int result;
-        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
-        if (!py_result)
             return -1;
-        result = __Pyx_PyObject_IsTrue(py_result);
-        Py_DECREF(py_result);
-        return result;
-    }
-#endif
-}
-
-/* UnicodeEquals */
-static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
-#if CYTHON_COMPILING_IN_PYPY
-    return PyObject_RichCompareBool(s1, s2, equals);
-#else
-#if PY_MAJOR_VERSION < 3
-    PyObject* owned_ref = NULL;
-#endif
-    int s1_is_unicode, s2_is_unicode;
-    if (s1 == s2) {
-        goto return_eq;
-    }
-    s1_is_unicode = PyUnicode_CheckExact(s1);
-    s2_is_unicode = PyUnicode_CheckExact(s2);
-#if PY_MAJOR_VERSION < 3
-    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
-        owned_ref = PyUnicode_FromObject(s2);
-        if (unlikely(!owned_ref))
-            return -1;
-        s2 = owned_ref;
-        s2_is_unicode = 1;
-    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
-        owned_ref = PyUnicode_FromObject(s1);
-        if (unlikely(!owned_ref))
-            return -1;
-        s1 = owned_ref;
-        s1_is_unicode = 1;
-    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
-        return __Pyx_PyBytes_Equals(s1, s2, equals);
-    }
-#endif
-    if (s1_is_unicode & s2_is_unicode) {
-        Py_ssize_t length;
-        int kind;
-        void *data1, *data2;
-        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
-            return -1;
-        length = __Pyx_PyUnicode_GET_LENGTH(s1);
-        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
-            goto return_ne;
-        }
-#if CYTHON_USE_UNICODE_INTERNALS
-        {
-            Py_hash_t hash1, hash2;
-        #if CYTHON_PEP393_ENABLED
-            hash1 = ((PyASCIIObject*)s1)->hash;
-            hash2 = ((PyASCIIObject*)s2)->hash;
-        #else
-            hash1 = ((PyUnicodeObject*)s1)->hash;
-            hash2 = ((PyUnicodeObject*)s2)->hash;
-        #endif
-            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
-                goto return_ne;
-            }
         }
-#endif
-        kind = __Pyx_PyUnicode_KIND(s1);
-        if (kind != __Pyx_PyUnicode_KIND(s2)) {
-            goto return_ne;
-        }
-        data1 = __Pyx_PyUnicode_DATA(s1);
-        data2 = __Pyx_PyUnicode_DATA(s2);
-        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
-            goto return_ne;
-        } else if (length == 1) {
-            goto return_eq;
-        } else {
-            int result = memcmp(data1, data2, (size_t)(length * kind));
-            #if PY_MAJOR_VERSION < 3
-            Py_XDECREF(owned_ref);
-            #endif
-            return (equals == Py_EQ) ? (result == 0) : (result != 0);
-        }
-    } else if ((s1 == Py_None) & s2_is_unicode) {
-        goto return_ne;
-    } else if ((s2 == Py_None) & s1_is_unicode) {
-        goto return_ne;
-    } else {
-        int result;
-        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
-        #if PY_MAJOR_VERSION < 3
-        Py_XDECREF(owned_ref);
-        #endif
-        if (!py_result)
-            return -1;
-        result = __Pyx_PyObject_IsTrue(py_result);
-        Py_DECREF(py_result);
-        return result;
     }
-return_eq:
-    #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(owned_ref);
-    #endif
-    return (equals == Py_EQ);
-return_ne:
-    #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(owned_ref);
-    #endif
-    return (equals == Py_NE);
+    return 0;
 #endif
 }
 
 /* PyObjectGetMethod */
 static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
     PyObject *attr;
 #if CYTHON_UNPACK_METHODS && CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_PYTYPE_LOOKUP
@@ -10131,14 +11235,218 @@
     if (unlikely(!method)) goto bad;
     result = __Pyx_PyObject_CallNoArg(method);
     Py_DECREF(method);
 bad:
     return result;
 }
 
+/* RaiseNeedMoreValuesToUnpack */
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
+    PyErr_Format(PyExc_ValueError,
+                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
+                 index, (index == 1) ? "" : "s");
+}
+
+/* RaiseTooManyValuesToUnpack */
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
+    PyErr_Format(PyExc_ValueError,
+                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
+}
+
+/* UnpackItemEndCheck */
+static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
+    if (unlikely(retval)) {
+        Py_DECREF(retval);
+        __Pyx_RaiseTooManyValuesError(expected);
+        return -1;
+    }
+    return __Pyx_IterFinish();
+}
+
+/* RaiseNoneIterError */
+static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
+}
+
+/* UnpackTupleError */
+static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
+    if (t == Py_None) {
+      __Pyx_RaiseNoneNotIterableError();
+    } else if (PyTuple_GET_SIZE(t) < index) {
+      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
+    } else {
+      __Pyx_RaiseTooManyValuesError(index);
+    }
+}
+
+/* UnpackTuple2 */
+static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
+        PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2, int decref_tuple) {
+    PyObject *value1 = NULL, *value2 = NULL;
+#if CYTHON_COMPILING_IN_PYPY
+    value1 = PySequence_ITEM(tuple, 0);  if (unlikely(!value1)) goto bad;
+    value2 = PySequence_ITEM(tuple, 1);  if (unlikely(!value2)) goto bad;
+#else
+    value1 = PyTuple_GET_ITEM(tuple, 0);  Py_INCREF(value1);
+    value2 = PyTuple_GET_ITEM(tuple, 1);  Py_INCREF(value2);
+#endif
+    if (decref_tuple) {
+        Py_DECREF(tuple);
+    }
+    *pvalue1 = value1;
+    *pvalue2 = value2;
+    return 0;
+#if CYTHON_COMPILING_IN_PYPY
+bad:
+    Py_XDECREF(value1);
+    Py_XDECREF(value2);
+    if (decref_tuple) { Py_XDECREF(tuple); }
+    return -1;
+#endif
+}
+static int __Pyx_unpack_tuple2_generic(PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2,
+                                       int has_known_size, int decref_tuple) {
+    Py_ssize_t index;
+    PyObject *value1 = NULL, *value2 = NULL, *iter = NULL;
+    iternextfunc iternext;
+    iter = PyObject_GetIter(tuple);
+    if (unlikely(!iter)) goto bad;
+    if (decref_tuple) { Py_DECREF(tuple); tuple = NULL; }
+    iternext = Py_TYPE(iter)->tp_iternext;
+    value1 = iternext(iter); if (unlikely(!value1)) { index = 0; goto unpacking_failed; }
+    value2 = iternext(iter); if (unlikely(!value2)) { index = 1; goto unpacking_failed; }
+    if (!has_known_size && unlikely(__Pyx_IternextUnpackEndCheck(iternext(iter), 2))) goto bad;
+    Py_DECREF(iter);
+    *pvalue1 = value1;
+    *pvalue2 = value2;
+    return 0;
+unpacking_failed:
+    if (!has_known_size && __Pyx_IterFinish() == 0)
+        __Pyx_RaiseNeedMoreValuesError(index);
+bad:
+    Py_XDECREF(iter);
+    Py_XDECREF(value1);
+    Py_XDECREF(value2);
+    if (decref_tuple) { Py_XDECREF(tuple); }
+    return -1;
+}
+
+/* dict_iter */
+static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* iterable, int is_dict, PyObject* method_name,
+                                                   Py_ssize_t* p_orig_length, int* p_source_is_dict) {
+    is_dict = is_dict || likely(PyDict_CheckExact(iterable));
+    *p_source_is_dict = is_dict;
+    if (is_dict) {
+#if !CYTHON_COMPILING_IN_PYPY
+        *p_orig_length = PyDict_Size(iterable);
+        Py_INCREF(iterable);
+        return iterable;
+#elif PY_MAJOR_VERSION >= 3
+        static PyObject *py_items = NULL, *py_keys = NULL, *py_values = NULL;
+        PyObject **pp = NULL;
+        if (method_name) {
+            const char *name = PyUnicode_AsUTF8(method_name);
+            if (strcmp(name, "iteritems") == 0) pp = &py_items;
+            else if (strcmp(name, "iterkeys") == 0) pp = &py_keys;
+            else if (strcmp(name, "itervalues") == 0) pp = &py_values;
+            if (pp) {
+                if (!*pp) {
+                    *pp = PyUnicode_FromString(name + 4);
+                    if (!*pp)
+                        return NULL;
+                }
+                method_name = *pp;
+            }
+        }
+#endif
+    }
+    *p_orig_length = 0;
+    if (method_name) {
+        PyObject* iter;
+        iterable = __Pyx_PyObject_CallMethod0(iterable, method_name);
+        if (!iterable)
+            return NULL;
+#if !CYTHON_COMPILING_IN_PYPY
+        if (PyTuple_CheckExact(iterable) || PyList_CheckExact(iterable))
+            return iterable;
+#endif
+        iter = PyObject_GetIter(iterable);
+        Py_DECREF(iterable);
+        return iter;
+    }
+    return PyObject_GetIter(iterable);
+}
+static CYTHON_INLINE int __Pyx_dict_iter_next(
+        PyObject* iter_obj, CYTHON_NCP_UNUSED Py_ssize_t orig_length, CYTHON_NCP_UNUSED Py_ssize_t* ppos,
+        PyObject** pkey, PyObject** pvalue, PyObject** pitem, int source_is_dict) {
+    PyObject* next_item;
+#if !CYTHON_COMPILING_IN_PYPY
+    if (source_is_dict) {
+        PyObject *key, *value;
+        if (unlikely(orig_length != PyDict_Size(iter_obj))) {
+            PyErr_SetString(PyExc_RuntimeError, "dictionary changed size during iteration");
+            return -1;
+        }
+        if (unlikely(!PyDict_Next(iter_obj, ppos, &key, &value))) {
+            return 0;
+        }
+        if (pitem) {
+            PyObject* tuple = PyTuple_New(2);
+            if (unlikely(!tuple)) {
+                return -1;
+            }
+            Py_INCREF(key);
+            Py_INCREF(value);
+            PyTuple_SET_ITEM(tuple, 0, key);
+            PyTuple_SET_ITEM(tuple, 1, value);
+            *pitem = tuple;
+        } else {
+            if (pkey) {
+                Py_INCREF(key);
+                *pkey = key;
+            }
+            if (pvalue) {
+                Py_INCREF(value);
+                *pvalue = value;
+            }
+        }
+        return 1;
+    } else if (PyTuple_CheckExact(iter_obj)) {
+        Py_ssize_t pos = *ppos;
+        if (unlikely(pos >= PyTuple_GET_SIZE(iter_obj))) return 0;
+        *ppos = pos + 1;
+        next_item = PyTuple_GET_ITEM(iter_obj, pos);
+        Py_INCREF(next_item);
+    } else if (PyList_CheckExact(iter_obj)) {
+        Py_ssize_t pos = *ppos;
+        if (unlikely(pos >= PyList_GET_SIZE(iter_obj))) return 0;
+        *ppos = pos + 1;
+        next_item = PyList_GET_ITEM(iter_obj, pos);
+        Py_INCREF(next_item);
+    } else
+#endif
+    {
+        next_item = PyIter_Next(iter_obj);
+        if (unlikely(!next_item)) {
+            return __Pyx_IterFinish();
+        }
+    }
+    if (pitem) {
+        *pitem = next_item;
+    } else if (pkey && pvalue) {
+        if (__Pyx_unpack_tuple2(next_item, pkey, pvalue, source_is_dict, source_is_dict, 1))
+            return -1;
+    } else if (pkey) {
+        *pkey = next_item;
+    } else {
+        *pvalue = next_item;
+    }
+    return 1;
+}
+
 /* UnpackUnboundCMethod */
 static int __Pyx_TryUnpackUnboundCMethod(__Pyx_CachedCFunction* target) {
     PyObject *method;
     method = __Pyx_PyObject_GetAttrStr(target->type, *target->method_name);
     if (unlikely(!method))
         return -1;
     target->method = method;
@@ -10187,45 +11495,14 @@
         __Pyx_SET_SIZE(L, Py_SIZE(L) - 1);
         return PyList_GET_ITEM(L, PyList_GET_SIZE(L));
     }
     return __Pyx_CallUnboundCMethod0(&__pyx_umethod_PyList_Type_pop, L);
 }
 #endif
 
-/* PyObjectCallMethod1 */
-static PyObject* __Pyx__PyObject_CallMethod1(PyObject* method, PyObject* arg) {
-    PyObject *result = __Pyx_PyObject_CallOneArg(method, arg);
-    Py_DECREF(method);
-    return result;
-}
-static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
-    PyObject *method = NULL, *result;
-    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
-    if (likely(is_method)) {
-        result = __Pyx_PyObject_Call2Args(method, obj, arg);
-        Py_DECREF(method);
-        return result;
-    }
-    if (unlikely(!method)) return NULL;
-    return __Pyx__PyObject_CallMethod1(method, arg);
-}
-
-/* append */
-static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x) {
-    if (likely(PyList_CheckExact(L))) {
-        if (unlikely(__Pyx_PyList_Append(L, x) < 0)) return -1;
-    } else {
-        PyObject* retval = __Pyx_PyObject_CallMethod1(L, __pyx_n_s_append, x);
-        if (unlikely(!retval))
-            return -1;
-        Py_DECREF(retval);
-    }
-    return 0;
-}
-
 /* PyIntCompare */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED long inplace) {
     if (op1 == op2) {
         Py_RETURN_TRUE;
     }
     #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_CheckExact(op1))) {
@@ -10441,26 +11718,284 @@
         Py_DECREF(float_value);
         return value;
     }
 bad:
     return (double)-1;
 }
 
-/* ExtTypeTest */
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
-    if (unlikely(!type)) {
-        PyErr_SetString(PyExc_SystemError, "Missing type object");
-        return 0;
+/* PyErrExceptionMatches */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
+    Py_ssize_t i, n;
+    n = PyTuple_GET_SIZE(tuple);
+#if PY_MAJOR_VERSION >= 3
+    for (i=0; i<n; i++) {
+        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
+    }
+#endif
+    for (i=0; i<n; i++) {
+        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
     }
-    if (likely(__Pyx_TypeCheck(obj, type)))
-        return 1;
-    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
-                 Py_TYPE(obj)->tp_name, type->tp_name);
     return 0;
 }
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
+    PyObject *exc_type = tstate->curexc_type;
+    if (exc_type == err) return 1;
+    if (unlikely(!exc_type)) return 0;
+    if (unlikely(PyTuple_Check(err)))
+        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
+    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
+}
+#endif
+
+/* GetAttr */
+static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
+#if CYTHON_USE_TYPE_SLOTS
+#if PY_MAJOR_VERSION >= 3
+    if (likely(PyUnicode_Check(n)))
+#else
+    if (likely(PyString_Check(n)))
+#endif
+        return __Pyx_PyObject_GetAttrStr(o, n);
+#endif
+    return PyObject_GetAttr(o, n);
+}
+
+/* GetAttr3 */
+static PyObject *__Pyx_GetAttr3Default(PyObject *d) {
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
+        return NULL;
+    __Pyx_PyErr_Clear();
+    Py_INCREF(d);
+    return d;
+}
+static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *o, PyObject *n, PyObject *d) {
+    PyObject *r = __Pyx_GetAttr(o, n);
+    return (likely(r)) ? r : __Pyx_GetAttr3Default(d);
+}
+
+/* BytesEquals */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
+#if CYTHON_COMPILING_IN_PYPY
+    return PyObject_RichCompareBool(s1, s2, equals);
+#else
+    if (s1 == s2) {
+        return (equals == Py_EQ);
+    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
+        const char *ps1, *ps2;
+        Py_ssize_t length = PyBytes_GET_SIZE(s1);
+        if (length != PyBytes_GET_SIZE(s2))
+            return (equals == Py_NE);
+        ps1 = PyBytes_AS_STRING(s1);
+        ps2 = PyBytes_AS_STRING(s2);
+        if (ps1[0] != ps2[0]) {
+            return (equals == Py_NE);
+        } else if (length == 1) {
+            return (equals == Py_EQ);
+        } else {
+            int result;
+#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
+            Py_hash_t hash1, hash2;
+            hash1 = ((PyBytesObject*)s1)->ob_shash;
+            hash2 = ((PyBytesObject*)s2)->ob_shash;
+            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
+                return (equals == Py_NE);
+            }
+#endif
+            result = memcmp(ps1, ps2, (size_t)length);
+            return (equals == Py_EQ) ? (result == 0) : (result != 0);
+        }
+    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
+        return (equals == Py_NE);
+    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
+        return (equals == Py_NE);
+    } else {
+        int result;
+        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        if (!py_result)
+            return -1;
+        result = __Pyx_PyObject_IsTrue(py_result);
+        Py_DECREF(py_result);
+        return result;
+    }
+#endif
+}
+
+/* UnicodeEquals */
+static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
+#if CYTHON_COMPILING_IN_PYPY
+    return PyObject_RichCompareBool(s1, s2, equals);
+#else
+#if PY_MAJOR_VERSION < 3
+    PyObject* owned_ref = NULL;
+#endif
+    int s1_is_unicode, s2_is_unicode;
+    if (s1 == s2) {
+        goto return_eq;
+    }
+    s1_is_unicode = PyUnicode_CheckExact(s1);
+    s2_is_unicode = PyUnicode_CheckExact(s2);
+#if PY_MAJOR_VERSION < 3
+    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
+        owned_ref = PyUnicode_FromObject(s2);
+        if (unlikely(!owned_ref))
+            return -1;
+        s2 = owned_ref;
+        s2_is_unicode = 1;
+    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
+        owned_ref = PyUnicode_FromObject(s1);
+        if (unlikely(!owned_ref))
+            return -1;
+        s1 = owned_ref;
+        s1_is_unicode = 1;
+    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
+        return __Pyx_PyBytes_Equals(s1, s2, equals);
+    }
+#endif
+    if (s1_is_unicode & s2_is_unicode) {
+        Py_ssize_t length;
+        int kind;
+        void *data1, *data2;
+        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
+            return -1;
+        length = __Pyx_PyUnicode_GET_LENGTH(s1);
+        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
+            goto return_ne;
+        }
+#if CYTHON_USE_UNICODE_INTERNALS
+        {
+            Py_hash_t hash1, hash2;
+        #if CYTHON_PEP393_ENABLED
+            hash1 = ((PyASCIIObject*)s1)->hash;
+            hash2 = ((PyASCIIObject*)s2)->hash;
+        #else
+            hash1 = ((PyUnicodeObject*)s1)->hash;
+            hash2 = ((PyUnicodeObject*)s2)->hash;
+        #endif
+            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
+                goto return_ne;
+            }
+        }
+#endif
+        kind = __Pyx_PyUnicode_KIND(s1);
+        if (kind != __Pyx_PyUnicode_KIND(s2)) {
+            goto return_ne;
+        }
+        data1 = __Pyx_PyUnicode_DATA(s1);
+        data2 = __Pyx_PyUnicode_DATA(s2);
+        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
+            goto return_ne;
+        } else if (length == 1) {
+            goto return_eq;
+        } else {
+            int result = memcmp(data1, data2, (size_t)(length * kind));
+            #if PY_MAJOR_VERSION < 3
+            Py_XDECREF(owned_ref);
+            #endif
+            return (equals == Py_EQ) ? (result == 0) : (result != 0);
+        }
+    } else if ((s1 == Py_None) & s2_is_unicode) {
+        goto return_ne;
+    } else if ((s2 == Py_None) & s1_is_unicode) {
+        goto return_ne;
+    } else {
+        int result;
+        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        #if PY_MAJOR_VERSION < 3
+        Py_XDECREF(owned_ref);
+        #endif
+        if (!py_result)
+            return -1;
+        result = __Pyx_PyObject_IsTrue(py_result);
+        Py_DECREF(py_result);
+        return result;
+    }
+return_eq:
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(owned_ref);
+    #endif
+    return (equals == Py_EQ);
+return_ne:
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(owned_ref);
+    #endif
+    return (equals == Py_NE);
+#endif
+}
+
+/* PyUnicode_Unicode */
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_Unicode(PyObject *obj) {
+    if (unlikely(obj == Py_None))
+        obj = __pyx_kp_u_None;
+    return __Pyx_NewRef(obj);
+}
+
+/* JoinPyUnicode */
+static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
+                                      CYTHON_UNUSED Py_UCS4 max_char) {
+#if CYTHON_USE_UNICODE_INTERNALS && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    PyObject *result_uval;
+    int result_ukind;
+    Py_ssize_t i, char_pos;
+    void *result_udata;
+#if CYTHON_PEP393_ENABLED
+    result_uval = PyUnicode_New(result_ulength, max_char);
+    if (unlikely(!result_uval)) return NULL;
+    result_ukind = (max_char <= 255) ? PyUnicode_1BYTE_KIND : (max_char <= 65535) ? PyUnicode_2BYTE_KIND : PyUnicode_4BYTE_KIND;
+    result_udata = PyUnicode_DATA(result_uval);
+#else
+    result_uval = PyUnicode_FromUnicode(NULL, result_ulength);
+    if (unlikely(!result_uval)) return NULL;
+    result_ukind = sizeof(Py_UNICODE);
+    result_udata = PyUnicode_AS_UNICODE(result_uval);
+#endif
+    char_pos = 0;
+    for (i=0; i < value_count; i++) {
+        int ukind;
+        Py_ssize_t ulength;
+        void *udata;
+        PyObject *uval = PyTuple_GET_ITEM(value_tuple, i);
+        if (unlikely(__Pyx_PyUnicode_READY(uval)))
+            goto bad;
+        ulength = __Pyx_PyUnicode_GET_LENGTH(uval);
+        if (unlikely(!ulength))
+            continue;
+        if (unlikely(char_pos + ulength < 0))
+            goto overflow;
+        ukind = __Pyx_PyUnicode_KIND(uval);
+        udata = __Pyx_PyUnicode_DATA(uval);
+        if (!CYTHON_PEP393_ENABLED || ukind == result_ukind) {
+            memcpy((char *)result_udata + char_pos * result_ukind, udata, (size_t) (ulength * result_ukind));
+        } else {
+            #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030300F0 || defined(_PyUnicode_FastCopyCharacters)
+            _PyUnicode_FastCopyCharacters(result_uval, char_pos, uval, 0, ulength);
+            #else
+            Py_ssize_t j;
+            for (j=0; j < ulength; j++) {
+                Py_UCS4 uchar = __Pyx_PyUnicode_READ(ukind, udata, j);
+                __Pyx_PyUnicode_WRITE(result_ukind, result_udata, char_pos+j, uchar);
+            }
+            #endif
+        }
+        char_pos += ulength;
+    }
+    return result_uval;
+overflow:
+    PyErr_SetString(PyExc_OverflowError, "join() result is too long for a Python string");
+bad:
+    Py_DECREF(result_uval);
+    return NULL;
+#else
+    result_ulength++;
+    value_count++;
+    return PyUnicode_Join(__pyx_empty_unicode, value_tuple);
+#endif
+}
 
 /* Import */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
     PyObject *empty_list = 0;
     PyObject *module = 0;
     PyObject *global_dict = 0;
     PyObject *empty_dict = 0;
@@ -10551,253 +12086,14 @@
         return 0;
     } else {
         Py_DECREF(r);
         return 1;
     }
 }
 
-/* IterFinish */
-static CYTHON_INLINE int __Pyx_IterFinish(void) {
-#if CYTHON_FAST_THREAD_STATE
-    PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject* exc_type = tstate->curexc_type;
-    if (unlikely(exc_type)) {
-        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
-            PyObject *exc_value, *exc_tb;
-            exc_value = tstate->curexc_value;
-            exc_tb = tstate->curexc_traceback;
-            tstate->curexc_type = 0;
-            tstate->curexc_value = 0;
-            tstate->curexc_traceback = 0;
-            Py_DECREF(exc_type);
-            Py_XDECREF(exc_value);
-            Py_XDECREF(exc_tb);
-            return 0;
-        } else {
-            return -1;
-        }
-    }
-    return 0;
-#else
-    if (unlikely(PyErr_Occurred())) {
-        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
-            PyErr_Clear();
-            return 0;
-        } else {
-            return -1;
-        }
-    }
-    return 0;
-#endif
-}
-
-/* RaiseNeedMoreValuesToUnpack */
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
-    PyErr_Format(PyExc_ValueError,
-                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
-                 index, (index == 1) ? "" : "s");
-}
-
-/* RaiseTooManyValuesToUnpack */
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
-    PyErr_Format(PyExc_ValueError,
-                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
-}
-
-/* UnpackItemEndCheck */
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
-    if (unlikely(retval)) {
-        Py_DECREF(retval);
-        __Pyx_RaiseTooManyValuesError(expected);
-        return -1;
-    }
-    return __Pyx_IterFinish();
-}
-
-/* RaiseNoneIterError */
-static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
-    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-}
-
-/* UnpackTupleError */
-static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
-    if (t == Py_None) {
-      __Pyx_RaiseNoneNotIterableError();
-    } else if (PyTuple_GET_SIZE(t) < index) {
-      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
-    } else {
-      __Pyx_RaiseTooManyValuesError(index);
-    }
-}
-
-/* UnpackTuple2 */
-static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
-        PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2, int decref_tuple) {
-    PyObject *value1 = NULL, *value2 = NULL;
-#if CYTHON_COMPILING_IN_PYPY
-    value1 = PySequence_ITEM(tuple, 0);  if (unlikely(!value1)) goto bad;
-    value2 = PySequence_ITEM(tuple, 1);  if (unlikely(!value2)) goto bad;
-#else
-    value1 = PyTuple_GET_ITEM(tuple, 0);  Py_INCREF(value1);
-    value2 = PyTuple_GET_ITEM(tuple, 1);  Py_INCREF(value2);
-#endif
-    if (decref_tuple) {
-        Py_DECREF(tuple);
-    }
-    *pvalue1 = value1;
-    *pvalue2 = value2;
-    return 0;
-#if CYTHON_COMPILING_IN_PYPY
-bad:
-    Py_XDECREF(value1);
-    Py_XDECREF(value2);
-    if (decref_tuple) { Py_XDECREF(tuple); }
-    return -1;
-#endif
-}
-static int __Pyx_unpack_tuple2_generic(PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2,
-                                       int has_known_size, int decref_tuple) {
-    Py_ssize_t index;
-    PyObject *value1 = NULL, *value2 = NULL, *iter = NULL;
-    iternextfunc iternext;
-    iter = PyObject_GetIter(tuple);
-    if (unlikely(!iter)) goto bad;
-    if (decref_tuple) { Py_DECREF(tuple); tuple = NULL; }
-    iternext = Py_TYPE(iter)->tp_iternext;
-    value1 = iternext(iter); if (unlikely(!value1)) { index = 0; goto unpacking_failed; }
-    value2 = iternext(iter); if (unlikely(!value2)) { index = 1; goto unpacking_failed; }
-    if (!has_known_size && unlikely(__Pyx_IternextUnpackEndCheck(iternext(iter), 2))) goto bad;
-    Py_DECREF(iter);
-    *pvalue1 = value1;
-    *pvalue2 = value2;
-    return 0;
-unpacking_failed:
-    if (!has_known_size && __Pyx_IterFinish() == 0)
-        __Pyx_RaiseNeedMoreValuesError(index);
-bad:
-    Py_XDECREF(iter);
-    Py_XDECREF(value1);
-    Py_XDECREF(value2);
-    if (decref_tuple) { Py_XDECREF(tuple); }
-    return -1;
-}
-
-/* dict_iter */
-static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* iterable, int is_dict, PyObject* method_name,
-                                                   Py_ssize_t* p_orig_length, int* p_source_is_dict) {
-    is_dict = is_dict || likely(PyDict_CheckExact(iterable));
-    *p_source_is_dict = is_dict;
-    if (is_dict) {
-#if !CYTHON_COMPILING_IN_PYPY
-        *p_orig_length = PyDict_Size(iterable);
-        Py_INCREF(iterable);
-        return iterable;
-#elif PY_MAJOR_VERSION >= 3
-        static PyObject *py_items = NULL, *py_keys = NULL, *py_values = NULL;
-        PyObject **pp = NULL;
-        if (method_name) {
-            const char *name = PyUnicode_AsUTF8(method_name);
-            if (strcmp(name, "iteritems") == 0) pp = &py_items;
-            else if (strcmp(name, "iterkeys") == 0) pp = &py_keys;
-            else if (strcmp(name, "itervalues") == 0) pp = &py_values;
-            if (pp) {
-                if (!*pp) {
-                    *pp = PyUnicode_FromString(name + 4);
-                    if (!*pp)
-                        return NULL;
-                }
-                method_name = *pp;
-            }
-        }
-#endif
-    }
-    *p_orig_length = 0;
-    if (method_name) {
-        PyObject* iter;
-        iterable = __Pyx_PyObject_CallMethod0(iterable, method_name);
-        if (!iterable)
-            return NULL;
-#if !CYTHON_COMPILING_IN_PYPY
-        if (PyTuple_CheckExact(iterable) || PyList_CheckExact(iterable))
-            return iterable;
-#endif
-        iter = PyObject_GetIter(iterable);
-        Py_DECREF(iterable);
-        return iter;
-    }
-    return PyObject_GetIter(iterable);
-}
-static CYTHON_INLINE int __Pyx_dict_iter_next(
-        PyObject* iter_obj, CYTHON_NCP_UNUSED Py_ssize_t orig_length, CYTHON_NCP_UNUSED Py_ssize_t* ppos,
-        PyObject** pkey, PyObject** pvalue, PyObject** pitem, int source_is_dict) {
-    PyObject* next_item;
-#if !CYTHON_COMPILING_IN_PYPY
-    if (source_is_dict) {
-        PyObject *key, *value;
-        if (unlikely(orig_length != PyDict_Size(iter_obj))) {
-            PyErr_SetString(PyExc_RuntimeError, "dictionary changed size during iteration");
-            return -1;
-        }
-        if (unlikely(!PyDict_Next(iter_obj, ppos, &key, &value))) {
-            return 0;
-        }
-        if (pitem) {
-            PyObject* tuple = PyTuple_New(2);
-            if (unlikely(!tuple)) {
-                return -1;
-            }
-            Py_INCREF(key);
-            Py_INCREF(value);
-            PyTuple_SET_ITEM(tuple, 0, key);
-            PyTuple_SET_ITEM(tuple, 1, value);
-            *pitem = tuple;
-        } else {
-            if (pkey) {
-                Py_INCREF(key);
-                *pkey = key;
-            }
-            if (pvalue) {
-                Py_INCREF(value);
-                *pvalue = value;
-            }
-        }
-        return 1;
-    } else if (PyTuple_CheckExact(iter_obj)) {
-        Py_ssize_t pos = *ppos;
-        if (unlikely(pos >= PyTuple_GET_SIZE(iter_obj))) return 0;
-        *ppos = pos + 1;
-        next_item = PyTuple_GET_ITEM(iter_obj, pos);
-        Py_INCREF(next_item);
-    } else if (PyList_CheckExact(iter_obj)) {
-        Py_ssize_t pos = *ppos;
-        if (unlikely(pos >= PyList_GET_SIZE(iter_obj))) return 0;
-        *ppos = pos + 1;
-        next_item = PyList_GET_ITEM(iter_obj, pos);
-        Py_INCREF(next_item);
-    } else
-#endif
-    {
-        next_item = PyIter_Next(iter_obj);
-        if (unlikely(!next_item)) {
-            return __Pyx_IterFinish();
-        }
-    }
-    if (pitem) {
-        *pitem = next_item;
-    } else if (pkey && pvalue) {
-        if (__Pyx_unpack_tuple2(next_item, pkey, pvalue, source_is_dict, source_is_dict, 1))
-            return -1;
-    } else if (pkey) {
-        *pkey = next_item;
-    } else {
-        *pvalue = next_item;
-    }
-    return 1;
-}
-
 /* PyObject_GenericGetAttrNoDict */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
     PyErr_Format(PyExc_AttributeError,
 #if PY_MAJOR_VERSION >= 3
                  "'%.50s' object has no attribute '%U'",
                  tp->tp_name, attr_name);
```

### Comparing `multimcts-0.4.2/multimcts/mcts.cpp` & `multimcts-0.5/multimcts/mcts.c`

 * *Files 8% similar despite different names*

```diff
@@ -1,23 +1,9 @@
 /* Generated by Cython 0.29.36 */
 
-/* BEGIN: Cython Metadata
-{
-    "distutils": {
-        "depends": [],
-        "language": "c++",
-        "name": "multimcts.mcts",
-        "sources": [
-            "multimcts/mcts.pyx"
-        ]
-    },
-    "module_name": "multimcts.mcts"
-}
-END: Cython Metadata */
-
 #ifndef PY_SSIZE_T_CLEAN
 #define PY_SSIZE_T_CLEAN
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
@@ -365,41 +351,27 @@
     #if __apple_build_version__ < 7000000
       #undef  CYTHON_FALLTHROUGH
       #define CYTHON_FALLTHROUGH
     #endif
   #endif
 #endif
 
-#ifndef __cplusplus
-  #error "Cython files generated with the C++ option must be compiled with a C++ compiler."
-#endif
 #ifndef CYTHON_INLINE
   #if defined(__clang__)
     #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
-  #else
+  #elif defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
   #endif
 #endif
-template<typename T>
-void __Pyx_call_destructor(T& x) {
-    x.~T();
-}
-template<typename T>
-class __Pyx_FakeReference {
-  public:
-    __Pyx_FakeReference() : ptr(NULL) { }
-    __Pyx_FakeReference(const T& ref) : ptr(const_cast<T*>(&ref)) { }
-    T *operator->() { return ptr; }
-    T *operator&() { return ptr; }
-    operator T&() { return *ptr; }
-    template<typename U> bool operator ==(U other) { return *ptr == other; }
-    template<typename U> bool operator !=(U other) { return *ptr != other; }
-  private:
-    T *ptr;
-};
 
 #define __PYX_BUILD_PY_SSIZE_T "n"
 #define CYTHON_FORMAT_SSIZE_T "z"
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
@@ -1008,102 +980,80 @@
   "multimcts/mcts.pyx",
   "stringsource",
 };
 
 /*--- Type declarations ---*/
 struct __pyx_obj_9multimcts_4mcts_Node;
 struct __pyx_obj_9multimcts_4mcts_MCTS;
-struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate;
 
-/* "multimcts/mcts.pyx":225
- *         return child
- * 
- *     cdef map[string,double] simulate(self, Node node, heuristic=None):             # <<<<<<<<<<<<<<
- *         """Step 3: Simulation (aka playout/rollout)
- *         Play out a game, from the given node to termination, and return the final reward.
- */
-struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate {
-  int __pyx_n;
-  PyObject *heuristic;
-};
-
-/* "multimcts/mcts.pyx":49
+/* "multimcts/mcts.pyx":67
  * 
  * 
  * cdef class Node:             # <<<<<<<<<<<<<<
  *     """Represents a game state node in the MCTS search tree.
  *     Args:
  */
 struct __pyx_obj_9multimcts_4mcts_Node {
   PyObject_HEAD
   struct __pyx_vtabstruct_9multimcts_4mcts_Node *__pyx_vtab;
   PyObject *state;
   PyObject *move;
-  PyObject *team;
-  std::string cteam;
-  struct __pyx_obj_9multimcts_4mcts_Node *parent;
   PyObject *children;
   PyObject *remaining_moves;
+  struct __pyx_obj_9multimcts_4mcts_Node *parent;
+  std::string team;
   std::map<std::string,double>  rewards;
+  std::map<std::string,double>  rave_rewards;
   int visits;
+  int rave_visits;
   int is_terminal;
   int is_fully_expanded;
-  double avg_reward;
   double sqrtlog_visits;
   double invsqrt_visits;
+  double avg_reward;
+  double avg_rave_reward;
 };
 
 
-/* "multimcts/mcts.pyx":134
+/* "multimcts/mcts.pyx":264
  * 
  * 
  * cdef class MCTS:             # <<<<<<<<<<<<<<
- *     cdef double exploration_bias
+ *     cdef double exploration_bias, rave_bias
  * 
  */
 struct __pyx_obj_9multimcts_4mcts_MCTS {
   PyObject_HEAD
-  struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *__pyx_vtab;
   double exploration_bias;
+  double rave_bias;
 };
 
 
 
-/* "multimcts/mcts.pyx":49
+/* "multimcts/mcts.pyx":67
  * 
  * 
  * cdef class Node:             # <<<<<<<<<<<<<<
  *     """Represents a game state node in the MCTS search tree.
  *     Args:
  */
 
 struct __pyx_vtabstruct_9multimcts_4mcts_Node {
-  PyObject *(*apply_rewards)(struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> );
-  double (*ucb)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double);
+  PyObject *(*visit)(struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> , PyObject *);
+  double (*uncertainty)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch);
+  double (*ucb)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch);
+  double (*rave_beta)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch);
+  double (*score)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double, int __pyx_skip_dispatch);
+  struct __pyx_obj_9multimcts_4mcts_Node *(*best_child)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double);
+  struct __pyx_obj_9multimcts_4mcts_Node *(*select)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double);
+  struct __pyx_obj_9multimcts_4mcts_Node *(*expand)(struct __pyx_obj_9multimcts_4mcts_Node *);
+  void (*execute_round)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double);
 };
 static struct __pyx_vtabstruct_9multimcts_4mcts_Node *__pyx_vtabptr_9multimcts_4mcts_Node;
 
-
-/* "multimcts/mcts.pyx":134
- * 
- * 
- * cdef class MCTS:             # <<<<<<<<<<<<<<
- *     cdef double exploration_bias
- * 
- */
-
-struct __pyx_vtabstruct_9multimcts_4mcts_MCTS {
-  struct __pyx_obj_9multimcts_4mcts_Node *(*select)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *);
-  struct __pyx_obj_9multimcts_4mcts_Node *(*expand)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *);
-  std::map<std::string,double>  (*simulate)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *, struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate *__pyx_optional_args);
-  PyObject *(*backpropagate)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> );
-  struct __pyx_obj_9multimcts_4mcts_Node *(*get_best_child)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *);
-};
-static struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *__pyx_vtabptr_9multimcts_4mcts_MCTS;
-
 /* --- Runtime support code (head) --- */
 /* Refnanny.proto */
 #ifndef CYTHON_REFNANNY
   #define CYTHON_REFNANNY 0
 #endif
 #if CYTHON_REFNANNY
   typedef struct {
@@ -1170,21 +1120,14 @@
 #else
 #define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
 #endif
 
 /* GetBuiltinName.proto */
 static PyObject *__Pyx_GetBuiltinName(PyObject *name);
 
-/* PyObjectCall.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
-#else
-#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
-#endif
-
 /* PyThreadStateGet.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
 #define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
 #define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
 #else
 #define __Pyx_PyThreadState_declare
@@ -1213,14 +1156,253 @@
 #define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
 #define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
 #define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
 #define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
 #define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
 #endif
 
+/* Profile.proto */
+#ifndef CYTHON_PROFILE
+#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_PYSTON
+  #define CYTHON_PROFILE 0
+#else
+  #define CYTHON_PROFILE 1
+#endif
+#endif
+#ifndef CYTHON_TRACE_NOGIL
+  #define CYTHON_TRACE_NOGIL 0
+#else
+  #if CYTHON_TRACE_NOGIL && !defined(CYTHON_TRACE)
+    #define CYTHON_TRACE 1
+  #endif
+#endif
+#ifndef CYTHON_TRACE
+  #define CYTHON_TRACE 0
+#endif
+#if CYTHON_TRACE
+  #undef CYTHON_PROFILE_REUSE_FRAME
+#endif
+#ifndef CYTHON_PROFILE_REUSE_FRAME
+  #define CYTHON_PROFILE_REUSE_FRAME 0
+#endif
+#if CYTHON_PROFILE || CYTHON_TRACE
+  #include "compile.h"
+  #include "frameobject.h"
+  #include "traceback.h"
+#if PY_VERSION_HEX >= 0x030b00a6
+  #ifndef Py_BUILD_CORE
+    #define Py_BUILD_CORE 1
+  #endif
+  #include "internal/pycore_frame.h"
+#endif
+  #if CYTHON_PROFILE_REUSE_FRAME
+    #define CYTHON_FRAME_MODIFIER static
+    #define CYTHON_FRAME_DEL(frame)
+  #else
+    #define CYTHON_FRAME_MODIFIER
+    #define CYTHON_FRAME_DEL(frame) Py_CLEAR(frame)
+  #endif
+  #define __Pyx_TraceDeclarations\
+      static PyCodeObject *__pyx_frame_code = NULL;\
+      CYTHON_FRAME_MODIFIER PyFrameObject *__pyx_frame = NULL;\
+      int __Pyx_use_tracing = 0;
+  #define __Pyx_TraceFrameInit(codeobj)\
+      if (codeobj) __pyx_frame_code = (PyCodeObject*) codeobj;
+#if PY_VERSION_HEX >= 0x030b00a2
+  #define __Pyx_IsTracing(tstate, check_tracing, check_funcs)\
+     (unlikely((tstate)->cframe->use_tracing) &&\
+         (!(check_tracing) || !(tstate)->tracing) &&\
+         (!(check_funcs) || (tstate)->c_profilefunc || (CYTHON_TRACE && (tstate)->c_tracefunc)))
+  #define __Pyx_EnterTracing(tstate) PyThreadState_EnterTracing(tstate)
+  #define __Pyx_LeaveTracing(tstate) PyThreadState_LeaveTracing(tstate)
+#elif PY_VERSION_HEX >= 0x030a00b1
+  #define __Pyx_IsTracing(tstate, check_tracing, check_funcs)\
+     (unlikely((tstate)->cframe->use_tracing) &&\
+         (!(check_tracing) || !(tstate)->tracing) &&\
+         (!(check_funcs) || (tstate)->c_profilefunc || (CYTHON_TRACE && (tstate)->c_tracefunc)))
+  #define __Pyx_EnterTracing(tstate)\
+      do { tstate->tracing++; tstate->cframe->use_tracing = 0; } while (0)
+  #define __Pyx_LeaveTracing(tstate)\
+      do {\
+          tstate->tracing--;\
+          tstate->cframe->use_tracing = ((CYTHON_TRACE && tstate->c_tracefunc != NULL)\
+                                 || tstate->c_profilefunc != NULL);\
+      } while (0)
+#else
+  #define __Pyx_IsTracing(tstate, check_tracing, check_funcs)\
+     (unlikely((tstate)->use_tracing) &&\
+         (!(check_tracing) || !(tstate)->tracing) &&\
+         (!(check_funcs) || (tstate)->c_profilefunc || (CYTHON_TRACE && (tstate)->c_tracefunc)))
+  #define __Pyx_EnterTracing(tstate)\
+      do { tstate->tracing++; tstate->use_tracing = 0; } while (0)
+  #define __Pyx_LeaveTracing(tstate)\
+      do {\
+          tstate->tracing--;\
+          tstate->use_tracing = ((CYTHON_TRACE && tstate->c_tracefunc != NULL)\
+                                         || tstate->c_profilefunc != NULL);\
+      } while (0)
+#endif
+  #ifdef WITH_THREAD
+  #define __Pyx_TraceCall(funcname, srcfile, firstlineno, nogil, goto_error)\
+  if (nogil) {\
+      if (CYTHON_TRACE_NOGIL) {\
+          PyThreadState *tstate;\
+          PyGILState_STATE state = PyGILState_Ensure();\
+          tstate = __Pyx_PyThreadState_Current;\
+          if (__Pyx_IsTracing(tstate, 1, 1)) {\
+              __Pyx_use_tracing = __Pyx_TraceSetupAndCall(&__pyx_frame_code, &__pyx_frame, tstate, funcname, srcfile, firstlineno);\
+          }\
+          PyGILState_Release(state);\
+          if (unlikely(__Pyx_use_tracing < 0)) goto_error;\
+      }\
+  } else {\
+      PyThreadState* tstate = PyThreadState_GET();\
+      if (__Pyx_IsTracing(tstate, 1, 1)) {\
+          __Pyx_use_tracing = __Pyx_TraceSetupAndCall(&__pyx_frame_code, &__pyx_frame, tstate, funcname, srcfile, firstlineno);\
+          if (unlikely(__Pyx_use_tracing < 0)) goto_error;\
+      }\
+  }
+  #else
+  #define __Pyx_TraceCall(funcname, srcfile, firstlineno, nogil, goto_error)\
+  {   PyThreadState* tstate = PyThreadState_GET();\
+      if (__Pyx_IsTracing(tstate, 1, 1)) {\
+          __Pyx_use_tracing = __Pyx_TraceSetupAndCall(&__pyx_frame_code, &__pyx_frame, tstate, funcname, srcfile, firstlineno);\
+          if (unlikely(__Pyx_use_tracing < 0)) goto_error;\
+      }\
+  }
+  #endif
+  #define __Pyx_TraceException()\
+  if (likely(!__Pyx_use_tracing)); else {\
+      PyThreadState* tstate = __Pyx_PyThreadState_Current;\
+      if (__Pyx_IsTracing(tstate, 0, 1)) {\
+          __Pyx_EnterTracing(tstate);\
+          PyObject *exc_info = __Pyx_GetExceptionTuple(tstate);\
+          if (exc_info) {\
+              if (CYTHON_TRACE && tstate->c_tracefunc)\
+                  tstate->c_tracefunc(\
+                      tstate->c_traceobj, __pyx_frame, PyTrace_EXCEPTION, exc_info);\
+              tstate->c_profilefunc(\
+                  tstate->c_profileobj, __pyx_frame, PyTrace_EXCEPTION, exc_info);\
+              Py_DECREF(exc_info);\
+          }\
+          __Pyx_LeaveTracing(tstate);\
+      }\
+  }
+  static void __Pyx_call_return_trace_func(PyThreadState *tstate, PyFrameObject *frame, PyObject *result) {
+      PyObject *type, *value, *traceback;
+      __Pyx_ErrFetchInState(tstate, &type, &value, &traceback);
+      __Pyx_EnterTracing(tstate);
+      if (CYTHON_TRACE && tstate->c_tracefunc)
+          tstate->c_tracefunc(tstate->c_traceobj, frame, PyTrace_RETURN, result);
+      if (tstate->c_profilefunc)
+          tstate->c_profilefunc(tstate->c_profileobj, frame, PyTrace_RETURN, result);
+      CYTHON_FRAME_DEL(frame);
+      __Pyx_LeaveTracing(tstate);
+      __Pyx_ErrRestoreInState(tstate, type, value, traceback);
+  }
+  #ifdef WITH_THREAD
+  #define __Pyx_TraceReturn(result, nogil)\
+  if (likely(!__Pyx_use_tracing)); else {\
+      if (nogil) {\
+          if (CYTHON_TRACE_NOGIL) {\
+              PyThreadState *tstate;\
+              PyGILState_STATE state = PyGILState_Ensure();\
+              tstate = __Pyx_PyThreadState_Current;\
+              if (__Pyx_IsTracing(tstate, 0, 0)) {\
+                  __Pyx_call_return_trace_func(tstate, __pyx_frame, (PyObject*)result);\
+              }\
+              PyGILState_Release(state);\
+          }\
+      } else {\
+          PyThreadState* tstate = __Pyx_PyThreadState_Current;\
+          if (__Pyx_IsTracing(tstate, 0, 0)) {\
+              __Pyx_call_return_trace_func(tstate, __pyx_frame, (PyObject*)result);\
+          }\
+      }\
+  }
+  #else
+  #define __Pyx_TraceReturn(result, nogil)\
+  if (likely(!__Pyx_use_tracing)); else {\
+      PyThreadState* tstate = __Pyx_PyThreadState_Current;\
+      if (__Pyx_IsTracing(tstate, 0, 0)) {\
+          __Pyx_call_return_trace_func(tstate, __pyx_frame, (PyObject*)result);\
+      }\
+  }
+  #endif
+  static PyCodeObject *__Pyx_createFrameCodeObject(const char *funcname, const char *srcfile, int firstlineno);
+  static int __Pyx_TraceSetupAndCall(PyCodeObject** code, PyFrameObject** frame, PyThreadState* tstate, const char *funcname, const char *srcfile, int firstlineno);
+#else
+  #define __Pyx_TraceDeclarations
+  #define __Pyx_TraceFrameInit(codeobj)
+  #define __Pyx_TraceCall(funcname, srcfile, firstlineno, nogil, goto_error)   if ((1)); else goto_error;
+  #define __Pyx_TraceException()
+  #define __Pyx_TraceReturn(result, nogil)
+#endif
+#if CYTHON_TRACE
+  static int __Pyx_call_line_trace_func(PyThreadState *tstate, PyFrameObject *frame, int lineno) {
+      int ret;
+      PyObject *type, *value, *traceback;
+      __Pyx_ErrFetchInState(tstate, &type, &value, &traceback);
+      __Pyx_PyFrame_SetLineNumber(frame, lineno);
+      __Pyx_EnterTracing(tstate);
+      ret = tstate->c_tracefunc(tstate->c_traceobj, frame, PyTrace_LINE, NULL);
+      __Pyx_LeaveTracing(tstate);
+      if (likely(!ret)) {
+          __Pyx_ErrRestoreInState(tstate, type, value, traceback);
+      } else {
+          Py_XDECREF(type);
+          Py_XDECREF(value);
+          Py_XDECREF(traceback);
+      }
+      return ret;
+  }
+  #ifdef WITH_THREAD
+  #define __Pyx_TraceLine(lineno, nogil, goto_error)\
+  if (likely(!__Pyx_use_tracing)); else {\
+      if (nogil) {\
+          if (CYTHON_TRACE_NOGIL) {\
+              int ret = 0;\
+              PyThreadState *tstate;\
+              PyGILState_STATE state = PyGILState_Ensure();\
+              tstate = __Pyx_PyThreadState_Current;\
+              if (__Pyx_IsTracing(tstate, 0, 0) && tstate->c_tracefunc && __pyx_frame->f_trace) {\
+                  ret = __Pyx_call_line_trace_func(tstate, __pyx_frame, lineno);\
+              }\
+              PyGILState_Release(state);\
+              if (unlikely(ret)) goto_error;\
+          }\
+      } else {\
+          PyThreadState* tstate = __Pyx_PyThreadState_Current;\
+          if (__Pyx_IsTracing(tstate, 0, 0) && tstate->c_tracefunc && __pyx_frame->f_trace) {\
+              int ret = __Pyx_call_line_trace_func(tstate, __pyx_frame, lineno);\
+              if (unlikely(ret)) goto_error;\
+          }\
+      }\
+  }
+  #else
+  #define __Pyx_TraceLine(lineno, nogil, goto_error)\
+  if (likely(!__Pyx_use_tracing)); else {\
+      PyThreadState* tstate = __Pyx_PyThreadState_Current;\
+      if (__Pyx_IsTracing(tstate, 0, 0) && tstate->c_tracefunc && __pyx_frame->f_trace) {\
+          int ret = __Pyx_call_line_trace_func(tstate, __pyx_frame, lineno);\
+          if (unlikely(ret)) goto_error;\
+      }\
+  }
+  #endif
+#else
+  #define __Pyx_TraceLine(lineno, nogil, goto_error)   if ((1)); else goto_error;
+#endif
+
+/* PyObjectCall.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
+#else
+#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
+#endif
+
 /* RaiseException.proto */
 static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
 
 /* RaiseArgTupleInvalid.proto */
 static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
     Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
 
@@ -1337,78 +1519,106 @@
 #define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
 #endif
 
 /* PyObjectCall2Args.proto */
 static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
 
-/* PyErrExceptionMatches.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
-#else
-#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
-#endif
-
-/* GetAttr.proto */
-static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);
-
-/* GetAttr3.proto */
-static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *, PyObject *, PyObject *);
-
-/* pyfrozenset_new.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyFrozenSet_New(PyObject* it);
-
-/* PySetContains.proto */
-static CYTHON_INLINE int __Pyx_PySet_ContainsTF(PyObject* key, PyObject* set, int eq);
+/* IncludeCppStringH.proto */
+#include <string>
 
-/* PyUnicode_Unicode.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_Unicode(PyObject *obj);
+/* decode_c_string_utf16.proto */
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = 0;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16LE(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = -1;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16BE(const char *s, Py_ssize_t size, const char *errors) {
+    int byteorder = 1;
+    return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
+}
+
+/* decode_c_bytes.proto */
+static CYTHON_INLINE PyObject* __Pyx_decode_c_bytes(
+         const char* cstring, Py_ssize_t length, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors));
+
+/* decode_cpp_string.proto */
+static CYTHON_INLINE PyObject* __Pyx_decode_cpp_string(
+         std::string cppstring, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
+    return __Pyx_decode_c_bytes(
+        cppstring.data(), cppstring.size(), start, stop, encoding, errors, decode_func);
+}
 
-/* PyObjectFormatSimple.proto */
-#if CYTHON_COMPILING_IN_PYPY
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
-#elif PY_MAJOR_VERSION < 3
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyString_CheckExact(s)) ? PyUnicode_FromEncodedObject(s, NULL, "strict") :\
-        PyObject_Format(s, f))
-#elif CYTHON_USE_TYPE_SLOTS
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        likely(PyLong_CheckExact(s)) ? PyLong_Type.tp_str(s) :\
-        likely(PyFloat_CheckExact(s)) ? PyFloat_Type.tp_str(s) :\
-        PyObject_Format(s, f))
-#else
-    #define __Pyx_PyObject_FormatSimple(s, f) (\
-        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
-        PyObject_Format(s, f))
-#endif
+/* PySequenceContains.proto */
+static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
+    int result = PySequence_Contains(seq, item);
+    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
+}
 
-/* IncludeStringH.proto */
-#include <string.h>
+/* WriteUnraisableException.proto */
+static void __Pyx_WriteUnraisable(const char *name, int clineno,
+                                  int lineno, const char *filename,
+                                  int full_traceback, int nogil);
 
-/* JoinPyUnicode.proto */
-static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
-                                      Py_UCS4 max_char);
+/* IterNext.proto */
+#define __Pyx_PyIter_Next(obj) __Pyx_PyIter_Next2(obj, NULL)
+static CYTHON_INLINE PyObject *__Pyx_PyIter_Next2(PyObject *, PyObject *);
 
-/* BytesEquals.proto */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
+/* ExtTypeTest.proto */
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
 
-/* UnicodeEquals.proto */
-static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);
+/* IterFinish.proto */
+static CYTHON_INLINE int __Pyx_IterFinish(void);
 
 /* PyObjectGetMethod.proto */
 static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);
 
 /* PyObjectCallMethod0.proto */
 static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name);
 
+/* RaiseNeedMoreValuesToUnpack.proto */
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
+
+/* RaiseTooManyValuesToUnpack.proto */
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
+
+/* UnpackItemEndCheck.proto */
+static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);
+
+/* RaiseNoneIterError.proto */
+static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
+
+/* UnpackTupleError.proto */
+static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index);
+
+/* UnpackTuple2.proto */
+#define __Pyx_unpack_tuple2(tuple, value1, value2, is_tuple, has_known_size, decref_tuple)\
+    (likely(is_tuple || PyTuple_Check(tuple)) ?\
+        (likely(has_known_size || PyTuple_GET_SIZE(tuple) == 2) ?\
+            __Pyx_unpack_tuple2_exact(tuple, value1, value2, decref_tuple) :\
+            (__Pyx_UnpackTupleError(tuple, 2), -1)) :\
+        __Pyx_unpack_tuple2_generic(tuple, value1, value2, has_known_size, decref_tuple))
+static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
+    PyObject* tuple, PyObject** value1, PyObject** value2, int decref_tuple);
+static int __Pyx_unpack_tuple2_generic(
+    PyObject* tuple, PyObject** value1, PyObject** value2, int has_known_size, int decref_tuple);
+
+/* dict_iter.proto */
+static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* dict, int is_dict, PyObject* method_name,
+                                                   Py_ssize_t* p_orig_length, int* p_is_dict);
+static CYTHON_INLINE int __Pyx_dict_iter_next(PyObject* dict_or_iter, Py_ssize_t orig_length, Py_ssize_t* ppos,
+                                              PyObject** pkey, PyObject** pvalue, PyObject** pitem, int is_dict);
+
 /* pop.proto */
 static CYTHON_INLINE PyObject* __Pyx__PyObject_Pop(PyObject* L);
 #if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
 static CYTHON_INLINE PyObject* __Pyx_PyList_Pop(PyObject* L);
 #define __Pyx_PyObject_Pop(L) (likely(PyList_CheckExact(L)) ?\
     __Pyx_PyList_Pop(L) : __Pyx__PyObject_Pop(L))
 #else
@@ -1441,37 +1651,14 @@
                ((cfunc)->flag == METH_VARARGS ?  (*((cfunc)->func))(self, __pyx_empty_tuple) :\
                __Pyx__CallUnboundCMethod0(cfunc, self)))))) :\
         __Pyx__CallUnboundCMethod0(cfunc, self))
 #else
 #define __Pyx_CallUnboundCMethod0(cfunc, self)  __Pyx__CallUnboundCMethod0(cfunc, self)
 #endif
 
-/* ListAppend.proto */
-#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
-static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
-    PyListObject* L = (PyListObject*) list;
-    Py_ssize_t len = Py_SIZE(list);
-    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
-        Py_INCREF(x);
-        PyList_SET_ITEM(list, len, x);
-        __Pyx_SET_SIZE(list, len + 1);
-        return 0;
-    }
-    return PyList_Append(list, x);
-}
-#else
-#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
-#endif
-
-/* PyObjectCallMethod1.proto */
-static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);
-
-/* append.proto */
-static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x);
-
 /* PyIntCompare.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, long intval, long inplace);
 
 /* GetItemInt.proto */
 #define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
     (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
     __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
@@ -1509,73 +1696,53 @@
  PyFloat_AsDouble(obj) : __Pyx__PyObject_AsDouble(obj))
 #else
 #define __Pyx_PyObject_AsDouble(obj)\
 ((likely(PyFloat_CheckExact(obj))) ?\
  PyFloat_AS_DOUBLE(obj) : __Pyx__PyObject_AsDouble(obj))
 #endif
 
-/* WriteUnraisableException.proto */
-static void __Pyx_WriteUnraisable(const char *name, int clineno,
-                                  int lineno, const char *filename,
-                                  int full_traceback, int nogil);
+/* PyErrExceptionMatches.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
+#else
+#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
+#endif
 
-/* ExtTypeTest.proto */
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
+/* GetAttr.proto */
+static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);
 
-/* PySequenceContains.proto */
-static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
-    int result = PySequence_Contains(seq, item);
-    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
-}
+/* GetAttr3.proto */
+static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *, PyObject *, PyObject *);
+
+/* IncludeStringH.proto */
+#include <string.h>
+
+/* BytesEquals.proto */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
+
+/* UnicodeEquals.proto */
+static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);
+
+/* PyUnicode_Unicode.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_Unicode(PyObject *obj);
+
+/* JoinPyUnicode.proto */
+static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
+                                      Py_UCS4 max_char);
 
 /* Import.proto */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
 /* ImportFrom.proto */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
 
 /* HasAttr.proto */
 static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
 
-/* IterFinish.proto */
-static CYTHON_INLINE int __Pyx_IterFinish(void);
-
-/* RaiseNeedMoreValuesToUnpack.proto */
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
-
-/* RaiseTooManyValuesToUnpack.proto */
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
-
-/* UnpackItemEndCheck.proto */
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);
-
-/* RaiseNoneIterError.proto */
-static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
-
-/* UnpackTupleError.proto */
-static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index);
-
-/* UnpackTuple2.proto */
-#define __Pyx_unpack_tuple2(tuple, value1, value2, is_tuple, has_known_size, decref_tuple)\
-    (likely(is_tuple || PyTuple_Check(tuple)) ?\
-        (likely(has_known_size || PyTuple_GET_SIZE(tuple) == 2) ?\
-            __Pyx_unpack_tuple2_exact(tuple, value1, value2, decref_tuple) :\
-            (__Pyx_UnpackTupleError(tuple, 2), -1)) :\
-        __Pyx_unpack_tuple2_generic(tuple, value1, value2, has_known_size, decref_tuple))
-static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
-    PyObject* tuple, PyObject** value1, PyObject** value2, int decref_tuple);
-static int __Pyx_unpack_tuple2_generic(
-    PyObject* tuple, PyObject** value1, PyObject** value2, int has_known_size, int decref_tuple);
-
-/* dict_iter.proto */
-static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* dict, int is_dict, PyObject* method_name,
-                                                   Py_ssize_t* p_orig_length, int* p_is_dict);
-static CYTHON_INLINE int __Pyx_dict_iter_next(PyObject* dict_or_iter, Py_ssize_t orig_length, Py_ssize_t* ppos,
-                                              PyObject** pkey, PyObject** pvalue, PyObject** pitem, int is_dict);
-
 /* PyObject_GenericGetAttrNoDict.proto */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
 #endif
 
@@ -1781,155 +1948,171 @@
 
 /* CheckBinaryVersion.proto */
 static int __Pyx_check_binary_version(void);
 
 /* InitStrings.proto */
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);
 
-static PyObject *__pyx_f_9multimcts_4mcts_4Node_apply_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, std::map<std::string,double>  __pyx_v_crewards); /* proto*/
-static double __pyx_f_9multimcts_4mcts_4Node_ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_parent_sqrtlog_visits); /* proto*/
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_select(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node); /* proto*/
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_expand(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node); /* proto*/
-static std::map<std::string,double>  __pyx_f_9multimcts_4mcts_4MCTS_simulate(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node, struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate *__pyx_optional_args); /* proto*/
-static PyObject *__pyx_f_9multimcts_4mcts_4MCTS_backpropagate(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node, std::map<std::string,double>  __pyx_v_crewards); /* proto*/
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_get_best_child(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node); /* proto*/
+static PyObject *__pyx_f_9multimcts_4mcts_4Node_visit(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, std::map<std::string,double>  __pyx_v_crewards, PyObject *__pyx_v_moves); /* proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_uncertainty(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, int __pyx_skip_dispatch); /* proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, int __pyx_skip_dispatch); /* proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_rave_beta(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_b, int __pyx_skip_dispatch); /* proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_score(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias, int __pyx_skip_dispatch); /* proto*/
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_best_child(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias); /* proto*/
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_select(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias); /* proto*/
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_expand(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto*/
+static void __pyx_f_9multimcts_4mcts_4Node_execute_round(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias); /* proto*/
+
+/* Module declarations from 'cython' */
 
 /* Module declarations from 'libc.math' */
 
 /* Module declarations from 'libcpp.utility' */
 
 /* Module declarations from 'libcpp.map' */
 
 /* Module declarations from 'libc.string' */
 
 /* Module declarations from 'libcpp.string' */
 
 /* Module declarations from 'libcpp.pair' */
 
-/* Module declarations from 'cython' */
-
 /* Module declarations from 'multimcts.mcts' */
 static PyTypeObject *__pyx_ptype_9multimcts_4mcts_Node = 0;
 static PyTypeObject *__pyx_ptype_9multimcts_4mcts_MCTS = 0;
+static double __pyx_v_9multimcts_4mcts_SQRTLOG[0x2710];
+static double __pyx_v_9multimcts_4mcts_INVSQRT[0x2710];
+static double __pyx_f_9multimcts_4mcts_sqrtlog(int); /*proto*/
+static double __pyx_f_9multimcts_4mcts_invsqrt(int); /*proto*/
+static void __pyx_f_9multimcts_4mcts_precalc(void); /*proto*/
 static PyObject *__pyx_f_9multimcts_4mcts___pyx_unpickle_Node__set_state(struct __pyx_obj_9multimcts_4mcts_Node *, PyObject *); /*proto*/
 static PyObject *__pyx_f_9multimcts_4mcts___pyx_unpickle_MCTS__set_state(struct __pyx_obj_9multimcts_4mcts_MCTS *, PyObject *); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &); /*proto*/
-static std::string __pyx_convert_string_from_py_std__in_string(PyObject *); /*proto*/
 static PyObject *__pyx_convert_map_to_py_std_3a__3a_string____double(std::map<std::string,double>  const &); /*proto*/
+static std::string __pyx_convert_string_from_py_std__in_string(PyObject *); /*proto*/
 static std::map<std::string,double>  __pyx_convert_map_from_py_std_3a__3a_string__and_double(PyObject *); /*proto*/
 #define __Pyx_MODULE_NAME "multimcts.mcts"
 extern int __pyx_module_is_main_multimcts__mcts;
 int __pyx_module_is_main_multimcts__mcts = 0;
 
 /* Implementation of 'multimcts.mcts' */
 static PyObject *__pyx_builtin_NotImplementedError;
 static PyObject *__pyx_builtin_ValueError;
-static const char __pyx_k_Any[] = "Any";
+static PyObject *__pyx_builtin_range;
 static const char __pyx_k_doc[] = "__doc__";
 static const char __pyx_k_new[] = "__new__";
 static const char __pyx_k_pop[] = "pop";
+static const char __pyx_k_ucb[] = "ucb";
 static const char __pyx_k_Dict[] = "Dict";
 static const char __pyx_k_List[] = "List";
 static const char __pyx_k_MCTS[] = "MCTS";
 static const char __pyx_k_Move[] = "Move";
 static const char __pyx_k_Node[] = "Node";
 static const char __pyx_k_None[] = "None";
 static const char __pyx_k_Team[] = "Team";
 static const char __pyx_k_dict[] = "__dict__";
+static const char __pyx_k_keys[] = "keys";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_move[] = "move";
 static const char __pyx_k_name[] = "__name__";
 static const char __pyx_k_node[] = "node";
 static const char __pyx_k_self[] = "self";
 static const char __pyx_k_test[] = "__test__";
 static const char __pyx_k_time[] = "time";
 static const char __pyx_k_Union[] = "Union";
-static const char __pyx_k_lower[] = "lower";
+static const char __pyx_k_items[] = "items";
+static const char __pyx_k_range[] = "range";
+static const char __pyx_k_score[] = "score";
 static const char __pyx_k_state[] = "state";
-static const char __pyx_k_append[] = "append";
 static const char __pyx_k_choice[] = "choice";
 static const char __pyx_k_import[] = "__import__";
 static const char __pyx_k_module[] = "__module__";
 static const char __pyx_k_parent[] = "parent";
 static const char __pyx_k_pickle[] = "pickle";
 static const char __pyx_k_random[] = "random";
 static const char __pyx_k_reduce[] = "__reduce__";
 static const char __pyx_k_return[] = "return";
 static const char __pyx_k_typing[] = "typing";
 static const char __pyx_k_update[] = "update";
+static const char __pyx_k_values[] = "values";
 static const char __pyx_k_Rewards[] = "Rewards";
 static const char __pyx_k_prepare[] = "__prepare__";
 static const char __pyx_k_shuffle[] = "shuffle";
+static const char __pyx_k_Hashable[] = "Hashable";
 static const char __pyx_k_getstate[] = "__getstate__";
 static const char __pyx_k_max_time[] = "max_time";
 static const char __pyx_k_pyx_type[] = "__pyx_type";
 static const char __pyx_k_qualname[] = "__qualname__";
 static const char __pyx_k_setstate[] = "__setstate__";
 static const char __pyx_k_GameState[] = "GameState";
-static const char __pyx_k_heuristic[] = "heuristic";
 static const char __pyx_k_iteritems[] = "iteritems";
 static const char __pyx_k_make_move[] = "make_move";
 static const char __pyx_k_metaclass[] = "__metaclass__";
 static const char __pyx_k_pyx_state[] = "__pyx_state";
+static const char __pyx_k_rave_beta[] = "rave_beta";
+static const char __pyx_k_rave_bias[] = "rave_bias";
 static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
 static const char __pyx_k_ValueError[] = "ValueError";
 static const char __pyx_k_get_reward[] = "get_reward";
 static const char __pyx_k_pyx_result[] = "__pyx_result";
 static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
 static const char __pyx_k_PickleError[] = "PickleError";
 static const char __pyx_k_is_terminal[] = "is_terminal";
 static const char __pyx_k_return_type[] = "return_type";
+static const char __pyx_k_uncertainty[] = "uncertainty";
 static const char __pyx_k_pyx_checksum[] = "__pyx_checksum";
 static const char __pyx_k_stringsource[] = "stringsource";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
 static const char __pyx_k_max_iterations[] = "max_iterations";
 static const char __pyx_k_multimcts_mcts[] = "multimcts.mcts";
-static const char __pyx_k_must_be_one_of[] = ", must be one of ";
 static const char __pyx_k_get_legal_moves[] = "get_legal_moves";
 static const char __pyx_k_pyx_PickleError[] = "__pyx_PickleError";
 static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
 static const char __pyx_k_exploration_bias[] = "exploration_bias";
 static const char __pyx_k_get_current_team[] = "get_current_team";
 static const char __pyx_k_pyx_unpickle_MCTS[] = "__pyx_unpickle_MCTS";
 static const char __pyx_k_pyx_unpickle_Node[] = "__pyx_unpickle_Node";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_multimcts_mcts_pyx[] = "multimcts/mcts.pyx";
 static const char __pyx_k_GameState_make_move[] = "GameState.make_move";
-static const char __pyx_k_Invalid_return_type[] = "Invalid return type: ";
+static const char __pyx_k_Invalid_return_type[] = "Invalid return_type \"";
 static const char __pyx_k_NotImplementedError[] = "NotImplementedError";
 static const char __pyx_k_GameState_get_reward[] = "GameState.get_reward";
 static const char __pyx_k_GameState_is_terminal[] = "GameState.is_terminal";
 static const char __pyx_k_GameState_get_legal_moves[] = "GameState.get_legal_moves";
 static const char __pyx_k_GameState_get_current_team[] = "GameState.get_current_team";
+static const char __pyx_k_must_be_one_of_state_move_node[] = "\" must be one of {\"state\",\"move\",\"node\"}";
+static const char __pyx_k_Could_not_determine_terminal_tea[] = "Could not determine terminal team during simulation.";
 static const char __pyx_k_GameState_must_implement_get_cur[] = "GameState must implement get_current_team.";
 static const char __pyx_k_GameState_must_implement_get_leg[] = "GameState must implement get_legal_moves.";
 static const char __pyx_k_GameState_must_implement_get_rew[] = "GameState must implement get_reward.";
 static const char __pyx_k_GameState_must_implement_is_term[] = "GameState must implement is_terminal.";
 static const char __pyx_k_GameState_must_implement_make_mo[] = "GameState must implement make_move.";
-static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))";
+static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))";
 static const char __pyx_k_One_or_more_of_max_time_max_iter[] = "One or more of max_time/max_iterations is required.";
-static const char __pyx_k_Incompatible_checksums_0x_x_vs_0_2[] = "Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))";
-static PyObject *__pyx_n_s_Any;
+static const char __pyx_k_Incompatible_checksums_0x_x_vs_0_2[] = "Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))";
+static PyObject *__pyx_kp_u_Could_not_determine_terminal_tea;
 static PyObject *__pyx_n_s_Dict;
 static PyObject *__pyx_n_s_GameState;
 static PyObject *__pyx_n_u_GameState;
 static PyObject *__pyx_n_s_GameState_get_current_team;
 static PyObject *__pyx_n_s_GameState_get_legal_moves;
 static PyObject *__pyx_n_s_GameState_get_reward;
 static PyObject *__pyx_n_s_GameState_is_terminal;
 static PyObject *__pyx_n_s_GameState_make_move;
 static PyObject *__pyx_kp_u_GameState_must_implement_get_cur;
 static PyObject *__pyx_kp_u_GameState_must_implement_get_leg;
 static PyObject *__pyx_kp_u_GameState_must_implement_get_rew;
 static PyObject *__pyx_kp_u_GameState_must_implement_is_term;
 static PyObject *__pyx_kp_u_GameState_must_implement_make_mo;
+static PyObject *__pyx_n_s_Hashable;
 static PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
 static PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0_2;
 static PyObject *__pyx_kp_u_Invalid_return_type;
 static PyObject *__pyx_n_s_List;
 static PyObject *__pyx_n_s_MCTS;
 static PyObject *__pyx_n_s_Move;
 static PyObject *__pyx_n_s_Node;
@@ -1937,40 +2120,39 @@
 static PyObject *__pyx_n_s_NotImplementedError;
 static PyObject *__pyx_kp_u_One_or_more_of_max_time_max_iter;
 static PyObject *__pyx_n_s_PickleError;
 static PyObject *__pyx_n_s_Rewards;
 static PyObject *__pyx_n_s_Team;
 static PyObject *__pyx_n_s_Union;
 static PyObject *__pyx_n_s_ValueError;
-static PyObject *__pyx_n_s_append;
 static PyObject *__pyx_n_s_choice;
 static PyObject *__pyx_n_s_cline_in_traceback;
 static PyObject *__pyx_n_s_dict;
 static PyObject *__pyx_n_s_doc;
 static PyObject *__pyx_n_s_exploration_bias;
 static PyObject *__pyx_n_s_get_current_team;
 static PyObject *__pyx_n_s_get_legal_moves;
 static PyObject *__pyx_n_s_get_reward;
 static PyObject *__pyx_n_s_getstate;
-static PyObject *__pyx_n_s_heuristic;
 static PyObject *__pyx_n_s_import;
 static PyObject *__pyx_n_s_is_terminal;
+static PyObject *__pyx_n_s_items;
 static PyObject *__pyx_n_s_iteritems;
-static PyObject *__pyx_n_s_lower;
+static PyObject *__pyx_n_s_keys;
 static PyObject *__pyx_n_s_main;
 static PyObject *__pyx_n_s_make_move;
 static PyObject *__pyx_n_s_max_iterations;
 static PyObject *__pyx_n_s_max_time;
 static PyObject *__pyx_n_s_metaclass;
 static PyObject *__pyx_n_s_module;
 static PyObject *__pyx_n_s_move;
 static PyObject *__pyx_n_u_move;
 static PyObject *__pyx_n_s_multimcts_mcts;
 static PyObject *__pyx_kp_s_multimcts_mcts_pyx;
-static PyObject *__pyx_kp_u_must_be_one_of;
+static PyObject *__pyx_kp_u_must_be_one_of_state_move_node;
 static PyObject *__pyx_n_s_name;
 static PyObject *__pyx_n_s_new;
 static PyObject *__pyx_n_u_node;
 static PyObject *__pyx_n_s_parent;
 static PyObject *__pyx_n_s_pickle;
 static PyObject *__pyx_n_s_pop;
 static PyObject *__pyx_n_s_prepare;
@@ -1980,79 +2162,101 @@
 static PyObject *__pyx_n_s_pyx_state;
 static PyObject *__pyx_n_s_pyx_type;
 static PyObject *__pyx_n_s_pyx_unpickle_MCTS;
 static PyObject *__pyx_n_s_pyx_unpickle_Node;
 static PyObject *__pyx_n_s_pyx_vtable;
 static PyObject *__pyx_n_s_qualname;
 static PyObject *__pyx_n_s_random;
+static PyObject *__pyx_n_s_range;
+static PyObject *__pyx_n_s_rave_beta;
+static PyObject *__pyx_n_s_rave_bias;
 static PyObject *__pyx_n_s_reduce;
 static PyObject *__pyx_n_s_reduce_cython;
 static PyObject *__pyx_n_s_reduce_ex;
 static PyObject *__pyx_n_s_return;
 static PyObject *__pyx_n_s_return_type;
+static PyObject *__pyx_n_s_score;
 static PyObject *__pyx_n_s_self;
 static PyObject *__pyx_n_s_setstate;
 static PyObject *__pyx_n_s_setstate_cython;
 static PyObject *__pyx_n_s_shuffle;
 static PyObject *__pyx_n_s_state;
 static PyObject *__pyx_n_u_state;
 static PyObject *__pyx_kp_s_stringsource;
 static PyObject *__pyx_n_s_test;
 static PyObject *__pyx_n_s_time;
 static PyObject *__pyx_n_s_typing;
+static PyObject *__pyx_n_s_ucb;
+static PyObject *__pyx_n_s_uncertainty;
 static PyObject *__pyx_n_s_update;
+static PyObject *__pyx_n_s_values;
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_get_current_team(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_2get_legal_moves(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_4make_move(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_move); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_6is_terminal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_8get_reward(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self); /* proto */
 static int __pyx_pf_9multimcts_4mcts_4Node___init__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v_state, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_parent, PyObject *__pyx_v_move); /* proto */
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_5state___get__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_7rewards___get__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_2__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_4__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v___pyx_state); /* proto */
-static int __pyx_pf_9multimcts_4mcts_4MCTS___init__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, double __pyx_v_exploration_bias); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_2get_state(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_4get_team(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_6get_move(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_pf_9multimcts_4mcts_4Node_8get_parent(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_10get_children(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_12get_visits(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_14get_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_16get_avg_reward(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_18get_rave_visits(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_20get_rave_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_22get_avg_rave_reward(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_24uncertainty(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_26ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_28rave_beta(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_b); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_30score(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_32__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_34__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v___pyx_state); /* proto */
+static int __pyx_pf_9multimcts_4mcts_4MCTS___init__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_16exploration_bias___get__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_2search(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v_state, PyObject *__pyx_v_max_time, PyObject *__pyx_v_max_iterations, PyObject *__pyx_v_heuristic, PyObject *__pyx_v_return_type); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_9rave_bias___get__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_2search(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v_state, PyObject *__pyx_v_max_time, PyObject *__pyx_v_max_iterations, PyObject *__pyx_v_return_type); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_4__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_6__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts___pyx_unpickle_Node(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_9multimcts_4mcts_2__pyx_unpickle_MCTS(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_tp_new_9multimcts_4mcts_Node(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_9multimcts_4mcts_MCTS(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static __Pyx_CachedCFunction __pyx_umethod_PyList_Type_pop = {0, &__pyx_n_s_pop, 0, 0, 0};
 static PyObject *__pyx_int_0;
-static PyObject *__pyx_int_56097295;
-static PyObject *__pyx_int_59888949;
-static PyObject *__pyx_int_82662024;
-static PyObject *__pyx_int_99932858;
-static PyObject *__pyx_int_203704333;
-static PyObject *__pyx_int_231097371;
-static PyObject *__pyx_tuple_;
+static PyObject *__pyx_int_47470116;
+static PyObject *__pyx_int_145648438;
+static PyObject *__pyx_int_160888804;
+static PyObject *__pyx_int_186508213;
+static PyObject *__pyx_int_233936184;
+static PyObject *__pyx_int_254580472;
+static PyObject *__pyx_codeobj_;
 static PyObject *__pyx_tuple__2;
-static PyObject *__pyx_tuple__3;
 static PyObject *__pyx_tuple__4;
-static PyObject *__pyx_tuple__5;
 static PyObject *__pyx_tuple__6;
-static PyObject *__pyx_tuple__7;
 static PyObject *__pyx_tuple__8;
-static PyObject *__pyx_tuple__9;
+static PyObject *__pyx_tuple__10;
 static PyObject *__pyx_tuple__11;
-static PyObject *__pyx_tuple__13;
-static PyObject *__pyx_tuple__15;
+static PyObject *__pyx_tuple__12;
+static PyObject *__pyx_tuple__14;
+static PyObject *__pyx_tuple__16;
 static PyObject *__pyx_tuple__17;
+static PyObject *__pyx_tuple__18;
 static PyObject *__pyx_tuple__19;
+static PyObject *__pyx_tuple__20;
 static PyObject *__pyx_tuple__21;
-static PyObject *__pyx_codeobj__10;
-static PyObject *__pyx_codeobj__12;
-static PyObject *__pyx_codeobj__14;
-static PyObject *__pyx_codeobj__16;
-static PyObject *__pyx_codeobj__18;
-static PyObject *__pyx_codeobj__20;
-static PyObject *__pyx_codeobj__22;
+static PyObject *__pyx_tuple__22;
+static PyObject *__pyx_tuple__23;
+static PyObject *__pyx_codeobj__3;
+static PyObject *__pyx_codeobj__5;
+static PyObject *__pyx_codeobj__7;
+static PyObject *__pyx_codeobj__9;
+static PyObject *__pyx_codeobj__13;
+static PyObject *__pyx_codeobj__15;
 /* Late includes */
 
 /* "multimcts/mcts.pyx":22
  * 
  * class GameState:
  *     def get_current_team(self) -> Team:             # <<<<<<<<<<<<<<
  *         """The identifier of the current player's team."""
@@ -2072,29 +2276,32 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_get_current_team(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
+  __Pyx_TraceFrameInit(__pyx_codeobj_)
   __Pyx_RefNannySetupContext("get_current_team", 0);
+  __Pyx_TraceCall("get_current_team", __pyx_f[0], 22, 0, __PYX_ERR(0, 22, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":24
  *     def get_current_team(self) -> Team:
  *         """The identifier of the current player's team."""
  *         raise NotImplementedError("GameState must implement get_current_team.")             # <<<<<<<<<<<<<<
  * 
  *     def get_legal_moves(self) -> List[Move]:
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 24, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 24, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(0, 24, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":22
  * 
@@ -2106,14 +2313,15 @@
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.GameState.get_current_team", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "multimcts/mcts.pyx":26
  *         raise NotImplementedError("GameState must implement get_current_team.")
  * 
@@ -2135,29 +2343,32 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_2get_legal_moves(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
+  __Pyx_TraceFrameInit(__pyx_codeobj__3)
   __Pyx_RefNannySetupContext("get_legal_moves", 0);
+  __Pyx_TraceCall("get_legal_moves", __pyx_f[0], 26, 0, __PYX_ERR(0, 26, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":28
  *     def get_legal_moves(self) -> List[Move]:
  *         """List of all legal moves from this state."""
  *         raise NotImplementedError("GameState must implement get_legal_moves.")             # <<<<<<<<<<<<<<
  * 
  *     def make_move(self, move:Move) -> 'GameState':
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 28, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 28, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(0, 28, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":26
  *         raise NotImplementedError("GameState must implement get_current_team.")
@@ -2169,14 +2380,15 @@
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.GameState.get_legal_moves", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "multimcts/mcts.pyx":30
  *         raise NotImplementedError("GameState must implement get_legal_moves.")
  * 
@@ -2249,29 +2461,32 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_4make_move(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_move) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
+  __Pyx_TraceFrameInit(__pyx_codeobj__5)
   __Pyx_RefNannySetupContext("make_move", 0);
+  __Pyx_TraceCall("make_move", __pyx_f[0], 30, 0, __PYX_ERR(0, 30, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":34
  *         Note: The current state (self) should NOT be modified. Rather, modify a copy of it.
  *         """
  *         raise NotImplementedError("GameState must implement make_move.")             # <<<<<<<<<<<<<<
  * 
  *     def is_terminal(self) -> bool:
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(0, 34, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":30
  *         raise NotImplementedError("GameState must implement get_legal_moves.")
@@ -2283,14 +2498,15 @@
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.GameState.make_move", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "multimcts/mcts.pyx":36
  *         raise NotImplementedError("GameState must implement make_move.")
  * 
@@ -2312,29 +2528,32 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_6is_terminal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
+  __Pyx_TraceFrameInit(__pyx_codeobj__7)
   __Pyx_RefNannySetupContext("is_terminal", 0);
+  __Pyx_TraceCall("is_terminal", __pyx_f[0], 36, 0, __PYX_ERR(0, 36, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":38
  *     def is_terminal(self) -> bool:
  *         """Is the game over?"""
  *         raise NotImplementedError("GameState must implement is_terminal.")             # <<<<<<<<<<<<<<
  * 
  *     def get_reward(self) -> Union[float,Rewards]:
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 38, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 38, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(0, 38, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":36
  *         raise NotImplementedError("GameState must implement make_move.")
@@ -2346,83 +2565,88 @@
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.GameState.is_terminal", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "multimcts/mcts.pyx":40
  *         raise NotImplementedError("GameState must implement is_terminal.")
  * 
  *     def get_reward(self) -> Union[float,Rewards]:             # <<<<<<<<<<<<<<
- *         """The reward earned by the team that played the game-ending move (the "terminal team", or the team from the previous state).
+ *         """The reward earned by the team that played the game-ending move (i.e. the team from the previous state).
  *         Typically 1 for win, -1 for loss, 0 for draw.
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_9multimcts_4mcts_9GameState_9get_reward(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
-static char __pyx_doc_9multimcts_4mcts_9GameState_8get_reward[] = "The reward earned by the team that played the game-ending move (the \"terminal team\", or the team from the previous state).\n        Typically 1 for win, -1 for loss, 0 for draw.\n        Alternatively, returns a dict of teams/rewards: {team1:reward1, team2:reward2, ...}\n        Note: This method is only called on terminal states.\n        ";
+static char __pyx_doc_9multimcts_4mcts_9GameState_8get_reward[] = "The reward earned by the team that played the game-ending move (i.e. the team from the previous state).\n        Typically 1 for win, -1 for loss, 0 for draw.\n        Alternatively, returns a dict of teams/rewards: {team1:reward1, team2:reward2, ...}\n        Note: This method is only called on terminal states.\n        ";
 static PyMethodDef __pyx_mdef_9multimcts_4mcts_9GameState_9get_reward = {"get_reward", (PyCFunction)__pyx_pw_9multimcts_4mcts_9GameState_9get_reward, METH_O, __pyx_doc_9multimcts_4mcts_9GameState_8get_reward};
 static PyObject *__pyx_pw_9multimcts_4mcts_9GameState_9get_reward(PyObject *__pyx_self, PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("get_reward (wrapper)", 0);
   __pyx_r = __pyx_pf_9multimcts_4mcts_9GameState_8get_reward(__pyx_self, ((PyObject *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_9GameState_8get_reward(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
+  __Pyx_TraceFrameInit(__pyx_codeobj__9)
   __Pyx_RefNannySetupContext("get_reward", 0);
+  __Pyx_TraceCall("get_reward", __pyx_f[0], 40, 0, __PYX_ERR(0, 40, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":46
  *         Note: This method is only called on terminal states.
  *         """
  *         raise NotImplementedError("GameState must implement get_reward.")             # <<<<<<<<<<<<<<
  * 
- * 
+ *     '''#.WIP
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 46, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 46, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(0, 46, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":40
  *         raise NotImplementedError("GameState must implement is_terminal.")
  * 
  *     def get_reward(self) -> Union[float,Rewards]:             # <<<<<<<<<<<<<<
- *         """The reward earned by the team that played the game-ending move (the "terminal team", or the team from the previous state).
+ *         """The reward earned by the team that played the game-ending move (i.e. the team from the previous state).
  *         Typically 1 for win, -1 for loss, 0 for draw.
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.GameState.get_reward", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":72
- *     cdef double avg_reward, sqrtlog_visits, invsqrt_visits
+/* "multimcts/mcts.pyx":89
+ *     cdef double sqrtlog_visits, invsqrt_visits, avg_reward, avg_rave_reward
  * 
  *     def __init__(self, state:GameState, parent:'Node'=None, move:Move=None):             # <<<<<<<<<<<<<<
  *         self.state = state
  *         self.parent = parent
  */
 
 /* Python wrapper */
@@ -2470,15 +2694,15 @@
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_move);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 72, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 89, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
@@ -2489,361 +2713,393 @@
     }
     __pyx_v_state = values[0];
     __pyx_v_parent = ((struct __pyx_obj_9multimcts_4mcts_Node *)values[1]);
     __pyx_v_move = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 72, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 89, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("multimcts.mcts.Node.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_parent), __pyx_ptype_9multimcts_4mcts_Node, 1, "parent", 0))) __PYX_ERR(0, 72, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_parent), __pyx_ptype_9multimcts_4mcts_Node, 1, "parent", 0))) __PYX_ERR(0, 89, __pyx_L1_error)
   __pyx_r = __pyx_pf_9multimcts_4mcts_4Node___init__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), __pyx_v_state, __pyx_v_parent, __pyx_v_move);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_9multimcts_4mcts_4Node___init__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v_state, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_parent, PyObject *__pyx_v_move) {
   int __pyx_r;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   std::map<std::string,double>  __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_t_5;
   std::string __pyx_t_6;
   int __pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
+  __Pyx_TraceCall("__init__", __pyx_f[0], 89, 0, __PYX_ERR(0, 89, __pyx_L1_error));
 
-  /* "multimcts/mcts.pyx":73
+  /* "multimcts/mcts.pyx":90
  * 
  *     def __init__(self, state:GameState, parent:'Node'=None, move:Move=None):
  *         self.state = state             # <<<<<<<<<<<<<<
  *         self.parent = parent
  *         self.move = move
  */
   __Pyx_INCREF(__pyx_v_state);
   __Pyx_GIVEREF(__pyx_v_state);
   __Pyx_GOTREF(__pyx_v_self->state);
   __Pyx_DECREF(__pyx_v_self->state);
   __pyx_v_self->state = __pyx_v_state;
 
-  /* "multimcts/mcts.pyx":74
+  /* "multimcts/mcts.pyx":91
  *     def __init__(self, state:GameState, parent:'Node'=None, move:Move=None):
  *         self.state = state
  *         self.parent = parent             # <<<<<<<<<<<<<<
  *         self.move = move
  * 
  */
   __Pyx_INCREF(((PyObject *)__pyx_v_parent));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_parent));
   __Pyx_GOTREF(__pyx_v_self->parent);
   __Pyx_DECREF(((PyObject *)__pyx_v_self->parent));
   __pyx_v_self->parent = __pyx_v_parent;
 
-  /* "multimcts/mcts.pyx":75
+  /* "multimcts/mcts.pyx":92
  *         self.state = state
  *         self.parent = parent
  *         self.move = move             # <<<<<<<<<<<<<<
  * 
- *         self.children:List['Node'] = []
+ *         self.children:Dict[Move,'Node'] = {}
  */
   __Pyx_INCREF(__pyx_v_move);
   __Pyx_GIVEREF(__pyx_v_move);
   __Pyx_GOTREF(__pyx_v_self->move);
   __Pyx_DECREF(__pyx_v_self->move);
   __pyx_v_self->move = __pyx_v_move;
 
-  /* "multimcts/mcts.pyx":77
+  /* "multimcts/mcts.pyx":94
  *         self.move = move
  * 
- *         self.children:List['Node'] = []             # <<<<<<<<<<<<<<
+ *         self.children:Dict[Move,'Node'] = {}             # <<<<<<<<<<<<<<
  *         self.visits = 0
- *         self.rewards = map[string,double]()
+ *         self.rave_visits = 0
  */
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 77, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v_self->children);
   __Pyx_DECREF(__pyx_v_self->children);
   __pyx_v_self->children = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "multimcts/mcts.pyx":78
+  /* "multimcts/mcts.pyx":95
  * 
- *         self.children:List['Node'] = []
+ *         self.children:Dict[Move,'Node'] = {}
  *         self.visits = 0             # <<<<<<<<<<<<<<
+ *         self.rave_visits = 0
  *         self.rewards = map[string,double]()
- *         self.is_terminal = self.state.is_terminal()
  */
   __pyx_v_self->visits = 0;
 
-  /* "multimcts/mcts.pyx":79
- *         self.children:List['Node'] = []
+  /* "multimcts/mcts.pyx":96
+ *         self.children:Dict[Move,'Node'] = {}
  *         self.visits = 0
+ *         self.rave_visits = 0             # <<<<<<<<<<<<<<
+ *         self.rewards = map[string,double]()
+ *         self.rave_rewards = map[string,double]()
+ */
+  __pyx_v_self->rave_visits = 0;
+
+  /* "multimcts/mcts.pyx":97
+ *         self.visits = 0
+ *         self.rave_visits = 0
  *         self.rewards = map[string,double]()             # <<<<<<<<<<<<<<
+ *         self.rave_rewards = map[string,double]()
  *         self.is_terminal = self.state.is_terminal()
- *         self.is_fully_expanded = self.is_terminal
  */
   try {
     __pyx_t_2 = std::map<std::string,double> ();
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 79, __pyx_L1_error)
+    __PYX_ERR(0, 97, __pyx_L1_error)
   }
   __pyx_v_self->rewards = __pyx_t_2;
 
-  /* "multimcts/mcts.pyx":80
- *         self.visits = 0
+  /* "multimcts/mcts.pyx":98
+ *         self.rave_visits = 0
  *         self.rewards = map[string,double]()
+ *         self.rave_rewards = map[string,double]()             # <<<<<<<<<<<<<<
+ *         self.is_terminal = self.state.is_terminal()
+ *         self.is_fully_expanded = self.is_terminal
+ */
+  try {
+    __pyx_t_2 = std::map<std::string,double> ();
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 98, __pyx_L1_error)
+  }
+  __pyx_v_self->rave_rewards = __pyx_t_2;
+
+  /* "multimcts/mcts.pyx":99
+ *         self.rewards = map[string,double]()
+ *         self.rave_rewards = map[string,double]()
  *         self.is_terminal = self.state.is_terminal()             # <<<<<<<<<<<<<<
  *         self.is_fully_expanded = self.is_terminal
  *         if self.is_fully_expanded:
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_is_terminal); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 80, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_is_terminal); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 80, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_self->is_terminal = __pyx_t_5;
 
-  /* "multimcts/mcts.pyx":81
- *         self.rewards = map[string,double]()
+  /* "multimcts/mcts.pyx":100
+ *         self.rave_rewards = map[string,double]()
  *         self.is_terminal = self.state.is_terminal()
  *         self.is_fully_expanded = self.is_terminal             # <<<<<<<<<<<<<<
  *         if self.is_fully_expanded:
  *             self.remaining_moves = []
  */
   __pyx_t_5 = __pyx_v_self->is_terminal;
   __pyx_v_self->is_fully_expanded = __pyx_t_5;
 
-  /* "multimcts/mcts.pyx":82
+  /* "multimcts/mcts.pyx":101
  *         self.is_terminal = self.state.is_terminal()
  *         self.is_fully_expanded = self.is_terminal
  *         if self.is_fully_expanded:             # <<<<<<<<<<<<<<
  *             self.remaining_moves = []
  *         else:
  */
   __pyx_t_5 = (__pyx_v_self->is_fully_expanded != 0);
   if (__pyx_t_5) {
 
-    /* "multimcts/mcts.pyx":83
+    /* "multimcts/mcts.pyx":102
  *         self.is_fully_expanded = self.is_terminal
  *         if self.is_fully_expanded:
  *             self.remaining_moves = []             # <<<<<<<<<<<<<<
  *         else:
  *             self.remaining_moves = self.state.get_legal_moves()
  */
-    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 83, __pyx_L1_error)
+    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 102, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_GIVEREF(__pyx_t_1);
     __Pyx_GOTREF(__pyx_v_self->remaining_moves);
     __Pyx_DECREF(__pyx_v_self->remaining_moves);
     __pyx_v_self->remaining_moves = __pyx_t_1;
     __pyx_t_1 = 0;
 
-    /* "multimcts/mcts.pyx":82
+    /* "multimcts/mcts.pyx":101
  *         self.is_terminal = self.state.is_terminal()
  *         self.is_fully_expanded = self.is_terminal
  *         if self.is_fully_expanded:             # <<<<<<<<<<<<<<
  *             self.remaining_moves = []
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "multimcts/mcts.pyx":85
+  /* "multimcts/mcts.pyx":104
  *             self.remaining_moves = []
  *         else:
  *             self.remaining_moves = self.state.get_legal_moves()             # <<<<<<<<<<<<<<
  *             shuffle(self.remaining_moves)
  * 
  */
   /*else*/ {
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_get_legal_moves); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 85, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_get_legal_moves); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 104, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_4 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_4)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 85, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 104, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GIVEREF(__pyx_t_1);
     __Pyx_GOTREF(__pyx_v_self->remaining_moves);
     __Pyx_DECREF(__pyx_v_self->remaining_moves);
     __pyx_v_self->remaining_moves = __pyx_t_1;
     __pyx_t_1 = 0;
 
-    /* "multimcts/mcts.pyx":86
+    /* "multimcts/mcts.pyx":105
  *         else:
  *             self.remaining_moves = self.state.get_legal_moves()
  *             shuffle(self.remaining_moves)             # <<<<<<<<<<<<<<
  * 
  *         # The following are cached for performance.
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_shuffle); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 86, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_shuffle); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 105, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_4 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_4)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_self->remaining_moves) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_self->remaining_moves);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 86, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 105, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   }
   __pyx_L3:;
 
-  /* "multimcts/mcts.pyx":89
+  /* "multimcts/mcts.pyx":108
  * 
  *         # The following are cached for performance.
- *         self.team = self.state.get_current_team()             # <<<<<<<<<<<<<<
- *         self.cteam = str(self.team).encode()
+ *         self.team = str(self.state.get_current_team()).encode()             # <<<<<<<<<<<<<<
  *         if self.parent is not None:
+ *             self.rewards[self.parent.team] = 0
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_get_current_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_get_current_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 108, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 89, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 108, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_GIVEREF(__pyx_t_1);
-  __Pyx_GOTREF(__pyx_v_self->team);
-  __Pyx_DECREF(__pyx_v_self->team);
-  __pyx_v_self->team = __pyx_t_1;
-  __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":90
- *         # The following are cached for performance.
- *         self.team = self.state.get_current_team()
- *         self.cteam = str(self.team).encode()             # <<<<<<<<<<<<<<
- *         if self.parent is not None:
- *             self.rewards[self.parent.cteam] = 0
- */
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_self->team); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 90, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = PyUnicode_AsEncodedString(((PyObject*)__pyx_t_1), NULL, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 90, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 108, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __pyx_convert_string_from_py_std__in_string(__pyx_t_3); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 90, __pyx_L1_error)
+  __pyx_t_1 = PyUnicode_AsEncodedString(((PyObject*)__pyx_t_3), NULL, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 108, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_self->cteam = __pyx_t_6;
+  __pyx_t_6 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 108, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_self->team = __pyx_t_6;
 
-  /* "multimcts/mcts.pyx":91
- *         self.team = self.state.get_current_team()
- *         self.cteam = str(self.team).encode()
+  /* "multimcts/mcts.pyx":109
+ *         # The following are cached for performance.
+ *         self.team = str(self.state.get_current_team()).encode()
  *         if self.parent is not None:             # <<<<<<<<<<<<<<
- *             self.rewards[self.parent.cteam] = 0
- *         self.sqrtlog_visits = 0
+ *             self.rewards[self.parent.team] = 0
+ *             self.rave_rewards[self.parent.team] = 0
  */
   __pyx_t_5 = (((PyObject *)__pyx_v_self->parent) != Py_None);
   __pyx_t_7 = (__pyx_t_5 != 0);
   if (__pyx_t_7) {
 
-    /* "multimcts/mcts.pyx":92
- *         self.cteam = str(self.team).encode()
+    /* "multimcts/mcts.pyx":110
+ *         self.team = str(self.state.get_current_team()).encode()
  *         if self.parent is not None:
- *             self.rewards[self.parent.cteam] = 0             # <<<<<<<<<<<<<<
+ *             self.rewards[self.parent.team] = 0             # <<<<<<<<<<<<<<
+ *             self.rave_rewards[self.parent.team] = 0
+ *         self.sqrtlog_visits = 0
+ */
+    (__pyx_v_self->rewards[__pyx_v_self->parent->team]) = 0.0;
+
+    /* "multimcts/mcts.pyx":111
+ *         if self.parent is not None:
+ *             self.rewards[self.parent.team] = 0
+ *             self.rave_rewards[self.parent.team] = 0             # <<<<<<<<<<<<<<
  *         self.sqrtlog_visits = 0
  *         self.invsqrt_visits = 0
  */
-    (__pyx_v_self->rewards[__pyx_v_self->parent->cteam]) = 0.0;
+    (__pyx_v_self->rave_rewards[__pyx_v_self->parent->team]) = 0.0;
 
-    /* "multimcts/mcts.pyx":91
- *         self.team = self.state.get_current_team()
- *         self.cteam = str(self.team).encode()
+    /* "multimcts/mcts.pyx":109
+ *         # The following are cached for performance.
+ *         self.team = str(self.state.get_current_team()).encode()
  *         if self.parent is not None:             # <<<<<<<<<<<<<<
- *             self.rewards[self.parent.cteam] = 0
- *         self.sqrtlog_visits = 0
+ *             self.rewards[self.parent.team] = 0
+ *             self.rave_rewards[self.parent.team] = 0
  */
   }
 
-  /* "multimcts/mcts.pyx":93
- *         if self.parent is not None:
- *             self.rewards[self.parent.cteam] = 0
+  /* "multimcts/mcts.pyx":112
+ *             self.rewards[self.parent.team] = 0
+ *             self.rave_rewards[self.parent.team] = 0
  *         self.sqrtlog_visits = 0             # <<<<<<<<<<<<<<
  *         self.invsqrt_visits = 0
  *         self.avg_reward = 0
  */
   __pyx_v_self->sqrtlog_visits = 0.0;
 
-  /* "multimcts/mcts.pyx":94
- *             self.rewards[self.parent.cteam] = 0
+  /* "multimcts/mcts.pyx":113
+ *             self.rave_rewards[self.parent.team] = 0
  *         self.sqrtlog_visits = 0
  *         self.invsqrt_visits = 0             # <<<<<<<<<<<<<<
  *         self.avg_reward = 0
- * 
+ *         self.avg_rave_reward = 0
  */
   __pyx_v_self->invsqrt_visits = 0.0;
 
-  /* "multimcts/mcts.pyx":95
+  /* "multimcts/mcts.pyx":114
  *         self.sqrtlog_visits = 0
  *         self.invsqrt_visits = 0
  *         self.avg_reward = 0             # <<<<<<<<<<<<<<
+ *         self.avg_rave_reward = 0
  * 
- *     @property
  */
   __pyx_v_self->avg_reward = 0.0;
 
-  /* "multimcts/mcts.pyx":72
- *     cdef double avg_reward, sqrtlog_visits, invsqrt_visits
+  /* "multimcts/mcts.pyx":115
+ *         self.invsqrt_visits = 0
+ *         self.avg_reward = 0
+ *         self.avg_rave_reward = 0             # <<<<<<<<<<<<<<
+ * 
+ *     def get_state(self) -> GameState: return self.state
+ */
+  __pyx_v_self->avg_rave_reward = 0.0;
+
+  /* "multimcts/mcts.pyx":89
+ *     cdef double sqrtlog_visits, invsqrt_visits, avg_reward, avg_rave_reward
  * 
  *     def __init__(self, state:GameState, parent:'Node'=None, move:Move=None):             # <<<<<<<<<<<<<<
  *         self.state = state
  *         self.parent = parent
  */
 
   /* function exit code */
@@ -2852,619 +3108,3262 @@
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("multimcts.mcts.Node.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
+  __Pyx_TraceReturn(Py_None, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":98
+/* "multimcts/mcts.pyx":117
+ *         self.avg_rave_reward = 0
  * 
- *     @property
- *     def state(self) -> GameState: return self.state             # <<<<<<<<<<<<<<
- *     @property
- *     def rewards(self): return self.rewards
+ *     def get_state(self) -> GameState: return self.state             # <<<<<<<<<<<<<<
+ *     def get_team(self) -> str: return self.team.decode()
+ *     def get_move(self) -> Move: return self.move
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5state_1__get__(PyObject *__pyx_v_self); /*proto*/
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5state_1__get__(PyObject *__pyx_v_self) {
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_3get_state(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_3get_state(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_5state___get__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+  __Pyx_RefNannySetupContext("get_state (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_2get_state(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_5state___get__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_2get_state(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__get__", 0);
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_state", 0);
+  __Pyx_TraceCall("get_state", __pyx_f[0], 117, 0, __PYX_ERR(0, 117, __pyx_L1_error));
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->state);
   __pyx_r = __pyx_v_self->state;
   goto __pyx_L0;
 
   /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":100
- *     def state(self) -> GameState: return self.state
- *     @property
- *     def rewards(self): return self.rewards             # <<<<<<<<<<<<<<
+/* "multimcts/mcts.pyx":118
+ * 
+ *     def get_state(self) -> GameState: return self.state
+ *     def get_team(self) -> str: return self.team.decode()             # <<<<<<<<<<<<<<
+ *     def get_move(self) -> Move: return self.move
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5get_team(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5get_team(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_team (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_4get_team(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_4get_team(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_team", 0);
+  __Pyx_TraceCall("get_team", __pyx_f[0], 118, 0, __PYX_ERR(0, 118, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_decode_cpp_string(__pyx_v_self->team, 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 118, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_team", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":119
+ *     def get_state(self) -> GameState: return self.state
+ *     def get_team(self) -> str: return self.team.decode()
+ *     def get_move(self) -> Move: return self.move             # <<<<<<<<<<<<<<
+ * 
+ *     def get_parent(self) -> 'Node': return self.parent
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_7get_move(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_7get_move(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_move (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_6get_move(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_6get_move(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_move", 0);
+  __Pyx_TraceCall("get_move", __pyx_f[0], 119, 0, __PYX_ERR(0, 119, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_self->move);
+  __pyx_r = __pyx_v_self->move;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_move", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":121
+ *     def get_move(self) -> Move: return self.move
+ * 
+ *     def get_parent(self) -> 'Node': return self.parent             # <<<<<<<<<<<<<<
+ *     def get_children(self) -> Dict[Move,'Node']: return self.children
+ * 
+ */
+
+/* Python wrapper */
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_pw_9multimcts_4mcts_4Node_9get_parent(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_pw_9multimcts_4mcts_4Node_9get_parent(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_parent (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_8get_parent(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_pf_9multimcts_4mcts_4Node_8get_parent(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_parent", 0);
+  __Pyx_TraceCall("get_parent", __pyx_f[0], 121, 0, __PYX_ERR(0, 121, __pyx_L1_error));
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_self->parent));
+  __pyx_r = __pyx_v_self->parent;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_parent", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":122
+ * 
+ *     def get_parent(self) -> 'Node': return self.parent
+ *     def get_children(self) -> Dict[Move,'Node']: return self.children             # <<<<<<<<<<<<<<
+ * 
+ *     def get_visits(self) -> int: return self.visits
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_11get_children(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_11get_children(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_children (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_10get_children(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_10get_children(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_children", 0);
+  __Pyx_TraceCall("get_children", __pyx_f[0], 122, 0, __PYX_ERR(0, 122, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_self->children);
+  __pyx_r = __pyx_v_self->children;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_children", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":124
+ *     def get_children(self) -> Dict[Move,'Node']: return self.children
+ * 
+ *     def get_visits(self) -> int: return self.visits             # <<<<<<<<<<<<<<
+ *     def get_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rewards}
+ *     def get_avg_reward(self) -> double: return self.avg_reward
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_13get_visits(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_13get_visits(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_visits (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_12get_visits(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_12get_visits(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_visits", 0);
+  __Pyx_TraceCall("get_visits", __pyx_f[0], 124, 0, __PYX_ERR(0, 124, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->visits); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 124, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_visits", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":125
+ * 
+ *     def get_visits(self) -> int: return self.visits
+ *     def get_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rewards}             # <<<<<<<<<<<<<<
+ *     def get_avg_reward(self) -> double: return self.avg_reward
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_15get_rewards(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_15get_rewards(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_rewards (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_14get_rewards(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_14get_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  std::pair<std::string,double>  __pyx_7genexpr__pyx_v_item;
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  std::map<std::string,double> ::iterator __pyx_t_2;
+  std::map<std::string,double>  *__pyx_t_3;
+  std::pair<std::string,double>  __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_rewards", 0);
+  __Pyx_TraceCall("get_rewards", __pyx_f[0], 125, 0, __PYX_ERR(0, 125, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  { /* enter inner scope */
+    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 125, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = &__pyx_v_self->rewards;
+    __pyx_t_2 = __pyx_t_3->begin();
+    for (;;) {
+      if (!(__pyx_t_2 != __pyx_t_3->end())) break;
+      __pyx_t_4 = *__pyx_t_2;
+      ++__pyx_t_2;
+      __pyx_7genexpr__pyx_v_item = __pyx_t_4;
+      __pyx_t_5 = __Pyx_decode_cpp_string(__pyx_7genexpr__pyx_v_item.first, 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 125, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_6 = PyFloat_FromDouble(__pyx_7genexpr__pyx_v_item.second); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 125, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      if (unlikely(PyDict_SetItem(__pyx_t_1, (PyObject*)__pyx_t_5, (PyObject*)__pyx_t_6))) __PYX_ERR(0, 125, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    }
+  } /* exit inner scope */
+  __pyx_r = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_rewards", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":126
+ *     def get_visits(self) -> int: return self.visits
+ *     def get_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rewards}
+ *     def get_avg_reward(self) -> double: return self.avg_reward             # <<<<<<<<<<<<<<
+ * 
+ *     def get_rave_visits(self) -> int: return self.rave_visits
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_17get_avg_reward(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_17get_avg_reward(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_avg_reward (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_16get_avg_reward(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_16get_avg_reward(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_avg_reward", 0);
+  __Pyx_TraceCall("get_avg_reward", __pyx_f[0], 126, 0, __PYX_ERR(0, 126, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->avg_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 126, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_avg_reward", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":128
+ *     def get_avg_reward(self) -> double: return self.avg_reward
+ * 
+ *     def get_rave_visits(self) -> int: return self.rave_visits             # <<<<<<<<<<<<<<
+ *     def get_rave_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rave_rewards}
+ *     def get_avg_rave_reward(self) -> double: return self.avg_rave_reward
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_19get_rave_visits(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_19get_rave_visits(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_rave_visits (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_18get_rave_visits(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_18get_rave_visits(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_rave_visits", 0);
+  __Pyx_TraceCall("get_rave_visits", __pyx_f[0], 128, 0, __PYX_ERR(0, 128, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->rave_visits); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_rave_visits", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":129
+ * 
+ *     def get_rave_visits(self) -> int: return self.rave_visits
+ *     def get_rave_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rave_rewards}             # <<<<<<<<<<<<<<
+ *     def get_avg_rave_reward(self) -> double: return self.avg_rave_reward
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_21get_rave_rewards(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_21get_rave_rewards(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("get_rave_rewards (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_20get_rave_rewards(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_20get_rave_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  std::pair<std::string,double>  __pyx_8genexpr1__pyx_v_item;
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  std::map<std::string,double> ::iterator __pyx_t_2;
+  std::map<std::string,double>  *__pyx_t_3;
+  std::pair<std::string,double>  __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("get_rave_rewards", 0);
+  __Pyx_TraceCall("get_rave_rewards", __pyx_f[0], 129, 0, __PYX_ERR(0, 129, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  { /* enter inner scope */
+    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = &__pyx_v_self->rave_rewards;
+    __pyx_t_2 = __pyx_t_3->begin();
+    for (;;) {
+      if (!(__pyx_t_2 != __pyx_t_3->end())) break;
+      __pyx_t_4 = *__pyx_t_2;
+      ++__pyx_t_2;
+      __pyx_8genexpr1__pyx_v_item = __pyx_t_4;
+      __pyx_t_5 = __Pyx_decode_cpp_string(__pyx_8genexpr1__pyx_v_item.first, 0, PY_SSIZE_T_MAX, NULL, NULL, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_6 = PyFloat_FromDouble(__pyx_8genexpr1__pyx_v_item.second); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      if (unlikely(PyDict_SetItem(__pyx_t_1, (PyObject*)__pyx_t_5, (PyObject*)__pyx_t_6))) __PYX_ERR(0, 129, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    }
+  } /* exit inner scope */
+  __pyx_r = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_rave_rewards", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":130
+ *     def get_rave_visits(self) -> int: return self.rave_visits
+ *     def get_rave_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rave_rewards}
+ *     def get_avg_rave_reward(self) -> double: return self.avg_rave_reward             # <<<<<<<<<<<<<<
  * 
  *     @cython.cdivision(True)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_7rewards_1__get__(PyObject *__pyx_v_self); /*proto*/
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_7rewards_1__get__(PyObject *__pyx_v_self) {
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_23get_avg_rave_reward(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_23get_avg_rave_reward(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_7rewards___get__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+  __Pyx_RefNannySetupContext("get_avg_rave_reward (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_22get_avg_rave_reward(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_7rewards___get__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_22get_avg_rave_reward(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_RefNannySetupContext("get_avg_rave_reward", 0);
+  __Pyx_TraceCall("get_avg_rave_reward", __pyx_f[0], 130, 0, __PYX_ERR(0, 130, __pyx_L1_error));
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_convert_map_to_py_std_3a__3a_string____double(__pyx_v_self->rewards); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 100, __pyx_L1_error)
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->avg_rave_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("multimcts.mcts.Node.rewards.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("multimcts.mcts.Node.get_avg_rave_reward", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":103
+/* "multimcts/mcts.pyx":133
  * 
  *     @cython.cdivision(True)
- *     cdef apply_rewards(self, map[string,double] crewards):             # <<<<<<<<<<<<<<
+ *     cdef visit(self, map[string,double] crewards, moves):             # <<<<<<<<<<<<<<
  *         """Update this node's visits and rewards, and cache some variables for more efficient UCB calculation."""
  *         self.visits += 1
  */
 
-static PyObject *__pyx_f_9multimcts_4mcts_4Node_apply_rewards(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, std::map<std::string,double>  __pyx_v_crewards) {
+static PyObject *__pyx_f_9multimcts_4mcts_4Node_visit(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, std::map<std::string,double>  __pyx_v_crewards, PyObject *__pyx_v_moves) {
   std::pair<std::string,double>  __pyx_v_item;
-  double __pyx_v_total_rewards;
+  double __pyx_v_total_reward;
+  int __pyx_v_rave_visits;
+  double __pyx_v_total_rave_reward;
+  PyObject *__pyx_v_move = NULL;
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   std::map<std::string,double> ::iterator __pyx_t_1;
   std::pair<std::string,double>  __pyx_t_2;
   int __pyx_t_3;
   std::string __pyx_t_4;
   int __pyx_t_5;
-  __Pyx_RefNannySetupContext("apply_rewards", 0);
+  PyObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  Py_ssize_t __pyx_t_9;
+  PyObject *(*__pyx_t_10)(PyObject *);
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("visit", 0);
+  __Pyx_TraceCall("visit", __pyx_f[0], 133, 0, __PYX_ERR(0, 133, __pyx_L1_error));
 
-  /* "multimcts/mcts.pyx":105
- *     cdef apply_rewards(self, map[string,double] crewards):
+  /* "multimcts/mcts.pyx":135
+ *     cdef visit(self, map[string,double] crewards, moves):
  *         """Update this node's visits and rewards, and cache some variables for more efficient UCB calculation."""
  *         self.visits += 1             # <<<<<<<<<<<<<<
  * 
- *         self.sqrtlog_visits = sqrt(log(self.visits))
+ *         self.sqrtlog_visits = sqrtlog(self.visits)
  */
   __pyx_v_self->visits = (__pyx_v_self->visits + 1);
 
-  /* "multimcts/mcts.pyx":107
+  /* "multimcts/mcts.pyx":137
  *         self.visits += 1
  * 
- *         self.sqrtlog_visits = sqrt(log(self.visits))             # <<<<<<<<<<<<<<
- *         self.invsqrt_visits = 1 / sqrt(self.visits)
+ *         self.sqrtlog_visits = sqrtlog(self.visits)             # <<<<<<<<<<<<<<
+ *         self.invsqrt_visits = invsqrt(self.visits)
  * 
  */
-  __pyx_v_self->sqrtlog_visits = sqrt(log(__pyx_v_self->visits));
+  __pyx_v_self->sqrtlog_visits = __pyx_f_9multimcts_4mcts_sqrtlog(__pyx_v_self->visits);
 
-  /* "multimcts/mcts.pyx":108
+  /* "multimcts/mcts.pyx":138
  * 
- *         self.sqrtlog_visits = sqrt(log(self.visits))
- *         self.invsqrt_visits = 1 / sqrt(self.visits)             # <<<<<<<<<<<<<<
+ *         self.sqrtlog_visits = sqrtlog(self.visits)
+ *         self.invsqrt_visits = invsqrt(self.visits)             # <<<<<<<<<<<<<<
  * 
- *         cdef pair[string,double] item
+ *         # Update regular rewards.
  */
-  __pyx_v_self->invsqrt_visits = (1.0 / sqrt(__pyx_v_self->visits));
+  __pyx_v_self->invsqrt_visits = __pyx_f_9multimcts_4mcts_invsqrt(__pyx_v_self->visits);
 
-  /* "multimcts/mcts.pyx":111
- * 
+  /* "multimcts/mcts.pyx":142
+ *         # Update regular rewards.
  *         cdef pair[string,double] item
- *         cdef double total_rewards = 0             # <<<<<<<<<<<<<<
+ *         cdef double total_reward = 0             # <<<<<<<<<<<<<<
  *         for item in crewards:
  *             if self.rewards.count(item.first) == 0:
  */
-  __pyx_v_total_rewards = 0.0;
+  __pyx_v_total_reward = 0.0;
 
-  /* "multimcts/mcts.pyx":112
+  /* "multimcts/mcts.pyx":143
  *         cdef pair[string,double] item
- *         cdef double total_rewards = 0
+ *         cdef double total_reward = 0
  *         for item in crewards:             # <<<<<<<<<<<<<<
  *             if self.rewards.count(item.first) == 0:
  *                 self.rewards[item.first] = 0
  */
   __pyx_t_1 = __pyx_v_crewards.begin();
   for (;;) {
     if (!(__pyx_t_1 != __pyx_v_crewards.end())) break;
     __pyx_t_2 = *__pyx_t_1;
     ++__pyx_t_1;
     __pyx_v_item = __pyx_t_2;
 
-    /* "multimcts/mcts.pyx":113
- *         cdef double total_rewards = 0
+    /* "multimcts/mcts.pyx":144
+ *         cdef double total_reward = 0
  *         for item in crewards:
  *             if self.rewards.count(item.first) == 0:             # <<<<<<<<<<<<<<
  *                 self.rewards[item.first] = 0
  *             self.rewards[item.first] += item.second
  */
     __pyx_t_3 = ((__pyx_v_self->rewards.count(__pyx_v_item.first) == 0) != 0);
     if (__pyx_t_3) {
 
-      /* "multimcts/mcts.pyx":114
+      /* "multimcts/mcts.pyx":145
  *         for item in crewards:
  *             if self.rewards.count(item.first) == 0:
  *                 self.rewards[item.first] = 0             # <<<<<<<<<<<<<<
  *             self.rewards[item.first] += item.second
- *             total_rewards += self.rewards[item.first]
+ *             total_reward += self.rewards[item.first]
  */
       (__pyx_v_self->rewards[__pyx_v_item.first]) = 0.0;
 
-      /* "multimcts/mcts.pyx":113
- *         cdef double total_rewards = 0
+      /* "multimcts/mcts.pyx":144
+ *         cdef double total_reward = 0
  *         for item in crewards:
  *             if self.rewards.count(item.first) == 0:             # <<<<<<<<<<<<<<
  *                 self.rewards[item.first] = 0
  *             self.rewards[item.first] += item.second
  */
     }
 
-    /* "multimcts/mcts.pyx":115
+    /* "multimcts/mcts.pyx":146
  *             if self.rewards.count(item.first) == 0:
  *                 self.rewards[item.first] = 0
  *             self.rewards[item.first] += item.second             # <<<<<<<<<<<<<<
- *             total_rewards += self.rewards[item.first]
- * 
+ *             total_reward += self.rewards[item.first]
+ *         if self.parent is not None:
  */
     __pyx_t_4 = __pyx_v_item.first;
     (__pyx_v_self->rewards[__pyx_t_4]) = ((__pyx_v_self->rewards[__pyx_t_4]) + __pyx_v_item.second);
 
-    /* "multimcts/mcts.pyx":116
+    /* "multimcts/mcts.pyx":147
  *                 self.rewards[item.first] = 0
  *             self.rewards[item.first] += item.second
- *             total_rewards += self.rewards[item.first]             # <<<<<<<<<<<<<<
- * 
+ *             total_reward += self.rewards[item.first]             # <<<<<<<<<<<<<<
  *         if self.parent is not None:
+ *             # Average reward: (reward for my parent's team - rewards for all other teams) / num visits to this node
  */
-    __pyx_v_total_rewards = (__pyx_v_total_rewards + (__pyx_v_self->rewards[__pyx_v_item.first]));
+    __pyx_v_total_reward = (__pyx_v_total_reward + (__pyx_v_self->rewards[__pyx_v_item.first]));
 
-    /* "multimcts/mcts.pyx":112
+    /* "multimcts/mcts.pyx":143
  *         cdef pair[string,double] item
- *         cdef double total_rewards = 0
+ *         cdef double total_reward = 0
  *         for item in crewards:             # <<<<<<<<<<<<<<
  *             if self.rewards.count(item.first) == 0:
  *                 self.rewards[item.first] = 0
  */
   }
 
-  /* "multimcts/mcts.pyx":118
- *             total_rewards += self.rewards[item.first]
- * 
+  /* "multimcts/mcts.pyx":148
+ *             self.rewards[item.first] += item.second
+ *             total_reward += self.rewards[item.first]
  *         if self.parent is not None:             # <<<<<<<<<<<<<<
- *             # Average reward is (reward for my parent's team - rewards for all other teams) / num visits to this node.
- *             self.avg_reward = ((2 * self.rewards[self.parent.cteam]) - total_rewards) / self.visits
+ *             # Average reward: (reward for my parent's team - rewards for all other teams) / num visits to this node
+ *             self.avg_reward = ((2*self.rewards[self.parent.team]) - total_reward) / self.visits
  */
   __pyx_t_3 = (((PyObject *)__pyx_v_self->parent) != Py_None);
   __pyx_t_5 = (__pyx_t_3 != 0);
   if (__pyx_t_5) {
 
-    /* "multimcts/mcts.pyx":120
+    /* "multimcts/mcts.pyx":150
  *         if self.parent is not None:
- *             # Average reward is (reward for my parent's team - rewards for all other teams) / num visits to this node.
- *             self.avg_reward = ((2 * self.rewards[self.parent.cteam]) - total_rewards) / self.visits             # <<<<<<<<<<<<<<
+ *             # Average reward: (reward for my parent's team - rewards for all other teams) / num visits to this node
+ *             self.avg_reward = ((2*self.rewards[self.parent.team]) - total_reward) / self.visits             # <<<<<<<<<<<<<<
  * 
- *     cdef double ucb(self, double exploration_bias, double parent_sqrtlog_visits):
+ *         # Update RAVE rewards.
  */
-    __pyx_v_self->avg_reward = (((2.0 * (__pyx_v_self->rewards[__pyx_v_self->parent->cteam])) - __pyx_v_total_rewards) / ((double)__pyx_v_self->visits));
+    __pyx_v_self->avg_reward = (((2.0 * (__pyx_v_self->rewards[__pyx_v_self->parent->team])) - __pyx_v_total_reward) / ((double)__pyx_v_self->visits));
 
-    /* "multimcts/mcts.pyx":118
- *             total_rewards += self.rewards[item.first]
- * 
+    /* "multimcts/mcts.pyx":148
+ *             self.rewards[item.first] += item.second
+ *             total_reward += self.rewards[item.first]
  *         if self.parent is not None:             # <<<<<<<<<<<<<<
- *             # Average reward is (reward for my parent's team - rewards for all other teams) / num visits to this node.
- *             self.avg_reward = ((2 * self.rewards[self.parent.cteam]) - total_rewards) / self.visits
+ *             # Average reward: (reward for my parent's team - rewards for all other teams) / num visits to this node
+ *             self.avg_reward = ((2*self.rewards[self.parent.team]) - total_reward) / self.visits
+ */
+  }
+
+  /* "multimcts/mcts.pyx":153
+ * 
+ *         # Update RAVE rewards.
+ *         cdef int rave_visits = 0             # <<<<<<<<<<<<<<
+ *         cdef double total_rave_reward = 0
+ *         for move in list(self.children.keys()) + self.remaining_moves:
+ */
+  __pyx_v_rave_visits = 0;
+
+  /* "multimcts/mcts.pyx":154
+ *         # Update RAVE rewards.
+ *         cdef int rave_visits = 0
+ *         cdef double total_rave_reward = 0             # <<<<<<<<<<<<<<
+ *         for move in list(self.children.keys()) + self.remaining_moves:
+ *             if move in moves:
+ */
+  __pyx_v_total_rave_reward = 0.0;
+
+  /* "multimcts/mcts.pyx":155
+ *         cdef int rave_visits = 0
+ *         cdef double total_rave_reward = 0
+ *         for move in list(self.children.keys()) + self.remaining_moves:             # <<<<<<<<<<<<<<
+ *             if move in moves:
+ *                 rave_visits += 1
+ */
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->children, __pyx_n_s_keys); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 155, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_8 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
+    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
+    if (likely(__pyx_t_8)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
+      __Pyx_INCREF(__pyx_t_8);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_7, function);
+    }
+  }
+  __pyx_t_6 = (__pyx_t_8) ? __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_8) : __Pyx_PyObject_CallNoArg(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+  if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 155, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_7 = PySequence_List(__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 155, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __pyx_t_6 = PyNumber_Add(__pyx_t_7, __pyx_v_self->remaining_moves); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 155, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_6);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  if (likely(PyList_CheckExact(__pyx_t_6)) || PyTuple_CheckExact(__pyx_t_6)) {
+    __pyx_t_7 = __pyx_t_6; __Pyx_INCREF(__pyx_t_7); __pyx_t_9 = 0;
+    __pyx_t_10 = NULL;
+  } else {
+    __pyx_t_9 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 155, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __pyx_t_10 = Py_TYPE(__pyx_t_7)->tp_iternext; if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 155, __pyx_L1_error)
+  }
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  for (;;) {
+    if (likely(!__pyx_t_10)) {
+      if (likely(PyList_CheckExact(__pyx_t_7))) {
+        if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_7)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_6 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_9); __Pyx_INCREF(__pyx_t_6); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 155, __pyx_L1_error)
+        #else
+        __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 155, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_6);
+        #endif
+      } else {
+        if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_6 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_9); __Pyx_INCREF(__pyx_t_6); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 155, __pyx_L1_error)
+        #else
+        __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 155, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_6);
+        #endif
+      }
+    } else {
+      __pyx_t_6 = __pyx_t_10(__pyx_t_7);
+      if (unlikely(!__pyx_t_6)) {
+        PyObject* exc_type = PyErr_Occurred();
+        if (exc_type) {
+          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+          else __PYX_ERR(0, 155, __pyx_L1_error)
+        }
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_6);
+    }
+    __Pyx_XDECREF_SET(__pyx_v_move, __pyx_t_6);
+    __pyx_t_6 = 0;
+
+    /* "multimcts/mcts.pyx":156
+ *         cdef double total_rave_reward = 0
+ *         for move in list(self.children.keys()) + self.remaining_moves:
+ *             if move in moves:             # <<<<<<<<<<<<<<
+ *                 rave_visits += 1
+ *         if rave_visits > 0:
+ */
+    __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_v_move, __pyx_v_moves, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 156, __pyx_L1_error)
+    __pyx_t_3 = (__pyx_t_5 != 0);
+    if (__pyx_t_3) {
+
+      /* "multimcts/mcts.pyx":157
+ *         for move in list(self.children.keys()) + self.remaining_moves:
+ *             if move in moves:
+ *                 rave_visits += 1             # <<<<<<<<<<<<<<
+ *         if rave_visits > 0:
+ *             self.rave_visits += rave_visits
+ */
+      __pyx_v_rave_visits = (__pyx_v_rave_visits + 1);
+
+      /* "multimcts/mcts.pyx":156
+ *         cdef double total_rave_reward = 0
+ *         for move in list(self.children.keys()) + self.remaining_moves:
+ *             if move in moves:             # <<<<<<<<<<<<<<
+ *                 rave_visits += 1
+ *         if rave_visits > 0:
+ */
+    }
+
+    /* "multimcts/mcts.pyx":155
+ *         cdef int rave_visits = 0
+ *         cdef double total_rave_reward = 0
+ *         for move in list(self.children.keys()) + self.remaining_moves:             # <<<<<<<<<<<<<<
+ *             if move in moves:
+ *                 rave_visits += 1
+ */
+  }
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+
+  /* "multimcts/mcts.pyx":158
+ *             if move in moves:
+ *                 rave_visits += 1
+ *         if rave_visits > 0:             # <<<<<<<<<<<<<<
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:
+ */
+  __pyx_t_3 = ((__pyx_v_rave_visits > 0) != 0);
+  if (__pyx_t_3) {
+
+    /* "multimcts/mcts.pyx":159
+ *                 rave_visits += 1
+ *         if rave_visits > 0:
+ *             self.rave_visits += rave_visits             # <<<<<<<<<<<<<<
+ *             for item in crewards:
+ *                 if self.rave_rewards.count(item.first) == 0:
+ */
+    __pyx_v_self->rave_visits = (__pyx_v_self->rave_visits + __pyx_v_rave_visits);
+
+    /* "multimcts/mcts.pyx":160
+ *         if rave_visits > 0:
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:             # <<<<<<<<<<<<<<
+ *                 if self.rave_rewards.count(item.first) == 0:
+ *                     self.rave_rewards[item.first] = 0
+ */
+    __pyx_t_1 = __pyx_v_crewards.begin();
+    for (;;) {
+      if (!(__pyx_t_1 != __pyx_v_crewards.end())) break;
+      __pyx_t_2 = *__pyx_t_1;
+      ++__pyx_t_1;
+      __pyx_v_item = __pyx_t_2;
+
+      /* "multimcts/mcts.pyx":161
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:
+ *                 if self.rave_rewards.count(item.first) == 0:             # <<<<<<<<<<<<<<
+ *                     self.rave_rewards[item.first] = 0
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ */
+      __pyx_t_3 = ((__pyx_v_self->rave_rewards.count(__pyx_v_item.first) == 0) != 0);
+      if (__pyx_t_3) {
+
+        /* "multimcts/mcts.pyx":162
+ *             for item in crewards:
+ *                 if self.rave_rewards.count(item.first) == 0:
+ *                     self.rave_rewards[item.first] = 0             # <<<<<<<<<<<<<<
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ *                 total_rave_reward += self.rave_rewards[item.first]
+ */
+        (__pyx_v_self->rave_rewards[__pyx_v_item.first]) = 0.0;
+
+        /* "multimcts/mcts.pyx":161
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:
+ *                 if self.rave_rewards.count(item.first) == 0:             # <<<<<<<<<<<<<<
+ *                     self.rave_rewards[item.first] = 0
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ */
+      }
+
+      /* "multimcts/mcts.pyx":163
+ *                 if self.rave_rewards.count(item.first) == 0:
+ *                     self.rave_rewards[item.first] = 0
+ *                 self.rave_rewards[item.first] += rave_visits * item.second             # <<<<<<<<<<<<<<
+ *                 total_rave_reward += self.rave_rewards[item.first]
+ *             if self.parent is not None:
+ */
+      __pyx_t_4 = __pyx_v_item.first;
+      (__pyx_v_self->rave_rewards[__pyx_t_4]) = ((__pyx_v_self->rave_rewards[__pyx_t_4]) + (__pyx_v_rave_visits * __pyx_v_item.second));
+
+      /* "multimcts/mcts.pyx":164
+ *                     self.rave_rewards[item.first] = 0
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ *                 total_rave_reward += self.rave_rewards[item.first]             # <<<<<<<<<<<<<<
+ *             if self.parent is not None:
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits
+ */
+      __pyx_v_total_rave_reward = (__pyx_v_total_rave_reward + (__pyx_v_self->rave_rewards[__pyx_v_item.first]));
+
+      /* "multimcts/mcts.pyx":160
+ *         if rave_visits > 0:
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:             # <<<<<<<<<<<<<<
+ *                 if self.rave_rewards.count(item.first) == 0:
+ *                     self.rave_rewards[item.first] = 0
+ */
+    }
+
+    /* "multimcts/mcts.pyx":165
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ *                 total_rave_reward += self.rave_rewards[item.first]
+ *             if self.parent is not None:             # <<<<<<<<<<<<<<
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits
+ * 
+ */
+    __pyx_t_3 = (((PyObject *)__pyx_v_self->parent) != Py_None);
+    __pyx_t_5 = (__pyx_t_3 != 0);
+    if (__pyx_t_5) {
+
+      /* "multimcts/mcts.pyx":166
+ *                 total_rave_reward += self.rave_rewards[item.first]
+ *             if self.parent is not None:
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef double uncertainty(self, double exploration_bias):
+ */
+      __pyx_v_self->avg_rave_reward = (((2.0 * (__pyx_v_self->rave_rewards[__pyx_v_self->parent->team])) - __pyx_v_total_rave_reward) / ((double)__pyx_v_self->rave_visits));
+
+      /* "multimcts/mcts.pyx":165
+ *                 self.rave_rewards[item.first] += rave_visits * item.second
+ *                 total_rave_reward += self.rave_rewards[item.first]
+ *             if self.parent is not None:             # <<<<<<<<<<<<<<
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits
+ * 
+ */
+    }
+
+    /* "multimcts/mcts.pyx":158
+ *             if move in moves:
+ *                 rave_visits += 1
+ *         if rave_visits > 0:             # <<<<<<<<<<<<<<
+ *             self.rave_visits += rave_visits
+ *             for item in crewards:
  */
   }
 
-  /* "multimcts/mcts.pyx":103
+  /* "multimcts/mcts.pyx":133
  * 
  *     @cython.cdivision(True)
- *     cdef apply_rewards(self, map[string,double] crewards):             # <<<<<<<<<<<<<<
+ *     cdef visit(self, map[string,double] crewards, moves):             # <<<<<<<<<<<<<<
  *         """Update this node's visits and rewards, and cache some variables for more efficient UCB calculation."""
  *         self.visits += 1
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_AddTraceback("multimcts.mcts.Node.visit", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_move);
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":122
- *             self.avg_reward = ((2 * self.rewards[self.parent.cteam]) - total_rewards) / self.visits
+/* "multimcts/mcts.pyx":168
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits
  * 
- *     cdef double ucb(self, double exploration_bias, double parent_sqrtlog_visits):             # <<<<<<<<<<<<<<
+ *     cpdef double uncertainty(self, double exploration_bias):             # <<<<<<<<<<<<<<
+ *         return exploration_bias * self.parent.sqrtlog_visits * self.invsqrt_visits
+ * 
+ */
+
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_25uncertainty(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias); /*proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_uncertainty(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, int __pyx_skip_dispatch) {
+  double __pyx_r;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  double __pyx_t_6;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("uncertainty", 0);
+  __Pyx_TraceCall("uncertainty", __pyx_f[0], 168, 0, __PYX_ERR(0, 168, __pyx_L1_error));
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_uncertainty); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_9multimcts_4mcts_4Node_25uncertainty)) {
+        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_exploration_bias); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 168, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
+          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+          if (likely(__pyx_t_5)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+            __Pyx_INCREF(__pyx_t_5);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_4, function);
+          }
+        }
+        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
+        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 168, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 168, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __pyx_r = __pyx_t_6;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
+      }
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+      }
+      #endif
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    }
+    #endif
+  }
+
+  /* "multimcts/mcts.pyx":169
+ * 
+ *     cpdef double uncertainty(self, double exploration_bias):
+ *         return exploration_bias * self.parent.sqrtlog_visits * self.invsqrt_visits             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef double ucb(self, double exploration_bias):
+ */
+  __pyx_r = ((__pyx_v_exploration_bias * __pyx_v_self->parent->sqrtlog_visits) * __pyx_v_self->invsqrt_visits);
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":168
+ *                 self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits
+ * 
+ *     cpdef double uncertainty(self, double exploration_bias):             # <<<<<<<<<<<<<<
+ *         return exploration_bias * self.parent.sqrtlog_visits * self.invsqrt_visits
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_WriteUnraisable("multimcts.mcts.Node.uncertainty", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_TraceReturn(Py_None, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_25uncertainty(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_25uncertainty(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias) {
+  double __pyx_v_exploration_bias;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("uncertainty (wrapper)", 0);
+  assert(__pyx_arg_exploration_bias); {
+    __pyx_v_exploration_bias = __pyx_PyFloat_AsDouble(__pyx_arg_exploration_bias); if (unlikely((__pyx_v_exploration_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 168, __pyx_L3_error)
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.uncertainty", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_24uncertainty(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), ((double)__pyx_v_exploration_bias));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_24uncertainty(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("uncertainty", 0);
+  __Pyx_TraceCall("uncertainty (wrapper)", __pyx_f[0], 168, 0, __PYX_ERR(0, 168, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_9multimcts_4mcts_4Node_uncertainty(__pyx_v_self, __pyx_v_exploration_bias, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.uncertainty", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":171
+ *         return exploration_bias * self.parent.sqrtlog_visits * self.invsqrt_visits
+ * 
+ *     cpdef double ucb(self, double exploration_bias):             # <<<<<<<<<<<<<<
  *         """Upper Confidence Bound
  *         ucb = (x / n) + C * sqrt(ln(N) / n)
  */
 
-static double __pyx_f_9multimcts_4mcts_4Node_ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_parent_sqrtlog_visits) {
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_27ucb(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias); /*proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, int __pyx_skip_dispatch) {
   double __pyx_r;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  double __pyx_t_6;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("ucb", 0);
+  __Pyx_TraceCall("ucb", __pyx_f[0], 171, 0, __PYX_ERR(0, 171, __pyx_L1_error));
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_ucb); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_9multimcts_4mcts_4Node_27ucb)) {
+        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_exploration_bias); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 171, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
+          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+          if (likely(__pyx_t_5)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+            __Pyx_INCREF(__pyx_t_5);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_4, function);
+          }
+        }
+        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
+        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 171, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 171, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __pyx_r = __pyx_t_6;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
+      }
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+      }
+      #endif
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    }
+    #endif
+  }
 
-  /* "multimcts/mcts.pyx":131
+  /* "multimcts/mcts.pyx":179
+ *         C=exploration bias
  *         """
- *         # ucb = avgR + C * sqrt(ln(N)) * (1/sqrt(n))
- *         return self.avg_reward + exploration_bias * parent_sqrtlog_visits * self.invsqrt_visits             # <<<<<<<<<<<<<<
- * 
+ *         return self.avg_reward + self.uncertainty(exploration_bias)             # <<<<<<<<<<<<<<
  * 
+ *     @cython.cdivision(True)
  */
-  __pyx_r = (__pyx_v_self->avg_reward + ((__pyx_v_exploration_bias * __pyx_v_parent_sqrtlog_visits) * __pyx_v_self->invsqrt_visits));
+  __pyx_r = (__pyx_v_self->avg_reward + ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_self->__pyx_vtab)->uncertainty(__pyx_v_self, __pyx_v_exploration_bias, 0));
   goto __pyx_L0;
 
-  /* "multimcts/mcts.pyx":122
- *             self.avg_reward = ((2 * self.rewards[self.parent.cteam]) - total_rewards) / self.visits
+  /* "multimcts/mcts.pyx":171
+ *         return exploration_bias * self.parent.sqrtlog_visits * self.invsqrt_visits
  * 
- *     cdef double ucb(self, double exploration_bias, double parent_sqrtlog_visits):             # <<<<<<<<<<<<<<
+ *     cpdef double ucb(self, double exploration_bias):             # <<<<<<<<<<<<<<
  *         """Upper Confidence Bound
  *         ucb = (x / n) + C * sqrt(ln(N) / n)
  */
 
   /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_WriteUnraisable("multimcts.mcts.Node.ucb", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_TraceReturn(Py_None, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_27ucb(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias); /*proto*/
+static char __pyx_doc_9multimcts_4mcts_4Node_26ucb[] = "Upper Confidence Bound\n        ucb = (x / n) + C * sqrt(ln(N) / n)\n        x=reward for this node\n        n=number of simulations for this node\n        N=number of simulations for parent node\n        C=exploration bias\n        ";
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_27ucb(PyObject *__pyx_v_self, PyObject *__pyx_arg_exploration_bias) {
+  double __pyx_v_exploration_bias;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("ucb (wrapper)", 0);
+  assert(__pyx_arg_exploration_bias); {
+    __pyx_v_exploration_bias = __pyx_PyFloat_AsDouble(__pyx_arg_exploration_bias); if (unlikely((__pyx_v_exploration_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 171, __pyx_L3_error)
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.ucb", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_26ucb(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), ((double)__pyx_v_exploration_bias));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_26ucb(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("ucb", 0);
+  __Pyx_TraceCall("ucb (wrapper)", __pyx_f[0], 171, 0, __PYX_ERR(0, 171, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_9multimcts_4mcts_4Node_ucb(__pyx_v_self, __pyx_v_exploration_bias, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.ucb", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":182
+ * 
+ *     @cython.cdivision(True)
+ *     cpdef double rave_beta(self, double b):             # <<<<<<<<<<<<<<
+ *         """Determines the relative weight of RAVE rewards in the final score calculation.
+ *         As this node is visited more times, the RAVE effect diminishes.
+ */
+
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_29rave_beta(PyObject *__pyx_v_self, PyObject *__pyx_arg_b); /*proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_rave_beta(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_b, int __pyx_skip_dispatch) {
+  int __pyx_v_n1;
+  int __pyx_v_n2;
+  double __pyx_r;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  double __pyx_t_6;
+  int __pyx_t_7;
+  int __pyx_t_8;
+  int __pyx_t_9;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("rave_beta", 0);
+  __Pyx_TraceCall("rave_beta", __pyx_f[0], 182, 0, __PYX_ERR(0, 182, __pyx_L1_error));
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_rave_beta); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 182, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_9multimcts_4mcts_4Node_29rave_beta)) {
+        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_b); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 182, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
+          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+          if (likely(__pyx_t_5)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+            __Pyx_INCREF(__pyx_t_5);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_4, function);
+          }
+        }
+        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
+        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 182, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 182, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __pyx_r = __pyx_t_6;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
+      }
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+      }
+      #endif
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    }
+    #endif
+  }
+
+  /* "multimcts/mcts.pyx":188
+ *         https://www.desmos.com/calculator/drlccftt6a
+ *         """
+ *         if self.rave_visits == 0 or b == 0:             # <<<<<<<<<<<<<<
+ *             return 0
+ *         elif self.visits == 0:
+ */
+  __pyx_t_8 = ((__pyx_v_self->rave_visits == 0) != 0);
+  if (!__pyx_t_8) {
+  } else {
+    __pyx_t_7 = __pyx_t_8;
+    goto __pyx_L4_bool_binop_done;
+  }
+  __pyx_t_8 = ((__pyx_v_b == 0.0) != 0);
+  __pyx_t_7 = __pyx_t_8;
+  __pyx_L4_bool_binop_done:;
+  if (__pyx_t_7) {
+
+    /* "multimcts/mcts.pyx":189
+ *         """
+ *         if self.rave_visits == 0 or b == 0:
+ *             return 0             # <<<<<<<<<<<<<<
+ *         elif self.visits == 0:
+ *             return 1
+ */
+    __pyx_r = 0.0;
+    goto __pyx_L0;
+
+    /* "multimcts/mcts.pyx":188
+ *         https://www.desmos.com/calculator/drlccftt6a
+ *         """
+ *         if self.rave_visits == 0 or b == 0:             # <<<<<<<<<<<<<<
+ *             return 0
+ *         elif self.visits == 0:
+ */
+  }
+
+  /* "multimcts/mcts.pyx":190
+ *         if self.rave_visits == 0 or b == 0:
+ *             return 0
+ *         elif self.visits == 0:             # <<<<<<<<<<<<<<
+ *             return 1
+ *         cdef int n1 = self.visits, n2 = self.rave_visits
+ */
+  __pyx_t_7 = ((__pyx_v_self->visits == 0) != 0);
+  if (__pyx_t_7) {
+
+    /* "multimcts/mcts.pyx":191
+ *             return 0
+ *         elif self.visits == 0:
+ *             return 1             # <<<<<<<<<<<<<<
+ *         cdef int n1 = self.visits, n2 = self.rave_visits
+ *         return n2 / (n1 + n2 + 4*n1*n2/(b**2))
+ */
+    __pyx_r = 1.0;
+    goto __pyx_L0;
+
+    /* "multimcts/mcts.pyx":190
+ *         if self.rave_visits == 0 or b == 0:
+ *             return 0
+ *         elif self.visits == 0:             # <<<<<<<<<<<<<<
+ *             return 1
+ *         cdef int n1 = self.visits, n2 = self.rave_visits
+ */
+  }
+
+  /* "multimcts/mcts.pyx":192
+ *         elif self.visits == 0:
+ *             return 1
+ *         cdef int n1 = self.visits, n2 = self.rave_visits             # <<<<<<<<<<<<<<
+ *         return n2 / (n1 + n2 + 4*n1*n2/(b**2))
+ * 
+ */
+  __pyx_t_9 = __pyx_v_self->visits;
+  __pyx_v_n1 = __pyx_t_9;
+  __pyx_t_9 = __pyx_v_self->rave_visits;
+  __pyx_v_n2 = __pyx_t_9;
+
+  /* "multimcts/mcts.pyx":193
+ *             return 1
+ *         cdef int n1 = self.visits, n2 = self.rave_visits
+ *         return n2 / (n1 + n2 + 4*n1*n2/(b**2))             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef double score(self, double exploration_bias, double rave_bias):
+ */
+  __pyx_r = (((double)__pyx_v_n2) / ((__pyx_v_n1 + __pyx_v_n2) + (((double)((4 * __pyx_v_n1) * __pyx_v_n2)) / pow(__pyx_v_b, 2.0))));
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":182
+ * 
+ *     @cython.cdivision(True)
+ *     cpdef double rave_beta(self, double b):             # <<<<<<<<<<<<<<
+ *         """Determines the relative weight of RAVE rewards in the final score calculation.
+ *         As this node is visited more times, the RAVE effect diminishes.
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_WriteUnraisable("multimcts.mcts.Node.rave_beta", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_TraceReturn(Py_None, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_29rave_beta(PyObject *__pyx_v_self, PyObject *__pyx_arg_b); /*proto*/
+static char __pyx_doc_9multimcts_4mcts_4Node_28rave_beta[] = "Determines the relative weight of RAVE rewards in the final score calculation.\n        As this node is visited more times, the RAVE effect diminishes.\n        The number of RAVE visits has little bearing on this value (the function's curve looks the same for all large values of rave_visits).\n        https://www.desmos.com/calculator/drlccftt6a\n        ";
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_29rave_beta(PyObject *__pyx_v_self, PyObject *__pyx_arg_b) {
+  double __pyx_v_b;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("rave_beta (wrapper)", 0);
+  assert(__pyx_arg_b); {
+    __pyx_v_b = __pyx_PyFloat_AsDouble(__pyx_arg_b); if (unlikely((__pyx_v_b == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 182, __pyx_L3_error)
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.rave_beta", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_28rave_beta(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), ((double)__pyx_v_b));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_28rave_beta(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_b) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("rave_beta", 0);
+  __Pyx_TraceCall("rave_beta (wrapper)", __pyx_f[0], 182, 0, __PYX_ERR(0, 182, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_9multimcts_4mcts_4Node_rave_beta(__pyx_v_self, __pyx_v_b, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 182, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.rave_beta", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":195
+ *         return n2 / (n1 + n2 + 4*n1*n2/(b**2))
+ * 
+ *     cpdef double score(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef double rave_beta = self.rave_beta(rave_bias)
+ *         return (rave_beta * self.avg_rave_reward) + ((1-rave_beta) * self.avg_reward) + self.uncertainty(exploration_bias)
+ */
+
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_31score(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static double __pyx_f_9multimcts_4mcts_4Node_score(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias, int __pyx_skip_dispatch) {
+  double __pyx_v_rave_beta;
+  double __pyx_r;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
+  double __pyx_t_9;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("score", 0);
+  __Pyx_TraceCall("score", __pyx_f[0], 195, 0, __PYX_ERR(0, 195, __pyx_L1_error));
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_score); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_9multimcts_4mcts_4Node_31score)) {
+        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_exploration_bias); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 195, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __pyx_t_4 = PyFloat_FromDouble(__pyx_v_rave_bias); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 195, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_4);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_5 = __pyx_t_1; __pyx_t_6 = NULL;
+        __pyx_t_7 = 0;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
+          __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
+          if (likely(__pyx_t_6)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+            __Pyx_INCREF(__pyx_t_6);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_5, function);
+            __pyx_t_7 = 1;
+          }
+        }
+        #if CYTHON_FAST_PYCALL
+        if (PyFunction_Check(__pyx_t_5)) {
+          PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_3, __pyx_t_4};
+          __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 195, __pyx_L1_error)
+          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        } else
+        #endif
+        #if CYTHON_FAST_PYCCALL
+        if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
+          PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_3, __pyx_t_4};
+          __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 195, __pyx_L1_error)
+          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        } else
+        #endif
+        {
+          __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 195, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_8);
+          if (__pyx_t_6) {
+            __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
+          }
+          __Pyx_GIVEREF(__pyx_t_3);
+          PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_3);
+          __Pyx_GIVEREF(__pyx_t_4);
+          PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_4);
+          __pyx_t_3 = 0;
+          __pyx_t_4 = 0;
+          __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 195, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        }
+        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __pyx_t_9 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_9 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 195, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __pyx_r = __pyx_t_9;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
+      }
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+      }
+      #endif
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    }
+    #endif
+  }
+
+  /* "multimcts/mcts.pyx":196
+ * 
+ *     cpdef double score(self, double exploration_bias, double rave_bias):
+ *         cdef double rave_beta = self.rave_beta(rave_bias)             # <<<<<<<<<<<<<<
+ *         return (rave_beta * self.avg_rave_reward) + ((1-rave_beta) * self.avg_reward) + self.uncertainty(exploration_bias)
+ * 
+ */
+  __pyx_v_rave_beta = ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_self->__pyx_vtab)->rave_beta(__pyx_v_self, __pyx_v_rave_bias, 0);
+
+  /* "multimcts/mcts.pyx":197
+ *     cpdef double score(self, double exploration_bias, double rave_bias):
+ *         cdef double rave_beta = self.rave_beta(rave_bias)
+ *         return (rave_beta * self.avg_rave_reward) + ((1-rave_beta) * self.avg_reward) + self.uncertainty(exploration_bias)             # <<<<<<<<<<<<<<
+ * 
+ *     @cython.wraparound(False)
+ */
+  __pyx_r = (((__pyx_v_rave_beta * __pyx_v_self->avg_rave_reward) + ((1.0 - __pyx_v_rave_beta) * __pyx_v_self->avg_reward)) + ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_self->__pyx_vtab)->uncertainty(__pyx_v_self, __pyx_v_exploration_bias, 0));
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":195
+ *         return n2 / (n1 + n2 + 4*n1*n2/(b**2))
+ * 
+ *     cpdef double score(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef double rave_beta = self.rave_beta(rave_bias)
+ *         return (rave_beta * self.avg_rave_reward) + ((1-rave_beta) * self.avg_reward) + self.uncertainty(exploration_bias)
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_WriteUnraisable("multimcts.mcts.Node.score", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_TraceReturn(Py_None, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_31score(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_31score(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  double __pyx_v_exploration_bias;
+  double __pyx_v_rave_bias;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("score (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_exploration_bias,&__pyx_n_s_rave_bias,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_exploration_bias)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rave_bias)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("score", 1, 2, 2, 1); __PYX_ERR(0, 195, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "score") < 0)) __PYX_ERR(0, 195, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_exploration_bias = __pyx_PyFloat_AsDouble(values[0]); if (unlikely((__pyx_v_exploration_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 195, __pyx_L3_error)
+    __pyx_v_rave_bias = __pyx_PyFloat_AsDouble(values[1]); if (unlikely((__pyx_v_rave_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 195, __pyx_L3_error)
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("score", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 195, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("multimcts.mcts.Node.score", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_30score(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), __pyx_v_exploration_bias, __pyx_v_rave_bias);
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_30score(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("score", 0);
+  __Pyx_TraceCall("score (wrapper)", __pyx_f[0], 195, 0, __PYX_ERR(0, 195, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_9multimcts_4mcts_4Node_score(__pyx_v_self, __pyx_v_exploration_bias, __pyx_v_rave_bias, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.Node.score", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":201
+ *     @cython.wraparound(False)
+ *     @cython.boundscheck(False)
+ *     cdef Node best_child(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef Node child, best_child = next(iter(self.children.values()))
+ *         cdef double score, best_score = -INFINITY
+ */
+
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_best_child(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias) {
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_child = 0;
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_best_child = 0;
+  double __pyx_v_score;
+  double __pyx_v_best_score;
+  CYTHON_UNUSED PyObject *__pyx_v_move = NULL;
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  Py_ssize_t __pyx_t_4;
+  Py_ssize_t __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  int __pyx_t_8;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("best_child", 0);
+  __Pyx_TraceCall("best_child", __pyx_f[0], 201, 0, __PYX_ERR(0, 201, __pyx_L1_error));
+
+  /* "multimcts/mcts.pyx":202
+ *     @cython.boundscheck(False)
+ *     cdef Node best_child(self, double exploration_bias, double rave_bias):
+ *         cdef Node child, best_child = next(iter(self.children.values()))             # <<<<<<<<<<<<<<
+ *         cdef double score, best_score = -INFINITY
+ *         for move, child in self.children.items():
+ */
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->children, __pyx_n_s_values); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_3);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyIter_Next(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_9multimcts_4mcts_Node))))) __PYX_ERR(0, 202, __pyx_L1_error)
+  __pyx_v_best_child = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":203
+ *     cdef Node best_child(self, double exploration_bias, double rave_bias):
+ *         cdef Node child, best_child = next(iter(self.children.values()))
+ *         cdef double score, best_score = -INFINITY             # <<<<<<<<<<<<<<
+ *         for move, child in self.children.items():
+ *             score = child.score(exploration_bias, rave_bias)
+ */
+  __pyx_v_best_score = (-INFINITY);
+
+  /* "multimcts/mcts.pyx":204
+ *         cdef Node child, best_child = next(iter(self.children.values()))
+ *         cdef double score, best_score = -INFINITY
+ *         for move, child in self.children.items():             # <<<<<<<<<<<<<<
+ *             score = child.score(exploration_bias, rave_bias)
+ *             if score > best_score:
+ */
+  __pyx_t_4 = 0;
+  if (unlikely(__pyx_v_self->children == Py_None)) {
+    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "items");
+    __PYX_ERR(0, 204, __pyx_L1_error)
+  }
+  __pyx_t_2 = __Pyx_dict_iterator(__pyx_v_self->children, 0, __pyx_n_s_items, (&__pyx_t_5), (&__pyx_t_6)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 204, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_1);
+  __pyx_t_1 = __pyx_t_2;
+  __pyx_t_2 = 0;
+  while (1) {
+    __pyx_t_7 = __Pyx_dict_iter_next(__pyx_t_1, __pyx_t_5, &__pyx_t_4, &__pyx_t_2, &__pyx_t_3, NULL, __pyx_t_6);
+    if (unlikely(__pyx_t_7 == 0)) break;
+    if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 204, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_GOTREF(__pyx_t_3);
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_9multimcts_4mcts_Node))))) __PYX_ERR(0, 204, __pyx_L1_error)
+    __Pyx_XDECREF_SET(__pyx_v_move, __pyx_t_2);
+    __pyx_t_2 = 0;
+    __Pyx_XDECREF_SET(__pyx_v_child, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_3));
+    __pyx_t_3 = 0;
+
+    /* "multimcts/mcts.pyx":205
+ *         cdef double score, best_score = -INFINITY
+ *         for move, child in self.children.items():
+ *             score = child.score(exploration_bias, rave_bias)             # <<<<<<<<<<<<<<
+ *             if score > best_score:
+ *                 best_score = score
+ */
+    __pyx_v_score = ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_child->__pyx_vtab)->score(__pyx_v_child, __pyx_v_exploration_bias, __pyx_v_rave_bias, 0);
+
+    /* "multimcts/mcts.pyx":206
+ *         for move, child in self.children.items():
+ *             score = child.score(exploration_bias, rave_bias)
+ *             if score > best_score:             # <<<<<<<<<<<<<<
+ *                 best_score = score
+ *                 best_child = child
+ */
+    __pyx_t_8 = ((__pyx_v_score > __pyx_v_best_score) != 0);
+    if (__pyx_t_8) {
+
+      /* "multimcts/mcts.pyx":207
+ *             score = child.score(exploration_bias, rave_bias)
+ *             if score > best_score:
+ *                 best_score = score             # <<<<<<<<<<<<<<
+ *                 best_child = child
+ *         return best_child
+ */
+      __pyx_v_best_score = __pyx_v_score;
+
+      /* "multimcts/mcts.pyx":208
+ *             if score > best_score:
+ *                 best_score = score
+ *                 best_child = child             # <<<<<<<<<<<<<<
+ *         return best_child
+ * 
+ */
+      __Pyx_INCREF(((PyObject *)__pyx_v_child));
+      __Pyx_DECREF_SET(__pyx_v_best_child, __pyx_v_child);
+
+      /* "multimcts/mcts.pyx":206
+ *         for move, child in self.children.items():
+ *             score = child.score(exploration_bias, rave_bias)
+ *             if score > best_score:             # <<<<<<<<<<<<<<
+ *                 best_score = score
+ *                 best_child = child
+ */
+    }
+  }
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":209
+ *                 best_score = score
+ *                 best_child = child
+ *         return best_child             # <<<<<<<<<<<<<<
+ * 
+ *     cdef Node select(self, double exploration_bias, double rave_bias):
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_best_child));
+  __pyx_r = __pyx_v_best_child;
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":201
+ *     @cython.wraparound(False)
+ *     @cython.boundscheck(False)
+ *     cdef Node best_child(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef Node child, best_child = next(iter(self.children.values()))
+ *         cdef double score, best_score = -INFINITY
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("multimcts.mcts.Node.best_child", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
   __pyx_L0:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_child);
+  __Pyx_XDECREF((PyObject *)__pyx_v_best_child);
+  __Pyx_XDECREF(__pyx_v_move);
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
+/* "multimcts/mcts.pyx":211
+ *         return best_child
+ * 
+ *     cdef Node select(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef Node node = self
+ *         while not node.is_terminal:
+ */
+
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_select(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias) {
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node = 0;
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("select", 0);
+  __Pyx_TraceCall("select", __pyx_f[0], 211, 0, __PYX_ERR(0, 211, __pyx_L1_error));
+
+  /* "multimcts/mcts.pyx":212
+ * 
+ *     cdef Node select(self, double exploration_bias, double rave_bias):
+ *         cdef Node node = self             # <<<<<<<<<<<<<<
+ *         while not node.is_terminal:
+ *             if node.is_fully_expanded:
+ */
+  __Pyx_INCREF(((PyObject *)__pyx_v_self));
+  __pyx_v_node = __pyx_v_self;
+
+  /* "multimcts/mcts.pyx":213
+ *     cdef Node select(self, double exploration_bias, double rave_bias):
+ *         cdef Node node = self
+ *         while not node.is_terminal:             # <<<<<<<<<<<<<<
+ *             if node.is_fully_expanded:
+ *                 node = node.best_child(exploration_bias, rave_bias)
+ */
+  while (1) {
+    __pyx_t_1 = ((!(__pyx_v_node->is_terminal != 0)) != 0);
+    if (!__pyx_t_1) break;
+
+    /* "multimcts/mcts.pyx":214
+ *         cdef Node node = self
+ *         while not node.is_terminal:
+ *             if node.is_fully_expanded:             # <<<<<<<<<<<<<<
+ *                 node = node.best_child(exploration_bias, rave_bias)
+ *             else:
+ */
+    __pyx_t_1 = (__pyx_v_node->is_fully_expanded != 0);
+    if (__pyx_t_1) {
+
+      /* "multimcts/mcts.pyx":215
+ *         while not node.is_terminal:
+ *             if node.is_fully_expanded:
+ *                 node = node.best_child(exploration_bias, rave_bias)             # <<<<<<<<<<<<<<
+ *             else:
+ *                 return node.expand()
+ */
+      __pyx_t_2 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->best_child(__pyx_v_node, __pyx_v_exploration_bias, __pyx_v_rave_bias)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 215, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF_SET(__pyx_v_node, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2));
+      __pyx_t_2 = 0;
+
+      /* "multimcts/mcts.pyx":214
+ *         cdef Node node = self
+ *         while not node.is_terminal:
+ *             if node.is_fully_expanded:             # <<<<<<<<<<<<<<
+ *                 node = node.best_child(exploration_bias, rave_bias)
+ *             else:
+ */
+      goto __pyx_L5;
+    }
+
+    /* "multimcts/mcts.pyx":217
+ *                 node = node.best_child(exploration_bias, rave_bias)
+ *             else:
+ *                 return node.expand()             # <<<<<<<<<<<<<<
+ *         return node
+ * 
+ */
+    /*else*/ {
+      __Pyx_XDECREF(((PyObject *)__pyx_r));
+      __pyx_t_2 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->expand(__pyx_v_node)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 217, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_r = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2);
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+    }
+    __pyx_L5:;
+  }
+
+  /* "multimcts/mcts.pyx":218
+ *             else:
+ *                 return node.expand()
+ *         return node             # <<<<<<<<<<<<<<
+ * 
+ *     cdef Node expand(self):
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_node));
+  __pyx_r = __pyx_v_node;
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":211
+ *         return best_child
+ * 
+ *     cdef Node select(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         cdef Node node = self
+ *         while not node.is_terminal:
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_AddTraceback("multimcts.mcts.Node.select", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_node);
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":220
+ *         return node
+ * 
+ *     cdef Node expand(self):             # <<<<<<<<<<<<<<
+ *         move = self.remaining_moves.pop()
+ *         if len(self.remaining_moves) == 0:
+ */
+
+static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4Node_expand(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+  PyObject *__pyx_v_move = NULL;
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_child = 0;
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  Py_ssize_t __pyx_t_2;
+  int __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("expand", 0);
+  __Pyx_TraceCall("expand", __pyx_f[0], 220, 0, __PYX_ERR(0, 220, __pyx_L1_error));
+
+  /* "multimcts/mcts.pyx":221
+ * 
+ *     cdef Node expand(self):
+ *         move = self.remaining_moves.pop()             # <<<<<<<<<<<<<<
+ *         if len(self.remaining_moves) == 0:
+ *             self.is_fully_expanded = True
+ */
+  __pyx_t_1 = __Pyx_PyObject_Pop(__pyx_v_self->remaining_moves); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 221, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_move = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":222
+ *     cdef Node expand(self):
+ *         move = self.remaining_moves.pop()
+ *         if len(self.remaining_moves) == 0:             # <<<<<<<<<<<<<<
+ *             self.is_fully_expanded = True
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)
+ */
+  __pyx_t_1 = __pyx_v_self->remaining_moves;
+  __Pyx_INCREF(__pyx_t_1);
+  __pyx_t_2 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 222, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_3 = ((__pyx_t_2 == 0) != 0);
+  if (__pyx_t_3) {
+
+    /* "multimcts/mcts.pyx":223
+ *         move = self.remaining_moves.pop()
+ *         if len(self.remaining_moves) == 0:
+ *             self.is_fully_expanded = True             # <<<<<<<<<<<<<<
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)
+ *         self.children[move] = child
+ */
+    __pyx_v_self->is_fully_expanded = 1;
+
+    /* "multimcts/mcts.pyx":222
+ *     cdef Node expand(self):
+ *         move = self.remaining_moves.pop()
+ *         if len(self.remaining_moves) == 0:             # <<<<<<<<<<<<<<
+ *             self.is_fully_expanded = True
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)
+ */
+  }
+
+  /* "multimcts/mcts.pyx":224
+ *         if len(self.remaining_moves) == 0:
+ *             self.is_fully_expanded = True
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)             # <<<<<<<<<<<<<<
+ *         self.children[move] = child
+ *         return child
+ */
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 224, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->state, __pyx_n_s_make_move); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 224, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_6 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
+    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
+    if (likely(__pyx_t_6)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+      __Pyx_INCREF(__pyx_t_6);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_5, function);
+    }
+  }
+  __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_move) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_move);
+  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 224, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_state, __pyx_t_4) < 0) __PYX_ERR(0, 224, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_parent, ((PyObject *)__pyx_v_self)) < 0) __PYX_ERR(0, 224, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_move, __pyx_v_move) < 0) __PYX_ERR(0, 224, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_9multimcts_4mcts_Node), __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 224, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_child = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "multimcts/mcts.pyx":225
+ *             self.is_fully_expanded = True
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)
+ *         self.children[move] = child             # <<<<<<<<<<<<<<
+ *         return child
+ * 
+ */
+  if (unlikely(PyObject_SetItem(__pyx_v_self->children, __pyx_v_move, ((PyObject *)__pyx_v_child)) < 0)) __PYX_ERR(0, 225, __pyx_L1_error)
+
+  /* "multimcts/mcts.pyx":226
+ *         cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)
+ *         self.children[move] = child
+ *         return child             # <<<<<<<<<<<<<<
+ * 
+ *     cdef void execute_round(self, double exploration_bias, double rave_bias):
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_child));
+  __pyx_r = __pyx_v_child;
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":220
+ *         return node
+ * 
+ *     cdef Node expand(self):             # <<<<<<<<<<<<<<
+ *         move = self.remaining_moves.pop()
+ *         if len(self.remaining_moves) == 0:
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("multimcts.mcts.Node.expand", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_move);
+  __Pyx_XDECREF((PyObject *)__pyx_v_child);
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":228
+ *         return child
+ * 
+ *     cdef void execute_round(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         """Step 1,2: Selection,Expansion"""
+ *         cdef Node node = self.select(exploration_bias, rave_bias)
+ */
+
+static void __pyx_f_9multimcts_4mcts_4Node_execute_round(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias) {
+  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node = 0;
+  PyObject *__pyx_v_state = NULL;
+  PyObject *__pyx_v_prev_state = NULL;
+  PyObject *__pyx_v_moves = NULL;
+  PyObject *__pyx_v_move = NULL;
+  PyObject *__pyx_v_reward = NULL;
+  PyObject *__pyx_v_terminal_team = NULL;
+  std::map<std::string,double>  __pyx_v_crewards;
+  PyObject *__pyx_v_team = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  PyObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  int __pyx_t_8;
+  std::map<std::string,double>  __pyx_t_9;
+  Py_ssize_t __pyx_t_10;
+  PyObject *(*__pyx_t_11)(PyObject *);
+  double __pyx_t_12;
+  std::string __pyx_t_13;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("execute_round", 0);
+  __Pyx_TraceCall("execute_round", __pyx_f[0], 228, 0, __PYX_ERR(0, 228, __pyx_L1_error));
+
+  /* "multimcts/mcts.pyx":230
+ *     cdef void execute_round(self, double exploration_bias, double rave_bias):
+ *         """Step 1,2: Selection,Expansion"""
+ *         cdef Node node = self.select(exploration_bias, rave_bias)             # <<<<<<<<<<<<<<
+ * 
+ *         """Step 3: Simulation"""
+ */
+  __pyx_t_1 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_self->__pyx_vtab)->select(__pyx_v_self, __pyx_v_exploration_bias, __pyx_v_rave_bias)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 230, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_node = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":233
+ * 
+ *         """Step 3: Simulation"""
+ *         state = node.state             # <<<<<<<<<<<<<<
+ *         prev_state = None
+ *         moves = set()
+ */
+  __pyx_t_1 = __pyx_v_node->state;
+  __Pyx_INCREF(__pyx_t_1);
+  __pyx_v_state = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":234
+ *         """Step 3: Simulation"""
+ *         state = node.state
+ *         prev_state = None             # <<<<<<<<<<<<<<
+ *         moves = set()
+ *         if not node.is_terminal:
+ */
+  __Pyx_INCREF(Py_None);
+  __pyx_v_prev_state = Py_None;
+
+  /* "multimcts/mcts.pyx":235
+ *         state = node.state
+ *         prev_state = None
+ *         moves = set()             # <<<<<<<<<<<<<<
+ *         if not node.is_terminal:
+ *             while not state.is_terminal():
+ */
+  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 235, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_moves = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":236
+ *         prev_state = None
+ *         moves = set()
+ *         if not node.is_terminal:             # <<<<<<<<<<<<<<
+ *             while not state.is_terminal():
+ *                 prev_state = state
+ */
+  __pyx_t_2 = ((!(__pyx_v_node->is_terminal != 0)) != 0);
+  if (__pyx_t_2) {
+
+    /* "multimcts/mcts.pyx":237
+ *         moves = set()
+ *         if not node.is_terminal:
+ *             while not state.is_terminal():             # <<<<<<<<<<<<<<
+ *                 prev_state = state
+ *                 move = choice(state.get_legal_moves())
+ */
+    while (1) {
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_is_terminal); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 237, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 237, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 237, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_5 = ((!__pyx_t_2) != 0);
+      if (!__pyx_t_5) break;
+
+      /* "multimcts/mcts.pyx":238
+ *         if not node.is_terminal:
+ *             while not state.is_terminal():
+ *                 prev_state = state             # <<<<<<<<<<<<<<
+ *                 move = choice(state.get_legal_moves())
+ *                 moves.add(move)
+ */
+      __Pyx_INCREF(__pyx_v_state);
+      __Pyx_DECREF_SET(__pyx_v_prev_state, __pyx_v_state);
+
+      /* "multimcts/mcts.pyx":239
+ *             while not state.is_terminal():
+ *                 prev_state = state
+ *                 move = choice(state.get_legal_moves())             # <<<<<<<<<<<<<<
+ *                 moves.add(move)
+ *                 state = state.make_move(move)
+ */
+      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_choice); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 239, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_get_legal_moves); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 239, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __pyx_t_7 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
+        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
+        if (likely(__pyx_t_7)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
+          __Pyx_INCREF(__pyx_t_7);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_6, function);
+        }
+      }
+      __pyx_t_4 = (__pyx_t_7) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
+      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 239, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __pyx_t_6 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_6)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_6);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_XDECREF_SET(__pyx_v_move, __pyx_t_1);
+      __pyx_t_1 = 0;
+
+      /* "multimcts/mcts.pyx":240
+ *                 prev_state = state
+ *                 move = choice(state.get_legal_moves())
+ *                 moves.add(move)             # <<<<<<<<<<<<<<
+ *                 state = state.make_move(move)
+ *         reward = state.get_reward()
+ */
+      __pyx_t_8 = PySet_Add(__pyx_v_moves, __pyx_v_move); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 240, __pyx_L1_error)
+
+      /* "multimcts/mcts.pyx":241
+ *                 move = choice(state.get_legal_moves())
+ *                 moves.add(move)
+ *                 state = state.make_move(move)             # <<<<<<<<<<<<<<
+ *         reward = state.get_reward()
+ *         if not isinstance(reward, dict):
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_make_move); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 241, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_move) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_move);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 241, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF_SET(__pyx_v_state, __pyx_t_1);
+      __pyx_t_1 = 0;
+    }
+
+    /* "multimcts/mcts.pyx":236
+ *         prev_state = None
+ *         moves = set()
+ *         if not node.is_terminal:             # <<<<<<<<<<<<<<
+ *             while not state.is_terminal():
+ *                 prev_state = state
+ */
+  }
+
+  /* "multimcts/mcts.pyx":242
+ *                 moves.add(move)
+ *                 state = state.make_move(move)
+ *         reward = state.get_reward()             # <<<<<<<<<<<<<<
+ *         if not isinstance(reward, dict):
+ *             terminal_team = None
+ */
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_get_reward); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 242, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 242, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_v_reward = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":243
+ *                 state = state.make_move(move)
+ *         reward = state.get_reward()
+ *         if not isinstance(reward, dict):             # <<<<<<<<<<<<<<
+ *             terminal_team = None
+ *             if node.is_terminal:
+ */
+  __pyx_t_5 = PyDict_Check(__pyx_v_reward); 
+  __pyx_t_2 = ((!(__pyx_t_5 != 0)) != 0);
+  if (__pyx_t_2) {
+
+    /* "multimcts/mcts.pyx":244
+ *         reward = state.get_reward()
+ *         if not isinstance(reward, dict):
+ *             terminal_team = None             # <<<<<<<<<<<<<<
+ *             if node.is_terminal:
+ *                 terminal_team = node.parent.state.get_current_team()
+ */
+    __Pyx_INCREF(Py_None);
+    __pyx_v_terminal_team = Py_None;
+
+    /* "multimcts/mcts.pyx":245
+ *         if not isinstance(reward, dict):
+ *             terminal_team = None
+ *             if node.is_terminal:             # <<<<<<<<<<<<<<
+ *                 terminal_team = node.parent.state.get_current_team()
+ *             elif prev_state is not None:
+ */
+    __pyx_t_2 = (__pyx_v_node->is_terminal != 0);
+    if (__pyx_t_2) {
+
+      /* "multimcts/mcts.pyx":246
+ *             terminal_team = None
+ *             if node.is_terminal:
+ *                 terminal_team = node.parent.state.get_current_team()             # <<<<<<<<<<<<<<
+ *             elif prev_state is not None:
+ *                 terminal_team = prev_state.get_current_team()
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_node->parent->state, __pyx_n_s_get_current_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 246, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 246, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF_SET(__pyx_v_terminal_team, __pyx_t_1);
+      __pyx_t_1 = 0;
+
+      /* "multimcts/mcts.pyx":245
+ *         if not isinstance(reward, dict):
+ *             terminal_team = None
+ *             if node.is_terminal:             # <<<<<<<<<<<<<<
+ *                 terminal_team = node.parent.state.get_current_team()
+ *             elif prev_state is not None:
+ */
+      goto __pyx_L7;
+    }
+
+    /* "multimcts/mcts.pyx":247
+ *             if node.is_terminal:
+ *                 terminal_team = node.parent.state.get_current_team()
+ *             elif prev_state is not None:             # <<<<<<<<<<<<<<
+ *                 terminal_team = prev_state.get_current_team()
+ *             else:
+ */
+    __pyx_t_2 = (__pyx_v_prev_state != Py_None);
+    __pyx_t_5 = (__pyx_t_2 != 0);
+    if (likely(__pyx_t_5)) {
+
+      /* "multimcts/mcts.pyx":248
+ *                 terminal_team = node.parent.state.get_current_team()
+ *             elif prev_state is not None:
+ *                 terminal_team = prev_state.get_current_team()             # <<<<<<<<<<<<<<
+ *             else:
+ *                 raise ValueError("Could not determine terminal team during simulation.")
+ */
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_prev_state, __pyx_n_s_get_current_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 248, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_4 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+        if (likely(__pyx_t_4)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+          __Pyx_INCREF(__pyx_t_4);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_3, function);
+        }
+      }
+      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 248, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF_SET(__pyx_v_terminal_team, __pyx_t_1);
+      __pyx_t_1 = 0;
+
+      /* "multimcts/mcts.pyx":247
+ *             if node.is_terminal:
+ *                 terminal_team = node.parent.state.get_current_team()
+ *             elif prev_state is not None:             # <<<<<<<<<<<<<<
+ *                 terminal_team = prev_state.get_current_team()
+ *             else:
+ */
+      goto __pyx_L7;
+    }
+
+    /* "multimcts/mcts.pyx":250
+ *                 terminal_team = prev_state.get_current_team()
+ *             else:
+ *                 raise ValueError("Could not determine terminal team during simulation.")             # <<<<<<<<<<<<<<
+ *             reward = {terminal_team: reward}
+ *         cdef map[string,double] crewards = map[string,double]()
+ */
+    /*else*/ {
+      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 250, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __PYX_ERR(0, 250, __pyx_L1_error)
+    }
+    __pyx_L7:;
+
+    /* "multimcts/mcts.pyx":251
+ *             else:
+ *                 raise ValueError("Could not determine terminal team during simulation.")
+ *             reward = {terminal_team: reward}             # <<<<<<<<<<<<<<
+ *         cdef map[string,double] crewards = map[string,double]()
+ *         for team in reward:
+ */
+    __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 251, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    if (PyDict_SetItem(__pyx_t_1, __pyx_v_terminal_team, __pyx_v_reward) < 0) __PYX_ERR(0, 251, __pyx_L1_error)
+    __Pyx_DECREF_SET(__pyx_v_reward, __pyx_t_1);
+    __pyx_t_1 = 0;
+
+    /* "multimcts/mcts.pyx":243
+ *                 state = state.make_move(move)
+ *         reward = state.get_reward()
+ *         if not isinstance(reward, dict):             # <<<<<<<<<<<<<<
+ *             terminal_team = None
+ *             if node.is_terminal:
+ */
+  }
+
+  /* "multimcts/mcts.pyx":252
+ *                 raise ValueError("Could not determine terminal team during simulation.")
+ *             reward = {terminal_team: reward}
+ *         cdef map[string,double] crewards = map[string,double]()             # <<<<<<<<<<<<<<
+ *         for team in reward:
+ *             if reward[team] == 0:
+ */
+  try {
+    __pyx_t_9 = std::map<std::string,double> ();
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(0, 252, __pyx_L1_error)
+  }
+  __pyx_v_crewards = __pyx_t_9;
+
+  /* "multimcts/mcts.pyx":253
+ *             reward = {terminal_team: reward}
+ *         cdef map[string,double] crewards = map[string,double]()
+ *         for team in reward:             # <<<<<<<<<<<<<<
+ *             if reward[team] == 0:
+ *                 continue
+ */
+  if (likely(PyList_CheckExact(__pyx_v_reward)) || PyTuple_CheckExact(__pyx_v_reward)) {
+    __pyx_t_1 = __pyx_v_reward; __Pyx_INCREF(__pyx_t_1); __pyx_t_10 = 0;
+    __pyx_t_11 = NULL;
+  } else {
+    __pyx_t_10 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 253, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_11 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 253, __pyx_L1_error)
+  }
+  for (;;) {
+    if (likely(!__pyx_t_11)) {
+      if (likely(PyList_CheckExact(__pyx_t_1))) {
+        if (__pyx_t_10 >= PyList_GET_SIZE(__pyx_t_1)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_10); __Pyx_INCREF(__pyx_t_3); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 253, __pyx_L1_error)
+        #else
+        __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 253, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        #endif
+      } else {
+        if (__pyx_t_10 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
+        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+        __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_10); __Pyx_INCREF(__pyx_t_3); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 253, __pyx_L1_error)
+        #else
+        __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 253, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        #endif
+      }
+    } else {
+      __pyx_t_3 = __pyx_t_11(__pyx_t_1);
+      if (unlikely(!__pyx_t_3)) {
+        PyObject* exc_type = PyErr_Occurred();
+        if (exc_type) {
+          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
+          else __PYX_ERR(0, 253, __pyx_L1_error)
+        }
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_3);
+    }
+    __Pyx_XDECREF_SET(__pyx_v_team, __pyx_t_3);
+    __pyx_t_3 = 0;
+
+    /* "multimcts/mcts.pyx":254
+ *         cdef map[string,double] crewards = map[string,double]()
+ *         for team in reward:
+ *             if reward[team] == 0:             # <<<<<<<<<<<<<<
+ *                 continue
+ *             crewards[str(team).encode()] = float(reward[team])
+ */
+    __pyx_t_3 = __Pyx_PyObject_GetItem(__pyx_v_reward, __pyx_v_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 254, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = __Pyx_PyInt_EqObjC(__pyx_t_3, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 254, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 254, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (__pyx_t_5) {
+
+      /* "multimcts/mcts.pyx":255
+ *         for team in reward:
+ *             if reward[team] == 0:
+ *                 continue             # <<<<<<<<<<<<<<
+ *             crewards[str(team).encode()] = float(reward[team])
+ * 
+ */
+      goto __pyx_L8_continue;
+
+      /* "multimcts/mcts.pyx":254
+ *         cdef map[string,double] crewards = map[string,double]()
+ *         for team in reward:
+ *             if reward[team] == 0:             # <<<<<<<<<<<<<<
+ *                 continue
+ *             crewards[str(team).encode()] = float(reward[team])
+ */
+    }
+
+    /* "multimcts/mcts.pyx":256
+ *             if reward[team] == 0:
+ *                 continue
+ *             crewards[str(team).encode()] = float(reward[team])             # <<<<<<<<<<<<<<
+ * 
+ *         """Step 4: Backpropagation"""
+ */
+    __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_reward, __pyx_v_team); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 256, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_12 = __Pyx_PyObject_AsDouble(__pyx_t_4); if (unlikely(__pyx_t_12 == ((double)((double)-1)) && PyErr_Occurred())) __PYX_ERR(0, 256, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_team); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 256, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_3 = PyUnicode_AsEncodedString(((PyObject*)__pyx_t_4), NULL, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 256, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_13 = __pyx_convert_string_from_py_std__in_string(__pyx_t_3); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 256, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    (__pyx_v_crewards[__pyx_t_13]) = __pyx_t_12;
+
+    /* "multimcts/mcts.pyx":253
+ *             reward = {terminal_team: reward}
+ *         cdef map[string,double] crewards = map[string,double]()
+ *         for team in reward:             # <<<<<<<<<<<<<<
+ *             if reward[team] == 0:
+ *                 continue
+ */
+    __pyx_L8_continue:;
+  }
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "multimcts/mcts.pyx":259
+ * 
+ *         """Step 4: Backpropagation"""
+ *         while node is not None:             # <<<<<<<<<<<<<<
+ *             node.visit(crewards, moves)
+ *             node = node.parent
+ */
+  while (1) {
+    __pyx_t_5 = (((PyObject *)__pyx_v_node) != Py_None);
+    __pyx_t_2 = (__pyx_t_5 != 0);
+    if (!__pyx_t_2) break;
+
+    /* "multimcts/mcts.pyx":260
+ *         """Step 4: Backpropagation"""
+ *         while node is not None:
+ *             node.visit(crewards, moves)             # <<<<<<<<<<<<<<
+ *             node = node.parent
+ * 
+ */
+    __pyx_t_1 = ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->visit(__pyx_v_node, __pyx_v_crewards, __pyx_v_moves); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 260, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+    /* "multimcts/mcts.pyx":261
+ *         while node is not None:
+ *             node.visit(crewards, moves)
+ *             node = node.parent             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+    __pyx_t_1 = ((PyObject *)__pyx_v_node->parent);
+    __Pyx_INCREF(__pyx_t_1);
+    __Pyx_DECREF_SET(__pyx_v_node, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_1));
+    __pyx_t_1 = 0;
+  }
+
+  /* "multimcts/mcts.pyx":228
+ *         return child
+ * 
+ *     cdef void execute_round(self, double exploration_bias, double rave_bias):             # <<<<<<<<<<<<<<
+ *         """Step 1,2: Selection,Expansion"""
+ *         cdef Node node = self.select(exploration_bias, rave_bias)
+ */
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_WriteUnraisable("multimcts.mcts.Node.execute_round", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_L0:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_node);
+  __Pyx_XDECREF(__pyx_v_state);
+  __Pyx_XDECREF(__pyx_v_prev_state);
+  __Pyx_XDECREF(__pyx_v_moves);
+  __Pyx_XDECREF(__pyx_v_move);
+  __Pyx_XDECREF(__pyx_v_reward);
+  __Pyx_XDECREF(__pyx_v_terminal_team);
+  __Pyx_XDECREF(__pyx_v_team);
+  __Pyx_TraceReturn(Py_None, 0);
+  __Pyx_RefNannyFinishContext();
+}
+
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
  *     cdef object _dict
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_33__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_33__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_2__reduce_cython__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_32__reduce_cython__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_2__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_32__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self) {
   PyObject *__pyx_v_state = 0;
   PyObject *__pyx_v__dict = 0;
   int __pyx_v_use_setstate;
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   PyObject *__pyx_t_9 = NULL;
-  int __pyx_t_10;
-  int __pyx_t_11;
-  int __pyx_t_12;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  int __pyx_t_13;
+  int __pyx_t_14;
+  int __pyx_t_15;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
+  __Pyx_TraceCall("__reduce_cython__", __pyx_f[1], 1, 0, __PYX_ERR(1, 1, __pyx_L1_error));
 
   /* "(tree fragment)":5
  *     cdef object _dict
  *     cdef bint use_setstate
- *     state = (self.avg_reward, self.children, self.cteam, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)             # <<<<<<<<<<<<<<
+ *     state = (self.avg_rave_reward, self.avg_reward, self.children, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.rave_rewards, self.rave_visits, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)             # <<<<<<<<<<<<<<
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  */
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->avg_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->avg_rave_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_v_self->cteam); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_self->avg_reward); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = PyFloat_FromDouble(__pyx_v_self->invsqrt_visits); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_self->is_fully_expanded); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = __Pyx_PyBool_FromLong(__pyx_v_self->is_terminal); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_6 = __pyx_convert_map_to_py_std_3a__3a_string____double(__pyx_v_self->rewards); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_6 = __pyx_convert_map_to_py_std_3a__3a_string____double(__pyx_v_self->rave_rewards); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_7 = PyFloat_FromDouble(__pyx_v_self->sqrtlog_visits); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_self->rave_visits); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_8 = __Pyx_PyInt_From_int(__pyx_v_self->visits); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_8 = __pyx_convert_map_to_py_std_3a__3a_string____double(__pyx_v_self->rewards); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_9 = PyTuple_New(14); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_9 = PyFloat_FromDouble(__pyx_v_self->sqrtlog_visits); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
+  __pyx_t_10 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_v_self->team); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_10);
+  __pyx_t_11 = __Pyx_PyInt_From_int(__pyx_v_self->visits); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_11);
+  __pyx_t_12 = PyTuple_New(16); if (unlikely(!__pyx_t_12)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_12);
   __Pyx_GIVEREF(__pyx_t_1);
-  PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_1);
+  PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_12, 1, __pyx_t_2);
   __Pyx_INCREF(__pyx_v_self->children);
   __Pyx_GIVEREF(__pyx_v_self->children);
-  PyTuple_SET_ITEM(__pyx_t_9, 1, __pyx_v_self->children);
-  __Pyx_GIVEREF(__pyx_t_2);
-  PyTuple_SET_ITEM(__pyx_t_9, 2, __pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_12, 2, __pyx_v_self->children);
   __Pyx_GIVEREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_9, 3, __pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_12, 3, __pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_4);
-  PyTuple_SET_ITEM(__pyx_t_9, 4, __pyx_t_4);
+  PyTuple_SET_ITEM(__pyx_t_12, 4, __pyx_t_4);
   __Pyx_GIVEREF(__pyx_t_5);
-  PyTuple_SET_ITEM(__pyx_t_9, 5, __pyx_t_5);
+  PyTuple_SET_ITEM(__pyx_t_12, 5, __pyx_t_5);
   __Pyx_INCREF(__pyx_v_self->move);
   __Pyx_GIVEREF(__pyx_v_self->move);
-  PyTuple_SET_ITEM(__pyx_t_9, 6, __pyx_v_self->move);
+  PyTuple_SET_ITEM(__pyx_t_12, 6, __pyx_v_self->move);
   __Pyx_INCREF(((PyObject *)__pyx_v_self->parent));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self->parent));
-  PyTuple_SET_ITEM(__pyx_t_9, 7, ((PyObject *)__pyx_v_self->parent));
-  __Pyx_INCREF(__pyx_v_self->remaining_moves);
-  __Pyx_GIVEREF(__pyx_v_self->remaining_moves);
-  PyTuple_SET_ITEM(__pyx_t_9, 8, __pyx_v_self->remaining_moves);
+  PyTuple_SET_ITEM(__pyx_t_12, 7, ((PyObject *)__pyx_v_self->parent));
   __Pyx_GIVEREF(__pyx_t_6);
-  PyTuple_SET_ITEM(__pyx_t_9, 9, __pyx_t_6);
+  PyTuple_SET_ITEM(__pyx_t_12, 8, __pyx_t_6);
   __Pyx_GIVEREF(__pyx_t_7);
-  PyTuple_SET_ITEM(__pyx_t_9, 10, __pyx_t_7);
+  PyTuple_SET_ITEM(__pyx_t_12, 9, __pyx_t_7);
+  __Pyx_INCREF(__pyx_v_self->remaining_moves);
+  __Pyx_GIVEREF(__pyx_v_self->remaining_moves);
+  PyTuple_SET_ITEM(__pyx_t_12, 10, __pyx_v_self->remaining_moves);
+  __Pyx_GIVEREF(__pyx_t_8);
+  PyTuple_SET_ITEM(__pyx_t_12, 11, __pyx_t_8);
+  __Pyx_GIVEREF(__pyx_t_9);
+  PyTuple_SET_ITEM(__pyx_t_12, 12, __pyx_t_9);
   __Pyx_INCREF(__pyx_v_self->state);
   __Pyx_GIVEREF(__pyx_v_self->state);
-  PyTuple_SET_ITEM(__pyx_t_9, 11, __pyx_v_self->state);
-  __Pyx_INCREF(__pyx_v_self->team);
-  __Pyx_GIVEREF(__pyx_v_self->team);
-  PyTuple_SET_ITEM(__pyx_t_9, 12, __pyx_v_self->team);
-  __Pyx_GIVEREF(__pyx_t_8);
-  PyTuple_SET_ITEM(__pyx_t_9, 13, __pyx_t_8);
+  PyTuple_SET_ITEM(__pyx_t_12, 13, __pyx_v_self->state);
+  __Pyx_GIVEREF(__pyx_t_10);
+  PyTuple_SET_ITEM(__pyx_t_12, 14, __pyx_t_10);
+  __Pyx_GIVEREF(__pyx_t_11);
+  PyTuple_SET_ITEM(__pyx_t_12, 15, __pyx_t_11);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
   __pyx_t_3 = 0;
   __pyx_t_4 = 0;
   __pyx_t_5 = 0;
   __pyx_t_6 = 0;
   __pyx_t_7 = 0;
   __pyx_t_8 = 0;
-  __pyx_v_state = ((PyObject*)__pyx_t_9);
   __pyx_t_9 = 0;
+  __pyx_t_10 = 0;
+  __pyx_t_11 = 0;
+  __pyx_v_state = ((PyObject*)__pyx_t_12);
+  __pyx_t_12 = 0;
 
   /* "(tree fragment)":6
  *     cdef bint use_setstate
- *     state = (self.avg_reward, self.children, self.cteam, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
+ *     state = (self.avg_rave_reward, self.avg_reward, self.children, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.rave_rewards, self.rave_visits, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
  *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<
  *     if _dict is not None:
  *         state += (_dict,)
  */
-  __pyx_t_9 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 6, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_9);
-  __pyx_v__dict = __pyx_t_9;
-  __pyx_t_9 = 0;
+  __pyx_t_12 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_12)) __PYX_ERR(1, 6, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_12);
+  __pyx_v__dict = __pyx_t_12;
+  __pyx_t_12 = 0;
 
   /* "(tree fragment)":7
- *     state = (self.avg_reward, self.children, self.cteam, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
+ *     state = (self.avg_rave_reward, self.avg_reward, self.children, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.rave_rewards, self.rave_visits, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
-  __pyx_t_10 = (__pyx_v__dict != Py_None);
-  __pyx_t_11 = (__pyx_t_10 != 0);
-  if (__pyx_t_11) {
+  __pyx_t_13 = (__pyx_v__dict != Py_None);
+  __pyx_t_14 = (__pyx_t_13 != 0);
+  if (__pyx_t_14) {
 
     /* "(tree fragment)":8
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  *         state += (_dict,)             # <<<<<<<<<<<<<<
  *         use_setstate = True
  *     else:
  */
-    __pyx_t_9 = PyTuple_New(1); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 8, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_9);
+    __pyx_t_12 = PyTuple_New(1); if (unlikely(!__pyx_t_12)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_12);
     __Pyx_INCREF(__pyx_v__dict);
     __Pyx_GIVEREF(__pyx_v__dict);
-    PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_v__dict);
-    __pyx_t_8 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_9); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 8, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_8);
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_8));
-    __pyx_t_8 = 0;
+    PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_v__dict);
+    __pyx_t_11 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_12); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_11);
+    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
+    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_11));
+    __pyx_t_11 = 0;
 
     /* "(tree fragment)":9
  *     if _dict is not None:
  *         state += (_dict,)
  *         use_setstate = True             # <<<<<<<<<<<<<<
  *     else:
- *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None or self.team is not None
+ *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None
  */
     __pyx_v_use_setstate = 1;
 
     /* "(tree fragment)":7
- *     state = (self.avg_reward, self.children, self.cteam, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
+ *     state = (self.avg_rave_reward, self.avg_reward, self.children, self.invsqrt_visits, self.is_fully_expanded, self.is_terminal, self.move, self.parent, self.rave_rewards, self.rave_visits, self.remaining_moves, self.rewards, self.sqrtlog_visits, self.state, self.team, self.visits)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
     goto __pyx_L3;
   }
 
   /* "(tree fragment)":11
  *         use_setstate = True
  *     else:
- *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None or self.team is not None             # <<<<<<<<<<<<<<
+ *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None             # <<<<<<<<<<<<<<
  *     if use_setstate:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, None), state
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, None), state
  */
   /*else*/ {
-    __pyx_t_10 = (__pyx_v_self->children != Py_None);
-    __pyx_t_12 = (__pyx_t_10 != 0);
-    if (!__pyx_t_12) {
+    __pyx_t_13 = (__pyx_v_self->children != Py_None);
+    __pyx_t_15 = (__pyx_t_13 != 0);
+    if (!__pyx_t_15) {
     } else {
-      __pyx_t_11 = __pyx_t_12;
+      __pyx_t_14 = __pyx_t_15;
       goto __pyx_L4_bool_binop_done;
     }
-    __pyx_t_12 = (__pyx_v_self->move != Py_None);
-    __pyx_t_10 = (__pyx_t_12 != 0);
-    if (!__pyx_t_10) {
+    __pyx_t_15 = (__pyx_v_self->move != Py_None);
+    __pyx_t_13 = (__pyx_t_15 != 0);
+    if (!__pyx_t_13) {
     } else {
-      __pyx_t_11 = __pyx_t_10;
+      __pyx_t_14 = __pyx_t_13;
       goto __pyx_L4_bool_binop_done;
     }
-    __pyx_t_10 = (((PyObject *)__pyx_v_self->parent) != Py_None);
-    __pyx_t_12 = (__pyx_t_10 != 0);
-    if (!__pyx_t_12) {
+    __pyx_t_13 = (((PyObject *)__pyx_v_self->parent) != Py_None);
+    __pyx_t_15 = (__pyx_t_13 != 0);
+    if (!__pyx_t_15) {
     } else {
-      __pyx_t_11 = __pyx_t_12;
+      __pyx_t_14 = __pyx_t_15;
       goto __pyx_L4_bool_binop_done;
     }
-    __pyx_t_12 = (__pyx_v_self->remaining_moves != Py_None);
-    __pyx_t_10 = (__pyx_t_12 != 0);
-    if (!__pyx_t_10) {
+    __pyx_t_15 = (__pyx_v_self->remaining_moves != Py_None);
+    __pyx_t_13 = (__pyx_t_15 != 0);
+    if (!__pyx_t_13) {
     } else {
-      __pyx_t_11 = __pyx_t_10;
+      __pyx_t_14 = __pyx_t_13;
       goto __pyx_L4_bool_binop_done;
     }
-    __pyx_t_10 = (__pyx_v_self->state != Py_None);
-    __pyx_t_12 = (__pyx_t_10 != 0);
-    if (!__pyx_t_12) {
-    } else {
-      __pyx_t_11 = __pyx_t_12;
-      goto __pyx_L4_bool_binop_done;
-    }
-    __pyx_t_12 = (__pyx_v_self->team != Py_None);
-    __pyx_t_10 = (__pyx_t_12 != 0);
-    __pyx_t_11 = __pyx_t_10;
+    __pyx_t_13 = (__pyx_v_self->state != Py_None);
+    __pyx_t_15 = (__pyx_t_13 != 0);
+    __pyx_t_14 = __pyx_t_15;
     __pyx_L4_bool_binop_done:;
-    __pyx_v_use_setstate = __pyx_t_11;
+    __pyx_v_use_setstate = __pyx_t_14;
   }
   __pyx_L3:;
 
   /* "(tree fragment)":12
  *     else:
- *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None or self.team is not None
+ *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, None), state
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, None), state
  *     else:
  */
-  __pyx_t_11 = (__pyx_v_use_setstate != 0);
-  if (__pyx_t_11) {
+  __pyx_t_14 = (__pyx_v_use_setstate != 0);
+  if (__pyx_t_14) {
 
     /* "(tree fragment)":13
- *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None or self.team is not None
+ *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None
  *     if use_setstate:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, None), state             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, None), state             # <<<<<<<<<<<<<<
  *     else:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, state)
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, state)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_pyx_unpickle_Node); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_8);
-    __pyx_t_9 = PyTuple_New(3); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_9);
+    __Pyx_GetModuleGlobalName(__pyx_t_11, __pyx_n_s_pyx_unpickle_Node); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_11);
+    __pyx_t_12 = PyTuple_New(3); if (unlikely(!__pyx_t_12)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_12);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    PyTuple_SET_ITEM(__pyx_t_9, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_56097295);
-    __Pyx_GIVEREF(__pyx_int_56097295);
-    PyTuple_SET_ITEM(__pyx_t_9, 1, __pyx_int_56097295);
+    PyTuple_SET_ITEM(__pyx_t_12, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
+    __Pyx_INCREF(__pyx_int_254580472);
+    __Pyx_GIVEREF(__pyx_int_254580472);
+    PyTuple_SET_ITEM(__pyx_t_12, 1, __pyx_int_254580472);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
-    PyTuple_SET_ITEM(__pyx_t_9, 2, Py_None);
-    __pyx_t_7 = PyTuple_New(3); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __Pyx_GIVEREF(__pyx_t_8);
-    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_8);
-    __Pyx_GIVEREF(__pyx_t_9);
-    PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_9);
+    PyTuple_SET_ITEM(__pyx_t_12, 2, Py_None);
+    __pyx_t_10 = PyTuple_New(3); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_10);
+    __Pyx_GIVEREF(__pyx_t_11);
+    PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_11);
+    __Pyx_GIVEREF(__pyx_t_12);
+    PyTuple_SET_ITEM(__pyx_t_10, 1, __pyx_t_12);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
-    PyTuple_SET_ITEM(__pyx_t_7, 2, __pyx_v_state);
-    __pyx_t_8 = 0;
-    __pyx_t_9 = 0;
-    __pyx_r = __pyx_t_7;
-    __pyx_t_7 = 0;
+    PyTuple_SET_ITEM(__pyx_t_10, 2, __pyx_v_state);
+    __pyx_t_11 = 0;
+    __pyx_t_12 = 0;
+    __pyx_r = __pyx_t_10;
+    __pyx_t_10 = 0;
     goto __pyx_L0;
 
     /* "(tree fragment)":12
  *     else:
- *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None or self.team is not None
+ *         use_setstate = self.children is not None or self.move is not None or self.parent is not None or self.remaining_moves is not None or self.state is not None
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, None), state
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, None), state
  *     else:
  */
   }
 
   /* "(tree fragment)":15
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, None), state
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, None), state
  *     else:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, state)             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, state)             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Node__set_state(self, __pyx_state)
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_pyx_unpickle_Node); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_9 = PyTuple_New(3); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_9);
+    __Pyx_GetModuleGlobalName(__pyx_t_10, __pyx_n_s_pyx_unpickle_Node); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_10);
+    __pyx_t_12 = PyTuple_New(3); if (unlikely(!__pyx_t_12)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_12);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    PyTuple_SET_ITEM(__pyx_t_9, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_56097295);
-    __Pyx_GIVEREF(__pyx_int_56097295);
-    PyTuple_SET_ITEM(__pyx_t_9, 1, __pyx_int_56097295);
+    PyTuple_SET_ITEM(__pyx_t_12, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
+    __Pyx_INCREF(__pyx_int_254580472);
+    __Pyx_GIVEREF(__pyx_int_254580472);
+    PyTuple_SET_ITEM(__pyx_t_12, 1, __pyx_int_254580472);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
-    PyTuple_SET_ITEM(__pyx_t_9, 2, __pyx_v_state);
-    __pyx_t_8 = PyTuple_New(2); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_8);
-    __Pyx_GIVEREF(__pyx_t_7);
-    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7);
-    __Pyx_GIVEREF(__pyx_t_9);
-    PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_9);
-    __pyx_t_7 = 0;
-    __pyx_t_9 = 0;
-    __pyx_r = __pyx_t_8;
-    __pyx_t_8 = 0;
+    PyTuple_SET_ITEM(__pyx_t_12, 2, __pyx_v_state);
+    __pyx_t_11 = PyTuple_New(2); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_11);
+    __Pyx_GIVEREF(__pyx_t_10);
+    PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_10);
+    __Pyx_GIVEREF(__pyx_t_12);
+    PyTuple_SET_ITEM(__pyx_t_11, 1, __pyx_t_12);
+    __pyx_t_10 = 0;
+    __pyx_t_12 = 0;
+    __pyx_r = __pyx_t_11;
+    __pyx_t_11 = 0;
     goto __pyx_L0;
   }
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
  *     cdef object _dict
@@ -3477,191 +6376,234 @@
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_7);
   __Pyx_XDECREF(__pyx_t_8);
   __Pyx_XDECREF(__pyx_t_9);
+  __Pyx_XDECREF(__pyx_t_10);
+  __Pyx_XDECREF(__pyx_t_11);
+  __Pyx_XDECREF(__pyx_t_12);
   __Pyx_AddTraceback("multimcts.mcts.Node.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_state);
   __Pyx_XDECREF(__pyx_v__dict);
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, state)
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_Node__set_state(self, __pyx_state)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
-static PyObject *__pyx_pw_9multimcts_4mcts_4Node_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_35__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4Node_35__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_4__setstate_cython__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4Node_34__setstate_cython__(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_9multimcts_4mcts_4Node_4__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
+static PyObject *__pyx_pf_9multimcts_4mcts_4Node_34__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
+  __Pyx_TraceCall("__setstate_cython__", __pyx_f[1], 16, 0, __PYX_ERR(1, 16, __pyx_L1_error));
 
   /* "(tree fragment)":17
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, state)
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, state)
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Node__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<
  */
   if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
   __pyx_t_1 = __pyx_f_9multimcts_4mcts___pyx_unpickle_Node__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_Node, (type(self), 0x357fa0f, state)
+ *         return __pyx_unpickle_Node, (type(self), 0xf2c96f8, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_Node__set_state(self, __pyx_state)
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.Node.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":137
- *     cdef double exploration_bias
+/* "multimcts/mcts.pyx":267
+ *     cdef double exploration_bias, rave_bias
  * 
- *     def __init__(self, exploration_bias:float=1.414):             # <<<<<<<<<<<<<<
+ *     def __init__(self, exploration_bias:float=1.414, rave_bias:float=0):             # <<<<<<<<<<<<<<
  *         """Initializes an MCTS agent.
  *         Args:
  */
 
 /* Python wrapper */
 static int __pyx_pw_9multimcts_4mcts_4MCTS_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static char __pyx_doc_9multimcts_4mcts_4MCTS___init__[] = "Initializes an MCTS agent.\n        Args:\n            exploration_bias (float): The exploration bias, which balances exploration (favoring untested moves) and exploitation (favoring good moves).\n                The default \342\210\2322 is often used in practice. However, the optimal value depends on the game and is usually found by experimentation.\n        ";
 #if CYTHON_UPDATE_DESCRIPTOR_DOC
 struct wrapperbase __pyx_wrapperbase_9multimcts_4mcts_4MCTS___init__;
 #endif
 static int __pyx_pw_9multimcts_4mcts_4MCTS_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   double __pyx_v_exploration_bias;
+  double __pyx_v_rave_bias;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_exploration_bias,0};
-    PyObject* values[1] = {0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_exploration_bias,&__pyx_n_s_rave_bias,0};
+    PyObject* values[2] = {0,0};
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
       const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
       switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_exploration_bias);
           if (value) { values[0] = value; kw_args--; }
         }
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (kw_args > 0) {
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rave_bias);
+          if (value) { values[1] = value; kw_args--; }
+        }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 137, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 267, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     if (values[0]) {
-      __pyx_v_exploration_bias = __pyx_PyFloat_AsDouble(values[0]); if (unlikely((__pyx_v_exploration_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 137, __pyx_L3_error)
+      __pyx_v_exploration_bias = __pyx_PyFloat_AsDouble(values[0]); if (unlikely((__pyx_v_exploration_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 267, __pyx_L3_error)
     } else {
       __pyx_v_exploration_bias = ((double)1.414);
     }
+    if (values[1]) {
+      __pyx_v_rave_bias = __pyx_PyFloat_AsDouble(values[1]); if (unlikely((__pyx_v_rave_bias == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 267, __pyx_L3_error)
+    } else {
+      __pyx_v_rave_bias = ((double)0.0);
+    }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 137, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 267, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("multimcts.mcts.MCTS.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4MCTS___init__(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v_self), __pyx_v_exploration_bias);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4MCTS___init__(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v_self), __pyx_v_exploration_bias, __pyx_v_rave_bias);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static int __pyx_pf_9multimcts_4mcts_4MCTS___init__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, double __pyx_v_exploration_bias) {
+static int __pyx_pf_9multimcts_4mcts_4MCTS___init__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, double __pyx_v_exploration_bias, double __pyx_v_rave_bias) {
   int __pyx_r;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
+  __Pyx_TraceCall("__init__", __pyx_f[0], 267, 0, __PYX_ERR(0, 267, __pyx_L1_error));
 
-  /* "multimcts/mcts.pyx":143
+  /* "multimcts/mcts.pyx":273
  *                 The default 2 is often used in practice. However, the optimal value depends on the game and is usually found by experimentation.
  *         """
  *         self.exploration_bias = exploration_bias             # <<<<<<<<<<<<<<
+ *         self.rave_bias = rave_bias
  * 
- *     @property
  */
   __pyx_v_self->exploration_bias = __pyx_v_exploration_bias;
 
-  /* "multimcts/mcts.pyx":137
- *     cdef double exploration_bias
+  /* "multimcts/mcts.pyx":274
+ *         """
+ *         self.exploration_bias = exploration_bias
+ *         self.rave_bias = rave_bias             # <<<<<<<<<<<<<<
  * 
- *     def __init__(self, exploration_bias:float=1.414):             # <<<<<<<<<<<<<<
+ *     @property
+ */
+  __pyx_v_self->rave_bias = __pyx_v_rave_bias;
+
+  /* "multimcts/mcts.pyx":267
+ *     cdef double exploration_bias, rave_bias
+ * 
+ *     def __init__(self, exploration_bias:float=1.414, rave_bias:float=0):             # <<<<<<<<<<<<<<
  *         """Initializes an MCTS agent.
  *         Args:
  */
 
   /* function exit code */
   __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("multimcts.mcts.MCTS.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_TraceReturn(Py_None, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":146
+/* "multimcts/mcts.pyx":277
  * 
  *     @property
  *     def exploration_bias(self) -> float: return self.exploration_bias             # <<<<<<<<<<<<<<
- * 
- *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, heuristic=None, return_type:str="state") -> Union[GameState,Move,Node]:
+ *     @property
+ *     def rave_bias(self) -> float: return self.rave_bias
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_16exploration_bias_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_16exploration_bias_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -3671,68 +6613,119 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_16exploration_bias___get__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_TraceCall("__get__", __pyx_f[0], 277, 0, __PYX_ERR(0, 277, __pyx_L1_error));
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->exploration_bias); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->exploration_bias); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 277, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.MCTS.exploration_bias.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "multimcts/mcts.pyx":148
+/* "multimcts/mcts.pyx":279
  *     def exploration_bias(self) -> float: return self.exploration_bias
+ *     @property
+ *     def rave_bias(self) -> float: return self.rave_bias             # <<<<<<<<<<<<<<
  * 
- *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, heuristic=None, return_type:str="state") -> Union[GameState,Move,Node]:             # <<<<<<<<<<<<<<
+ *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, return_type:str="state") -> Union[GameState,Move,Node]:
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_9rave_bias_1__get__(PyObject *__pyx_v_self); /*proto*/
+static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_9rave_bias_1__get__(PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4MCTS_9rave_bias___get__(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_9rave_bias___get__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__get__", 0);
+  __Pyx_TraceCall("__get__", __pyx_f[0], 279, 0, __PYX_ERR(0, 279, __pyx_L1_error));
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->rave_bias); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 279, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("multimcts.mcts.MCTS.rave_bias.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":281
+ *     def rave_bias(self) -> float: return self.rave_bias
+ * 
+ *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, return_type:str="state") -> Union[GameState,Move,Node]:             # <<<<<<<<<<<<<<
  *         """Searches for this state's best move until some limit has been reached.
  *         Args:
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_3search(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_9multimcts_4mcts_4MCTS_2search[] = "Searches for this state's best move until some limit has been reached.\n        Args:\n            state (GameState): The game state for which to find the best move.\n            max_time (int|float): The maximum time to search, in seconds.\n            max_iterations (int): The maximum number of selections/simulations to perform.\n            heuristic (callable): A function that takes a state and returns a move. See simulate() for more information.\n            return_type (str): One of \"state\", \"move\", or \"node\".\n        Returns:\n            GameState: A new game state which is the result of applying the best move to the given state.\n        ";
+static char __pyx_doc_9multimcts_4mcts_4MCTS_2search[] = "Searches for this state's best move until some limit has been reached.\n        Args:\n            state (GameState): The game state for which to find the best move.\n            max_time (int|float): The maximum time to search, in seconds.\n            max_iterations (int): The maximum number of selections/simulations to perform.\n            return_type (str): One of \"state\", \"move\", or \"node\".\n        Returns:\n            GameState: A new game state which is the result of applying the best move to the given state.\n        ";
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_3search(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_state = 0;
   PyObject *__pyx_v_max_time = 0;
   PyObject *__pyx_v_max_iterations = 0;
-  PyObject *__pyx_v_heuristic = 0;
   PyObject *__pyx_v_return_type = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("search (wrapper)", 0);
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_state,&__pyx_n_s_max_time,&__pyx_n_s_max_iterations,&__pyx_n_s_heuristic,&__pyx_n_s_return_type,0};
-    PyObject* values[5] = {0,0,0,0,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_state,&__pyx_n_s_max_time,&__pyx_n_s_max_iterations,&__pyx_n_s_return_type,0};
+    PyObject* values[4] = {0,0,0,0};
     values[1] = ((PyObject *)Py_None);
     values[2] = ((PyObject *)Py_None);
-    values[3] = ((PyObject *)Py_None);
-    values[4] = ((PyObject*)__pyx_n_u_state);
+    values[3] = ((PyObject*)__pyx_n_u_state);
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
       const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
       switch (pos_args) {
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
@@ -3740,1692 +6733,552 @@
       }
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_state)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
-      if (kw_args > 0 && likely(kw_args <= 4)) {
+      if (kw_args > 0 && likely(kw_args <= 3)) {
         Py_ssize_t index;
-        for (index = 1; index < 5 && kw_args > 0; index++) {
+        for (index = 1; index < 4 && kw_args > 0; index++) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
           if (value) { values[index] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "search") < 0)) __PYX_ERR(0, 148, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "search") < 0)) __PYX_ERR(0, 281, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_state = values[0];
     __pyx_v_max_time = values[1];
     __pyx_v_max_iterations = values[2];
-    __pyx_v_heuristic = values[3];
-    __pyx_v_return_type = ((PyObject*)values[4]);
+    __pyx_v_return_type = ((PyObject*)values[3]);
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("search", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 148, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("search", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 281, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("multimcts.mcts.MCTS.search", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_return_type), (&PyUnicode_Type), 1, "return_type", 1))) __PYX_ERR(0, 148, __pyx_L1_error)
-  __pyx_r = __pyx_pf_9multimcts_4mcts_4MCTS_2search(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v_self), __pyx_v_state, __pyx_v_max_time, __pyx_v_max_iterations, __pyx_v_heuristic, __pyx_v_return_type);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_return_type), (&PyUnicode_Type), 1, "return_type", 1))) __PYX_ERR(0, 281, __pyx_L1_error)
+  __pyx_r = __pyx_pf_9multimcts_4mcts_4MCTS_2search(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v_self), __pyx_v_state, __pyx_v_max_time, __pyx_v_max_iterations, __pyx_v_return_type);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_2search(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v_state, PyObject *__pyx_v_max_time, PyObject *__pyx_v_max_iterations, PyObject *__pyx_v_heuristic, PyObject *__pyx_v_return_type) {
-  PyObject *__pyx_v_VALID_RETURN_TYPES = NULL;
+static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_2search(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v_state, PyObject *__pyx_v_max_time, PyObject *__pyx_v_max_iterations, PyObject *__pyx_v_return_type) {
   struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node = NULL;
   double __pyx_v_end_time;
   int __pyx_v_i;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_child = NULL;
-  std::map<std::string,double>  __pyx_v_rewards;
   struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_best = 0;
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  int __pyx_t_4;
-  int __pyx_t_5;
+  int __pyx_t_1;
+  int __pyx_t_2;
+  int __pyx_t_3;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
   Py_ssize_t __pyx_t_6;
   Py_UCS4 __pyx_t_7;
-  int __pyx_t_8;
-  double __pyx_t_9;
-  std::map<std::string,double>  __pyx_t_10;
-  struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate __pyx_t_11;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_9 = NULL;
+  double __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("search", 0);
-  __Pyx_INCREF(__pyx_v_return_type);
+  __Pyx_TraceCall("search", __pyx_f[0], 281, 0, __PYX_ERR(0, 281, __pyx_L1_error));
 
-  /* "multimcts/mcts.pyx":159
+  /* "multimcts/mcts.pyx":291
  *             GameState: A new game state which is the result of applying the best move to the given state.
  *         """
- *         return_type = return_type.lower()             # <<<<<<<<<<<<<<
- *         VALID_RETURN_TYPES = {"state","move","node"}
- *         if return_type not in VALID_RETURN_TYPES:
+ *         if max_time is None and max_iterations is None:             # <<<<<<<<<<<<<<
+ *             raise ValueError('One or more of max_time/max_iterations is required.')
+ * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_return_type, __pyx_n_s_lower); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 159, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_3)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_3);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-    }
+  __pyx_t_2 = (__pyx_v_max_time == Py_None);
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
+  } else {
+    __pyx_t_1 = __pyx_t_3;
+    goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 159, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (!(likely(PyUnicode_CheckExact(__pyx_t_1))||((__pyx_t_1) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "unicode", Py_TYPE(__pyx_t_1)->tp_name), 0))) __PYX_ERR(0, 159, __pyx_L1_error)
-  __Pyx_DECREF_SET(__pyx_v_return_type, ((PyObject*)__pyx_t_1));
-  __pyx_t_1 = 0;
+  __pyx_t_3 = (__pyx_v_max_iterations == Py_None);
+  __pyx_t_2 = (__pyx_t_3 != 0);
+  __pyx_t_1 = __pyx_t_2;
+  __pyx_L4_bool_binop_done:;
+  if (unlikely(__pyx_t_1)) {
 
-  /* "multimcts/mcts.pyx":160
+    /* "multimcts/mcts.pyx":292
  *         """
- *         return_type = return_type.lower()
- *         VALID_RETURN_TYPES = {"state","move","node"}             # <<<<<<<<<<<<<<
- *         if return_type not in VALID_RETURN_TYPES:
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')
- */
-  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 160, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PySet_Add(__pyx_t_1, __pyx_n_u_state) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_1, __pyx_n_u_move) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_1, __pyx_n_u_node) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
-  __pyx_v_VALID_RETURN_TYPES = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":161
- *         return_type = return_type.lower()
- *         VALID_RETURN_TYPES = {"state","move","node"}
- *         if return_type not in VALID_RETURN_TYPES:             # <<<<<<<<<<<<<<
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')
- * 
- */
-  __pyx_t_4 = (__Pyx_PySet_ContainsTF(__pyx_v_return_type, __pyx_v_VALID_RETURN_TYPES, Py_NE)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 161, __pyx_L1_error)
-  __pyx_t_5 = (__pyx_t_4 != 0);
-  if (unlikely(__pyx_t_5)) {
-
-    /* "multimcts/mcts.pyx":162
- *         VALID_RETURN_TYPES = {"state","move","node"}
- *         if return_type not in VALID_RETURN_TYPES:
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')             # <<<<<<<<<<<<<<
- * 
  *         if max_time is None and max_iterations is None:
+ *             raise ValueError('One or more of max_time/max_iterations is required.')             # <<<<<<<<<<<<<<
+ * 
+ *         if return_type not in {'state','move','node'}:
  */
-    __pyx_t_1 = PyTuple_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_6 = 0;
-    __pyx_t_7 = 127;
-    __Pyx_INCREF(__pyx_kp_u_Invalid_return_type);
-    __pyx_t_6 += 21;
-    __Pyx_GIVEREF(__pyx_kp_u_Invalid_return_type);
-    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Invalid_return_type);
-    __pyx_t_2 = __Pyx_PyUnicode_Unicode(__pyx_v_return_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_7;
-    __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
-    __pyx_t_2 = 0;
-    __Pyx_INCREF(__pyx_kp_u_must_be_one_of);
-    __pyx_t_6 += 17;
-    __Pyx_GIVEREF(__pyx_kp_u_must_be_one_of);
-    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_must_be_one_of);
-    __pyx_t_2 = __Pyx_PyObject_FormatSimple(__pyx_v_VALID_RETURN_TYPES, __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_7;
-    __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_2);
-    __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_PyUnicode_Join(__pyx_t_1, 4, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 162, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 292, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __PYX_ERR(0, 292, __pyx_L1_error)
 
-    /* "multimcts/mcts.pyx":161
- *         return_type = return_type.lower()
- *         VALID_RETURN_TYPES = {"state","move","node"}
- *         if return_type not in VALID_RETURN_TYPES:             # <<<<<<<<<<<<<<
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')
+    /* "multimcts/mcts.pyx":291
+ *             GameState: A new game state which is the result of applying the best move to the given state.
+ *         """
+ *         if max_time is None and max_iterations is None:             # <<<<<<<<<<<<<<
+ *             raise ValueError('One or more of max_time/max_iterations is required.')
  * 
  */
   }
 
-  /* "multimcts/mcts.pyx":164
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')
+  /* "multimcts/mcts.pyx":294
+ *             raise ValueError('One or more of max_time/max_iterations is required.')
  * 
- *         if max_time is None and max_iterations is None:             # <<<<<<<<<<<<<<
- *             raise ValueError("One or more of max_time/max_iterations is required.")
+ *         if return_type not in {'state','move','node'}:             # <<<<<<<<<<<<<<
+ *             raise ValueError(f'Invalid return_type "{return_type}" must be one of {{"state","move","node"}}')
  * 
  */
-  __pyx_t_4 = (__pyx_v_max_time == Py_None);
-  __pyx_t_8 = (__pyx_t_4 != 0);
-  if (__pyx_t_8) {
+  __Pyx_INCREF(__pyx_v_return_type);
+  __pyx_t_5 = __pyx_v_return_type;
+  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_n_u_state, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 294, __pyx_L1_error)
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
   } else {
-    __pyx_t_5 = __pyx_t_8;
-    goto __pyx_L5_bool_binop_done;
+    __pyx_t_1 = __pyx_t_3;
+    goto __pyx_L7_bool_binop_done;
   }
-  __pyx_t_8 = (__pyx_v_max_iterations == Py_None);
-  __pyx_t_4 = (__pyx_t_8 != 0);
-  __pyx_t_5 = __pyx_t_4;
-  __pyx_L5_bool_binop_done:;
-  if (unlikely(__pyx_t_5)) {
+  __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_n_u_move, Py_NE)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 294, __pyx_L1_error)
+  __pyx_t_2 = (__pyx_t_3 != 0);
+  if (__pyx_t_2) {
+  } else {
+    __pyx_t_1 = __pyx_t_2;
+    goto __pyx_L7_bool_binop_done;
+  }
+  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_n_u_node, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 294, __pyx_L1_error)
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  __pyx_t_1 = __pyx_t_3;
+  __pyx_L7_bool_binop_done:;
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_t_3 = (__pyx_t_1 != 0);
+  if (unlikely(__pyx_t_3)) {
 
-    /* "multimcts/mcts.pyx":165
+    /* "multimcts/mcts.pyx":295
  * 
- *         if max_time is None and max_iterations is None:
- *             raise ValueError("One or more of max_time/max_iterations is required.")             # <<<<<<<<<<<<<<
+ *         if return_type not in {'state','move','node'}:
+ *             raise ValueError(f'Invalid return_type "{return_type}" must be one of {{"state","move","node"}}')             # <<<<<<<<<<<<<<
  * 
  *         node = Node(state)
  */
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 165, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 165, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 295, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_6 = 0;
+    __pyx_t_7 = 127;
+    __Pyx_INCREF(__pyx_kp_u_Invalid_return_type);
+    __pyx_t_6 += 21;
+    __Pyx_GIVEREF(__pyx_kp_u_Invalid_return_type);
+    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_u_Invalid_return_type);
+    __pyx_t_8 = __Pyx_PyUnicode_Unicode(__pyx_v_return_type); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 295, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) : __pyx_t_7;
+    __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_8);
+    __Pyx_GIVEREF(__pyx_t_8);
+    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_8);
+    __pyx_t_8 = 0;
+    __Pyx_INCREF(__pyx_kp_u_must_be_one_of_state_move_node);
+    __pyx_t_6 += 40;
+    __Pyx_GIVEREF(__pyx_kp_u_must_be_one_of_state_move_node);
+    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_kp_u_must_be_one_of_state_move_node);
+    __pyx_t_8 = __Pyx_PyUnicode_Join(__pyx_t_4, 3, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 295, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 295, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __PYX_ERR(0, 295, __pyx_L1_error)
 
-    /* "multimcts/mcts.pyx":164
- *             raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')
+    /* "multimcts/mcts.pyx":294
+ *             raise ValueError('One or more of max_time/max_iterations is required.')
  * 
- *         if max_time is None and max_iterations is None:             # <<<<<<<<<<<<<<
- *             raise ValueError("One or more of max_time/max_iterations is required.")
+ *         if return_type not in {'state','move','node'}:             # <<<<<<<<<<<<<<
+ *             raise ValueError(f'Invalid return_type "{return_type}" must be one of {{"state","move","node"}}')
  * 
  */
   }
 
-  /* "multimcts/mcts.pyx":167
- *             raise ValueError("One or more of max_time/max_iterations is required.")
+  /* "multimcts/mcts.pyx":297
+ *             raise ValueError(f'Invalid return_type "{return_type}" must be one of {{"state","move","node"}}')
  * 
  *         node = Node(state)             # <<<<<<<<<<<<<<
  * 
  *         cdef double end_time
  */
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_9multimcts_4mcts_Node), __pyx_v_state); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 167, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_node = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_1);
-  __pyx_t_1 = 0;
+  __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_9multimcts_4mcts_Node), __pyx_v_state); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 297, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_v_node = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_4);
+  __pyx_t_4 = 0;
 
-  /* "multimcts/mcts.pyx":170
+  /* "multimcts/mcts.pyx":300
  * 
  *         cdef double end_time
  *         cdef int i = 0             # <<<<<<<<<<<<<<
  *         if max_time is not None:
  *             end_time = time() + max_time
  */
   __pyx_v_i = 0;
 
-  /* "multimcts/mcts.pyx":171
+  /* "multimcts/mcts.pyx":301
  *         cdef double end_time
  *         cdef int i = 0
  *         if max_time is not None:             # <<<<<<<<<<<<<<
  *             end_time = time() + max_time
  * 
  */
-  __pyx_t_5 = (__pyx_v_max_time != Py_None);
-  __pyx_t_4 = (__pyx_t_5 != 0);
-  if (__pyx_t_4) {
+  __pyx_t_3 = (__pyx_v_max_time != Py_None);
+  __pyx_t_1 = (__pyx_t_3 != 0);
+  if (__pyx_t_1) {
 
-    /* "multimcts/mcts.pyx":172
+    /* "multimcts/mcts.pyx":302
  *         cdef int i = 0
  *         if max_time is not None:
  *             end_time = time() + max_time             # <<<<<<<<<<<<<<
  * 
  *         while True:
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_time); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 172, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = NULL;
-    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_3)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_3);
+    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_time); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 302, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_t_9 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
+      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);
+      if (likely(__pyx_t_9)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
+        __Pyx_INCREF(__pyx_t_9);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __Pyx_DECREF_SET(__pyx_t_8, function);
       }
     }
-    __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 172, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = PyNumber_Add(__pyx_t_1, __pyx_v_max_time); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 172, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_9 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_9 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 172, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_v_end_time = __pyx_t_9;
+    __pyx_t_4 = (__pyx_t_9) ? __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_9) : __Pyx_PyObject_CallNoArg(__pyx_t_8);
+    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
+    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 302, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __pyx_t_8 = PyNumber_Add(__pyx_t_4, __pyx_v_max_time); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 302, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_10 = __pyx_PyFloat_AsDouble(__pyx_t_8); if (unlikely((__pyx_t_10 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 302, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __pyx_v_end_time = __pyx_t_10;
 
-    /* "multimcts/mcts.pyx":171
+    /* "multimcts/mcts.pyx":301
  *         cdef double end_time
  *         cdef int i = 0
  *         if max_time is not None:             # <<<<<<<<<<<<<<
  *             end_time = time() + max_time
  * 
  */
   }
 
-  /* "multimcts/mcts.pyx":174
+  /* "multimcts/mcts.pyx":304
  *             end_time = time() + max_time
  * 
  *         while True:             # <<<<<<<<<<<<<<
- *             child = self.select(node)
- *             rewards = self.simulate(child, heuristic=heuristic)
+ *             node.execute_round(self.exploration_bias, self.rave_bias)
+ * 
  */
   while (1) {
 
-    /* "multimcts/mcts.pyx":175
+    /* "multimcts/mcts.pyx":305
  * 
  *         while True:
- *             child = self.select(node)             # <<<<<<<<<<<<<<
- *             rewards = self.simulate(child, heuristic=heuristic)
- *             self.backpropagate(child, rewards)
- */
-    __pyx_t_2 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->select(__pyx_v_self, __pyx_v_node)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 175, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_XDECREF_SET(__pyx_v_child, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2));
-    __pyx_t_2 = 0;
-
-    /* "multimcts/mcts.pyx":176
- *         while True:
- *             child = self.select(node)
- *             rewards = self.simulate(child, heuristic=heuristic)             # <<<<<<<<<<<<<<
- *             self.backpropagate(child, rewards)
- * 
- */
-    __pyx_t_11.__pyx_n = 1;
-    __pyx_t_11.heuristic = __pyx_v_heuristic;
-    __pyx_t_10 = ((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->simulate(__pyx_v_self, __pyx_v_child, &__pyx_t_11); 
-    __pyx_v_rewards = __pyx_t_10;
-
-    /* "multimcts/mcts.pyx":177
- *             child = self.select(node)
- *             rewards = self.simulate(child, heuristic=heuristic)
- *             self.backpropagate(child, rewards)             # <<<<<<<<<<<<<<
- * 
- *             # If there is only one legal move, we don't need to search.
- */
-    __pyx_t_2 = ((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->backpropagate(__pyx_v_self, __pyx_v_child, __pyx_v_rewards); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 177, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-    /* "multimcts/mcts.pyx":180
- * 
- *             # If there is only one legal move, we don't need to search.
- *             if node.is_fully_expanded and len(node.children) == 1:             # <<<<<<<<<<<<<<
- *                 break
- * 
- */
-    __pyx_t_5 = (__pyx_v_node->is_fully_expanded != 0);
-    if (__pyx_t_5) {
-    } else {
-      __pyx_t_4 = __pyx_t_5;
-      goto __pyx_L11_bool_binop_done;
-    }
-    __pyx_t_2 = __pyx_v_node->children;
-    __Pyx_INCREF(__pyx_t_2);
-    __pyx_t_6 = PyObject_Length(__pyx_t_2); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 180, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_5 = ((__pyx_t_6 == 1) != 0);
-    __pyx_t_4 = __pyx_t_5;
-    __pyx_L11_bool_binop_done:;
-    if (__pyx_t_4) {
-
-      /* "multimcts/mcts.pyx":181
- *             # If there is only one legal move, we don't need to search.
- *             if node.is_fully_expanded and len(node.children) == 1:
- *                 break             # <<<<<<<<<<<<<<
+ *             node.execute_round(self.exploration_bias, self.rave_bias)             # <<<<<<<<<<<<<<
  * 
  *             if max_time is not None:
  */
-      goto __pyx_L9_break;
-
-      /* "multimcts/mcts.pyx":180
- * 
- *             # If there is only one legal move, we don't need to search.
- *             if node.is_fully_expanded and len(node.children) == 1:             # <<<<<<<<<<<<<<
- *                 break
- * 
- */
-    }
+    ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->execute_round(__pyx_v_node, __pyx_v_self->exploration_bias, __pyx_v_self->rave_bias);
 
-    /* "multimcts/mcts.pyx":183
- *                 break
+    /* "multimcts/mcts.pyx":307
+ *             node.execute_round(self.exploration_bias, self.rave_bias)
  * 
  *             if max_time is not None:             # <<<<<<<<<<<<<<
  *                 if time() >= end_time:
  *                     break
  */
-    __pyx_t_4 = (__pyx_v_max_time != Py_None);
-    __pyx_t_5 = (__pyx_t_4 != 0);
-    if (__pyx_t_5) {
+    __pyx_t_1 = (__pyx_v_max_time != Py_None);
+    __pyx_t_3 = (__pyx_t_1 != 0);
+    if (__pyx_t_3) {
 
-      /* "multimcts/mcts.pyx":184
+      /* "multimcts/mcts.pyx":308
  * 
  *             if max_time is not None:
  *                 if time() >= end_time:             # <<<<<<<<<<<<<<
  *                     break
  *             if max_iterations is not None:
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_time); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 184, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = NULL;
-      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
-        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
-        if (likely(__pyx_t_3)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-          __Pyx_INCREF(__pyx_t_3);
+      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_time); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 308, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_9 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
+        __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_4);
+        if (likely(__pyx_t_9)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+          __Pyx_INCREF(__pyx_t_9);
           __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_1, function);
+          __Pyx_DECREF_SET(__pyx_t_4, function);
         }
       }
-      __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_1);
-      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 184, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_1 = PyFloat_FromDouble(__pyx_v_end_time); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 184, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, __pyx_t_1, Py_GE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 184, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 184, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (__pyx_t_5) {
+      __pyx_t_8 = (__pyx_t_9) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_9) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
+      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
+      if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 308, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_4 = PyFloat_FromDouble(__pyx_v_end_time); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 308, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_9 = PyObject_RichCompare(__pyx_t_8, __pyx_t_4, Py_GE); __Pyx_XGOTREF(__pyx_t_9); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 308, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 308, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+      if (__pyx_t_3) {
 
-        /* "multimcts/mcts.pyx":185
+        /* "multimcts/mcts.pyx":309
  *             if max_time is not None:
  *                 if time() >= end_time:
  *                     break             # <<<<<<<<<<<<<<
  *             if max_iterations is not None:
  *                 i += 1
  */
-        goto __pyx_L9_break;
+        goto __pyx_L12_break;
 
-        /* "multimcts/mcts.pyx":184
+        /* "multimcts/mcts.pyx":308
  * 
  *             if max_time is not None:
  *                 if time() >= end_time:             # <<<<<<<<<<<<<<
  *                     break
  *             if max_iterations is not None:
  */
       }
 
-      /* "multimcts/mcts.pyx":183
- *                 break
+      /* "multimcts/mcts.pyx":307
+ *             node.execute_round(self.exploration_bias, self.rave_bias)
  * 
  *             if max_time is not None:             # <<<<<<<<<<<<<<
  *                 if time() >= end_time:
  *                     break
  */
     }
 
-    /* "multimcts/mcts.pyx":186
+    /* "multimcts/mcts.pyx":310
  *                 if time() >= end_time:
  *                     break
  *             if max_iterations is not None:             # <<<<<<<<<<<<<<
  *                 i += 1
  *                 if i >= max_iterations:
  */
-    __pyx_t_5 = (__pyx_v_max_iterations != Py_None);
-    __pyx_t_4 = (__pyx_t_5 != 0);
-    if (__pyx_t_4) {
+    __pyx_t_3 = (__pyx_v_max_iterations != Py_None);
+    __pyx_t_1 = (__pyx_t_3 != 0);
+    if (__pyx_t_1) {
 
-      /* "multimcts/mcts.pyx":187
+      /* "multimcts/mcts.pyx":311
  *                     break
  *             if max_iterations is not None:
  *                 i += 1             # <<<<<<<<<<<<<<
  *                 if i >= max_iterations:
  *                     break
  */
       __pyx_v_i = (__pyx_v_i + 1);
 
-      /* "multimcts/mcts.pyx":188
+      /* "multimcts/mcts.pyx":312
  *             if max_iterations is not None:
  *                 i += 1
  *                 if i >= max_iterations:             # <<<<<<<<<<<<<<
  *                     break
  * 
  */
-      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 188, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_1 = PyObject_RichCompare(__pyx_t_3, __pyx_v_max_iterations, Py_GE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 188, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 188, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      if (__pyx_t_4) {
+      __pyx_t_9 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 312, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_t_9, __pyx_v_max_iterations, Py_GE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 312, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 312, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_1) {
 
-        /* "multimcts/mcts.pyx":189
+        /* "multimcts/mcts.pyx":313
  *                 i += 1
  *                 if i >= max_iterations:
  *                     break             # <<<<<<<<<<<<<<
  * 
- *         cdef Node best = self.get_best_child(node)
+ *         # We've performed the full search above using the desired biases.
  */
-        goto __pyx_L9_break;
+        goto __pyx_L12_break;
 
-        /* "multimcts/mcts.pyx":188
+        /* "multimcts/mcts.pyx":312
  *             if max_iterations is not None:
  *                 i += 1
  *                 if i >= max_iterations:             # <<<<<<<<<<<<<<
  *                     break
  * 
  */
       }
 
-      /* "multimcts/mcts.pyx":186
+      /* "multimcts/mcts.pyx":310
  *                 if time() >= end_time:
  *                     break
  *             if max_iterations is not None:             # <<<<<<<<<<<<<<
  *                 i += 1
  *                 if i >= max_iterations:
  */
     }
   }
-  __pyx_L9_break:;
+  __pyx_L12_break:;
 
-  /* "multimcts/mcts.pyx":191
- *                     break
- * 
- *         cdef Node best = self.get_best_child(node)             # <<<<<<<<<<<<<<
+  /* "multimcts/mcts.pyx":317
+ *         # We've performed the full search above using the desired biases.
+ *         # For the final pick we will be a bit more exploitative and a bit less RAVEy.
+ *         cdef Node best = node.best_child(self.exploration_bias*0.9, self.rave_bias*0.9)             # <<<<<<<<<<<<<<
  * 
  *         if return_type == "state":
  */
-  __pyx_t_1 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->get_best_child(__pyx_v_self, __pyx_v_node)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_best = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_1);
-  __pyx_t_1 = 0;
+  __pyx_t_4 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->best_child(__pyx_v_node, (__pyx_v_self->exploration_bias * 0.9), (__pyx_v_self->rave_bias * 0.9))); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 317, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_v_best = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_4);
+  __pyx_t_4 = 0;
 
-  /* "multimcts/mcts.pyx":193
- *         cdef Node best = self.get_best_child(node)
+  /* "multimcts/mcts.pyx":319
+ *         cdef Node best = node.best_child(self.exploration_bias*0.9, self.rave_bias*0.9)
  * 
  *         if return_type == "state":             # <<<<<<<<<<<<<<
  *             return best.state
  *         elif return_type == "move":
  */
-  __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_state, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 193, __pyx_L1_error)
-  __pyx_t_5 = (__pyx_t_4 != 0);
-  if (__pyx_t_5) {
+  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_state, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 319, __pyx_L1_error)
+  __pyx_t_3 = (__pyx_t_1 != 0);
+  if (__pyx_t_3) {
 
-    /* "multimcts/mcts.pyx":194
+    /* "multimcts/mcts.pyx":320
  * 
  *         if return_type == "state":
  *             return best.state             # <<<<<<<<<<<<<<
  *         elif return_type == "move":
  *             return best.move
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_v_best->state);
     __pyx_r = __pyx_v_best->state;
     goto __pyx_L0;
 
-    /* "multimcts/mcts.pyx":193
- *         cdef Node best = self.get_best_child(node)
+    /* "multimcts/mcts.pyx":319
+ *         cdef Node best = node.best_child(self.exploration_bias*0.9, self.rave_bias*0.9)
  * 
  *         if return_type == "state":             # <<<<<<<<<<<<<<
  *             return best.state
  *         elif return_type == "move":
  */
   }
 
-  /* "multimcts/mcts.pyx":195
+  /* "multimcts/mcts.pyx":321
  *         if return_type == "state":
  *             return best.state
  *         elif return_type == "move":             # <<<<<<<<<<<<<<
  *             return best.move
  *         elif return_type == "node":
  */
-  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_move, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 195, __pyx_L1_error)
-  __pyx_t_4 = (__pyx_t_5 != 0);
-  if (__pyx_t_4) {
+  __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_move, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 321, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_3 != 0);
+  if (__pyx_t_1) {
 
-    /* "multimcts/mcts.pyx":196
+    /* "multimcts/mcts.pyx":322
  *             return best.state
  *         elif return_type == "move":
  *             return best.move             # <<<<<<<<<<<<<<
  *         elif return_type == "node":
  *             return best
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_v_best->move);
     __pyx_r = __pyx_v_best->move;
     goto __pyx_L0;
 
-    /* "multimcts/mcts.pyx":195
+    /* "multimcts/mcts.pyx":321
  *         if return_type == "state":
  *             return best.state
  *         elif return_type == "move":             # <<<<<<<<<<<<<<
  *             return best.move
  *         elif return_type == "node":
  */
   }
 
-  /* "multimcts/mcts.pyx":197
+  /* "multimcts/mcts.pyx":323
  *         elif return_type == "move":
  *             return best.move
  *         elif return_type == "node":             # <<<<<<<<<<<<<<
  *             return best
  * 
  */
-  __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_node, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 197, __pyx_L1_error)
-  __pyx_t_5 = (__pyx_t_4 != 0);
-  if (__pyx_t_5) {
+  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_return_type, __pyx_n_u_node, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 323, __pyx_L1_error)
+  __pyx_t_3 = (__pyx_t_1 != 0);
+  if (__pyx_t_3) {
 
-    /* "multimcts/mcts.pyx":198
+    /* "multimcts/mcts.pyx":324
  *             return best.move
  *         elif return_type == "node":
  *             return best             # <<<<<<<<<<<<<<
  * 
- *     cdef Node select(self, Node node):
+ * 
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject *)__pyx_v_best));
     __pyx_r = ((PyObject *)__pyx_v_best);
     goto __pyx_L0;
 
-    /* "multimcts/mcts.pyx":197
+    /* "multimcts/mcts.pyx":323
  *         elif return_type == "move":
  *             return best.move
  *         elif return_type == "node":             # <<<<<<<<<<<<<<
  *             return best
  * 
  */
   }
 
-  /* "multimcts/mcts.pyx":148
- *     def exploration_bias(self) -> float: return self.exploration_bias
+  /* "multimcts/mcts.pyx":281
+ *     def rave_bias(self) -> float: return self.rave_bias
  * 
- *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, heuristic=None, return_type:str="state") -> Union[GameState,Move,Node]:             # <<<<<<<<<<<<<<
+ *     def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, return_type:str="state") -> Union[GameState,Move,Node]:             # <<<<<<<<<<<<<<
  *         """Searches for this state's best move until some limit has been reached.
  *         Args:
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_XDECREF(__pyx_t_9);
   __Pyx_AddTraceback("multimcts.mcts.MCTS.search", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_VALID_RETURN_TYPES);
   __Pyx_XDECREF((PyObject *)__pyx_v_node);
-  __Pyx_XDECREF((PyObject *)__pyx_v_child);
   __Pyx_XDECREF((PyObject *)__pyx_v_best);
-  __Pyx_XDECREF(__pyx_v_return_type);
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "multimcts/mcts.pyx":200
- *             return best
- * 
- *     cdef Node select(self, Node node):             # <<<<<<<<<<<<<<
- *         """Step 1: Selection
- *         Traverse the tree for the node we most want to simulate.
- */
-
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_select(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node) {
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("select", 0);
-  __Pyx_INCREF((PyObject *)__pyx_v_node);
-
-  /* "multimcts/mcts.pyx":205
- *         Looks for an unexplored child of this node's best child's best child's...best child.
- *         """
- *         while not node.is_terminal:             # <<<<<<<<<<<<<<
- *             if not node.is_fully_expanded:
- *                 return self.expand(node)
- */
-  while (1) {
-    __pyx_t_1 = ((!(__pyx_v_node->is_terminal != 0)) != 0);
-    if (!__pyx_t_1) break;
-
-    /* "multimcts/mcts.pyx":206
- *         """
- *         while not node.is_terminal:
- *             if not node.is_fully_expanded:             # <<<<<<<<<<<<<<
- *                 return self.expand(node)
- *             else:
- */
-    __pyx_t_1 = ((!(__pyx_v_node->is_fully_expanded != 0)) != 0);
-    if (__pyx_t_1) {
-
-      /* "multimcts/mcts.pyx":207
- *         while not node.is_terminal:
- *             if not node.is_fully_expanded:
- *                 return self.expand(node)             # <<<<<<<<<<<<<<
- *             else:
- *                 node = self.get_best_child(node)
- */
-      __Pyx_XDECREF(((PyObject *)__pyx_r));
-      __pyx_t_2 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->expand(__pyx_v_self, __pyx_v_node)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 207, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __pyx_r = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2);
-      __pyx_t_2 = 0;
-      goto __pyx_L0;
-
-      /* "multimcts/mcts.pyx":206
- *         """
- *         while not node.is_terminal:
- *             if not node.is_fully_expanded:             # <<<<<<<<<<<<<<
- *                 return self.expand(node)
- *             else:
- */
-    }
-
-    /* "multimcts/mcts.pyx":209
- *                 return self.expand(node)
- *             else:
- *                 node = self.get_best_child(node)             # <<<<<<<<<<<<<<
- *         return node
- * 
- */
-    /*else*/ {
-      __pyx_t_2 = ((PyObject *)((struct __pyx_vtabstruct_9multimcts_4mcts_MCTS *)__pyx_v_self->__pyx_vtab)->get_best_child(__pyx_v_self, __pyx_v_node)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 209, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF_SET(__pyx_v_node, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2));
-      __pyx_t_2 = 0;
-    }
-  }
-
-  /* "multimcts/mcts.pyx":210
- *             else:
- *                 node = self.get_best_child(node)
- *         return node             # <<<<<<<<<<<<<<
- * 
- *     cdef Node expand(self, Node node):
- */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_INCREF(((PyObject *)__pyx_v_node));
-  __pyx_r = __pyx_v_node;
-  goto __pyx_L0;
-
-  /* "multimcts/mcts.pyx":200
- *             return best
- * 
- *     cdef Node select(self, Node node):             # <<<<<<<<<<<<<<
- *         """Step 1: Selection
- *         Traverse the tree for the node we most want to simulate.
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_AddTraceback("multimcts.mcts.MCTS.select", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_node);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "multimcts/mcts.pyx":212
- *         return node
- * 
- *     cdef Node expand(self, Node node):             # <<<<<<<<<<<<<<
- *         """Step 2: Expansion
- *         Add a new child to this node.
- */
-
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_expand(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node) {
-  PyObject *__pyx_v_move = NULL;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_child = 0;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  Py_ssize_t __pyx_t_2;
-  int __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  int __pyx_t_7;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("expand", 0);
-
-  /* "multimcts/mcts.pyx":216
- *         Add a new child to this node.
- *         """
- *         move = node.remaining_moves.pop()             # <<<<<<<<<<<<<<
- *         if len(node.remaining_moves) == 0:
- *             node.is_fully_expanded = True
- */
-  __pyx_t_1 = __Pyx_PyObject_Pop(__pyx_v_node->remaining_moves); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 216, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_move = __pyx_t_1;
-  __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":217
- *         """
- *         move = node.remaining_moves.pop()
- *         if len(node.remaining_moves) == 0:             # <<<<<<<<<<<<<<
- *             node.is_fully_expanded = True
- * 
- */
-  __pyx_t_1 = __pyx_v_node->remaining_moves;
-  __Pyx_INCREF(__pyx_t_1);
-  __pyx_t_2 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 217, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = ((__pyx_t_2 == 0) != 0);
-  if (__pyx_t_3) {
-
-    /* "multimcts/mcts.pyx":218
- *         move = node.remaining_moves.pop()
- *         if len(node.remaining_moves) == 0:
- *             node.is_fully_expanded = True             # <<<<<<<<<<<<<<
- * 
- *         cdef Node child = Node(state=node.state.make_move(move), parent=node, move=move)
- */
-    __pyx_v_node->is_fully_expanded = 1;
-
-    /* "multimcts/mcts.pyx":217
- *         """
- *         move = node.remaining_moves.pop()
- *         if len(node.remaining_moves) == 0:             # <<<<<<<<<<<<<<
- *             node.is_fully_expanded = True
- * 
- */
-  }
-
-  /* "multimcts/mcts.pyx":220
- *             node.is_fully_expanded = True
- * 
- *         cdef Node child = Node(state=node.state.make_move(move), parent=node, move=move)             # <<<<<<<<<<<<<<
- *         node.children.append(child)
- * 
- */
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 220, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_node->state, __pyx_n_s_make_move); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 220, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_6 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
-    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
-    if (likely(__pyx_t_6)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-      __Pyx_INCREF(__pyx_t_6);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_5, function);
-    }
-  }
-  __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_move) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_move);
-  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 220, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_state, __pyx_t_4) < 0) __PYX_ERR(0, 220, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_parent, ((PyObject *)__pyx_v_node)) < 0) __PYX_ERR(0, 220, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_move, __pyx_v_move) < 0) __PYX_ERR(0, 220, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_9multimcts_4mcts_Node), __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 220, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v_child = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_4);
-  __pyx_t_4 = 0;
-
-  /* "multimcts/mcts.pyx":221
- * 
- *         cdef Node child = Node(state=node.state.make_move(move), parent=node, move=move)
- *         node.children.append(child)             # <<<<<<<<<<<<<<
- * 
- *         return child
- */
-  __pyx_t_7 = __Pyx_PyObject_Append(__pyx_v_node->children, ((PyObject *)__pyx_v_child)); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 221, __pyx_L1_error)
-
-  /* "multimcts/mcts.pyx":223
- *         node.children.append(child)
- * 
- *         return child             # <<<<<<<<<<<<<<
- * 
- *     cdef map[string,double] simulate(self, Node node, heuristic=None):
- */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_INCREF(((PyObject *)__pyx_v_child));
-  __pyx_r = __pyx_v_child;
-  goto __pyx_L0;
-
-  /* "multimcts/mcts.pyx":212
- *         return node
- * 
- *     cdef Node expand(self, Node node):             # <<<<<<<<<<<<<<
- *         """Step 2: Expansion
- *         Add a new child to this node.
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_AddTraceback("multimcts.mcts.MCTS.expand", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_move);
-  __Pyx_XDECREF((PyObject *)__pyx_v_child);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "multimcts/mcts.pyx":225
- *         return child
- * 
- *     cdef map[string,double] simulate(self, Node node, heuristic=None):             # <<<<<<<<<<<<<<
- *         """Step 3: Simulation (aka playout/rollout)
- *         Play out a game, from the given node to termination, and return the final reward.
- */
-
-static std::map<std::string,double>  __pyx_f_9multimcts_4mcts_4MCTS_simulate(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node, struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate *__pyx_optional_args) {
-  PyObject *__pyx_v_heuristic = ((PyObject *)Py_None);
-  PyObject *__pyx_v_state = NULL;
-  PyObject *__pyx_v_terminal_team = NULL;
-  PyObject *__pyx_v_move = NULL;
-  PyObject *__pyx_v_reward = NULL;
-  std::map<std::string,double>  __pyx_v_crewards;
-  PyObject *__pyx_v_team = NULL;
-  std::map<std::string,double>  __pyx_r;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  int __pyx_t_5;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  std::map<std::string,double>  __pyx_t_8;
-  Py_ssize_t __pyx_t_9;
-  PyObject *(*__pyx_t_10)(PyObject *);
-  double __pyx_t_11;
-  std::string __pyx_t_12;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("simulate", 0);
-  if (__pyx_optional_args) {
-    if (__pyx_optional_args->__pyx_n > 0) {
-      __pyx_v_heuristic = __pyx_optional_args->heuristic;
-    }
-  }
-
-  /* "multimcts/mcts.pyx":233
- *             heuristic (callable): A function that takes a state and returns a move.
- *         """
- *         state = node.state             # <<<<<<<<<<<<<<
- * 
- *         terminal_team = None
- */
-  __pyx_t_1 = __pyx_v_node->state;
-  __Pyx_INCREF(__pyx_t_1);
-  __pyx_v_state = __pyx_t_1;
-  __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":235
- *         state = node.state
- * 
- *         terminal_team = None             # <<<<<<<<<<<<<<
- *         if node.is_terminal:
- *             terminal_team = node.parent.team
- */
-  __Pyx_INCREF(Py_None);
-  __pyx_v_terminal_team = Py_None;
-
-  /* "multimcts/mcts.pyx":236
- * 
- *         terminal_team = None
- *         if node.is_terminal:             # <<<<<<<<<<<<<<
- *             terminal_team = node.parent.team
- *         else:
- */
-  __pyx_t_2 = (__pyx_v_node->is_terminal != 0);
-  if (__pyx_t_2) {
-
-    /* "multimcts/mcts.pyx":237
- *         terminal_team = None
- *         if node.is_terminal:
- *             terminal_team = node.parent.team             # <<<<<<<<<<<<<<
- *         else:
- *             while not state.is_terminal():
- */
-    __pyx_t_1 = __pyx_v_node->parent->team;
-    __Pyx_INCREF(__pyx_t_1);
-    __Pyx_DECREF_SET(__pyx_v_terminal_team, __pyx_t_1);
-    __pyx_t_1 = 0;
-
-    /* "multimcts/mcts.pyx":236
- * 
- *         terminal_team = None
- *         if node.is_terminal:             # <<<<<<<<<<<<<<
- *             terminal_team = node.parent.team
- *         else:
- */
-    goto __pyx_L3;
-  }
-
-  /* "multimcts/mcts.pyx":239
- *             terminal_team = node.parent.team
- *         else:
- *             while not state.is_terminal():             # <<<<<<<<<<<<<<
- *                 terminal_team = state.get_current_team()
- *                 if heuristic is not None:
- */
-  /*else*/ {
-    while (1) {
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_is_terminal); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 239, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = NULL;
-      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-        if (likely(__pyx_t_4)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-          __Pyx_INCREF(__pyx_t_4);
-          __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_3, function);
-        }
-      }
-      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
-      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 239, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_5 = ((!__pyx_t_2) != 0);
-      if (!__pyx_t_5) break;
-
-      /* "multimcts/mcts.pyx":240
- *         else:
- *             while not state.is_terminal():
- *                 terminal_team = state.get_current_team()             # <<<<<<<<<<<<<<
- *                 if heuristic is not None:
- *                     move = heuristic(state)
- */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_get_current_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 240, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = NULL;
-      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-        if (likely(__pyx_t_4)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-          __Pyx_INCREF(__pyx_t_4);
-          __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_3, function);
-        }
-      }
-      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
-      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 240, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_DECREF_SET(__pyx_v_terminal_team, __pyx_t_1);
-      __pyx_t_1 = 0;
-
-      /* "multimcts/mcts.pyx":241
- *             while not state.is_terminal():
- *                 terminal_team = state.get_current_team()
- *                 if heuristic is not None:             # <<<<<<<<<<<<<<
- *                     move = heuristic(state)
- *                 else:
- */
-      __pyx_t_5 = (__pyx_v_heuristic != Py_None);
-      __pyx_t_2 = (__pyx_t_5 != 0);
-      if (__pyx_t_2) {
-
-        /* "multimcts/mcts.pyx":242
- *                 terminal_team = state.get_current_team()
- *                 if heuristic is not None:
- *                     move = heuristic(state)             # <<<<<<<<<<<<<<
- *                 else:
- *                     move = choice(state.get_legal_moves())
- */
-        __Pyx_INCREF(__pyx_v_heuristic);
-        __pyx_t_3 = __pyx_v_heuristic; __pyx_t_4 = NULL;
-        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-          if (likely(__pyx_t_4)) {
-            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-            __Pyx_INCREF(__pyx_t_4);
-            __Pyx_INCREF(function);
-            __Pyx_DECREF_SET(__pyx_t_3, function);
-          }
-        }
-        __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_state) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_state);
-        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 242, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __Pyx_XDECREF_SET(__pyx_v_move, __pyx_t_1);
-        __pyx_t_1 = 0;
-
-        /* "multimcts/mcts.pyx":241
- *             while not state.is_terminal():
- *                 terminal_team = state.get_current_team()
- *                 if heuristic is not None:             # <<<<<<<<<<<<<<
- *                     move = heuristic(state)
- *                 else:
- */
-        goto __pyx_L6;
-      }
-
-      /* "multimcts/mcts.pyx":244
- *                     move = heuristic(state)
- *                 else:
- *                     move = choice(state.get_legal_moves())             # <<<<<<<<<<<<<<
- *                 state = state.make_move(move)
- * 
- */
-      /*else*/ {
-        __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_choice); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 244, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_get_legal_moves); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 244, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_6);
-        __pyx_t_7 = NULL;
-        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
-          __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
-          if (likely(__pyx_t_7)) {
-            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
-            __Pyx_INCREF(__pyx_t_7);
-            __Pyx_INCREF(function);
-            __Pyx_DECREF_SET(__pyx_t_6, function);
-          }
-        }
-        __pyx_t_4 = (__pyx_t_7) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
-        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-        if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 244, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-        __pyx_t_6 = NULL;
-        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-          __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
-          if (likely(__pyx_t_6)) {
-            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-            __Pyx_INCREF(__pyx_t_6);
-            __Pyx_INCREF(function);
-            __Pyx_DECREF_SET(__pyx_t_3, function);
-          }
-        }
-        __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
-        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 244, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __Pyx_XDECREF_SET(__pyx_v_move, __pyx_t_1);
-        __pyx_t_1 = 0;
-      }
-      __pyx_L6:;
-
-      /* "multimcts/mcts.pyx":245
- *                 else:
- *                     move = choice(state.get_legal_moves())
- *                 state = state.make_move(move)             # <<<<<<<<<<<<<<
- * 
- *         reward = state.get_reward()
- */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_make_move); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 245, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = NULL;
-      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-        if (likely(__pyx_t_4)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-          __Pyx_INCREF(__pyx_t_4);
-          __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_3, function);
-        }
-      }
-      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_move) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_move);
-      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 245, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_DECREF_SET(__pyx_v_state, __pyx_t_1);
-      __pyx_t_1 = 0;
-    }
-  }
-  __pyx_L3:;
-
-  /* "multimcts/mcts.pyx":247
- *                 state = state.make_move(move)
- * 
- *         reward = state.get_reward()             # <<<<<<<<<<<<<<
- *         if not isinstance(reward, dict):
- *             reward = {terminal_team: reward}
- */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_state, __pyx_n_s_get_reward); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 247, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_4);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-    }
-  }
-  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 247, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_reward = __pyx_t_1;
-  __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":248
- * 
- *         reward = state.get_reward()
- *         if not isinstance(reward, dict):             # <<<<<<<<<<<<<<
- *             reward = {terminal_team: reward}
- * 
- */
-  __pyx_t_2 = PyDict_Check(__pyx_v_reward); 
-  __pyx_t_5 = ((!(__pyx_t_2 != 0)) != 0);
-  if (__pyx_t_5) {
-
-    /* "multimcts/mcts.pyx":249
- *         reward = state.get_reward()
- *         if not isinstance(reward, dict):
- *             reward = {terminal_team: reward}             # <<<<<<<<<<<<<<
- * 
- *         cdef map[string,double] crewards = map[string,double]()
- */
-    __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 249, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    if (PyDict_SetItem(__pyx_t_1, __pyx_v_terminal_team, __pyx_v_reward) < 0) __PYX_ERR(0, 249, __pyx_L1_error)
-    __Pyx_DECREF_SET(__pyx_v_reward, __pyx_t_1);
-    __pyx_t_1 = 0;
-
-    /* "multimcts/mcts.pyx":248
- * 
- *         reward = state.get_reward()
- *         if not isinstance(reward, dict):             # <<<<<<<<<<<<<<
- *             reward = {terminal_team: reward}
- * 
- */
-  }
-
-  /* "multimcts/mcts.pyx":251
- *             reward = {terminal_team: reward}
- * 
- *         cdef map[string,double] crewards = map[string,double]()             # <<<<<<<<<<<<<<
- *         for team in reward:
- *             if reward[team] == 0:
- */
-  try {
-    __pyx_t_8 = std::map<std::string,double> ();
-  } catch(...) {
-    __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 251, __pyx_L1_error)
-  }
-  __pyx_v_crewards = __pyx_t_8;
-
-  /* "multimcts/mcts.pyx":252
- * 
- *         cdef map[string,double] crewards = map[string,double]()
- *         for team in reward:             # <<<<<<<<<<<<<<
- *             if reward[team] == 0:
- *                 continue
- */
-  if (likely(PyList_CheckExact(__pyx_v_reward)) || PyTuple_CheckExact(__pyx_v_reward)) {
-    __pyx_t_1 = __pyx_v_reward; __Pyx_INCREF(__pyx_t_1); __pyx_t_9 = 0;
-    __pyx_t_10 = NULL;
-  } else {
-    __pyx_t_9 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_reward); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 252, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_10 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 252, __pyx_L1_error)
-  }
-  for (;;) {
-    if (likely(!__pyx_t_10)) {
-      if (likely(PyList_CheckExact(__pyx_t_1))) {
-        if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_1)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_9); __Pyx_INCREF(__pyx_t_3); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 252, __pyx_L1_error)
-        #else
-        __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 252, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        #endif
-      } else {
-        if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_9); __Pyx_INCREF(__pyx_t_3); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 252, __pyx_L1_error)
-        #else
-        __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 252, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        #endif
-      }
-    } else {
-      __pyx_t_3 = __pyx_t_10(__pyx_t_1);
-      if (unlikely(!__pyx_t_3)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 252, __pyx_L1_error)
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_3);
-    }
-    __Pyx_XDECREF_SET(__pyx_v_team, __pyx_t_3);
-    __pyx_t_3 = 0;
-
-    /* "multimcts/mcts.pyx":253
- *         cdef map[string,double] crewards = map[string,double]()
- *         for team in reward:
- *             if reward[team] == 0:             # <<<<<<<<<<<<<<
- *                 continue
- *             crewards[str(team).encode()] = float(reward[team])
- */
-    __pyx_t_3 = __Pyx_PyObject_GetItem(__pyx_v_reward, __pyx_v_team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 253, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyInt_EqObjC(__pyx_t_3, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 253, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 253, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (__pyx_t_5) {
-
-      /* "multimcts/mcts.pyx":254
- *         for team in reward:
- *             if reward[team] == 0:
- *                 continue             # <<<<<<<<<<<<<<
- *             crewards[str(team).encode()] = float(reward[team])
- * 
- */
-      goto __pyx_L8_continue;
-
-      /* "multimcts/mcts.pyx":253
- *         cdef map[string,double] crewards = map[string,double]()
- *         for team in reward:
- *             if reward[team] == 0:             # <<<<<<<<<<<<<<
- *                 continue
- *             crewards[str(team).encode()] = float(reward[team])
- */
-    }
-
-    /* "multimcts/mcts.pyx":255
- *             if reward[team] == 0:
- *                 continue
- *             crewards[str(team).encode()] = float(reward[team])             # <<<<<<<<<<<<<<
- * 
- *         return crewards
- */
-    __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_reward, __pyx_v_team); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 255, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_11 = __Pyx_PyObject_AsDouble(__pyx_t_4); if (unlikely(__pyx_t_11 == ((double)((double)-1)) && PyErr_Occurred())) __PYX_ERR(0, 255, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_team); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 255, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = PyUnicode_AsEncodedString(((PyObject*)__pyx_t_4), NULL, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 255, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_12 = __pyx_convert_string_from_py_std__in_string(__pyx_t_3); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 255, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    (__pyx_v_crewards[__pyx_t_12]) = __pyx_t_11;
-
-    /* "multimcts/mcts.pyx":252
- * 
- *         cdef map[string,double] crewards = map[string,double]()
- *         for team in reward:             # <<<<<<<<<<<<<<
- *             if reward[team] == 0:
- *                 continue
- */
-    __pyx_L8_continue:;
-  }
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-
-  /* "multimcts/mcts.pyx":257
- *             crewards[str(team).encode()] = float(reward[team])
- * 
- *         return crewards             # <<<<<<<<<<<<<<
- * 
- *     cdef backpropagate(self, Node node, map[string,double] crewards):
- */
-  __pyx_r = __pyx_v_crewards;
-  goto __pyx_L0;
-
-  /* "multimcts/mcts.pyx":225
- *         return child
- * 
- *     cdef map[string,double] simulate(self, Node node, heuristic=None):             # <<<<<<<<<<<<<<
- *         """Step 3: Simulation (aka playout/rollout)
- *         Play out a game, from the given node to termination, and return the final reward.
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_WriteUnraisable("multimcts.mcts.MCTS.simulate", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
-  __Pyx_pretend_to_initialize(&__pyx_r);
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_state);
-  __Pyx_XDECREF(__pyx_v_terminal_team);
-  __Pyx_XDECREF(__pyx_v_move);
-  __Pyx_XDECREF(__pyx_v_reward);
-  __Pyx_XDECREF(__pyx_v_team);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "multimcts/mcts.pyx":259
- *         return crewards
- * 
- *     cdef backpropagate(self, Node node, map[string,double] crewards):             # <<<<<<<<<<<<<<
- *         """Step 4: Backpropagation
- *         Update all ancestors with the reward from this terminal node.
- */
-
-static PyObject *__pyx_f_9multimcts_4mcts_4MCTS_backpropagate(CYTHON_UNUSED struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node, std::map<std::string,double>  __pyx_v_crewards) {
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("backpropagate", 0);
-  __Pyx_INCREF((PyObject *)__pyx_v_node);
-
-  /* "multimcts/mcts.pyx":263
- *         Update all ancestors with the reward from this terminal node.
- *         """
- *         while node is not None:             # <<<<<<<<<<<<<<
- *             node.apply_rewards(crewards)
- *             node = node.parent
- */
-  while (1) {
-    __pyx_t_1 = (((PyObject *)__pyx_v_node) != Py_None);
-    __pyx_t_2 = (__pyx_t_1 != 0);
-    if (!__pyx_t_2) break;
-
-    /* "multimcts/mcts.pyx":264
- *         """
- *         while node is not None:
- *             node.apply_rewards(crewards)             # <<<<<<<<<<<<<<
- *             node = node.parent
- * 
- */
-    __pyx_t_3 = ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_node->__pyx_vtab)->apply_rewards(__pyx_v_node, __pyx_v_crewards); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 264, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-
-    /* "multimcts/mcts.pyx":265
- *         while node is not None:
- *             node.apply_rewards(crewards)
- *             node = node.parent             # <<<<<<<<<<<<<<
- * 
- *     cdef Node get_best_child(self, Node node):
- */
-    __pyx_t_3 = ((PyObject *)__pyx_v_node->parent);
-    __Pyx_INCREF(__pyx_t_3);
-    __Pyx_DECREF_SET(__pyx_v_node, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_3));
-    __pyx_t_3 = 0;
-  }
-
-  /* "multimcts/mcts.pyx":259
- *         return crewards
- * 
- *     cdef backpropagate(self, Node node, map[string,double] crewards):             # <<<<<<<<<<<<<<
- *         """Step 4: Backpropagation
- *         Update all ancestors with the reward from this terminal node.
- */
-
-  /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("multimcts.mcts.MCTS.backpropagate", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_node);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "multimcts/mcts.pyx":267
- *             node = node.parent
- * 
- *     cdef Node get_best_child(self, Node node):             # <<<<<<<<<<<<<<
- *         """Find the child with the highest Upper Confidence Bound (UCB)."""
- *         cdef double parent_sqrtlog_visits = node.sqrtlog_visits
- */
-
-static struct __pyx_obj_9multimcts_4mcts_Node *__pyx_f_9multimcts_4mcts_4MCTS_get_best_child(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_node) {
-  double __pyx_v_parent_sqrtlog_visits;
-  double __pyx_v_best_score;
-  double __pyx_v_ucb;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_child = 0;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v_best_child = 0;
-  struct __pyx_obj_9multimcts_4mcts_Node *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  double __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  Py_ssize_t __pyx_t_3;
-  PyObject *(*__pyx_t_4)(PyObject *);
-  PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("get_best_child", 0);
-
-  /* "multimcts/mcts.pyx":269
- *     cdef Node get_best_child(self, Node node):
- *         """Find the child with the highest Upper Confidence Bound (UCB)."""
- *         cdef double parent_sqrtlog_visits = node.sqrtlog_visits             # <<<<<<<<<<<<<<
- *         cdef double best_score = -INFINITY
- *         cdef double ucb
- */
-  __pyx_t_1 = __pyx_v_node->sqrtlog_visits;
-  __pyx_v_parent_sqrtlog_visits = __pyx_t_1;
-
-  /* "multimcts/mcts.pyx":270
- *         """Find the child with the highest Upper Confidence Bound (UCB)."""
- *         cdef double parent_sqrtlog_visits = node.sqrtlog_visits
- *         cdef double best_score = -INFINITY             # <<<<<<<<<<<<<<
- *         cdef double ucb
- *         cdef Node child, best_child = node.children[0]
- */
-  __pyx_v_best_score = (-INFINITY);
-
-  /* "multimcts/mcts.pyx":272
- *         cdef double best_score = -INFINITY
- *         cdef double ucb
- *         cdef Node child, best_child = node.children[0]             # <<<<<<<<<<<<<<
- *         cdef pair[string,double] item
- * 
- */
-  __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_node->children, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 272, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_9multimcts_4mcts_Node))))) __PYX_ERR(0, 272, __pyx_L1_error)
-  __pyx_v_best_child = ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_2);
-  __pyx_t_2 = 0;
-
-  /* "multimcts/mcts.pyx":275
- *         cdef pair[string,double] item
- * 
- *         for child in node.children:             # <<<<<<<<<<<<<<
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)
- *             if ucb > best_score:
- */
-  if (likely(PyList_CheckExact(__pyx_v_node->children)) || PyTuple_CheckExact(__pyx_v_node->children)) {
-    __pyx_t_2 = __pyx_v_node->children; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
-    __pyx_t_4 = NULL;
-  } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_node->children); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 275, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 275, __pyx_L1_error)
-  }
-  for (;;) {
-    if (likely(!__pyx_t_4)) {
-      if (likely(PyList_CheckExact(__pyx_t_2))) {
-        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 275, __pyx_L1_error)
-        #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 275, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        #endif
-      } else {
-        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 275, __pyx_L1_error)
-        #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 275, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        #endif
-      }
-    } else {
-      __pyx_t_5 = __pyx_t_4(__pyx_t_2);
-      if (unlikely(!__pyx_t_5)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 275, __pyx_L1_error)
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_5);
-    }
-    if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_9multimcts_4mcts_Node))))) __PYX_ERR(0, 275, __pyx_L1_error)
-    __Pyx_XDECREF_SET(__pyx_v_child, ((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_t_5));
-    __pyx_t_5 = 0;
-
-    /* "multimcts/mcts.pyx":276
- * 
- *         for child in node.children:
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)             # <<<<<<<<<<<<<<
- *             if ucb > best_score:
- *                 best_score = ucb
- */
-    __pyx_v_ucb = ((struct __pyx_vtabstruct_9multimcts_4mcts_Node *)__pyx_v_child->__pyx_vtab)->ucb(__pyx_v_child, __pyx_v_self->exploration_bias, __pyx_v_parent_sqrtlog_visits);
-
-    /* "multimcts/mcts.pyx":277
- *         for child in node.children:
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)
- *             if ucb > best_score:             # <<<<<<<<<<<<<<
- *                 best_score = ucb
- *                 best_child = child
- */
-    __pyx_t_6 = ((__pyx_v_ucb > __pyx_v_best_score) != 0);
-    if (__pyx_t_6) {
-
-      /* "multimcts/mcts.pyx":278
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)
- *             if ucb > best_score:
- *                 best_score = ucb             # <<<<<<<<<<<<<<
- *                 best_child = child
- * 
- */
-      __pyx_v_best_score = __pyx_v_ucb;
-
-      /* "multimcts/mcts.pyx":279
- *             if ucb > best_score:
- *                 best_score = ucb
- *                 best_child = child             # <<<<<<<<<<<<<<
- * 
- *         return best_child
- */
-      __Pyx_INCREF(((PyObject *)__pyx_v_child));
-      __Pyx_DECREF_SET(__pyx_v_best_child, __pyx_v_child);
-
-      /* "multimcts/mcts.pyx":277
- *         for child in node.children:
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)
- *             if ucb > best_score:             # <<<<<<<<<<<<<<
- *                 best_score = ucb
- *                 best_child = child
- */
-    }
-
-    /* "multimcts/mcts.pyx":275
- *         cdef pair[string,double] item
- * 
- *         for child in node.children:             # <<<<<<<<<<<<<<
- *             ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)
- *             if ucb > best_score:
- */
-  }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "multimcts/mcts.pyx":281
- *                 best_child = child
- * 
- *         return best_child             # <<<<<<<<<<<<<<
- */
-  __Pyx_XDECREF(((PyObject *)__pyx_r));
-  __Pyx_INCREF(((PyObject *)__pyx_v_best_child));
-  __pyx_r = __pyx_v_best_child;
-  goto __pyx_L0;
-
-  /* "multimcts/mcts.pyx":267
- *             node = node.parent
- * 
- *     cdef Node get_best_child(self, Node node):             # <<<<<<<<<<<<<<
- *         """Find the child with the highest Upper Confidence Bound (UCB)."""
- *         cdef double parent_sqrtlog_visits = node.sqrtlog_visits
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_AddTraceback("multimcts.mcts.MCTS.get_best_child", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  __pyx_L0:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_child);
-  __Pyx_XDECREF((PyObject *)__pyx_v_best_child);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
@@ -5446,228 +7299,236 @@
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_4__reduce_cython__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self) {
   PyObject *__pyx_v_state = 0;
   PyObject *__pyx_v__dict = 0;
   int __pyx_v_use_setstate;
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
-  int __pyx_t_3;
+  PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
+  __Pyx_TraceCall("__reduce_cython__", __pyx_f[1], 1, 0, __PYX_ERR(1, 1, __pyx_L1_error));
 
   /* "(tree fragment)":5
  *     cdef object _dict
  *     cdef bint use_setstate
- *     state = (self.exploration_bias,)             # <<<<<<<<<<<<<<
+ *     state = (self.exploration_bias, self.rave_bias)             # <<<<<<<<<<<<<<
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  */
   __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->exploration_bias); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_self->rave_bias); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_1);
-  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
   __pyx_t_1 = 0;
-  __pyx_v_state = ((PyObject*)__pyx_t_2);
   __pyx_t_2 = 0;
+  __pyx_v_state = ((PyObject*)__pyx_t_3);
+  __pyx_t_3 = 0;
 
   /* "(tree fragment)":6
  *     cdef bint use_setstate
- *     state = (self.exploration_bias,)
+ *     state = (self.exploration_bias, self.rave_bias)
  *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<
  *     if _dict is not None:
  *         state += (_dict,)
  */
-  __pyx_t_2 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_v__dict = __pyx_t_2;
-  __pyx_t_2 = 0;
+  __pyx_t_3 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_v__dict = __pyx_t_3;
+  __pyx_t_3 = 0;
 
   /* "(tree fragment)":7
- *     state = (self.exploration_bias,)
+ *     state = (self.exploration_bias, self.rave_bias)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
-  __pyx_t_3 = (__pyx_v__dict != Py_None);
-  __pyx_t_4 = (__pyx_t_3 != 0);
-  if (__pyx_t_4) {
+  __pyx_t_4 = (__pyx_v__dict != Py_None);
+  __pyx_t_5 = (__pyx_t_4 != 0);
+  if (__pyx_t_5) {
 
     /* "(tree fragment)":8
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  *         state += (_dict,)             # <<<<<<<<<<<<<<
  *         use_setstate = True
  *     else:
  */
-    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 8, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v__dict);
     __Pyx_GIVEREF(__pyx_v__dict);
-    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v__dict);
-    __pyx_t_1 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 8, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_1));
-    __pyx_t_1 = 0;
+    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v__dict);
+    __pyx_t_2 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_2));
+    __pyx_t_2 = 0;
 
     /* "(tree fragment)":9
  *     if _dict is not None:
  *         state += (_dict,)
  *         use_setstate = True             # <<<<<<<<<<<<<<
  *     else:
  *         use_setstate = False
  */
     __pyx_v_use_setstate = 1;
 
     /* "(tree fragment)":7
- *     state = (self.exploration_bias,)
+ *     state = (self.exploration_bias, self.rave_bias)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
     goto __pyx_L3;
   }
 
   /* "(tree fragment)":11
  *         use_setstate = True
  *     else:
  *         use_setstate = False             # <<<<<<<<<<<<<<
  *     if use_setstate:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, None), state
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, None), state
  */
   /*else*/ {
     __pyx_v_use_setstate = 0;
   }
   __pyx_L3:;
 
   /* "(tree fragment)":12
  *     else:
  *         use_setstate = False
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, None), state
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, None), state
  *     else:
  */
-  __pyx_t_4 = (__pyx_v_use_setstate != 0);
-  if (__pyx_t_4) {
+  __pyx_t_5 = (__pyx_v_use_setstate != 0);
+  if (__pyx_t_5) {
 
     /* "(tree fragment)":13
  *         use_setstate = False
  *     if use_setstate:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, None), state             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, None), state             # <<<<<<<<<<<<<<
  *     else:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, state)
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, state)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pyx_unpickle_MCTS); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pyx_unpickle_MCTS); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 13, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_203704333);
-    __Pyx_GIVEREF(__pyx_int_203704333);
-    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_int_203704333);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
+    __Pyx_INCREF(__pyx_int_145648438);
+    __Pyx_GIVEREF(__pyx_int_145648438);
+    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_145648438);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
-    PyTuple_SET_ITEM(__pyx_t_2, 2, Py_None);
-    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 13, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_GIVEREF(__pyx_t_1);
-    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_3, 2, Py_None);
+    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
     __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
+    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);
+    __Pyx_GIVEREF(__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
-    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_v_state);
-    __pyx_t_1 = 0;
+    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_state);
     __pyx_t_2 = 0;
-    __pyx_r = __pyx_t_5;
-    __pyx_t_5 = 0;
+    __pyx_t_3 = 0;
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
     goto __pyx_L0;
 
     /* "(tree fragment)":12
  *     else:
  *         use_setstate = False
  *     if use_setstate:             # <<<<<<<<<<<<<<
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, None), state
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, None), state
  *     else:
  */
   }
 
   /* "(tree fragment)":15
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, None), state
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, None), state
  *     else:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, state)             # <<<<<<<<<<<<<<
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, state)             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_MCTS__set_state(self, __pyx_state)
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_pyx_unpickle_MCTS); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pyx_unpickle_MCTS); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
-    __Pyx_INCREF(__pyx_int_203704333);
-    __Pyx_GIVEREF(__pyx_int_203704333);
-    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_int_203704333);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
+    __Pyx_INCREF(__pyx_int_145648438);
+    __Pyx_GIVEREF(__pyx_int_145648438);
+    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_145648438);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
-    PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_v_state);
-    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_GIVEREF(__pyx_t_5);
-    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_5);
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
-    __pyx_t_5 = 0;
-    __pyx_t_2 = 0;
-    __pyx_r = __pyx_t_1;
+    PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_v_state);
+    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_GIVEREF(__pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
+    __Pyx_GIVEREF(__pyx_t_3);
+    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);
     __pyx_t_1 = 0;
+    __pyx_t_3 = 0;
+    __pyx_r = __pyx_t_2;
+    __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
  *     cdef object _dict
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("multimcts.mcts.MCTS.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_state);
   __Pyx_XDECREF(__pyx_v__dict);
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, state)
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_MCTS__set_state(self, __pyx_state)
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_7__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
 static PyObject *__pyx_pw_9multimcts_4mcts_4MCTS_7__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
@@ -5679,51 +7540,259 @@
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_4MCTS_6__setstate_cython__(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
+  __Pyx_TraceCall("__setstate_cython__", __pyx_f[1], 16, 0, __PYX_ERR(1, 16, __pyx_L1_error));
 
   /* "(tree fragment)":17
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, state)
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, state)
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_MCTS__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<
  */
   if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
   __pyx_t_1 = __pyx_f_9multimcts_4mcts___pyx_unpickle_MCTS__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":16
  *     else:
- *         return __pyx_unpickle_MCTS, (type(self), 0xc24480d, state)
+ *         return __pyx_unpickle_MCTS, (type(self), 0x8ae6b36, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_MCTS__set_state(self, __pyx_state)
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("multimcts.mcts.MCTS.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":333
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef double sqrtlog(int x):             # <<<<<<<<<<<<<<
+ *     return SQRTLOG[x] if 0 <= x < 10000 else sqrt(log(x))
+ * @cython.cdivision(True)
+ */
+
+static double __pyx_f_9multimcts_4mcts_sqrtlog(int __pyx_v_x) {
+  double __pyx_r;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  double __pyx_t_1;
+  int __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("sqrtlog", 0);
+  __Pyx_TraceCall("sqrtlog", __pyx_f[0], 333, 0, __PYX_ERR(0, 333, __pyx_L1_error));
+
+  /* "multimcts/mcts.pyx":334
+ * @cython.wraparound(False)
+ * cdef double sqrtlog(int x):
+ *     return SQRTLOG[x] if 0 <= x < 10000 else sqrt(log(x))             # <<<<<<<<<<<<<<
+ * @cython.cdivision(True)
+ * @cython.boundscheck(False)
+ */
+  __pyx_t_2 = (0 <= __pyx_v_x);
+  if (__pyx_t_2) {
+    __pyx_t_2 = (__pyx_v_x < 0x2710);
+  }
+  if ((__pyx_t_2 != 0)) {
+    __pyx_t_1 = (__pyx_v_9multimcts_4mcts_SQRTLOG[__pyx_v_x]);
+  } else {
+    __pyx_t_1 = sqrt(log(__pyx_v_x));
+  }
+  __pyx_r = __pyx_t_1;
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":333
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef double sqrtlog(int x):             # <<<<<<<<<<<<<<
+ *     return SQRTLOG[x] if 0 <= x < 10000 else sqrt(log(x))
+ * @cython.cdivision(True)
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_WriteUnraisable("multimcts.mcts.sqrtlog", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_TraceReturn(Py_None, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "multimcts/mcts.pyx":338
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef double invsqrt(int x):             # <<<<<<<<<<<<<<
+ *     return INVSQRT[x] if 0 <= x < 10000 else 1 / sqrt(x)
+ * 
+ */
+
+static double __pyx_f_9multimcts_4mcts_invsqrt(int __pyx_v_x) {
+  double __pyx_r;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  double __pyx_t_1;
+  int __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("invsqrt", 0);
+  __Pyx_TraceCall("invsqrt", __pyx_f[0], 338, 0, __PYX_ERR(0, 338, __pyx_L1_error));
+
+  /* "multimcts/mcts.pyx":339
+ * @cython.wraparound(False)
+ * cdef double invsqrt(int x):
+ *     return INVSQRT[x] if 0 <= x < 10000 else 1 / sqrt(x)             # <<<<<<<<<<<<<<
+ * 
+ * @cython.cdivision(True)
+ */
+  __pyx_t_2 = (0 <= __pyx_v_x);
+  if (__pyx_t_2) {
+    __pyx_t_2 = (__pyx_v_x < 0x2710);
+  }
+  if ((__pyx_t_2 != 0)) {
+    __pyx_t_1 = (__pyx_v_9multimcts_4mcts_INVSQRT[__pyx_v_x]);
+  } else {
+    __pyx_t_1 = (1.0 / sqrt(__pyx_v_x));
+  }
+  __pyx_r = __pyx_t_1;
+  goto __pyx_L0;
+
+  /* "multimcts/mcts.pyx":338
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef double invsqrt(int x):             # <<<<<<<<<<<<<<
+ *     return INVSQRT[x] if 0 <= x < 10000 else 1 / sqrt(x)
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_WriteUnraisable("multimcts.mcts.invsqrt", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_TraceReturn(Py_None, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
+/* "multimcts/mcts.pyx":344
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef void precalc():             # <<<<<<<<<<<<<<
+ *     SQRTLOG[0] = 0
+ *     INVSQRT[0] = 0
+ */
+
+static void __pyx_f_9multimcts_4mcts_precalc(void) {
+  int __pyx_v_x;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("precalc", 0);
+  __Pyx_TraceCall("precalc", __pyx_f[0], 344, 0, __PYX_ERR(0, 344, __pyx_L1_error));
+
+  /* "multimcts/mcts.pyx":345
+ * @cython.wraparound(False)
+ * cdef void precalc():
+ *     SQRTLOG[0] = 0             # <<<<<<<<<<<<<<
+ *     INVSQRT[0] = 0
+ *     cdef int x = 0
+ */
+  (__pyx_v_9multimcts_4mcts_SQRTLOG[0]) = 0.0;
+
+  /* "multimcts/mcts.pyx":346
+ * cdef void precalc():
+ *     SQRTLOG[0] = 0
+ *     INVSQRT[0] = 0             # <<<<<<<<<<<<<<
+ *     cdef int x = 0
+ *     for x in range(1,10000):
+ */
+  (__pyx_v_9multimcts_4mcts_INVSQRT[0]) = 0.0;
+
+  /* "multimcts/mcts.pyx":347
+ *     SQRTLOG[0] = 0
+ *     INVSQRT[0] = 0
+ *     cdef int x = 0             # <<<<<<<<<<<<<<
+ *     for x in range(1,10000):
+ *         SQRTLOG[x] = sqrt(log(x))
+ */
+  __pyx_v_x = 0;
+
+  /* "multimcts/mcts.pyx":348
+ *     INVSQRT[0] = 0
+ *     cdef int x = 0
+ *     for x in range(1,10000):             # <<<<<<<<<<<<<<
+ *         SQRTLOG[x] = sqrt(log(x))
+ *         INVSQRT[x] = 1 / sqrt(x)
+ */
+  for (__pyx_t_1 = 1; __pyx_t_1 < 0x2710; __pyx_t_1+=1) {
+    __pyx_v_x = __pyx_t_1;
+
+    /* "multimcts/mcts.pyx":349
+ *     cdef int x = 0
+ *     for x in range(1,10000):
+ *         SQRTLOG[x] = sqrt(log(x))             # <<<<<<<<<<<<<<
+ *         INVSQRT[x] = 1 / sqrt(x)
+ * precalc()
+ */
+    (__pyx_v_9multimcts_4mcts_SQRTLOG[__pyx_v_x]) = sqrt(log(__pyx_v_x));
+
+    /* "multimcts/mcts.pyx":350
+ *     for x in range(1,10000):
+ *         SQRTLOG[x] = sqrt(log(x))
+ *         INVSQRT[x] = 1 / sqrt(x)             # <<<<<<<<<<<<<<
+ * precalc()
+ */
+    (__pyx_v_9multimcts_4mcts_INVSQRT[__pyx_v_x]) = (1.0 / sqrt(__pyx_v_x));
+  }
+
+  /* "multimcts/mcts.pyx":344
+ * @cython.boundscheck(False)
+ * @cython.wraparound(False)
+ * cdef void precalc():             # <<<<<<<<<<<<<<
+ *     SQRTLOG[0] = 0
+ *     INVSQRT[0] = 0
+ */
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_WriteUnraisable("multimcts.mcts.precalc", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
+  __pyx_L0:;
+  __Pyx_TraceReturn(Py_None, 0);
+  __Pyx_RefNannyFinishContext();
+}
+
 /* "(tree fragment)":1
  * def __pyx_unpickle_Node(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
 
 /* Python wrapper */
@@ -5802,45 +7871,48 @@
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts___pyx_unpickle_Node(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_v___pyx_PickleError = 0;
   PyObject *__pyx_v___pyx_result = 0;
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
+  __Pyx_TraceFrameInit(__pyx_codeobj__13)
   __Pyx_RefNannySetupContext("__pyx_unpickle_Node", 0);
+  __Pyx_TraceCall("__pyx_unpickle_Node", __pyx_f[1], 1, 0, __PYX_ERR(1, 1, __pyx_L1_error));
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x357fa0f, 0x5f4daba, 0x391d535):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0xf2c96f8, 0x996f7e4, 0x2d45624):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  */
   __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__7, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__14, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
     /* "(tree fragment)":5
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x357fa0f, 0x5f4daba, 0x391d535):
+ *     if __pyx_checksum not in (0xf2c96f8, 0x996f7e4, 0x2d45624):
  *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  *     __pyx_result = Node.__new__(__pyx_type)
  */
     __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_n_s_PickleError);
     __Pyx_GIVEREF(__pyx_n_s_PickleError);
     PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_PickleError);
@@ -5851,17 +7923,17 @@
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_t_1);
     __pyx_v___pyx_PickleError = __pyx_t_1;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
     /* "(tree fragment)":6
- *     if __pyx_checksum not in (0x357fa0f, 0x5f4daba, 0x391d535):
+ *     if __pyx_checksum not in (0xf2c96f8, 0x996f7e4, 0x2d45624):
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)             # <<<<<<<<<<<<<<
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)             # <<<<<<<<<<<<<<
  *     __pyx_result = Node.__new__(__pyx_type)
  *     if __pyx_state is not None:
  */
     __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
@@ -5886,23 +7958,23 @@
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __PYX_ERR(1, 6, __pyx_L1_error)
 
     /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x357fa0f, 0x5f4daba, 0x391d535):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0xf2c96f8, 0x996f7e4, 0x2d45624):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  */
   }
 
   /* "(tree fragment)":7
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  *     __pyx_result = Node.__new__(__pyx_type)             # <<<<<<<<<<<<<<
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  */
   __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_9multimcts_4mcts_Node), __pyx_n_s_new); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_5 = NULL;
@@ -5920,15 +7992,15 @@
   if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v___pyx_result = __pyx_t_4;
   __pyx_t_4 = 0;
 
   /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  *     __pyx_result = Node.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   __pyx_t_3 = (__pyx_v___pyx_state != Py_None);
   __pyx_t_2 = (__pyx_t_3 != 0);
@@ -5943,28 +8015,28 @@
  */
     if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
     __pyx_t_4 = __pyx_f_9multimcts_4mcts___pyx_unpickle_Node__set_state(((struct __pyx_obj_9multimcts_4mcts_Node *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 9, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
     /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  *     __pyx_result = Node.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   }
 
   /* "(tree fragment)":10
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result             # <<<<<<<<<<<<<<
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v___pyx_result);
   __pyx_r = __pyx_v___pyx_result;
   goto __pyx_L0;
 
   /* "(tree fragment)":1
@@ -5981,82 +8053,85 @@
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("multimcts.mcts.__pyx_unpickle_Node", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v___pyx_PickleError);
   __Pyx_XDECREF(__pyx_v___pyx_result);
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":11
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):
  */
 
 static PyObject *__pyx_f_9multimcts_4mcts___pyx_unpickle_Node__set_state(struct __pyx_obj_9multimcts_4mcts_Node *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   double __pyx_t_2;
-  std::string __pyx_t_3;
-  int __pyx_t_4;
-  std::map<std::string,double>  __pyx_t_5;
-  int __pyx_t_6;
+  int __pyx_t_3;
+  std::map<std::string,double>  __pyx_t_4;
+  int __pyx_t_5;
+  std::string __pyx_t_6;
   Py_ssize_t __pyx_t_7;
   int __pyx_t_8;
   int __pyx_t_9;
   PyObject *__pyx_t_10 = NULL;
   PyObject *__pyx_t_11 = NULL;
   PyObject *__pyx_t_12 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_unpickle_Node__set_state", 0);
+  __Pyx_TraceCall("__pyx_unpickle_Node__set_state", __pyx_f[1], 11, 0, __PYX_ERR(1, 11, __pyx_L1_error));
 
   /* "(tree fragment)":12
  *     return __pyx_result
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]             # <<<<<<<<<<<<<<
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):
- *         __pyx_result.__dict__.update(__pyx_state[14])
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]             # <<<<<<<<<<<<<<
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):
+ *         __pyx_result.__dict__.update(__pyx_state[16])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->avg_reward = __pyx_t_2;
+  __pyx_v___pyx_result->avg_rave_reward = __pyx_t_2;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_1);
-  __Pyx_GOTREF(__pyx_v___pyx_result->children);
-  __Pyx_DECREF(__pyx_v___pyx_result->children);
-  __pyx_v___pyx_result->children = __pyx_t_1;
-  __pyx_t_1 = 0;
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v___pyx_result->avg_reward = __pyx_t_2;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->cteam = __pyx_t_3;
+  __Pyx_GIVEREF(__pyx_t_1);
+  __Pyx_GOTREF(__pyx_v___pyx_result->children);
+  __Pyx_DECREF(__pyx_v___pyx_result->children);
+  __pyx_v___pyx_result->children = __pyx_t_1;
+  __pyx_t_1 = 0;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
@@ -6064,26 +8139,26 @@
   __pyx_v___pyx_result->invsqrt_visits = __pyx_t_2;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 4, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->is_fully_expanded = __pyx_t_4;
+  __pyx_v___pyx_result->is_fully_expanded = __pyx_t_3;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 5, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->is_terminal = __pyx_t_4;
+  __pyx_v___pyx_result->is_terminal = __pyx_t_3;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 6, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
@@ -6105,107 +8180,123 @@
   __pyx_t_1 = 0;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 8, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_4 = __pyx_convert_map_from_py_std_3a__3a_string__and_double(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v___pyx_result->rave_rewards = __pyx_t_4;
+  if (unlikely(__pyx_v___pyx_state == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
+    __PYX_ERR(1, 12, __pyx_L1_error)
+  }
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 9, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v___pyx_result->rave_visits = __pyx_t_5;
+  if (unlikely(__pyx_v___pyx_state == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
+    __PYX_ERR(1, 12, __pyx_L1_error)
+  }
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 10, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v___pyx_result->remaining_moves);
   __Pyx_DECREF(__pyx_v___pyx_result->remaining_moves);
   __pyx_v___pyx_result->remaining_moves = __pyx_t_1;
   __pyx_t_1 = 0;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 9, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 11, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __pyx_convert_map_from_py_std_3a__3a_string__and_double(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_4 = __pyx_convert_map_from_py_std_3a__3a_string__and_double(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->rewards = __pyx_t_5;
+  __pyx_v___pyx_result->rewards = __pyx_t_4;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 10, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 12, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v___pyx_result->sqrtlog_visits = __pyx_t_2;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 11, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 13, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v___pyx_result->state);
   __Pyx_DECREF(__pyx_v___pyx_result->state);
   __pyx_v___pyx_result->state = __pyx_t_1;
   __pyx_t_1 = 0;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 12, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 14, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_1);
-  __Pyx_GOTREF(__pyx_v___pyx_result->team);
-  __Pyx_DECREF(__pyx_v___pyx_result->team);
-  __pyx_v___pyx_result->team = __pyx_t_1;
-  __pyx_t_1 = 0;
+  __pyx_t_6 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v___pyx_result->team = __pyx_t_6;
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 13, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 15, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v___pyx_result->visits = __pyx_t_6;
+  __pyx_v___pyx_result->visits = __pyx_t_5;
 
   /* "(tree fragment)":13
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
- *         __pyx_result.__dict__.update(__pyx_state[14])
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
+ *         __pyx_result.__dict__.update(__pyx_state[16])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
     __PYX_ERR(1, 13, __pyx_L1_error)
   }
   __pyx_t_7 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
-  __pyx_t_8 = ((__pyx_t_7 > 14) != 0);
+  __pyx_t_8 = ((__pyx_t_7 > 16) != 0);
   if (__pyx_t_8) {
   } else {
-    __pyx_t_4 = __pyx_t_8;
+    __pyx_t_3 = __pyx_t_8;
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_8 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
   __pyx_t_9 = (__pyx_t_8 != 0);
-  __pyx_t_4 = __pyx_t_9;
+  __pyx_t_3 = __pyx_t_9;
   __pyx_L4_bool_binop_done:;
-  if (__pyx_t_4) {
+  if (__pyx_t_3) {
 
     /* "(tree fragment)":14
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):
- *         __pyx_result.__dict__.update(__pyx_state[14])             # <<<<<<<<<<<<<<
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):
+ *         __pyx_result.__dict__.update(__pyx_state[16])             # <<<<<<<<<<<<<<
  */
     __pyx_t_10 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_update); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_11);
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
     if (unlikely(__pyx_v___pyx_state == Py_None)) {
       PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
       __PYX_ERR(1, 14, __pyx_L1_error)
     }
-    __pyx_t_10 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 14, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 16, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __pyx_t_12 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_11))) {
       __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_11);
       if (likely(__pyx_t_12)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
         __Pyx_INCREF(__pyx_t_12);
@@ -6219,40 +8310,41 @@
     if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
     /* "(tree fragment)":13
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
- *         __pyx_result.__dict__.update(__pyx_state[14])
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
+ *         __pyx_result.__dict__.update(__pyx_state[16])
  */
   }
 
   /* "(tree fragment)":11
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_10);
   __Pyx_XDECREF(__pyx_t_11);
   __Pyx_XDECREF(__pyx_t_12);
   __Pyx_AddTraceback("multimcts.mcts.__pyx_unpickle_Node__set_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __pyx_unpickle_MCTS(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
@@ -6335,45 +8427,48 @@
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_9multimcts_4mcts_2__pyx_unpickle_MCTS(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_v___pyx_PickleError = 0;
   PyObject *__pyx_v___pyx_result = 0;
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
+  __Pyx_TraceFrameInit(__pyx_codeobj__15)
   __Pyx_RefNannySetupContext("__pyx_unpickle_MCTS", 0);
+  __Pyx_TraceCall("__pyx_unpickle_MCTS", __pyx_f[1], 1, 0, __PYX_ERR(1, 1, __pyx_L1_error));
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xc24480d, 0xdc6441b, 0x4ed5288):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0x8ae6b36, 0xb1de3b5, 0xdf19538):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  */
   __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__8, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__16, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
     /* "(tree fragment)":5
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xc24480d, 0xdc6441b, 0x4ed5288):
+ *     if __pyx_checksum not in (0x8ae6b36, 0xb1de3b5, 0xdf19538):
  *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  *     __pyx_result = MCTS.__new__(__pyx_type)
  */
     __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_n_s_PickleError);
     __Pyx_GIVEREF(__pyx_n_s_PickleError);
     PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_PickleError);
@@ -6384,17 +8479,17 @@
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_t_1);
     __pyx_v___pyx_PickleError = __pyx_t_1;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
     /* "(tree fragment)":6
- *     if __pyx_checksum not in (0xc24480d, 0xdc6441b, 0x4ed5288):
+ *     if __pyx_checksum not in (0x8ae6b36, 0xb1de3b5, 0xdf19538):
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)             # <<<<<<<<<<<<<<
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)             # <<<<<<<<<<<<<<
  *     __pyx_result = MCTS.__new__(__pyx_type)
  *     if __pyx_state is not None:
  */
     __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_0x_x_vs_0_2, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
@@ -6419,23 +8514,23 @@
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __PYX_ERR(1, 6, __pyx_L1_error)
 
     /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0xc24480d, 0xdc6441b, 0x4ed5288):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0x8ae6b36, 0xb1de3b5, 0xdf19538):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  */
   }
 
   /* "(tree fragment)":7
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  *     __pyx_result = MCTS.__new__(__pyx_type)             # <<<<<<<<<<<<<<
  *     if __pyx_state is not None:
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  */
   __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_9multimcts_4mcts_MCTS), __pyx_n_s_new); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_5 = NULL;
@@ -6453,15 +8548,15 @@
   if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v___pyx_result = __pyx_t_4;
   __pyx_t_4 = 0;
 
   /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  *     __pyx_result = MCTS.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   __pyx_t_3 = (__pyx_v___pyx_state != Py_None);
   __pyx_t_2 = (__pyx_t_3 != 0);
@@ -6476,28 +8571,28 @@
  */
     if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
     __pyx_t_4 = __pyx_f_9multimcts_4mcts___pyx_unpickle_MCTS__set_state(((struct __pyx_obj_9multimcts_4mcts_MCTS *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 9, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
     /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xc24480d, 0xdc6441b, 0x4ed5288) = (exploration_bias))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x8ae6b36, 0xb1de3b5, 0xdf19538) = (exploration_bias, rave_bias))" % __pyx_checksum)
  *     __pyx_result = MCTS.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   }
 
   /* "(tree fragment)":10
  *     if __pyx_state is not None:
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  *     return __pyx_result             # <<<<<<<<<<<<<<
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):
- *     __pyx_result.exploration_bias = __pyx_state[0]
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v___pyx_result);
   __pyx_r = __pyx_v___pyx_result;
   goto __pyx_L0;
 
   /* "(tree fragment)":1
@@ -6514,98 +8609,110 @@
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("multimcts.mcts.__pyx_unpickle_MCTS", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v___pyx_PickleError);
   __Pyx_XDECREF(__pyx_v___pyx_result);
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":11
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
- *     __pyx_result.exploration_bias = __pyx_state[0]
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):
  */
 
 static PyObject *__pyx_f_9multimcts_4mcts___pyx_unpickle_MCTS__set_state(struct __pyx_obj_9multimcts_4mcts_MCTS *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   double __pyx_t_2;
   int __pyx_t_3;
   Py_ssize_t __pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   PyObject *__pyx_t_9 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_unpickle_MCTS__set_state", 0);
+  __Pyx_TraceCall("__pyx_unpickle_MCTS__set_state", __pyx_f[1], 11, 0, __PYX_ERR(1, 11, __pyx_L1_error));
 
   /* "(tree fragment)":12
  *     return __pyx_result
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):
- *     __pyx_result.exploration_bias = __pyx_state[0]             # <<<<<<<<<<<<<<
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
- *         __pyx_result.__dict__.update(__pyx_state[1])
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]             # <<<<<<<<<<<<<<
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):
+ *         __pyx_result.__dict__.update(__pyx_state[2])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
     __PYX_ERR(1, 12, __pyx_L1_error)
   }
   __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v___pyx_result->exploration_bias = __pyx_t_2;
+  if (unlikely(__pyx_v___pyx_state == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
+    __PYX_ERR(1, 12, __pyx_L1_error)
+  }
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v___pyx_result->rave_bias = __pyx_t_2;
 
   /* "(tree fragment)":13
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):
- *     __pyx_result.exploration_bias = __pyx_state[0]
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
- *         __pyx_result.__dict__.update(__pyx_state[1])
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
+ *         __pyx_result.__dict__.update(__pyx_state[2])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
     __PYX_ERR(1, 13, __pyx_L1_error)
   }
   __pyx_t_4 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
-  __pyx_t_5 = ((__pyx_t_4 > 1) != 0);
+  __pyx_t_5 = ((__pyx_t_4 > 2) != 0);
   if (__pyx_t_5) {
   } else {
     __pyx_t_3 = __pyx_t_5;
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_5 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
   __pyx_t_6 = (__pyx_t_5 != 0);
   __pyx_t_3 = __pyx_t_6;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_3) {
 
     /* "(tree fragment)":14
- *     __pyx_result.exploration_bias = __pyx_state[0]
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
- *         __pyx_result.__dict__.update(__pyx_state[1])             # <<<<<<<<<<<<<<
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):
+ *         __pyx_result.__dict__.update(__pyx_state[2])             # <<<<<<<<<<<<<<
  */
     __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_update); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     if (unlikely(__pyx_v___pyx_state == Py_None)) {
       PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
       __PYX_ERR(1, 14, __pyx_L1_error)
     }
-    __pyx_t_7 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __pyx_t_9 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {
       __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);
       if (likely(__pyx_t_9)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
         __Pyx_INCREF(__pyx_t_9);
@@ -6619,60 +8726,63 @@
     if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
     /* "(tree fragment)":13
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):
- *     __pyx_result.exploration_bias = __pyx_state[0]
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
- *         __pyx_result.__dict__.update(__pyx_state[1])
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
+ *         __pyx_result.__dict__.update(__pyx_state[2])
  */
   }
 
   /* "(tree fragment)":11
  *         __pyx_unpickle_MCTS__set_state(<MCTS> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_MCTS__set_state(MCTS __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
- *     __pyx_result.exploration_bias = __pyx_state[0]
- *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
+ *     __pyx_result.exploration_bias = __pyx_state[0]; __pyx_result.rave_bias = __pyx_state[1]
+ *     if len(__pyx_state) > 2 and hasattr(__pyx_result, '__dict__'):
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_7);
   __Pyx_XDECREF(__pyx_t_8);
   __Pyx_XDECREF(__pyx_t_9);
   __Pyx_AddTraceback("multimcts.mcts.__pyx_unpickle_MCTS__set_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "string.to_py":31
  * 
  * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
  *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
  * cdef extern from *:
  */
 
 static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &__pyx_v_s) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_PyObject_string_to_py_std__in_string", 0);
+  __Pyx_TraceCall("__pyx_convert_PyObject_string_to_py_std__in_string", __pyx_f[1], 31, 0, __PYX_ERR(1, 31, __pyx_L1_error));
 
   /* "string.to_py":32
  * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):
  *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
  * cdef extern from *:
  *     cdef object __Pyx_PyUnicode_FromStringAndSize(const char*, size_t)
@@ -6695,34 +8805,37 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("string.to_py.__pyx_convert_PyObject_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "string.to_py":37
  * 
  * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
  *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
  * cdef extern from *:
  */
 
 static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &__pyx_v_s) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_PyUnicode_string_to_py_std__in_string", 0);
+  __Pyx_TraceCall("__pyx_convert_PyUnicode_string_to_py_std__in_string", __pyx_f[1], 37, 0, __PYX_ERR(1, 37, __pyx_L1_error));
 
   /* "string.to_py":38
  * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):
  *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
  * cdef extern from *:
  *     cdef object __Pyx_PyStr_FromStringAndSize(const char*, size_t)
@@ -6745,34 +8858,37 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("string.to_py.__pyx_convert_PyUnicode_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "string.to_py":43
  * 
  * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
  *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
  * cdef extern from *:
  */
 
 static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &__pyx_v_s) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_PyStr_string_to_py_std__in_string", 0);
+  __Pyx_TraceCall("__pyx_convert_PyStr_string_to_py_std__in_string", __pyx_f[1], 43, 0, __PYX_ERR(1, 43, __pyx_L1_error));
 
   /* "string.to_py":44
  * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):
  *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
  * cdef extern from *:
  *     cdef object __Pyx_PyBytes_FromStringAndSize(const char*, size_t)
@@ -6795,34 +8911,37 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("string.to_py.__pyx_convert_PyStr_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "string.to_py":49
  * 
  * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
  *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
  * cdef extern from *:
  */
 
 static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &__pyx_v_s) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_PyBytes_string_to_py_std__in_string", 0);
+  __Pyx_TraceCall("__pyx_convert_PyBytes_string_to_py_std__in_string", __pyx_f[1], 49, 0, __PYX_ERR(1, 49, __pyx_L1_error));
 
   /* "string.to_py":50
  * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):
  *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
  * cdef extern from *:
  *     cdef object __Pyx_PyByteArray_FromStringAndSize(const char*, size_t)
@@ -6845,34 +8964,37 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("string.to_py.__pyx_convert_PyBytes_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "string.to_py":55
  * 
  * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
  *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &__pyx_v_s) {
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_PyByteArray_string_to_py_std__in_string", 0);
+  __Pyx_TraceCall("__pyx_convert_PyByteArray_string_to_py_std__in_string", __pyx_f[1], 55, 0, __PYX_ERR(1, 55, __pyx_L1_error));
 
   /* "string.to_py":56
  * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
  * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):
  *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
  * 
  */
@@ -6894,79 +9016,15 @@
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_AddTraceback("string.to_py.__pyx_convert_PyByteArray_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "string.from_py":13
- * 
- * @cname("__pyx_convert_string_from_py_std__in_string")
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- */
-
-static std::string __pyx_convert_string_from_py_std__in_string(PyObject *__pyx_v_o) {
-  Py_ssize_t __pyx_v_length;
-  char const *__pyx_v_data;
-  std::string __pyx_r;
-  __Pyx_RefNannyDeclarations
-  char const *__pyx_t_1;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_string_from_py_std__in_string", 0);
-
-  /* "string.from_py":14
- * @cname("__pyx_convert_string_from_py_std__in_string")
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
- *     cdef Py_ssize_t length = 0             # <<<<<<<<<<<<<<
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- *     return string(data, length)
- */
-  __pyx_v_length = 0;
-
-  /* "string.from_py":15
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
- *     return string(data, length)
- * 
- */
-  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == ((char const *)NULL))) __PYX_ERR(1, 15, __pyx_L1_error)
-  __pyx_v_data = __pyx_t_1;
-
-  /* "string.from_py":16
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- *     return string(data, length)             # <<<<<<<<<<<<<<
- * 
- * 
- */
-  __pyx_r = std::string(__pyx_v_data, __pyx_v_length);
-  goto __pyx_L0;
-
-  /* "string.from_py":13
- * 
- * @cname("__pyx_convert_string_from_py_std__in_string")
- * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
- *     cdef Py_ssize_t length = 0
- *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("string.from_py.__pyx_convert_string_from_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_pretend_to_initialize(&__pyx_r);
-  __pyx_L0:;
+  __Pyx_TraceReturn(__pyx_r, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "map.to_py":201
  * 
  * @cname("__pyx_convert_map_to_py_std_3a__3a_string____double")
@@ -6976,22 +9034,24 @@
  */
 
 static PyObject *__pyx_convert_map_to_py_std_3a__3a_string____double(std::map<std::string,double>  const &__pyx_v_s) {
   PyObject *__pyx_v_o = NULL;
   std::map<std::string,double> ::value_type const *__pyx_v_key_value;
   std::map<std::string,double> ::const_iterator __pyx_v_iter;
   PyObject *__pyx_r = NULL;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_map_to_py_std_3a__3a_string____double", 0);
+  __Pyx_TraceCall("__pyx_convert_map_to_py_std_3a__3a_string____double", __pyx_f[1], 201, 0, __PYX_ERR(1, 201, __pyx_L1_error));
 
   /* "map.to_py":202
  * @cname("__pyx_convert_map_to_py_std_3a__3a_string____double")
  * cdef object __pyx_convert_map_to_py_std_3a__3a_string____double(const map[X,Y]& s):
  *     o = {}             # <<<<<<<<<<<<<<
  *     cdef const map[X,Y].value_type *key_value
  *     cdef map[X,Y].const_iterator iter = s.begin()
@@ -7080,14 +9140,83 @@
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("map.to_py.__pyx_convert_map_to_py_std_3a__3a_string____double", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_o);
   __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_TraceReturn(__pyx_r, 0);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "string.from_py":13
+ * 
+ * @cname("__pyx_convert_string_from_py_std__in_string")
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ */
+
+static std::string __pyx_convert_string_from_py_std__in_string(PyObject *__pyx_v_o) {
+  Py_ssize_t __pyx_v_length;
+  char const *__pyx_v_data;
+  std::string __pyx_r;
+  __Pyx_TraceDeclarations
+  __Pyx_RefNannyDeclarations
+  char const *__pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__pyx_convert_string_from_py_std__in_string", 0);
+  __Pyx_TraceCall("__pyx_convert_string_from_py_std__in_string", __pyx_f[1], 13, 0, __PYX_ERR(1, 13, __pyx_L1_error));
+
+  /* "string.from_py":14
+ * @cname("__pyx_convert_string_from_py_std__in_string")
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
+ *     cdef Py_ssize_t length = 0             # <<<<<<<<<<<<<<
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ *     return string(data, length)
+ */
+  __pyx_v_length = 0;
+
+  /* "string.from_py":15
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
+ *     return string(data, length)
+ * 
+ */
+  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == ((char const *)NULL))) __PYX_ERR(1, 15, __pyx_L1_error)
+  __pyx_v_data = __pyx_t_1;
+
+  /* "string.from_py":16
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ *     return string(data, length)             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_r = std::string(__pyx_v_data, __pyx_v_length);
+  goto __pyx_L0;
+
+  /* "string.from_py":13
+ * 
+ * @cname("__pyx_convert_string_from_py_std__in_string")
+ * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
+ *     cdef Py_ssize_t length = 0
+ *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("string.from_py.__pyx_convert_string_from_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_pretend_to_initialize(&__pyx_r);
+  __pyx_L0:;
+  __Pyx_TraceReturn(Py_None, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "map.from_py":174
  * 
  * @cname("__pyx_convert_map_from_py_std_3a__3a_string__and_double")
@@ -7098,28 +9227,30 @@
 
 static std::map<std::string,double>  __pyx_convert_map_from_py_std_3a__3a_string__and_double(PyObject *__pyx_v_o) {
   PyObject *__pyx_v_d = 0;
   std::map<std::string,double>  __pyx_v_m;
   PyObject *__pyx_v_key = NULL;
   PyObject *__pyx_v_value = NULL;
   std::map<std::string,double>  __pyx_r;
+  __Pyx_TraceDeclarations
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_t_7;
   std::string __pyx_t_8;
   double __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_convert_map_from_py_std_3a__3a_string__and_double", 0);
+  __Pyx_TraceCall("__pyx_convert_map_from_py_std_3a__3a_string__and_double", __pyx_f[1], 174, 0, __PYX_ERR(1, 174, __pyx_L1_error));
 
   /* "map.from_py":175
  * @cname("__pyx_convert_map_from_py_std_3a__3a_string__and_double")
  * cdef map[X,Y] __pyx_convert_map_from_py_std_3a__3a_string__and_double(object o) except *:
  *     cdef dict d = o             # <<<<<<<<<<<<<<
  *     cdef map[X,Y] m
  *     for key, value in d.iteritems():
@@ -7196,14 +9327,15 @@
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("map.from_py.__pyx_convert_map_from_py_std_3a__3a_string__and_double", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_pretend_to_initialize(&__pyx_r);
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_d);
   __Pyx_XDECREF(__pyx_v_key);
   __Pyx_XDECREF(__pyx_v_value);
+  __Pyx_TraceReturn(Py_None, 0);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 static struct __pyx_vtabstruct_9multimcts_4mcts_Node __pyx_vtable_9multimcts_4mcts_Node;
 
 static PyObject *__pyx_tp_new_9multimcts_4mcts_Node(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_obj_9multimcts_4mcts_Node *p;
@@ -7212,112 +9344,107 @@
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
   p = ((struct __pyx_obj_9multimcts_4mcts_Node *)o);
   p->__pyx_vtab = __pyx_vtabptr_9multimcts_4mcts_Node;
-  new((void*)&(p->cteam)) std::string();
+  new((void*)&(p->team)) std::string();
   new((void*)&(p->rewards)) std::map<std::string,double> ();
+  new((void*)&(p->rave_rewards)) std::map<std::string,double> ();
   p->state = Py_None; Py_INCREF(Py_None);
   p->move = Py_None; Py_INCREF(Py_None);
-  p->team = Py_None; Py_INCREF(Py_None);
-  p->parent = ((struct __pyx_obj_9multimcts_4mcts_Node *)Py_None); Py_INCREF(Py_None);
   p->children = Py_None; Py_INCREF(Py_None);
   p->remaining_moves = Py_None; Py_INCREF(Py_None);
+  p->parent = ((struct __pyx_obj_9multimcts_4mcts_Node *)Py_None); Py_INCREF(Py_None);
   return o;
 }
 
 static void __pyx_tp_dealloc_9multimcts_4mcts_Node(PyObject *o) {
   struct __pyx_obj_9multimcts_4mcts_Node *p = (struct __pyx_obj_9multimcts_4mcts_Node *)o;
   #if CYTHON_USE_TP_FINALIZE
   if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !__Pyx_PyObject_GC_IsFinalized(o)) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
-  __Pyx_call_destructor(p->cteam);
+  __Pyx_call_destructor(p->team);
   __Pyx_call_destructor(p->rewards);
+  __Pyx_call_destructor(p->rave_rewards);
   Py_CLEAR(p->state);
   Py_CLEAR(p->move);
-  Py_CLEAR(p->team);
-  Py_CLEAR(p->parent);
   Py_CLEAR(p->children);
   Py_CLEAR(p->remaining_moves);
+  Py_CLEAR(p->parent);
   (*Py_TYPE(o)->tp_free)(o);
 }
 
 static int __pyx_tp_traverse_9multimcts_4mcts_Node(PyObject *o, visitproc v, void *a) {
   int e;
   struct __pyx_obj_9multimcts_4mcts_Node *p = (struct __pyx_obj_9multimcts_4mcts_Node *)o;
   if (p->state) {
     e = (*v)(p->state, a); if (e) return e;
   }
   if (p->move) {
     e = (*v)(p->move, a); if (e) return e;
   }
-  if (p->team) {
-    e = (*v)(p->team, a); if (e) return e;
-  }
-  if (p->parent) {
-    e = (*v)(((PyObject *)p->parent), a); if (e) return e;
-  }
   if (p->children) {
     e = (*v)(p->children, a); if (e) return e;
   }
   if (p->remaining_moves) {
     e = (*v)(p->remaining_moves, a); if (e) return e;
   }
+  if (p->parent) {
+    e = (*v)(((PyObject *)p->parent), a); if (e) return e;
+  }
   return 0;
 }
 
 static int __pyx_tp_clear_9multimcts_4mcts_Node(PyObject *o) {
   PyObject* tmp;
   struct __pyx_obj_9multimcts_4mcts_Node *p = (struct __pyx_obj_9multimcts_4mcts_Node *)o;
   tmp = ((PyObject*)p->state);
   p->state = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
   tmp = ((PyObject*)p->move);
   p->move = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
-  tmp = ((PyObject*)p->team);
-  p->team = Py_None; Py_INCREF(Py_None);
-  Py_XDECREF(tmp);
-  tmp = ((PyObject*)p->parent);
-  p->parent = ((struct __pyx_obj_9multimcts_4mcts_Node *)Py_None); Py_INCREF(Py_None);
-  Py_XDECREF(tmp);
   tmp = ((PyObject*)p->children);
   p->children = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
   tmp = ((PyObject*)p->remaining_moves);
   p->remaining_moves = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
+  tmp = ((PyObject*)p->parent);
+  p->parent = ((struct __pyx_obj_9multimcts_4mcts_Node *)Py_None); Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
   return 0;
 }
 
-static PyObject *__pyx_getprop_9multimcts_4mcts_4Node_state(PyObject *o, CYTHON_UNUSED void *x) {
-  return __pyx_pw_9multimcts_4mcts_4Node_5state_1__get__(o);
-}
-
-static PyObject *__pyx_getprop_9multimcts_4mcts_4Node_rewards(PyObject *o, CYTHON_UNUSED void *x) {
-  return __pyx_pw_9multimcts_4mcts_4Node_7rewards_1__get__(o);
-}
-
 static PyMethodDef __pyx_methods_9multimcts_4mcts_Node[] = {
-  {"__reduce_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_3__reduce_cython__, METH_NOARGS, 0},
-  {"__setstate_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_5__setstate_cython__, METH_O, 0},
+  {"get_state", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_3get_state, METH_NOARGS, 0},
+  {"get_team", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_5get_team, METH_NOARGS, 0},
+  {"get_move", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_7get_move, METH_NOARGS, 0},
+  {"get_parent", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_9get_parent, METH_NOARGS, 0},
+  {"get_children", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_11get_children, METH_NOARGS, 0},
+  {"get_visits", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_13get_visits, METH_NOARGS, 0},
+  {"get_rewards", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_15get_rewards, METH_NOARGS, 0},
+  {"get_avg_reward", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_17get_avg_reward, METH_NOARGS, 0},
+  {"get_rave_visits", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_19get_rave_visits, METH_NOARGS, 0},
+  {"get_rave_rewards", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_21get_rave_rewards, METH_NOARGS, 0},
+  {"get_avg_rave_reward", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_23get_avg_rave_reward, METH_NOARGS, 0},
+  {"uncertainty", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_25uncertainty, METH_O, 0},
+  {"ucb", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_27ucb, METH_O, __pyx_doc_9multimcts_4mcts_4Node_26ucb},
+  {"rave_beta", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_29rave_beta, METH_O, __pyx_doc_9multimcts_4mcts_4Node_28rave_beta},
+  {"score", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9multimcts_4mcts_4Node_31score, METH_VARARGS|METH_KEYWORDS, 0},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_33__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4Node_35__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
-static struct PyGetSetDef __pyx_getsets_9multimcts_4mcts_Node[] = {
-  {(char *)"state", __pyx_getprop_9multimcts_4mcts_4Node_state, 0, (char *)0, 0},
-  {(char *)"rewards", __pyx_getprop_9multimcts_4mcts_4Node_rewards, 0, (char *)0, 0},
-  {0, 0, 0, 0, 0}
-};
-
 static PyTypeObject __pyx_type_9multimcts_4mcts_Node = {
   PyVarObject_HEAD_INIT(0, 0)
   "multimcts.mcts.Node", /*tp_name*/
   sizeof(struct __pyx_obj_9multimcts_4mcts_Node), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_9multimcts_4mcts_Node, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
@@ -7341,24 +9468,24 @@
   0, /*tp_hash*/
   0, /*tp_call*/
   0, /*tp_str*/
   0, /*tp_getattro*/
   0, /*tp_setattro*/
   0, /*tp_as_buffer*/
   Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
-  "Represents a game state node in the MCTS search tree.\n    Args:\n        state (GameState): The game state at the current node.\n        parent (Node): The parent of the current node in the search tree.\n        move (Move): The move that was played from the parent node to get to this node.\n    Attributes:\n        children (List[Node]): The child nodes of the current node. These represent legal moves that have been visited.\n        visits (int): The number of times the node has been visited.\n        rewards (dict): All teams' rewards obtained from simulations through the node. Keys are teams; values are rewards.\n        is_terminal (bool): Whether the node represents a terminal state.\n        is_fully_expanded (bool): Whether all children of the node have been visited.\n        remaining_moves (list): A list of moves that have not yet been tried.\n    ", /*tp_doc*/
+  "Represents a game state node in the MCTS search tree.\n    Args:\n        state (GameState): The game state at the current node.\n        parent (Node): The parent of the current node in the search tree.\n        move (Move): The move that was played from the parent node to get to this node.\n    Attributes:\n        children (Dict[Move,Node]): The child nodes of the current node. These represent legal moves that have been visited.\n        visits (int): The number of times the node has been visited.\n        rewards (dict): All teams' rewards obtained from simulations through the node. Keys are teams; values are rewards.\n        is_terminal (bool): Whether the node represents a terminal state.\n        is_fully_expanded (bool): Whether all children of the node have been visited.\n        remaining_moves (list): A list of moves that have not yet been tried.\n    ", /*tp_doc*/
   __pyx_tp_traverse_9multimcts_4mcts_Node, /*tp_traverse*/
   __pyx_tp_clear_9multimcts_4mcts_Node, /*tp_clear*/
   0, /*tp_richcompare*/
   0, /*tp_weaklistoffset*/
   0, /*tp_iter*/
   0, /*tp_iternext*/
   __pyx_methods_9multimcts_4mcts_Node, /*tp_methods*/
   0, /*tp_members*/
-  __pyx_getsets_9multimcts_4mcts_Node, /*tp_getset*/
+  0, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
   0, /*tp_dictoffset*/
   __pyx_pw_9multimcts_4mcts_4Node_1__init__, /*tp_init*/
   0, /*tp_alloc*/
@@ -7381,27 +9508,23 @@
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
   #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
-static struct __pyx_vtabstruct_9multimcts_4mcts_MCTS __pyx_vtable_9multimcts_4mcts_MCTS;
 
 static PyObject *__pyx_tp_new_9multimcts_4mcts_MCTS(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
-  struct __pyx_obj_9multimcts_4mcts_MCTS *p;
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  p = ((struct __pyx_obj_9multimcts_4mcts_MCTS *)o);
-  p->__pyx_vtab = __pyx_vtabptr_9multimcts_4mcts_MCTS;
   return o;
 }
 
 static void __pyx_tp_dealloc_9multimcts_4mcts_MCTS(PyObject *o) {
   #if CYTHON_USE_TP_FINALIZE
   if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !__Pyx_PyObject_GC_IsFinalized(o))) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
@@ -7410,23 +9533,28 @@
   (*Py_TYPE(o)->tp_free)(o);
 }
 
 static PyObject *__pyx_getprop_9multimcts_4mcts_4MCTS_exploration_bias(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_9multimcts_4mcts_4MCTS_16exploration_bias_1__get__(o);
 }
 
+static PyObject *__pyx_getprop_9multimcts_4mcts_4MCTS_rave_bias(PyObject *o, CYTHON_UNUSED void *x) {
+  return __pyx_pw_9multimcts_4mcts_4MCTS_9rave_bias_1__get__(o);
+}
+
 static PyMethodDef __pyx_methods_9multimcts_4mcts_MCTS[] = {
   {"search", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9multimcts_4mcts_4MCTS_3search, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9multimcts_4mcts_4MCTS_2search},
   {"__reduce_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4MCTS_5__reduce_cython__, METH_NOARGS, 0},
   {"__setstate_cython__", (PyCFunction)__pyx_pw_9multimcts_4mcts_4MCTS_7__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_9multimcts_4mcts_MCTS[] = {
   {(char *)"exploration_bias", __pyx_getprop_9multimcts_4mcts_4MCTS_exploration_bias, 0, (char *)0, 0},
+  {(char *)"rave_bias", __pyx_getprop_9multimcts_4mcts_4MCTS_rave_bias, 0, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type_9multimcts_4mcts_MCTS = {
   PyVarObject_HEAD_INIT(0, 0)
   "multimcts.mcts.MCTS", /*tp_name*/
   sizeof(struct __pyx_obj_9multimcts_4mcts_MCTS), /*tp_basicsize*/
@@ -7540,28 +9668,29 @@
     #define CYTHON_SMALL_CODE __attribute__((cold))
 #else
     #define CYTHON_SMALL_CODE
 #endif
 #endif
 
 static __Pyx_StringTabEntry __pyx_string_tab[] = {
-  {&__pyx_n_s_Any, __pyx_k_Any, sizeof(__pyx_k_Any), 0, 0, 1, 1},
+  {&__pyx_kp_u_Could_not_determine_terminal_tea, __pyx_k_Could_not_determine_terminal_tea, sizeof(__pyx_k_Could_not_determine_terminal_tea), 0, 1, 0, 0},
   {&__pyx_n_s_Dict, __pyx_k_Dict, sizeof(__pyx_k_Dict), 0, 0, 1, 1},
   {&__pyx_n_s_GameState, __pyx_k_GameState, sizeof(__pyx_k_GameState), 0, 0, 1, 1},
   {&__pyx_n_u_GameState, __pyx_k_GameState, sizeof(__pyx_k_GameState), 0, 1, 0, 1},
   {&__pyx_n_s_GameState_get_current_team, __pyx_k_GameState_get_current_team, sizeof(__pyx_k_GameState_get_current_team), 0, 0, 1, 1},
   {&__pyx_n_s_GameState_get_legal_moves, __pyx_k_GameState_get_legal_moves, sizeof(__pyx_k_GameState_get_legal_moves), 0, 0, 1, 1},
   {&__pyx_n_s_GameState_get_reward, __pyx_k_GameState_get_reward, sizeof(__pyx_k_GameState_get_reward), 0, 0, 1, 1},
   {&__pyx_n_s_GameState_is_terminal, __pyx_k_GameState_is_terminal, sizeof(__pyx_k_GameState_is_terminal), 0, 0, 1, 1},
   {&__pyx_n_s_GameState_make_move, __pyx_k_GameState_make_move, sizeof(__pyx_k_GameState_make_move), 0, 0, 1, 1},
   {&__pyx_kp_u_GameState_must_implement_get_cur, __pyx_k_GameState_must_implement_get_cur, sizeof(__pyx_k_GameState_must_implement_get_cur), 0, 1, 0, 0},
   {&__pyx_kp_u_GameState_must_implement_get_leg, __pyx_k_GameState_must_implement_get_leg, sizeof(__pyx_k_GameState_must_implement_get_leg), 0, 1, 0, 0},
   {&__pyx_kp_u_GameState_must_implement_get_rew, __pyx_k_GameState_must_implement_get_rew, sizeof(__pyx_k_GameState_must_implement_get_rew), 0, 1, 0, 0},
   {&__pyx_kp_u_GameState_must_implement_is_term, __pyx_k_GameState_must_implement_is_term, sizeof(__pyx_k_GameState_must_implement_is_term), 0, 1, 0, 0},
   {&__pyx_kp_u_GameState_must_implement_make_mo, __pyx_k_GameState_must_implement_make_mo, sizeof(__pyx_k_GameState_must_implement_make_mo), 0, 1, 0, 0},
+  {&__pyx_n_s_Hashable, __pyx_k_Hashable, sizeof(__pyx_k_Hashable), 0, 0, 1, 1},
   {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
   {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0_2, __pyx_k_Incompatible_checksums_0x_x_vs_0_2, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0_2), 0, 0, 1, 0},
   {&__pyx_kp_u_Invalid_return_type, __pyx_k_Invalid_return_type, sizeof(__pyx_k_Invalid_return_type), 0, 1, 0, 0},
   {&__pyx_n_s_List, __pyx_k_List, sizeof(__pyx_k_List), 0, 0, 1, 1},
   {&__pyx_n_s_MCTS, __pyx_k_MCTS, sizeof(__pyx_k_MCTS), 0, 0, 1, 1},
   {&__pyx_n_s_Move, __pyx_k_Move, sizeof(__pyx_k_Move), 0, 0, 1, 1},
   {&__pyx_n_s_Node, __pyx_k_Node, sizeof(__pyx_k_Node), 0, 0, 1, 1},
@@ -7569,40 +9698,39 @@
   {&__pyx_n_s_NotImplementedError, __pyx_k_NotImplementedError, sizeof(__pyx_k_NotImplementedError), 0, 0, 1, 1},
   {&__pyx_kp_u_One_or_more_of_max_time_max_iter, __pyx_k_One_or_more_of_max_time_max_iter, sizeof(__pyx_k_One_or_more_of_max_time_max_iter), 0, 1, 0, 0},
   {&__pyx_n_s_PickleError, __pyx_k_PickleError, sizeof(__pyx_k_PickleError), 0, 0, 1, 1},
   {&__pyx_n_s_Rewards, __pyx_k_Rewards, sizeof(__pyx_k_Rewards), 0, 0, 1, 1},
   {&__pyx_n_s_Team, __pyx_k_Team, sizeof(__pyx_k_Team), 0, 0, 1, 1},
   {&__pyx_n_s_Union, __pyx_k_Union, sizeof(__pyx_k_Union), 0, 0, 1, 1},
   {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
-  {&__pyx_n_s_append, __pyx_k_append, sizeof(__pyx_k_append), 0, 0, 1, 1},
   {&__pyx_n_s_choice, __pyx_k_choice, sizeof(__pyx_k_choice), 0, 0, 1, 1},
   {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
   {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
   {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
   {&__pyx_n_s_exploration_bias, __pyx_k_exploration_bias, sizeof(__pyx_k_exploration_bias), 0, 0, 1, 1},
   {&__pyx_n_s_get_current_team, __pyx_k_get_current_team, sizeof(__pyx_k_get_current_team), 0, 0, 1, 1},
   {&__pyx_n_s_get_legal_moves, __pyx_k_get_legal_moves, sizeof(__pyx_k_get_legal_moves), 0, 0, 1, 1},
   {&__pyx_n_s_get_reward, __pyx_k_get_reward, sizeof(__pyx_k_get_reward), 0, 0, 1, 1},
   {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
-  {&__pyx_n_s_heuristic, __pyx_k_heuristic, sizeof(__pyx_k_heuristic), 0, 0, 1, 1},
   {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
   {&__pyx_n_s_is_terminal, __pyx_k_is_terminal, sizeof(__pyx_k_is_terminal), 0, 0, 1, 1},
+  {&__pyx_n_s_items, __pyx_k_items, sizeof(__pyx_k_items), 0, 0, 1, 1},
   {&__pyx_n_s_iteritems, __pyx_k_iteritems, sizeof(__pyx_k_iteritems), 0, 0, 1, 1},
-  {&__pyx_n_s_lower, __pyx_k_lower, sizeof(__pyx_k_lower), 0, 0, 1, 1},
+  {&__pyx_n_s_keys, __pyx_k_keys, sizeof(__pyx_k_keys), 0, 0, 1, 1},
   {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
   {&__pyx_n_s_make_move, __pyx_k_make_move, sizeof(__pyx_k_make_move), 0, 0, 1, 1},
   {&__pyx_n_s_max_iterations, __pyx_k_max_iterations, sizeof(__pyx_k_max_iterations), 0, 0, 1, 1},
   {&__pyx_n_s_max_time, __pyx_k_max_time, sizeof(__pyx_k_max_time), 0, 0, 1, 1},
   {&__pyx_n_s_metaclass, __pyx_k_metaclass, sizeof(__pyx_k_metaclass), 0, 0, 1, 1},
   {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
   {&__pyx_n_s_move, __pyx_k_move, sizeof(__pyx_k_move), 0, 0, 1, 1},
   {&__pyx_n_u_move, __pyx_k_move, sizeof(__pyx_k_move), 0, 1, 0, 1},
   {&__pyx_n_s_multimcts_mcts, __pyx_k_multimcts_mcts, sizeof(__pyx_k_multimcts_mcts), 0, 0, 1, 1},
   {&__pyx_kp_s_multimcts_mcts_pyx, __pyx_k_multimcts_mcts_pyx, sizeof(__pyx_k_multimcts_mcts_pyx), 0, 0, 1, 0},
-  {&__pyx_kp_u_must_be_one_of, __pyx_k_must_be_one_of, sizeof(__pyx_k_must_be_one_of), 0, 1, 0, 0},
+  {&__pyx_kp_u_must_be_one_of_state_move_node, __pyx_k_must_be_one_of_state_move_node, sizeof(__pyx_k_must_be_one_of_state_move_node), 0, 1, 0, 0},
   {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
   {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
   {&__pyx_n_u_node, __pyx_k_node, sizeof(__pyx_k_node), 0, 1, 0, 1},
   {&__pyx_n_s_parent, __pyx_k_parent, sizeof(__pyx_k_parent), 0, 0, 1, 1},
   {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
   {&__pyx_n_s_pop, __pyx_k_pop, sizeof(__pyx_k_pop), 0, 0, 1, 1},
   {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
@@ -7612,35 +9740,43 @@
   {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_unpickle_MCTS, __pyx_k_pyx_unpickle_MCTS, sizeof(__pyx_k_pyx_unpickle_MCTS), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_unpickle_Node, __pyx_k_pyx_unpickle_Node, sizeof(__pyx_k_pyx_unpickle_Node), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
   {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
   {&__pyx_n_s_random, __pyx_k_random, sizeof(__pyx_k_random), 0, 0, 1, 1},
+  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
+  {&__pyx_n_s_rave_beta, __pyx_k_rave_beta, sizeof(__pyx_k_rave_beta), 0, 0, 1, 1},
+  {&__pyx_n_s_rave_bias, __pyx_k_rave_bias, sizeof(__pyx_k_rave_bias), 0, 0, 1, 1},
   {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
   {&__pyx_n_s_return, __pyx_k_return, sizeof(__pyx_k_return), 0, 0, 1, 1},
   {&__pyx_n_s_return_type, __pyx_k_return_type, sizeof(__pyx_k_return_type), 0, 0, 1, 1},
+  {&__pyx_n_s_score, __pyx_k_score, sizeof(__pyx_k_score), 0, 0, 1, 1},
   {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
   {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
   {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
   {&__pyx_n_s_shuffle, __pyx_k_shuffle, sizeof(__pyx_k_shuffle), 0, 0, 1, 1},
   {&__pyx_n_s_state, __pyx_k_state, sizeof(__pyx_k_state), 0, 0, 1, 1},
   {&__pyx_n_u_state, __pyx_k_state, sizeof(__pyx_k_state), 0, 1, 0, 1},
   {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
   {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
   {&__pyx_n_s_time, __pyx_k_time, sizeof(__pyx_k_time), 0, 0, 1, 1},
   {&__pyx_n_s_typing, __pyx_k_typing, sizeof(__pyx_k_typing), 0, 0, 1, 1},
+  {&__pyx_n_s_ucb, __pyx_k_ucb, sizeof(__pyx_k_ucb), 0, 0, 1, 1},
+  {&__pyx_n_s_uncertainty, __pyx_k_uncertainty, sizeof(__pyx_k_uncertainty), 0, 0, 1, 1},
   {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
+  {&__pyx_n_s_values, __pyx_k_values, sizeof(__pyx_k_values), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
   __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s_NotImplementedError); if (!__pyx_builtin_NotImplementedError) __PYX_ERR(0, 24, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 162, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 250, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 348, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
@@ -7649,177 +9785,188 @@
   /* "multimcts/mcts.pyx":24
  *     def get_current_team(self) -> Team:
  *         """The identifier of the current player's team."""
  *         raise NotImplementedError("GameState must implement get_current_team.")             # <<<<<<<<<<<<<<
  * 
  *     def get_legal_moves(self) -> List[Move]:
  */
-  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_cur); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 24, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple_);
-  __Pyx_GIVEREF(__pyx_tuple_);
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_cur); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 24, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__2);
+  __Pyx_GIVEREF(__pyx_tuple__2);
 
   /* "multimcts/mcts.pyx":28
  *     def get_legal_moves(self) -> List[Move]:
  *         """List of all legal moves from this state."""
  *         raise NotImplementedError("GameState must implement get_legal_moves.")             # <<<<<<<<<<<<<<
  * 
  *     def make_move(self, move:Move) -> 'GameState':
  */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_leg); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 28, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__2);
-  __Pyx_GIVEREF(__pyx_tuple__2);
+  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_leg); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 28, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__4);
+  __Pyx_GIVEREF(__pyx_tuple__4);
 
   /* "multimcts/mcts.pyx":34
  *         Note: The current state (self) should NOT be modified. Rather, modify a copy of it.
  *         """
  *         raise NotImplementedError("GameState must implement make_move.")             # <<<<<<<<<<<<<<
  * 
  *     def is_terminal(self) -> bool:
  */
-  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_make_mo); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 34, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__3);
-  __Pyx_GIVEREF(__pyx_tuple__3);
+  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_make_mo); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 34, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__6);
+  __Pyx_GIVEREF(__pyx_tuple__6);
 
   /* "multimcts/mcts.pyx":38
  *     def is_terminal(self) -> bool:
  *         """Is the game over?"""
  *         raise NotImplementedError("GameState must implement is_terminal.")             # <<<<<<<<<<<<<<
  * 
  *     def get_reward(self) -> Union[float,Rewards]:
  */
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_is_term); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 38, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__4);
-  __Pyx_GIVEREF(__pyx_tuple__4);
+  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_is_term); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 38, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__8);
+  __Pyx_GIVEREF(__pyx_tuple__8);
 
   /* "multimcts/mcts.pyx":46
  *         Note: This method is only called on terminal states.
  *         """
  *         raise NotImplementedError("GameState must implement get_reward.")             # <<<<<<<<<<<<<<
  * 
- * 
+ *     '''#.WIP
  */
-  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_rew); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 46, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__5);
-  __Pyx_GIVEREF(__pyx_tuple__5);
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_u_GameState_must_implement_get_rew); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 46, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__10);
+  __Pyx_GIVEREF(__pyx_tuple__10);
 
-  /* "multimcts/mcts.pyx":165
- * 
+  /* "multimcts/mcts.pyx":250
+ *                 terminal_team = prev_state.get_current_team()
+ *             else:
+ *                 raise ValueError("Could not determine terminal team during simulation.")             # <<<<<<<<<<<<<<
+ *             reward = {terminal_team: reward}
+ *         cdef map[string,double] crewards = map[string,double]()
+ */
+  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_u_Could_not_determine_terminal_tea); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 250, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__11);
+  __Pyx_GIVEREF(__pyx_tuple__11);
+
+  /* "multimcts/mcts.pyx":292
+ *         """
  *         if max_time is None and max_iterations is None:
- *             raise ValueError("One or more of max_time/max_iterations is required.")             # <<<<<<<<<<<<<<
+ *             raise ValueError('One or more of max_time/max_iterations is required.')             # <<<<<<<<<<<<<<
  * 
- *         node = Node(state)
+ *         if return_type not in {'state','move','node'}:
  */
-  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_u_One_or_more_of_max_time_max_iter); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 165, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__6);
-  __Pyx_GIVEREF(__pyx_tuple__6);
+  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_u_One_or_more_of_max_time_max_iter); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__12);
+  __Pyx_GIVEREF(__pyx_tuple__12);
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum not in (0x357fa0f, 0x5f4daba, 0x391d535):             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0xf2c96f8, 0x996f7e4, 0x2d45624):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0x357fa0f, 0x5f4daba, 0x391d535) = (avg_reward, children, cteam, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xf2c96f8, 0x996f7e4, 0x2d45624) = (avg_rave_reward, avg_reward, children, invsqrt_visits, is_fully_expanded, is_terminal, move, parent, rave_rewards, rave_visits, remaining_moves, rewards, sqrtlog_visits, state, team, visits))" % __pyx_checksum)
  */
-  __pyx_tuple__7 = PyTuple_Pack(3, __pyx_int_56097295, __pyx_int_99932858, __pyx_int_59888949); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__7);
-  __Pyx_GIVEREF(__pyx_tuple__7);
-  __pyx_tuple__8 = PyTuple_Pack(3, __pyx_int_203704333, __pyx_int_231097371, __pyx_int_82662024); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__8);
-  __Pyx_GIVEREF(__pyx_tuple__8);
+  __pyx_tuple__14 = PyTuple_Pack(3, __pyx_int_254580472, __pyx_int_160888804, __pyx_int_47470116); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__14);
+  __Pyx_GIVEREF(__pyx_tuple__14);
+  __pyx_tuple__16 = PyTuple_Pack(3, __pyx_int_145648438, __pyx_int_186508213, __pyx_int_233936184); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__16);
+  __Pyx_GIVEREF(__pyx_tuple__16);
 
   /* "multimcts/mcts.pyx":22
  * 
  * class GameState:
  *     def get_current_team(self) -> Team:             # <<<<<<<<<<<<<<
  *         """The identifier of the current player's team."""
  *         raise NotImplementedError("GameState must implement get_current_team.")
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 22, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__9);
-  __Pyx_GIVEREF(__pyx_tuple__9);
-  __pyx_codeobj__10 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__9, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_current_team, 22, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__10)) __PYX_ERR(0, 22, __pyx_L1_error)
+  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(0, 22, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__17);
+  __Pyx_GIVEREF(__pyx_tuple__17);
+  __pyx_codeobj_ = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__17, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_current_team, 22, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj_)) __PYX_ERR(0, 22, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":26
  *         raise NotImplementedError("GameState must implement get_current_team.")
  * 
  *     def get_legal_moves(self) -> List[Move]:             # <<<<<<<<<<<<<<
  *         """List of all legal moves from this state."""
  *         raise NotImplementedError("GameState must implement get_legal_moves.")
  */
-  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 26, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__11);
-  __Pyx_GIVEREF(__pyx_tuple__11);
-  __pyx_codeobj__12 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__11, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_legal_moves, 26, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__12)) __PYX_ERR(0, 26, __pyx_L1_error)
+  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 26, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__18);
+  __Pyx_GIVEREF(__pyx_tuple__18);
+  __pyx_codeobj__3 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__18, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_legal_moves, 26, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__3)) __PYX_ERR(0, 26, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":30
  *         raise NotImplementedError("GameState must implement get_legal_moves.")
  * 
  *     def make_move(self, move:Move) -> 'GameState':             # <<<<<<<<<<<<<<
  *         """A new GameState--the result of applying the given move to this state.
  *         Note: The current state (self) should NOT be modified. Rather, modify a copy of it.
  */
-  __pyx_tuple__13 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_move); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 30, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__13);
-  __Pyx_GIVEREF(__pyx_tuple__13);
-  __pyx_codeobj__14 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__13, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_make_move, 30, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__14)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __pyx_tuple__19 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_move); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__19);
+  __Pyx_GIVEREF(__pyx_tuple__19);
+  __pyx_codeobj__5 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__19, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_make_move, 30, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__5)) __PYX_ERR(0, 30, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":36
  *         raise NotImplementedError("GameState must implement make_move.")
  * 
  *     def is_terminal(self) -> bool:             # <<<<<<<<<<<<<<
  *         """Is the game over?"""
  *         raise NotImplementedError("GameState must implement is_terminal.")
  */
-  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(0, 36, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__15);
-  __Pyx_GIVEREF(__pyx_tuple__15);
-  __pyx_codeobj__16 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__15, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_is_terminal, 36, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__16)) __PYX_ERR(0, 36, __pyx_L1_error)
+  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 36, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__20);
+  __Pyx_GIVEREF(__pyx_tuple__20);
+  __pyx_codeobj__7 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__20, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_is_terminal, 36, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__7)) __PYX_ERR(0, 36, __pyx_L1_error)
 
   /* "multimcts/mcts.pyx":40
  *         raise NotImplementedError("GameState must implement is_terminal.")
  * 
  *     def get_reward(self) -> Union[float,Rewards]:             # <<<<<<<<<<<<<<
- *         """The reward earned by the team that played the game-ending move (the "terminal team", or the team from the previous state).
+ *         """The reward earned by the team that played the game-ending move (i.e. the team from the previous state).
  *         Typically 1 for win, -1 for loss, 0 for draw.
  */
-  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(0, 40, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__17);
-  __Pyx_GIVEREF(__pyx_tuple__17);
-  __pyx_codeobj__18 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__17, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_reward, 40, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__18)) __PYX_ERR(0, 40, __pyx_L1_error)
+  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 40, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__21);
+  __Pyx_GIVEREF(__pyx_tuple__21);
+  __pyx_codeobj__9 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_multimcts_mcts_pyx, __pyx_n_s_get_reward, 40, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__9)) __PYX_ERR(0, 40, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Node(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_tuple__19 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__19);
-  __Pyx_GIVEREF(__pyx_tuple__19);
-  __pyx_codeobj__20 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__19, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Node, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__20)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __pyx_tuple__21 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__21);
-  __Pyx_GIVEREF(__pyx_tuple__21);
-  __pyx_codeobj__22 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_MCTS, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__22)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_tuple__22 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__22);
+  __Pyx_GIVEREF(__pyx_tuple__22);
+  __pyx_codeobj__13 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__22, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Node, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__13)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_tuple__23 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__23);
+  __Pyx_GIVEREF(__pyx_tuple__23);
+  __pyx_codeobj__15 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_MCTS, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__15)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
   __pyx_umethod_PyList_Type_pop.type = (PyObject*)&PyList_Type;
   if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_56097295 = PyInt_FromLong(56097295L); if (unlikely(!__pyx_int_56097295)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_59888949 = PyInt_FromLong(59888949L); if (unlikely(!__pyx_int_59888949)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_82662024 = PyInt_FromLong(82662024L); if (unlikely(!__pyx_int_82662024)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_99932858 = PyInt_FromLong(99932858L); if (unlikely(!__pyx_int_99932858)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_203704333 = PyInt_FromLong(203704333L); if (unlikely(!__pyx_int_203704333)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_231097371 = PyInt_FromLong(231097371L); if (unlikely(!__pyx_int_231097371)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_47470116 = PyInt_FromLong(47470116L); if (unlikely(!__pyx_int_47470116)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_145648438 = PyInt_FromLong(145648438L); if (unlikely(!__pyx_int_145648438)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_160888804 = PyInt_FromLong(160888804L); if (unlikely(!__pyx_int_160888804)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_186508213 = PyInt_FromLong(186508213L); if (unlikely(!__pyx_int_186508213)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_233936184 = PyInt_FromLong(233936184L); if (unlikely(!__pyx_int_233936184)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_254580472 = PyInt_FromLong(254580472L); if (unlikely(!__pyx_int_254580472)) __PYX_ERR(0, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
@@ -7857,53 +10004,53 @@
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
   __pyx_vtabptr_9multimcts_4mcts_Node = &__pyx_vtable_9multimcts_4mcts_Node;
-  __pyx_vtable_9multimcts_4mcts_Node.apply_rewards = (PyObject *(*)(struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> ))__pyx_f_9multimcts_4mcts_4Node_apply_rewards;
-  __pyx_vtable_9multimcts_4mcts_Node.ucb = (double (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double))__pyx_f_9multimcts_4mcts_4Node_ucb;
-  if (PyType_Ready(&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
+  __pyx_vtable_9multimcts_4mcts_Node.visit = (PyObject *(*)(struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> , PyObject *))__pyx_f_9multimcts_4mcts_4Node_visit;
+  __pyx_vtable_9multimcts_4mcts_Node.uncertainty = (double (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch))__pyx_f_9multimcts_4mcts_4Node_uncertainty;
+  __pyx_vtable_9multimcts_4mcts_Node.ucb = (double (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch))__pyx_f_9multimcts_4mcts_4Node_ucb;
+  __pyx_vtable_9multimcts_4mcts_Node.rave_beta = (double (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, int __pyx_skip_dispatch))__pyx_f_9multimcts_4mcts_4Node_rave_beta;
+  __pyx_vtable_9multimcts_4mcts_Node.score = (double (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double, int __pyx_skip_dispatch))__pyx_f_9multimcts_4mcts_4Node_score;
+  __pyx_vtable_9multimcts_4mcts_Node.best_child = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double))__pyx_f_9multimcts_4mcts_4Node_best_child;
+  __pyx_vtable_9multimcts_4mcts_Node.select = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double))__pyx_f_9multimcts_4mcts_4Node_select;
+  __pyx_vtable_9multimcts_4mcts_Node.expand = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_Node *))__pyx_f_9multimcts_4mcts_4Node_expand;
+  __pyx_vtable_9multimcts_4mcts_Node.execute_round = (void (*)(struct __pyx_obj_9multimcts_4mcts_Node *, double, double))__pyx_f_9multimcts_4mcts_4Node_execute_round;
+  if (PyType_Ready(&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_9multimcts_4mcts_Node.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9multimcts_4mcts_Node.tp_dictoffset && __pyx_type_9multimcts_4mcts_Node.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_9multimcts_4mcts_Node.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type_9multimcts_4mcts_Node.tp_dict, __pyx_vtabptr_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Node, (PyObject *)&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type_9multimcts_4mcts_Node.tp_dict, __pyx_vtabptr_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Node, (PyObject *)&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9multimcts_4mcts_Node) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
   __pyx_ptype_9multimcts_4mcts_Node = &__pyx_type_9multimcts_4mcts_Node;
-  __pyx_vtabptr_9multimcts_4mcts_MCTS = &__pyx_vtable_9multimcts_4mcts_MCTS;
-  __pyx_vtable_9multimcts_4mcts_MCTS.select = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *))__pyx_f_9multimcts_4mcts_4MCTS_select;
-  __pyx_vtable_9multimcts_4mcts_MCTS.expand = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *))__pyx_f_9multimcts_4mcts_4MCTS_expand;
-  __pyx_vtable_9multimcts_4mcts_MCTS.simulate = (std::map<std::string,double>  (*)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *, struct __pyx_opt_args_9multimcts_4mcts_4MCTS_simulate *__pyx_optional_args))__pyx_f_9multimcts_4mcts_4MCTS_simulate;
-  __pyx_vtable_9multimcts_4mcts_MCTS.backpropagate = (PyObject *(*)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *, std::map<std::string,double> ))__pyx_f_9multimcts_4mcts_4MCTS_backpropagate;
-  __pyx_vtable_9multimcts_4mcts_MCTS.get_best_child = (struct __pyx_obj_9multimcts_4mcts_Node *(*)(struct __pyx_obj_9multimcts_4mcts_MCTS *, struct __pyx_obj_9multimcts_4mcts_Node *))__pyx_f_9multimcts_4mcts_4MCTS_get_best_child;
-  if (PyType_Ready(&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 134, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 264, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_9multimcts_4mcts_MCTS.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9multimcts_4mcts_MCTS.tp_dictoffset && __pyx_type_9multimcts_4mcts_MCTS.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_9multimcts_4mcts_MCTS.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
   #if CYTHON_UPDATE_DESCRIPTOR_DOC
   {
-    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_9multimcts_4mcts_MCTS, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 134, __pyx_L1_error)
+    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_9multimcts_4mcts_MCTS, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 264, __pyx_L1_error)
     if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
       __pyx_wrapperbase_9multimcts_4mcts_4MCTS___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
       __pyx_wrapperbase_9multimcts_4mcts_4MCTS___init__.doc = __pyx_doc_9multimcts_4mcts_4MCTS___init__;
       ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_9multimcts_4mcts_4MCTS___init__;
     }
   }
   #endif
-  if (__Pyx_SetVtable(__pyx_type_9multimcts_4mcts_MCTS.tp_dict, __pyx_vtabptr_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 134, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_MCTS, (PyObject *)&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 134, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 134, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_MCTS, (PyObject *)&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 264, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9multimcts_4mcts_MCTS) < 0) __PYX_ERR(0, 264, __pyx_L1_error)
   __pyx_ptype_9multimcts_4mcts_MCTS = &__pyx_type_9multimcts_4mcts_MCTS;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
@@ -8022,14 +10169,15 @@
 }
 
 
 static CYTHON_SMALL_CODE int __pyx_pymod_exec_mcts(PyObject *__pyx_pyinit_module)
 #endif
 #endif
 {
+  __Pyx_TraceDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
@@ -8131,21 +10279,22 @@
   (void)__Pyx_modinit_type_import_code();
   (void)__Pyx_modinit_variable_import_code();
   (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
+  __Pyx_TraceCall("__Pyx_PyMODINIT_FUNC PyInit_mcts(void)", __pyx_f[0], 1, 0, __PYX_ERR(0, 1, __pyx_L1_error));
 
   /* "multimcts/mcts.pyx":5
- * # cython: profile=False
+ * # cython: profile=True
  * 
  * from time import time             # <<<<<<<<<<<<<<
  * from random import shuffle, choice
- * from typing import Union, Dict, List, Any
+ * from typing import Union, Dict, List, Hashable
  */
   __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_n_s_time);
   __Pyx_GIVEREF(__pyx_n_s_time);
   PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_time);
   __pyx_t_2 = __Pyx_Import(__pyx_n_s_time, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5, __pyx_L1_error)
@@ -8157,15 +10306,15 @@
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "multimcts/mcts.pyx":6
  * 
  * from time import time
  * from random import shuffle, choice             # <<<<<<<<<<<<<<
- * from typing import Union, Dict, List, Any
+ * from typing import Union, Dict, List, Hashable
  * 
  */
   __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 6, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_shuffle);
   __Pyx_GIVEREF(__pyx_n_s_shuffle);
   PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_shuffle);
@@ -8184,32 +10333,32 @@
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_choice, __pyx_t_2) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "multimcts/mcts.pyx":7
  * from time import time
  * from random import shuffle, choice
- * from typing import Union, Dict, List, Any             # <<<<<<<<<<<<<<
+ * from typing import Union, Dict, List, Hashable             # <<<<<<<<<<<<<<
  * 
- * from libc.math cimport log, sqrt, INFINITY
+ * cimport cython
  */
   __pyx_t_1 = PyList_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_n_s_Union);
   __Pyx_GIVEREF(__pyx_n_s_Union);
   PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_Union);
   __Pyx_INCREF(__pyx_n_s_Dict);
   __Pyx_GIVEREF(__pyx_n_s_Dict);
   PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_Dict);
   __Pyx_INCREF(__pyx_n_s_List);
   __Pyx_GIVEREF(__pyx_n_s_List);
   PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_s_List);
-  __Pyx_INCREF(__pyx_n_s_Any);
-  __Pyx_GIVEREF(__pyx_n_s_Any);
-  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_n_s_Any);
+  __Pyx_INCREF(__pyx_n_s_Hashable);
+  __Pyx_GIVEREF(__pyx_n_s_Hashable);
+  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_n_s_Hashable);
   __pyx_t_2 = __Pyx_Import(__pyx_n_s_typing, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Union); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_Union, __pyx_t_1) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
@@ -8217,35 +10366,35 @@
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_Dict, __pyx_t_1) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_List); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_List, __pyx_t_1) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Any); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Hashable); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Any, __pyx_t_1) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Hashable, __pyx_t_1) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "multimcts/mcts.pyx":16
  * 
  * 
- * Move = Any # MCTS does not care about the contents of a move; it merely passes the output of get_legal_moves() to make_move(), both of which are handled by the user.             # <<<<<<<<<<<<<<
+ * Move = Hashable # Moves can be any type, as long as they can be added to a set and used as dict keys.             # <<<<<<<<<<<<<<
  * Team = Union[int,str]
  * Rewards = Dict[Team,float]
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_Any); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 16, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_Hashable); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 16, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_Move, __pyx_t_2) < 0) __PYX_ERR(0, 16, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "multimcts/mcts.pyx":17
  * 
- * Move = Any # MCTS does not care about the contents of a move; it merely passes the output of get_legal_moves() to make_move(), both of which are handled by the user.
+ * Move = Hashable # Moves can be any type, as long as they can be added to a set and used as dict keys.
  * Team = Union[int,str]             # <<<<<<<<<<<<<<
  * Rewards = Dict[Team,float]
  * 
  */
   __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_Union); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 17, __pyx_L1_error)
@@ -8260,15 +10409,15 @@
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_Team, __pyx_t_3) < 0) __PYX_ERR(0, 17, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "multimcts/mcts.pyx":18
- * Move = Any # MCTS does not care about the contents of a move; it merely passes the output of get_legal_moves() to make_move(), both of which are handled by the user.
+ * Move = Hashable # Moves can be any type, as long as they can be added to a set and used as dict keys.
  * Team = Union[int,str]
  * Rewards = Dict[Team,float]             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Dict); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
@@ -8308,15 +10457,15 @@
  */
   __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Team); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_return, __pyx_t_3) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_1get_current_team, 0, __pyx_n_s_GameState_get_current_team, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__10)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 22, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_1get_current_team, 0, __pyx_n_s_GameState_get_current_team, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj_)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_3, __pyx_t_2);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_get_current_team, __pyx_t_3) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "multimcts/mcts.pyx":26
@@ -8334,15 +10483,15 @@
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 26, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_return, __pyx_t_5) < 0) __PYX_ERR(0, 26, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_3get_legal_moves, 0, __pyx_n_s_GameState_get_legal_moves, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__12)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 26, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_3get_legal_moves, 0, __pyx_n_s_GameState_get_legal_moves, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__3)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 26, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_5, __pyx_t_3);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_get_legal_moves, __pyx_t_5) < 0) __PYX_ERR(0, 26, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
   /* "multimcts/mcts.pyx":30
@@ -8355,15 +10504,15 @@
   __pyx_t_5 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Move); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_move, __pyx_t_3) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_return, __pyx_n_u_GameState) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_5make_move, 0, __pyx_n_s_GameState_make_move, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__14)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_5make_move, 0, __pyx_n_s_GameState_make_move, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__5)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_3, __pyx_t_5);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_make_move, __pyx_t_3) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "multimcts/mcts.pyx":36
@@ -8372,26 +10521,26 @@
  *     def is_terminal(self) -> bool:             # <<<<<<<<<<<<<<
  *         """Is the game over?"""
  *         raise NotImplementedError("GameState must implement is_terminal.")
  */
   __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 36, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_return, ((PyObject*)&PyBool_Type)) < 0) __PYX_ERR(0, 36, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_7is_terminal, 0, __pyx_n_s_GameState_is_terminal, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__16)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 36, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_7is_terminal, 0, __pyx_n_s_GameState_is_terminal, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__7)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 36, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_5, __pyx_t_3);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_is_terminal, __pyx_t_5) < 0) __PYX_ERR(0, 36, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
   /* "multimcts/mcts.pyx":40
  *         raise NotImplementedError("GameState must implement is_terminal.")
  * 
  *     def get_reward(self) -> Union[float,Rewards]:             # <<<<<<<<<<<<<<
- *         """The reward earned by the team that played the game-ending move (the "terminal team", or the team from the previous state).
+ *         """The reward earned by the team that played the game-ending move (i.e. the team from the previous state).
  *         Typically 1 for win, -1 for loss, 0 for draw.
  */
   __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Union); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_Rewards); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
@@ -8406,15 +10555,15 @@
   __pyx_t_4 = 0;
   __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_return, __pyx_t_4) < 0) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_9get_reward, 0, __pyx_n_s_GameState_get_reward, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__18)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_9multimcts_4mcts_9GameState_9get_reward, 0, __pyx_n_s_GameState_get_reward, NULL, __pyx_n_s_multimcts_mcts, __pyx_d, ((PyObject *)__pyx_codeobj__9)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_5);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_get_reward, __pyx_t_4) < 0) __PYX_ERR(0, 40, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
   /* "multimcts/mcts.pyx":21
@@ -8426,53 +10575,61 @@
  */
   __pyx_t_4 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_GameState, __pyx_empty_tuple, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 21, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_GameState, __pyx_t_4) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
+  /* "multimcts/mcts.pyx":351
+ *         SQRTLOG[x] = sqrt(log(x))
+ *         INVSQRT[x] = 1 / sqrt(x)
+ * precalc()             # <<<<<<<<<<<<<<
+ */
+  __pyx_f_9multimcts_4mcts_precalc();
+
   /* "(tree fragment)":1
  * def __pyx_unpickle_Node(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
   __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9multimcts_4mcts_1__pyx_unpickle_Node, NULL, __pyx_n_s_multimcts_mcts); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Node, __pyx_t_1) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":11
  *         __pyx_unpickle_Node__set_state(<Node> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_Node__set_state(Node __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
- *     __pyx_result.avg_reward = __pyx_state[0]; __pyx_result.children = __pyx_state[1]; __pyx_result.cteam = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.remaining_moves = __pyx_state[8]; __pyx_result.rewards = __pyx_state[9]; __pyx_result.sqrtlog_visits = __pyx_state[10]; __pyx_result.state = __pyx_state[11]; __pyx_result.team = __pyx_state[12]; __pyx_result.visits = __pyx_state[13]
- *     if len(__pyx_state) > 14 and hasattr(__pyx_result, '__dict__'):
+ *     __pyx_result.avg_rave_reward = __pyx_state[0]; __pyx_result.avg_reward = __pyx_state[1]; __pyx_result.children = __pyx_state[2]; __pyx_result.invsqrt_visits = __pyx_state[3]; __pyx_result.is_fully_expanded = __pyx_state[4]; __pyx_result.is_terminal = __pyx_state[5]; __pyx_result.move = __pyx_state[6]; __pyx_result.parent = __pyx_state[7]; __pyx_result.rave_rewards = __pyx_state[8]; __pyx_result.rave_visits = __pyx_state[9]; __pyx_result.remaining_moves = __pyx_state[10]; __pyx_result.rewards = __pyx_state[11]; __pyx_result.sqrtlog_visits = __pyx_state[12]; __pyx_result.state = __pyx_state[13]; __pyx_result.team = __pyx_state[14]; __pyx_result.visits = __pyx_state[15]
+ *     if len(__pyx_state) > 16 and hasattr(__pyx_result, '__dict__'):
  */
   __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9multimcts_4mcts_3__pyx_unpickle_MCTS, NULL, __pyx_n_s_multimcts_mcts); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_MCTS, __pyx_t_1) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "multimcts/mcts.pyx":1
  * # distutils: language=c++             # <<<<<<<<<<<<<<
  * # cython: language_level=3
- * # cython: profile=False
+ * # cython: profile=True
  */
   __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "map.from_py":174
  * 
  * @cname("__pyx_convert_map_from_py_std_3a__3a_string__and_double")
  * cdef map[X,Y] __pyx_convert_map_from_py_std_3a__3a_string__and_double(object o) except *:             # <<<<<<<<<<<<<<
  *     cdef dict d = o
  *     cdef map[X,Y] m
  */
+  __Pyx_TraceReturn(Py_None, 0);
 
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
@@ -8540,34 +10697,14 @@
 #else
             "name '%.200s' is not defined", PyString_AS_STRING(name));
 #endif
     }
     return result;
 }
 
-/* PyObjectCall */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
-    PyObject *result;
-    ternaryfunc call = Py_TYPE(func)->tp_call;
-    if (unlikely(!call))
-        return PyObject_Call(func, arg, kw);
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
-        return NULL;
-    result = (*call)(func, arg, kw);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
-    }
-    return result;
-}
-#endif
-
 /* PyErrFetchRestore */
 #if CYTHON_FAST_THREAD_STATE
 static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
     PyObject *tmp_type, *tmp_value, *tmp_tb;
     tmp_type = tstate->curexc_type;
     tmp_value = tstate->curexc_value;
     tmp_tb = tstate->curexc_traceback;
@@ -8584,14 +10721,124 @@
     *tb = tstate->curexc_traceback;
     tstate->curexc_type = 0;
     tstate->curexc_value = 0;
     tstate->curexc_traceback = 0;
 }
 #endif
 
+/* Profile */
+#if CYTHON_PROFILE
+static int __Pyx_TraceSetupAndCall(PyCodeObject** code,
+                                   PyFrameObject** frame,
+                                   PyThreadState* tstate,
+                                   const char *funcname,
+                                   const char *srcfile,
+                                   int firstlineno) {
+    PyObject *type, *value, *traceback;
+    int retval;
+    if (*frame == NULL || !CYTHON_PROFILE_REUSE_FRAME) {
+        if (*code == NULL) {
+            *code = __Pyx_createFrameCodeObject(funcname, srcfile, firstlineno);
+            if (*code == NULL) return 0;
+        }
+        *frame = PyFrame_New(
+            tstate,                          /*PyThreadState *tstate*/
+            *code,                           /*PyCodeObject *code*/
+            __pyx_d,                  /*PyObject *globals*/
+            0                                /*PyObject *locals*/
+        );
+        if (*frame == NULL) return 0;
+        if (CYTHON_TRACE && (*frame)->f_trace == NULL) {
+            Py_INCREF(Py_None);
+            (*frame)->f_trace = Py_None;
+        }
+#if PY_VERSION_HEX < 0x030400B1
+    } else {
+        (*frame)->f_tstate = tstate;
+#endif
+    }
+    __Pyx_PyFrame_SetLineNumber(*frame, firstlineno);
+    retval = 1;
+    __Pyx_EnterTracing(tstate);
+    __Pyx_ErrFetchInState(tstate, &type, &value, &traceback);
+    #if CYTHON_TRACE
+    if (tstate->c_tracefunc)
+        retval = tstate->c_tracefunc(tstate->c_traceobj, *frame, PyTrace_CALL, NULL) == 0;
+    if (retval && tstate->c_profilefunc)
+    #endif
+        retval = tstate->c_profilefunc(tstate->c_profileobj, *frame, PyTrace_CALL, NULL) == 0;
+    __Pyx_LeaveTracing(tstate);
+    if (retval) {
+        __Pyx_ErrRestoreInState(tstate, type, value, traceback);
+        return __Pyx_IsTracing(tstate, 0, 0) && retval;
+    } else {
+        Py_XDECREF(type);
+        Py_XDECREF(value);
+        Py_XDECREF(traceback);
+        return -1;
+    }
+}
+static PyCodeObject *__Pyx_createFrameCodeObject(const char *funcname, const char *srcfile, int firstlineno) {
+    PyCodeObject *py_code = 0;
+#if PY_MAJOR_VERSION >= 3
+    py_code = PyCode_NewEmpty(srcfile, funcname, firstlineno);
+    if (likely(py_code)) {
+        py_code->co_flags |= CO_OPTIMIZED | CO_NEWLOCALS;
+    }
+#else
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
+    py_funcname = PyString_FromString(funcname);
+    if (unlikely(!py_funcname)) goto bad;
+    py_srcfile = PyString_FromString(srcfile);
+    if (unlikely(!py_srcfile)) goto bad;
+    py_code = PyCode_New(
+        0,
+        0,
+        0,
+        CO_OPTIMIZED | CO_NEWLOCALS,
+        __pyx_empty_bytes,     /*PyObject *code,*/
+        __pyx_empty_tuple,     /*PyObject *consts,*/
+        __pyx_empty_tuple,     /*PyObject *names,*/
+        __pyx_empty_tuple,     /*PyObject *varnames,*/
+        __pyx_empty_tuple,     /*PyObject *freevars,*/
+        __pyx_empty_tuple,     /*PyObject *cellvars,*/
+        py_srcfile,       /*PyObject *filename,*/
+        py_funcname,      /*PyObject *name,*/
+        firstlineno,
+        __pyx_empty_bytes      /*PyObject *lnotab*/
+    );
+bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
+#endif
+    return py_code;
+}
+#endif
+
+/* PyObjectCall */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+    PyObject *result;
+    ternaryfunc call = Py_TYPE(func)->tp_call;
+    if (unlikely(!call))
+        return PyObject_Call(func, arg, kw);
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    result = (*call)(func, arg, kw);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
+    }
+    return result;
+}
+#endif
+
 /* RaiseException */
 #if PY_MAJOR_VERSION < 3
 static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                         CYTHON_UNUSED PyObject *cause) {
     __Pyx_PyThreadState_declare
     Py_XINCREF(type);
     if (!value || value == Py_None)
@@ -9220,336 +11467,181 @@
     result = __Pyx_PyObject_Call(function, args, NULL);
     Py_DECREF(args);
     Py_DECREF(function);
 done:
     return result;
 }
 
-/* PyErrExceptionMatches */
-#if CYTHON_FAST_THREAD_STATE
-static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
-    Py_ssize_t i, n;
-    n = PyTuple_GET_SIZE(tuple);
-#if PY_MAJOR_VERSION >= 3
-    for (i=0; i<n; i++) {
-        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
-    }
-#endif
-    for (i=0; i<n; i++) {
-        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
+/* decode_c_bytes */
+static CYTHON_INLINE PyObject* __Pyx_decode_c_bytes(
+         const char* cstring, Py_ssize_t length, Py_ssize_t start, Py_ssize_t stop,
+         const char* encoding, const char* errors,
+         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
+    if (unlikely((start < 0) | (stop < 0))) {
+        if (start < 0) {
+            start += length;
+            if (start < 0)
+                start = 0;
+        }
+        if (stop < 0)
+            stop += length;
+    }
+    if (stop > length)
+        stop = length;
+    if (unlikely(stop <= start))
+        return __Pyx_NewRef(__pyx_empty_unicode);
+    length = stop - start;
+    cstring += start;
+    if (decode_func) {
+        return decode_func(cstring, length, errors);
+    } else {
+        return PyUnicode_Decode(cstring, length, encoding, errors);
     }
-    return 0;
-}
-static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
-    PyObject *exc_type = tstate->curexc_type;
-    if (exc_type == err) return 1;
-    if (unlikely(!exc_type)) return 0;
-    if (unlikely(PyTuple_Check(err)))
-        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
-    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
 }
-#endif
 
-/* GetAttr */
-static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
-#if CYTHON_USE_TYPE_SLOTS
-#if PY_MAJOR_VERSION >= 3
-    if (likely(PyUnicode_Check(n)))
-#else
-    if (likely(PyString_Check(n)))
+/* WriteUnraisableException */
+static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
+                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
+                                  int full_traceback, CYTHON_UNUSED int nogil) {
+    PyObject *old_exc, *old_val, *old_tb;
+    PyObject *ctx;
+    __Pyx_PyThreadState_declare
+#ifdef WITH_THREAD
+    PyGILState_STATE state;
+    if (nogil)
+        state = PyGILState_Ensure();
+    else state = (PyGILState_STATE)0;
 #endif
-        return __Pyx_PyObject_GetAttrStr(o, n);
+    __Pyx_PyThreadState_assign
+    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
+    if (full_traceback) {
+        Py_XINCREF(old_exc);
+        Py_XINCREF(old_val);
+        Py_XINCREF(old_tb);
+        __Pyx_ErrRestore(old_exc, old_val, old_tb);
+        PyErr_PrintEx(1);
+    }
+    #if PY_MAJOR_VERSION < 3
+    ctx = PyString_FromString(name);
+    #else
+    ctx = PyUnicode_FromString(name);
+    #endif
+    __Pyx_ErrRestore(old_exc, old_val, old_tb);
+    if (!ctx) {
+        PyErr_WriteUnraisable(Py_None);
+    } else {
+        PyErr_WriteUnraisable(ctx);
+        Py_DECREF(ctx);
+    }
+#ifdef WITH_THREAD
+    if (nogil)
+        PyGILState_Release(state);
 #endif
-    return PyObject_GetAttr(o, n);
 }
 
-/* GetAttr3 */
-static PyObject *__Pyx_GetAttr3Default(PyObject *d) {
+/* IterNext */
+static PyObject *__Pyx_PyIter_Next2Default(PyObject* defval) {
+    PyObject* exc_type;
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
-    if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
-        return NULL;
-    __Pyx_PyErr_Clear();
-    Py_INCREF(d);
-    return d;
+    exc_type = __Pyx_PyErr_Occurred();
+    if (unlikely(exc_type)) {
+        if (!defval || unlikely(!__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)))
+            return NULL;
+        __Pyx_PyErr_Clear();
+        Py_INCREF(defval);
+        return defval;
+    }
+    if (defval) {
+        Py_INCREF(defval);
+        return defval;
+    }
+    __Pyx_PyErr_SetNone(PyExc_StopIteration);
+    return NULL;
 }
-static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *o, PyObject *n, PyObject *d) {
-    PyObject *r = __Pyx_GetAttr(o, n);
-    return (likely(r)) ? r : __Pyx_GetAttr3Default(d);
+static void __Pyx_PyIter_Next_ErrorNoIterator(PyObject *iterator) {
+    PyErr_Format(PyExc_TypeError,
+        "%.200s object is not an iterator", Py_TYPE(iterator)->tp_name);
 }
-
-/* pyfrozenset_new */
-static CYTHON_INLINE PyObject* __Pyx_PyFrozenSet_New(PyObject* it) {
-    if (it) {
-        PyObject* result;
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject* args;
-        args = PyTuple_Pack(1, it);
-        if (unlikely(!args))
+static CYTHON_INLINE PyObject *__Pyx_PyIter_Next2(PyObject* iterator, PyObject* defval) {
+    PyObject* next;
+    iternextfunc iternext = Py_TYPE(iterator)->tp_iternext;
+    if (likely(iternext)) {
+#if CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY
+        next = iternext(iterator);
+        if (likely(next))
+            return next;
+        #if PY_VERSION_HEX >= 0x02070000 && CYTHON_COMPILING_IN_CPYTHON
+        if (unlikely(iternext == &_PyObject_NextNotImplemented))
             return NULL;
-        result = PyObject_Call((PyObject*)&PyFrozenSet_Type, args, NULL);
-        Py_DECREF(args);
-        return result;
+        #endif
 #else
-        if (PyFrozenSet_CheckExact(it)) {
-            Py_INCREF(it);
-            return it;
-        }
-        result = PyFrozenSet_New(it);
-        if (unlikely(!result))
-            return NULL;
-        if ((PY_VERSION_HEX >= 0x031000A1) || likely(PySet_GET_SIZE(result)))
-            return result;
-        Py_DECREF(result);
+        next = PyIter_Next(iterator);
+        if (likely(next))
+            return next;
 #endif
+    } else if (CYTHON_USE_TYPE_SLOTS || unlikely(!PyIter_Check(iterator))) {
+        __Pyx_PyIter_Next_ErrorNoIterator(iterator);
+        return NULL;
+    }
+#if !CYTHON_USE_TYPE_SLOTS
+    else {
+        next = PyIter_Next(iterator);
+        if (likely(next))
+            return next;
     }
-#if CYTHON_USE_TYPE_SLOTS
-    return PyFrozenSet_Type.tp_new(&PyFrozenSet_Type, __pyx_empty_tuple, NULL);
-#else
-    return PyObject_Call((PyObject*)&PyFrozenSet_Type, __pyx_empty_tuple, NULL);
 #endif
+    return __Pyx_PyIter_Next2Default(defval);
 }
 
-/* PySetContains */
-static int __Pyx_PySet_ContainsUnhashable(PyObject *set, PyObject *key) {
-    int result = -1;
-    if (PySet_Check(key) && PyErr_ExceptionMatches(PyExc_TypeError)) {
-        PyObject *tmpkey;
-        PyErr_Clear();
-        tmpkey = __Pyx_PyFrozenSet_New(key);
-        if (tmpkey != NULL) {
-            result = PySet_Contains(set, tmpkey);
-            Py_DECREF(tmpkey);
-        }
-    }
-    return result;
-}
-static CYTHON_INLINE int __Pyx_PySet_ContainsTF(PyObject* key, PyObject* set, int eq) {
-    int result = PySet_Contains(set, key);
-    if (unlikely(result < 0)) {
-        result = __Pyx_PySet_ContainsUnhashable(set, key);
+/* ExtTypeTest */
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
+    if (unlikely(!type)) {
+        PyErr_SetString(PyExc_SystemError, "Missing type object");
+        return 0;
     }
-    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
-}
-
-/* PyUnicode_Unicode */
-static CYTHON_INLINE PyObject* __Pyx_PyUnicode_Unicode(PyObject *obj) {
-    if (unlikely(obj == Py_None))
-        obj = __pyx_kp_u_None;
-    return __Pyx_NewRef(obj);
+    if (likely(__Pyx_TypeCheck(obj, type)))
+        return 1;
+    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
+                 Py_TYPE(obj)->tp_name, type->tp_name);
+    return 0;
 }
 
-/* JoinPyUnicode */
-static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
-                                      CYTHON_UNUSED Py_UCS4 max_char) {
-#if CYTHON_USE_UNICODE_INTERNALS && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    PyObject *result_uval;
-    int result_ukind;
-    Py_ssize_t i, char_pos;
-    void *result_udata;
-#if CYTHON_PEP393_ENABLED
-    result_uval = PyUnicode_New(result_ulength, max_char);
-    if (unlikely(!result_uval)) return NULL;
-    result_ukind = (max_char <= 255) ? PyUnicode_1BYTE_KIND : (max_char <= 65535) ? PyUnicode_2BYTE_KIND : PyUnicode_4BYTE_KIND;
-    result_udata = PyUnicode_DATA(result_uval);
-#else
-    result_uval = PyUnicode_FromUnicode(NULL, result_ulength);
-    if (unlikely(!result_uval)) return NULL;
-    result_ukind = sizeof(Py_UNICODE);
-    result_udata = PyUnicode_AS_UNICODE(result_uval);
-#endif
-    char_pos = 0;
-    for (i=0; i < value_count; i++) {
-        int ukind;
-        Py_ssize_t ulength;
-        void *udata;
-        PyObject *uval = PyTuple_GET_ITEM(value_tuple, i);
-        if (unlikely(__Pyx_PyUnicode_READY(uval)))
-            goto bad;
-        ulength = __Pyx_PyUnicode_GET_LENGTH(uval);
-        if (unlikely(!ulength))
-            continue;
-        if (unlikely(char_pos + ulength < 0))
-            goto overflow;
-        ukind = __Pyx_PyUnicode_KIND(uval);
-        udata = __Pyx_PyUnicode_DATA(uval);
-        if (!CYTHON_PEP393_ENABLED || ukind == result_ukind) {
-            memcpy((char *)result_udata + char_pos * result_ukind, udata, (size_t) (ulength * result_ukind));
+/* IterFinish */
+static CYTHON_INLINE int __Pyx_IterFinish(void) {
+#if CYTHON_FAST_THREAD_STATE
+    PyThreadState *tstate = __Pyx_PyThreadState_Current;
+    PyObject* exc_type = tstate->curexc_type;
+    if (unlikely(exc_type)) {
+        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
+            PyObject *exc_value, *exc_tb;
+            exc_value = tstate->curexc_value;
+            exc_tb = tstate->curexc_traceback;
+            tstate->curexc_type = 0;
+            tstate->curexc_value = 0;
+            tstate->curexc_traceback = 0;
+            Py_DECREF(exc_type);
+            Py_XDECREF(exc_value);
+            Py_XDECREF(exc_tb);
+            return 0;
         } else {
-            #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030300F0 || defined(_PyUnicode_FastCopyCharacters)
-            _PyUnicode_FastCopyCharacters(result_uval, char_pos, uval, 0, ulength);
-            #else
-            Py_ssize_t j;
-            for (j=0; j < ulength; j++) {
-                Py_UCS4 uchar = __Pyx_PyUnicode_READ(ukind, udata, j);
-                __Pyx_PyUnicode_WRITE(result_ukind, result_udata, char_pos+j, uchar);
-            }
-            #endif
+            return -1;
         }
-        char_pos += ulength;
     }
-    return result_uval;
-overflow:
-    PyErr_SetString(PyExc_OverflowError, "join() result is too long for a Python string");
-bad:
-    Py_DECREF(result_uval);
-    return NULL;
-#else
-    result_ulength++;
-    value_count++;
-    return PyUnicode_Join(__pyx_empty_unicode, value_tuple);
-#endif
-}
-
-/* BytesEquals */
-static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
-#if CYTHON_COMPILING_IN_PYPY
-    return PyObject_RichCompareBool(s1, s2, equals);
+    return 0;
 #else
-    if (s1 == s2) {
-        return (equals == Py_EQ);
-    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
-        const char *ps1, *ps2;
-        Py_ssize_t length = PyBytes_GET_SIZE(s1);
-        if (length != PyBytes_GET_SIZE(s2))
-            return (equals == Py_NE);
-        ps1 = PyBytes_AS_STRING(s1);
-        ps2 = PyBytes_AS_STRING(s2);
-        if (ps1[0] != ps2[0]) {
-            return (equals == Py_NE);
-        } else if (length == 1) {
-            return (equals == Py_EQ);
+    if (unlikely(PyErr_Occurred())) {
+        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
+            PyErr_Clear();
+            return 0;
         } else {
-            int result;
-#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
-            Py_hash_t hash1, hash2;
-            hash1 = ((PyBytesObject*)s1)->ob_shash;
-            hash2 = ((PyBytesObject*)s2)->ob_shash;
-            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
-                return (equals == Py_NE);
-            }
-#endif
-            result = memcmp(ps1, ps2, (size_t)length);
-            return (equals == Py_EQ) ? (result == 0) : (result != 0);
-        }
-    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
-        return (equals == Py_NE);
-    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
-        return (equals == Py_NE);
-    } else {
-        int result;
-        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
-        if (!py_result)
-            return -1;
-        result = __Pyx_PyObject_IsTrue(py_result);
-        Py_DECREF(py_result);
-        return result;
-    }
-#endif
-}
-
-/* UnicodeEquals */
-static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
-#if CYTHON_COMPILING_IN_PYPY
-    return PyObject_RichCompareBool(s1, s2, equals);
-#else
-#if PY_MAJOR_VERSION < 3
-    PyObject* owned_ref = NULL;
-#endif
-    int s1_is_unicode, s2_is_unicode;
-    if (s1 == s2) {
-        goto return_eq;
-    }
-    s1_is_unicode = PyUnicode_CheckExact(s1);
-    s2_is_unicode = PyUnicode_CheckExact(s2);
-#if PY_MAJOR_VERSION < 3
-    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
-        owned_ref = PyUnicode_FromObject(s2);
-        if (unlikely(!owned_ref))
             return -1;
-        s2 = owned_ref;
-        s2_is_unicode = 1;
-    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
-        owned_ref = PyUnicode_FromObject(s1);
-        if (unlikely(!owned_ref))
-            return -1;
-        s1 = owned_ref;
-        s1_is_unicode = 1;
-    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
-        return __Pyx_PyBytes_Equals(s1, s2, equals);
-    }
-#endif
-    if (s1_is_unicode & s2_is_unicode) {
-        Py_ssize_t length;
-        int kind;
-        void *data1, *data2;
-        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
-            return -1;
-        length = __Pyx_PyUnicode_GET_LENGTH(s1);
-        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
-            goto return_ne;
         }
-#if CYTHON_USE_UNICODE_INTERNALS
-        {
-            Py_hash_t hash1, hash2;
-        #if CYTHON_PEP393_ENABLED
-            hash1 = ((PyASCIIObject*)s1)->hash;
-            hash2 = ((PyASCIIObject*)s2)->hash;
-        #else
-            hash1 = ((PyUnicodeObject*)s1)->hash;
-            hash2 = ((PyUnicodeObject*)s2)->hash;
-        #endif
-            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
-                goto return_ne;
-            }
-        }
-#endif
-        kind = __Pyx_PyUnicode_KIND(s1);
-        if (kind != __Pyx_PyUnicode_KIND(s2)) {
-            goto return_ne;
-        }
-        data1 = __Pyx_PyUnicode_DATA(s1);
-        data2 = __Pyx_PyUnicode_DATA(s2);
-        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
-            goto return_ne;
-        } else if (length == 1) {
-            goto return_eq;
-        } else {
-            int result = memcmp(data1, data2, (size_t)(length * kind));
-            #if PY_MAJOR_VERSION < 3
-            Py_XDECREF(owned_ref);
-            #endif
-            return (equals == Py_EQ) ? (result == 0) : (result != 0);
-        }
-    } else if ((s1 == Py_None) & s2_is_unicode) {
-        goto return_ne;
-    } else if ((s2 == Py_None) & s1_is_unicode) {
-        goto return_ne;
-    } else {
-        int result;
-        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
-        #if PY_MAJOR_VERSION < 3
-        Py_XDECREF(owned_ref);
-        #endif
-        if (!py_result)
-            return -1;
-        result = __Pyx_PyObject_IsTrue(py_result);
-        Py_DECREF(py_result);
-        return result;
     }
-return_eq:
-    #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(owned_ref);
-    #endif
-    return (equals == Py_EQ);
-return_ne:
-    #if PY_MAJOR_VERSION < 3
-    Py_XDECREF(owned_ref);
-    #endif
-    return (equals == Py_NE);
+    return 0;
 #endif
 }
 
 /* PyObjectGetMethod */
 static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
     PyObject *attr;
 #if CYTHON_UNPACK_METHODS && CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_PYTYPE_LOOKUP
@@ -9657,14 +11749,218 @@
     if (unlikely(!method)) goto bad;
     result = __Pyx_PyObject_CallNoArg(method);
     Py_DECREF(method);
 bad:
     return result;
 }
 
+/* RaiseNeedMoreValuesToUnpack */
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
+    PyErr_Format(PyExc_ValueError,
+                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
+                 index, (index == 1) ? "" : "s");
+}
+
+/* RaiseTooManyValuesToUnpack */
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
+    PyErr_Format(PyExc_ValueError,
+                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
+}
+
+/* UnpackItemEndCheck */
+static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
+    if (unlikely(retval)) {
+        Py_DECREF(retval);
+        __Pyx_RaiseTooManyValuesError(expected);
+        return -1;
+    }
+    return __Pyx_IterFinish();
+}
+
+/* RaiseNoneIterError */
+static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
+}
+
+/* UnpackTupleError */
+static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
+    if (t == Py_None) {
+      __Pyx_RaiseNoneNotIterableError();
+    } else if (PyTuple_GET_SIZE(t) < index) {
+      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
+    } else {
+      __Pyx_RaiseTooManyValuesError(index);
+    }
+}
+
+/* UnpackTuple2 */
+static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
+        PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2, int decref_tuple) {
+    PyObject *value1 = NULL, *value2 = NULL;
+#if CYTHON_COMPILING_IN_PYPY
+    value1 = PySequence_ITEM(tuple, 0);  if (unlikely(!value1)) goto bad;
+    value2 = PySequence_ITEM(tuple, 1);  if (unlikely(!value2)) goto bad;
+#else
+    value1 = PyTuple_GET_ITEM(tuple, 0);  Py_INCREF(value1);
+    value2 = PyTuple_GET_ITEM(tuple, 1);  Py_INCREF(value2);
+#endif
+    if (decref_tuple) {
+        Py_DECREF(tuple);
+    }
+    *pvalue1 = value1;
+    *pvalue2 = value2;
+    return 0;
+#if CYTHON_COMPILING_IN_PYPY
+bad:
+    Py_XDECREF(value1);
+    Py_XDECREF(value2);
+    if (decref_tuple) { Py_XDECREF(tuple); }
+    return -1;
+#endif
+}
+static int __Pyx_unpack_tuple2_generic(PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2,
+                                       int has_known_size, int decref_tuple) {
+    Py_ssize_t index;
+    PyObject *value1 = NULL, *value2 = NULL, *iter = NULL;
+    iternextfunc iternext;
+    iter = PyObject_GetIter(tuple);
+    if (unlikely(!iter)) goto bad;
+    if (decref_tuple) { Py_DECREF(tuple); tuple = NULL; }
+    iternext = Py_TYPE(iter)->tp_iternext;
+    value1 = iternext(iter); if (unlikely(!value1)) { index = 0; goto unpacking_failed; }
+    value2 = iternext(iter); if (unlikely(!value2)) { index = 1; goto unpacking_failed; }
+    if (!has_known_size && unlikely(__Pyx_IternextUnpackEndCheck(iternext(iter), 2))) goto bad;
+    Py_DECREF(iter);
+    *pvalue1 = value1;
+    *pvalue2 = value2;
+    return 0;
+unpacking_failed:
+    if (!has_known_size && __Pyx_IterFinish() == 0)
+        __Pyx_RaiseNeedMoreValuesError(index);
+bad:
+    Py_XDECREF(iter);
+    Py_XDECREF(value1);
+    Py_XDECREF(value2);
+    if (decref_tuple) { Py_XDECREF(tuple); }
+    return -1;
+}
+
+/* dict_iter */
+static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* iterable, int is_dict, PyObject* method_name,
+                                                   Py_ssize_t* p_orig_length, int* p_source_is_dict) {
+    is_dict = is_dict || likely(PyDict_CheckExact(iterable));
+    *p_source_is_dict = is_dict;
+    if (is_dict) {
+#if !CYTHON_COMPILING_IN_PYPY
+        *p_orig_length = PyDict_Size(iterable);
+        Py_INCREF(iterable);
+        return iterable;
+#elif PY_MAJOR_VERSION >= 3
+        static PyObject *py_items = NULL, *py_keys = NULL, *py_values = NULL;
+        PyObject **pp = NULL;
+        if (method_name) {
+            const char *name = PyUnicode_AsUTF8(method_name);
+            if (strcmp(name, "iteritems") == 0) pp = &py_items;
+            else if (strcmp(name, "iterkeys") == 0) pp = &py_keys;
+            else if (strcmp(name, "itervalues") == 0) pp = &py_values;
+            if (pp) {
+                if (!*pp) {
+                    *pp = PyUnicode_FromString(name + 4);
+                    if (!*pp)
+                        return NULL;
+                }
+                method_name = *pp;
+            }
+        }
+#endif
+    }
+    *p_orig_length = 0;
+    if (method_name) {
+        PyObject* iter;
+        iterable = __Pyx_PyObject_CallMethod0(iterable, method_name);
+        if (!iterable)
+            return NULL;
+#if !CYTHON_COMPILING_IN_PYPY
+        if (PyTuple_CheckExact(iterable) || PyList_CheckExact(iterable))
+            return iterable;
+#endif
+        iter = PyObject_GetIter(iterable);
+        Py_DECREF(iterable);
+        return iter;
+    }
+    return PyObject_GetIter(iterable);
+}
+static CYTHON_INLINE int __Pyx_dict_iter_next(
+        PyObject* iter_obj, CYTHON_NCP_UNUSED Py_ssize_t orig_length, CYTHON_NCP_UNUSED Py_ssize_t* ppos,
+        PyObject** pkey, PyObject** pvalue, PyObject** pitem, int source_is_dict) {
+    PyObject* next_item;
+#if !CYTHON_COMPILING_IN_PYPY
+    if (source_is_dict) {
+        PyObject *key, *value;
+        if (unlikely(orig_length != PyDict_Size(iter_obj))) {
+            PyErr_SetString(PyExc_RuntimeError, "dictionary changed size during iteration");
+            return -1;
+        }
+        if (unlikely(!PyDict_Next(iter_obj, ppos, &key, &value))) {
+            return 0;
+        }
+        if (pitem) {
+            PyObject* tuple = PyTuple_New(2);
+            if (unlikely(!tuple)) {
+                return -1;
+            }
+            Py_INCREF(key);
+            Py_INCREF(value);
+            PyTuple_SET_ITEM(tuple, 0, key);
+            PyTuple_SET_ITEM(tuple, 1, value);
+            *pitem = tuple;
+        } else {
+            if (pkey) {
+                Py_INCREF(key);
+                *pkey = key;
+            }
+            if (pvalue) {
+                Py_INCREF(value);
+                *pvalue = value;
+            }
+        }
+        return 1;
+    } else if (PyTuple_CheckExact(iter_obj)) {
+        Py_ssize_t pos = *ppos;
+        if (unlikely(pos >= PyTuple_GET_SIZE(iter_obj))) return 0;
+        *ppos = pos + 1;
+        next_item = PyTuple_GET_ITEM(iter_obj, pos);
+        Py_INCREF(next_item);
+    } else if (PyList_CheckExact(iter_obj)) {
+        Py_ssize_t pos = *ppos;
+        if (unlikely(pos >= PyList_GET_SIZE(iter_obj))) return 0;
+        *ppos = pos + 1;
+        next_item = PyList_GET_ITEM(iter_obj, pos);
+        Py_INCREF(next_item);
+    } else
+#endif
+    {
+        next_item = PyIter_Next(iter_obj);
+        if (unlikely(!next_item)) {
+            return __Pyx_IterFinish();
+        }
+    }
+    if (pitem) {
+        *pitem = next_item;
+    } else if (pkey && pvalue) {
+        if (__Pyx_unpack_tuple2(next_item, pkey, pvalue, source_is_dict, source_is_dict, 1))
+            return -1;
+    } else if (pkey) {
+        *pkey = next_item;
+    } else {
+        *pvalue = next_item;
+    }
+    return 1;
+}
+
 /* UnpackUnboundCMethod */
 static int __Pyx_TryUnpackUnboundCMethod(__Pyx_CachedCFunction* target) {
     PyObject *method;
     method = __Pyx_PyObject_GetAttrStr(target->type, *target->method_name);
     if (unlikely(!method))
         return -1;
     target->method = method;
@@ -9713,45 +12009,14 @@
         __Pyx_SET_SIZE(L, Py_SIZE(L) - 1);
         return PyList_GET_ITEM(L, PyList_GET_SIZE(L));
     }
     return __Pyx_CallUnboundCMethod0(&__pyx_umethod_PyList_Type_pop, L);
 }
 #endif
 
-/* PyObjectCallMethod1 */
-static PyObject* __Pyx__PyObject_CallMethod1(PyObject* method, PyObject* arg) {
-    PyObject *result = __Pyx_PyObject_CallOneArg(method, arg);
-    Py_DECREF(method);
-    return result;
-}
-static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
-    PyObject *method = NULL, *result;
-    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
-    if (likely(is_method)) {
-        result = __Pyx_PyObject_Call2Args(method, obj, arg);
-        Py_DECREF(method);
-        return result;
-    }
-    if (unlikely(!method)) return NULL;
-    return __Pyx__PyObject_CallMethod1(method, arg);
-}
-
-/* append */
-static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x) {
-    if (likely(PyList_CheckExact(L))) {
-        if (unlikely(__Pyx_PyList_Append(L, x) < 0)) return -1;
-    } else {
-        PyObject* retval = __Pyx_PyObject_CallMethod1(L, __pyx_n_s_append, x);
-        if (unlikely(!retval))
-            return -1;
-        Py_DECREF(retval);
-    }
-    return 0;
-}
-
 /* PyIntCompare */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED long inplace) {
     if (op1 == op2) {
         Py_RETURN_TRUE;
     }
     #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_CheckExact(op1))) {
@@ -9967,65 +12232,283 @@
         Py_DECREF(float_value);
         return value;
     }
 bad:
     return (double)-1;
 }
 
-/* WriteUnraisableException */
-static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
-                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
-                                  int full_traceback, CYTHON_UNUSED int nogil) {
-    PyObject *old_exc, *old_val, *old_tb;
-    PyObject *ctx;
-    __Pyx_PyThreadState_declare
-#ifdef WITH_THREAD
-    PyGILState_STATE state;
-    if (nogil)
-        state = PyGILState_Ensure();
-    else state = (PyGILState_STATE)0;
+/* PyErrExceptionMatches */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
+    Py_ssize_t i, n;
+    n = PyTuple_GET_SIZE(tuple);
+#if PY_MAJOR_VERSION >= 3
+    for (i=0; i<n; i++) {
+        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
+    }
+#endif
+    for (i=0; i<n; i++) {
+        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
+    }
+    return 0;
+}
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
+    PyObject *exc_type = tstate->curexc_type;
+    if (exc_type == err) return 1;
+    if (unlikely(!exc_type)) return 0;
+    if (unlikely(PyTuple_Check(err)))
+        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
+    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
+}
+#endif
+
+/* GetAttr */
+static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
+#if CYTHON_USE_TYPE_SLOTS
+#if PY_MAJOR_VERSION >= 3
+    if (likely(PyUnicode_Check(n)))
+#else
+    if (likely(PyString_Check(n)))
+#endif
+        return __Pyx_PyObject_GetAttrStr(o, n);
 #endif
+    return PyObject_GetAttr(o, n);
+}
+
+/* GetAttr3 */
+static PyObject *__Pyx_GetAttr3Default(PyObject *d) {
+    __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
-    if (full_traceback) {
-        Py_XINCREF(old_exc);
-        Py_XINCREF(old_val);
-        Py_XINCREF(old_tb);
-        __Pyx_ErrRestore(old_exc, old_val, old_tb);
-        PyErr_PrintEx(1);
+    if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
+        return NULL;
+    __Pyx_PyErr_Clear();
+    Py_INCREF(d);
+    return d;
+}
+static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *o, PyObject *n, PyObject *d) {
+    PyObject *r = __Pyx_GetAttr(o, n);
+    return (likely(r)) ? r : __Pyx_GetAttr3Default(d);
+}
+
+/* BytesEquals */
+static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
+#if CYTHON_COMPILING_IN_PYPY
+    return PyObject_RichCompareBool(s1, s2, equals);
+#else
+    if (s1 == s2) {
+        return (equals == Py_EQ);
+    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
+        const char *ps1, *ps2;
+        Py_ssize_t length = PyBytes_GET_SIZE(s1);
+        if (length != PyBytes_GET_SIZE(s2))
+            return (equals == Py_NE);
+        ps1 = PyBytes_AS_STRING(s1);
+        ps2 = PyBytes_AS_STRING(s2);
+        if (ps1[0] != ps2[0]) {
+            return (equals == Py_NE);
+        } else if (length == 1) {
+            return (equals == Py_EQ);
+        } else {
+            int result;
+#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
+            Py_hash_t hash1, hash2;
+            hash1 = ((PyBytesObject*)s1)->ob_shash;
+            hash2 = ((PyBytesObject*)s2)->ob_shash;
+            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
+                return (equals == Py_NE);
+            }
+#endif
+            result = memcmp(ps1, ps2, (size_t)length);
+            return (equals == Py_EQ) ? (result == 0) : (result != 0);
+        }
+    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
+        return (equals == Py_NE);
+    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
+        return (equals == Py_NE);
+    } else {
+        int result;
+        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        if (!py_result)
+            return -1;
+        result = __Pyx_PyObject_IsTrue(py_result);
+        Py_DECREF(py_result);
+        return result;
     }
-    #if PY_MAJOR_VERSION < 3
-    ctx = PyString_FromString(name);
-    #else
-    ctx = PyUnicode_FromString(name);
-    #endif
-    __Pyx_ErrRestore(old_exc, old_val, old_tb);
-    if (!ctx) {
-        PyErr_WriteUnraisable(Py_None);
+#endif
+}
+
+/* UnicodeEquals */
+static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
+#if CYTHON_COMPILING_IN_PYPY
+    return PyObject_RichCompareBool(s1, s2, equals);
+#else
+#if PY_MAJOR_VERSION < 3
+    PyObject* owned_ref = NULL;
+#endif
+    int s1_is_unicode, s2_is_unicode;
+    if (s1 == s2) {
+        goto return_eq;
+    }
+    s1_is_unicode = PyUnicode_CheckExact(s1);
+    s2_is_unicode = PyUnicode_CheckExact(s2);
+#if PY_MAJOR_VERSION < 3
+    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
+        owned_ref = PyUnicode_FromObject(s2);
+        if (unlikely(!owned_ref))
+            return -1;
+        s2 = owned_ref;
+        s2_is_unicode = 1;
+    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
+        owned_ref = PyUnicode_FromObject(s1);
+        if (unlikely(!owned_ref))
+            return -1;
+        s1 = owned_ref;
+        s1_is_unicode = 1;
+    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
+        return __Pyx_PyBytes_Equals(s1, s2, equals);
+    }
+#endif
+    if (s1_is_unicode & s2_is_unicode) {
+        Py_ssize_t length;
+        int kind;
+        void *data1, *data2;
+        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
+            return -1;
+        length = __Pyx_PyUnicode_GET_LENGTH(s1);
+        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
+            goto return_ne;
+        }
+#if CYTHON_USE_UNICODE_INTERNALS
+        {
+            Py_hash_t hash1, hash2;
+        #if CYTHON_PEP393_ENABLED
+            hash1 = ((PyASCIIObject*)s1)->hash;
+            hash2 = ((PyASCIIObject*)s2)->hash;
+        #else
+            hash1 = ((PyUnicodeObject*)s1)->hash;
+            hash2 = ((PyUnicodeObject*)s2)->hash;
+        #endif
+            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
+                goto return_ne;
+            }
+        }
+#endif
+        kind = __Pyx_PyUnicode_KIND(s1);
+        if (kind != __Pyx_PyUnicode_KIND(s2)) {
+            goto return_ne;
+        }
+        data1 = __Pyx_PyUnicode_DATA(s1);
+        data2 = __Pyx_PyUnicode_DATA(s2);
+        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
+            goto return_ne;
+        } else if (length == 1) {
+            goto return_eq;
+        } else {
+            int result = memcmp(data1, data2, (size_t)(length * kind));
+            #if PY_MAJOR_VERSION < 3
+            Py_XDECREF(owned_ref);
+            #endif
+            return (equals == Py_EQ) ? (result == 0) : (result != 0);
+        }
+    } else if ((s1 == Py_None) & s2_is_unicode) {
+        goto return_ne;
+    } else if ((s2 == Py_None) & s1_is_unicode) {
+        goto return_ne;
     } else {
-        PyErr_WriteUnraisable(ctx);
-        Py_DECREF(ctx);
+        int result;
+        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        #if PY_MAJOR_VERSION < 3
+        Py_XDECREF(owned_ref);
+        #endif
+        if (!py_result)
+            return -1;
+        result = __Pyx_PyObject_IsTrue(py_result);
+        Py_DECREF(py_result);
+        return result;
     }
-#ifdef WITH_THREAD
-    if (nogil)
-        PyGILState_Release(state);
+return_eq:
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(owned_ref);
+    #endif
+    return (equals == Py_EQ);
+return_ne:
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(owned_ref);
+    #endif
+    return (equals == Py_NE);
 #endif
 }
 
-/* ExtTypeTest */
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
-    if (unlikely(!type)) {
-        PyErr_SetString(PyExc_SystemError, "Missing type object");
-        return 0;
+/* PyUnicode_Unicode */
+static CYTHON_INLINE PyObject* __Pyx_PyUnicode_Unicode(PyObject *obj) {
+    if (unlikely(obj == Py_None))
+        obj = __pyx_kp_u_None;
+    return __Pyx_NewRef(obj);
+}
+
+/* JoinPyUnicode */
+static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
+                                      CYTHON_UNUSED Py_UCS4 max_char) {
+#if CYTHON_USE_UNICODE_INTERNALS && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    PyObject *result_uval;
+    int result_ukind;
+    Py_ssize_t i, char_pos;
+    void *result_udata;
+#if CYTHON_PEP393_ENABLED
+    result_uval = PyUnicode_New(result_ulength, max_char);
+    if (unlikely(!result_uval)) return NULL;
+    result_ukind = (max_char <= 255) ? PyUnicode_1BYTE_KIND : (max_char <= 65535) ? PyUnicode_2BYTE_KIND : PyUnicode_4BYTE_KIND;
+    result_udata = PyUnicode_DATA(result_uval);
+#else
+    result_uval = PyUnicode_FromUnicode(NULL, result_ulength);
+    if (unlikely(!result_uval)) return NULL;
+    result_ukind = sizeof(Py_UNICODE);
+    result_udata = PyUnicode_AS_UNICODE(result_uval);
+#endif
+    char_pos = 0;
+    for (i=0; i < value_count; i++) {
+        int ukind;
+        Py_ssize_t ulength;
+        void *udata;
+        PyObject *uval = PyTuple_GET_ITEM(value_tuple, i);
+        if (unlikely(__Pyx_PyUnicode_READY(uval)))
+            goto bad;
+        ulength = __Pyx_PyUnicode_GET_LENGTH(uval);
+        if (unlikely(!ulength))
+            continue;
+        if (unlikely(char_pos + ulength < 0))
+            goto overflow;
+        ukind = __Pyx_PyUnicode_KIND(uval);
+        udata = __Pyx_PyUnicode_DATA(uval);
+        if (!CYTHON_PEP393_ENABLED || ukind == result_ukind) {
+            memcpy((char *)result_udata + char_pos * result_ukind, udata, (size_t) (ulength * result_ukind));
+        } else {
+            #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030300F0 || defined(_PyUnicode_FastCopyCharacters)
+            _PyUnicode_FastCopyCharacters(result_uval, char_pos, uval, 0, ulength);
+            #else
+            Py_ssize_t j;
+            for (j=0; j < ulength; j++) {
+                Py_UCS4 uchar = __Pyx_PyUnicode_READ(ukind, udata, j);
+                __Pyx_PyUnicode_WRITE(result_ukind, result_udata, char_pos+j, uchar);
+            }
+            #endif
+        }
+        char_pos += ulength;
     }
-    if (likely(__Pyx_TypeCheck(obj, type)))
-        return 1;
-    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
-                 Py_TYPE(obj)->tp_name, type->tp_name);
-    return 0;
+    return result_uval;
+overflow:
+    PyErr_SetString(PyExc_OverflowError, "join() result is too long for a Python string");
+bad:
+    Py_DECREF(result_uval);
+    return NULL;
+#else
+    result_ulength++;
+    value_count++;
+    return PyUnicode_Join(__pyx_empty_unicode, value_tuple);
+#endif
 }
 
 /* Import */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
     PyObject *empty_list = 0;
     PyObject *module = 0;
     PyObject *global_dict = 0;
@@ -10117,253 +12600,14 @@
         return 0;
     } else {
         Py_DECREF(r);
         return 1;
     }
 }
 
-/* IterFinish */
-static CYTHON_INLINE int __Pyx_IterFinish(void) {
-#if CYTHON_FAST_THREAD_STATE
-    PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject* exc_type = tstate->curexc_type;
-    if (unlikely(exc_type)) {
-        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
-            PyObject *exc_value, *exc_tb;
-            exc_value = tstate->curexc_value;
-            exc_tb = tstate->curexc_traceback;
-            tstate->curexc_type = 0;
-            tstate->curexc_value = 0;
-            tstate->curexc_traceback = 0;
-            Py_DECREF(exc_type);
-            Py_XDECREF(exc_value);
-            Py_XDECREF(exc_tb);
-            return 0;
-        } else {
-            return -1;
-        }
-    }
-    return 0;
-#else
-    if (unlikely(PyErr_Occurred())) {
-        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
-            PyErr_Clear();
-            return 0;
-        } else {
-            return -1;
-        }
-    }
-    return 0;
-#endif
-}
-
-/* RaiseNeedMoreValuesToUnpack */
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
-    PyErr_Format(PyExc_ValueError,
-                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
-                 index, (index == 1) ? "" : "s");
-}
-
-/* RaiseTooManyValuesToUnpack */
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
-    PyErr_Format(PyExc_ValueError,
-                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
-}
-
-/* UnpackItemEndCheck */
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
-    if (unlikely(retval)) {
-        Py_DECREF(retval);
-        __Pyx_RaiseTooManyValuesError(expected);
-        return -1;
-    }
-    return __Pyx_IterFinish();
-}
-
-/* RaiseNoneIterError */
-static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
-    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-}
-
-/* UnpackTupleError */
-static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
-    if (t == Py_None) {
-      __Pyx_RaiseNoneNotIterableError();
-    } else if (PyTuple_GET_SIZE(t) < index) {
-      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
-    } else {
-      __Pyx_RaiseTooManyValuesError(index);
-    }
-}
-
-/* UnpackTuple2 */
-static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
-        PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2, int decref_tuple) {
-    PyObject *value1 = NULL, *value2 = NULL;
-#if CYTHON_COMPILING_IN_PYPY
-    value1 = PySequence_ITEM(tuple, 0);  if (unlikely(!value1)) goto bad;
-    value2 = PySequence_ITEM(tuple, 1);  if (unlikely(!value2)) goto bad;
-#else
-    value1 = PyTuple_GET_ITEM(tuple, 0);  Py_INCREF(value1);
-    value2 = PyTuple_GET_ITEM(tuple, 1);  Py_INCREF(value2);
-#endif
-    if (decref_tuple) {
-        Py_DECREF(tuple);
-    }
-    *pvalue1 = value1;
-    *pvalue2 = value2;
-    return 0;
-#if CYTHON_COMPILING_IN_PYPY
-bad:
-    Py_XDECREF(value1);
-    Py_XDECREF(value2);
-    if (decref_tuple) { Py_XDECREF(tuple); }
-    return -1;
-#endif
-}
-static int __Pyx_unpack_tuple2_generic(PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2,
-                                       int has_known_size, int decref_tuple) {
-    Py_ssize_t index;
-    PyObject *value1 = NULL, *value2 = NULL, *iter = NULL;
-    iternextfunc iternext;
-    iter = PyObject_GetIter(tuple);
-    if (unlikely(!iter)) goto bad;
-    if (decref_tuple) { Py_DECREF(tuple); tuple = NULL; }
-    iternext = Py_TYPE(iter)->tp_iternext;
-    value1 = iternext(iter); if (unlikely(!value1)) { index = 0; goto unpacking_failed; }
-    value2 = iternext(iter); if (unlikely(!value2)) { index = 1; goto unpacking_failed; }
-    if (!has_known_size && unlikely(__Pyx_IternextUnpackEndCheck(iternext(iter), 2))) goto bad;
-    Py_DECREF(iter);
-    *pvalue1 = value1;
-    *pvalue2 = value2;
-    return 0;
-unpacking_failed:
-    if (!has_known_size && __Pyx_IterFinish() == 0)
-        __Pyx_RaiseNeedMoreValuesError(index);
-bad:
-    Py_XDECREF(iter);
-    Py_XDECREF(value1);
-    Py_XDECREF(value2);
-    if (decref_tuple) { Py_XDECREF(tuple); }
-    return -1;
-}
-
-/* dict_iter */
-static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* iterable, int is_dict, PyObject* method_name,
-                                                   Py_ssize_t* p_orig_length, int* p_source_is_dict) {
-    is_dict = is_dict || likely(PyDict_CheckExact(iterable));
-    *p_source_is_dict = is_dict;
-    if (is_dict) {
-#if !CYTHON_COMPILING_IN_PYPY
-        *p_orig_length = PyDict_Size(iterable);
-        Py_INCREF(iterable);
-        return iterable;
-#elif PY_MAJOR_VERSION >= 3
-        static PyObject *py_items = NULL, *py_keys = NULL, *py_values = NULL;
-        PyObject **pp = NULL;
-        if (method_name) {
-            const char *name = PyUnicode_AsUTF8(method_name);
-            if (strcmp(name, "iteritems") == 0) pp = &py_items;
-            else if (strcmp(name, "iterkeys") == 0) pp = &py_keys;
-            else if (strcmp(name, "itervalues") == 0) pp = &py_values;
-            if (pp) {
-                if (!*pp) {
-                    *pp = PyUnicode_FromString(name + 4);
-                    if (!*pp)
-                        return NULL;
-                }
-                method_name = *pp;
-            }
-        }
-#endif
-    }
-    *p_orig_length = 0;
-    if (method_name) {
-        PyObject* iter;
-        iterable = __Pyx_PyObject_CallMethod0(iterable, method_name);
-        if (!iterable)
-            return NULL;
-#if !CYTHON_COMPILING_IN_PYPY
-        if (PyTuple_CheckExact(iterable) || PyList_CheckExact(iterable))
-            return iterable;
-#endif
-        iter = PyObject_GetIter(iterable);
-        Py_DECREF(iterable);
-        return iter;
-    }
-    return PyObject_GetIter(iterable);
-}
-static CYTHON_INLINE int __Pyx_dict_iter_next(
-        PyObject* iter_obj, CYTHON_NCP_UNUSED Py_ssize_t orig_length, CYTHON_NCP_UNUSED Py_ssize_t* ppos,
-        PyObject** pkey, PyObject** pvalue, PyObject** pitem, int source_is_dict) {
-    PyObject* next_item;
-#if !CYTHON_COMPILING_IN_PYPY
-    if (source_is_dict) {
-        PyObject *key, *value;
-        if (unlikely(orig_length != PyDict_Size(iter_obj))) {
-            PyErr_SetString(PyExc_RuntimeError, "dictionary changed size during iteration");
-            return -1;
-        }
-        if (unlikely(!PyDict_Next(iter_obj, ppos, &key, &value))) {
-            return 0;
-        }
-        if (pitem) {
-            PyObject* tuple = PyTuple_New(2);
-            if (unlikely(!tuple)) {
-                return -1;
-            }
-            Py_INCREF(key);
-            Py_INCREF(value);
-            PyTuple_SET_ITEM(tuple, 0, key);
-            PyTuple_SET_ITEM(tuple, 1, value);
-            *pitem = tuple;
-        } else {
-            if (pkey) {
-                Py_INCREF(key);
-                *pkey = key;
-            }
-            if (pvalue) {
-                Py_INCREF(value);
-                *pvalue = value;
-            }
-        }
-        return 1;
-    } else if (PyTuple_CheckExact(iter_obj)) {
-        Py_ssize_t pos = *ppos;
-        if (unlikely(pos >= PyTuple_GET_SIZE(iter_obj))) return 0;
-        *ppos = pos + 1;
-        next_item = PyTuple_GET_ITEM(iter_obj, pos);
-        Py_INCREF(next_item);
-    } else if (PyList_CheckExact(iter_obj)) {
-        Py_ssize_t pos = *ppos;
-        if (unlikely(pos >= PyList_GET_SIZE(iter_obj))) return 0;
-        *ppos = pos + 1;
-        next_item = PyList_GET_ITEM(iter_obj, pos);
-        Py_INCREF(next_item);
-    } else
-#endif
-    {
-        next_item = PyIter_Next(iter_obj);
-        if (unlikely(!next_item)) {
-            return __Pyx_IterFinish();
-        }
-    }
-    if (pitem) {
-        *pitem = next_item;
-    } else if (pkey && pvalue) {
-        if (__Pyx_unpack_tuple2(next_item, pkey, pvalue, source_is_dict, source_is_dict, 1))
-            return -1;
-    } else if (pkey) {
-        *pkey = next_item;
-    } else {
-        *pvalue = next_item;
-    }
-    return 1;
-}
-
 /* PyObject_GenericGetAttrNoDict */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
     PyErr_Format(PyExc_AttributeError,
 #if PY_MAJOR_VERSION >= 3
                  "'%.50s' object has no attribute '%U'",
                  tp->tp_name, attr_name);
```

### Comparing `multimcts-0.4.2/multimcts/mcts.pyx` & `multimcts-0.5/multimcts/mcts.pyx`

 * *Files 18% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 # distutils: language=c++
 # cython: language_level=3
 # cython: profile=False
 
 from time import time
 from random import shuffle, choice
-from typing import Union, Dict, List, Any
+from typing import Union, Dict, List, Hashable
 
+cimport cython
 from libc.math cimport log, sqrt, INFINITY
 from libcpp.map cimport map
 from libcpp.string cimport string
 from libcpp.pair cimport pair
-cimport cython
 
 
-Move = Any # MCTS does not care about the contents of a move; it merely passes the output of get_legal_moves() to make_move(), both of which are handled by the user.
+Move = Hashable # Moves can be any type, as long as they can be added to a set and used as dict keys.
 Team = Union[int,str]
 Rewards = Dict[Team,float]
 
 
 class GameState:
     def get_current_team(self) -> Team:
         """The identifier of the current player's team."""
@@ -34,248 +34,318 @@
         raise NotImplementedError("GameState must implement make_move.")
 
     def is_terminal(self) -> bool:
         """Is the game over?"""
         raise NotImplementedError("GameState must implement is_terminal.")
 
     def get_reward(self) -> Union[float,Rewards]:
-        """The reward earned by the team that played the game-ending move (the "terminal team", or the team from the previous state).
+        """The reward earned by the team that played the game-ending move (i.e. the team from the previous state).
         Typically 1 for win, -1 for loss, 0 for draw.
         Alternatively, returns a dict of teams/rewards: {team1:reward1, team2:reward2, ...}
         Note: This method is only called on terminal states.
         """
         raise NotImplementedError("GameState must implement get_reward.")
 
+    '''#.WIP
+    def simulate(self) -> ('GameState', 'GameState'):
+        """Simulate a game beginning from this state.
+        The default implementation plays random moves until termination.
+        This method may be overridden with a heuristic to guide the playout.
+        Note: This method is only called on non-terminal nodes.
+        Returns:
+            state (GameState): The final (terminal) state of the simulation.
+            prev_state (GameState): The penultimate state of the simulation. This is used by MCTS to propagate rewards to the correct teams.
+        """
+        state = self
+        prev_state = None
+        while not state.is_terminal():
+            prev_state = state
+            state = state.make_move(choice(state.get_legal_moves()))
+        return (state, prev_state)
+    '''
+
 
 cdef class Node:
     """Represents a game state node in the MCTS search tree.
     Args:
         state (GameState): The game state at the current node.
         parent (Node): The parent of the current node in the search tree.
         move (Move): The move that was played from the parent node to get to this node.
     Attributes:
-        children (List[Node]): The child nodes of the current node. These represent legal moves that have been visited.
+        children (Dict[Move,Node]): The child nodes of the current node. These represent legal moves that have been visited.
         visits (int): The number of times the node has been visited.
         rewards (dict): All teams' rewards obtained from simulations through the node. Keys are teams; values are rewards.
         is_terminal (bool): Whether the node represents a terminal state.
         is_fully_expanded (bool): Whether all children of the node have been visited.
         remaining_moves (list): A list of moves that have not yet been tried.
     """
-    cdef state, move, team
-    cdef string cteam
+    cdef state, move, children, remaining_moves
     cdef Node parent
-    cdef children, remaining_moves
-    cdef map[string,double] rewards
-    cdef int visits
+    cdef string team
+    cdef map[string,double] rewards, rave_rewards
+    cdef int visits, rave_visits
     cdef bint is_terminal, is_fully_expanded
-    cdef double avg_reward, sqrtlog_visits, invsqrt_visits
+    cdef double sqrtlog_visits, invsqrt_visits, avg_reward, avg_rave_reward
 
     def __init__(self, state:GameState, parent:'Node'=None, move:Move=None):
         self.state = state
         self.parent = parent
         self.move = move
 
-        self.children:List['Node'] = []
+        self.children:Dict[Move,'Node'] = {}
         self.visits = 0
+        self.rave_visits = 0
         self.rewards = map[string,double]()
+        self.rave_rewards = map[string,double]()
         self.is_terminal = self.state.is_terminal()
         self.is_fully_expanded = self.is_terminal
         if self.is_fully_expanded:
             self.remaining_moves = []
         else:
             self.remaining_moves = self.state.get_legal_moves()
             shuffle(self.remaining_moves)
 
         # The following are cached for performance.
-        self.team = self.state.get_current_team()
-        self.cteam = str(self.team).encode()
+        self.team = str(self.state.get_current_team()).encode()
         if self.parent is not None:
-            self.rewards[self.parent.cteam] = 0
+            self.rewards[self.parent.team] = 0
+            self.rave_rewards[self.parent.team] = 0
         self.sqrtlog_visits = 0
         self.invsqrt_visits = 0
         self.avg_reward = 0
+        self.avg_rave_reward = 0
 
-    @property
-    def state(self) -> GameState: return self.state
-    @property
-    def rewards(self): return self.rewards
+    def get_state(self) -> GameState: return self.state
+    def get_team(self) -> str: return self.team.decode()
+    def get_move(self) -> Move: return self.move
+
+    def get_parent(self) -> 'Node': return self.parent
+    def get_children(self) -> Dict[Move,'Node']: return self.children
+
+    def get_visits(self) -> int: return self.visits
+    def get_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rewards}
+    def get_avg_reward(self) -> double: return self.avg_reward
+
+    def get_rave_visits(self) -> int: return self.rave_visits
+    def get_rave_rewards(self) -> dict: return {item.first.decode():item.second for item in self.rave_rewards}
+    def get_avg_rave_reward(self) -> double: return self.avg_rave_reward
 
     @cython.cdivision(True)
-    cdef apply_rewards(self, map[string,double] crewards):
+    cdef visit(self, map[string,double] crewards, moves):
         """Update this node's visits and rewards, and cache some variables for more efficient UCB calculation."""
         self.visits += 1
 
-        self.sqrtlog_visits = sqrt(log(self.visits))
-        self.invsqrt_visits = 1 / sqrt(self.visits)
+        self.sqrtlog_visits = sqrtlog(self.visits)
+        self.invsqrt_visits = invsqrt(self.visits)
 
+        # Update regular rewards.
         cdef pair[string,double] item
-        cdef double total_rewards = 0
+        cdef double total_reward = 0
         for item in crewards:
             if self.rewards.count(item.first) == 0:
                 self.rewards[item.first] = 0
             self.rewards[item.first] += item.second
-            total_rewards += self.rewards[item.first]
-
+            total_reward += self.rewards[item.first]
         if self.parent is not None:
-            # Average reward is (reward for my parent's team - rewards for all other teams) / num visits to this node.
-            self.avg_reward = ((2 * self.rewards[self.parent.cteam]) - total_rewards) / self.visits
+            # Average reward: (reward for my parent's team - rewards for all other teams) / num visits to this node
+            self.avg_reward = ((2*self.rewards[self.parent.team]) - total_reward) / self.visits
+
+        # Update RAVE rewards.
+        cdef int rave_visits = 0
+        cdef double total_rave_reward = 0
+        for move in list(self.children.keys()) + self.remaining_moves:
+            if move in moves:
+                rave_visits += 1
+        if rave_visits > 0:
+            self.rave_visits += rave_visits
+            for item in crewards:
+                if self.rave_rewards.count(item.first) == 0:
+                    self.rave_rewards[item.first] = 0
+                self.rave_rewards[item.first] += rave_visits * item.second
+                total_rave_reward += self.rave_rewards[item.first]
+            if self.parent is not None:
+                self.avg_rave_reward = ((2*self.rave_rewards[self.parent.team]) - total_rave_reward) / self.rave_visits
+
+    cpdef double uncertainty(self, double exploration_bias):
+        return exploration_bias * self.parent.sqrtlog_visits * self.invsqrt_visits
 
-    cdef double ucb(self, double exploration_bias, double parent_sqrtlog_visits):
+    cpdef double ucb(self, double exploration_bias):
         """Upper Confidence Bound
         ucb = (x / n) + C * sqrt(ln(N) / n)
         x=reward for this node
         n=number of simulations for this node
         N=number of simulations for parent node
         C=exploration bias
         """
-        # ucb = avgR + C * sqrt(ln(N)) * (1/sqrt(n))
-        return self.avg_reward + exploration_bias * parent_sqrtlog_visits * self.invsqrt_visits
+        return self.avg_reward + self.uncertainty(exploration_bias)
+
+    @cython.cdivision(True)
+    cpdef double rave_beta(self, double b):
+        """Determines the relative weight of RAVE rewards in the final score calculation.
+        As this node is visited more times, the RAVE effect diminishes.
+        The number of RAVE visits has little bearing on this value (the function's curve looks the same for all large values of rave_visits).
+        https://www.desmos.com/calculator/drlccftt6a
+        """
+        if self.rave_visits == 0 or b == 0:
+            return 0
+        elif self.visits == 0:
+            return 1
+        cdef int n1 = self.visits, n2 = self.rave_visits
+        return n2 / (n1 + n2 + 4*n1*n2/(b**2))
+
+    cpdef double score(self, double exploration_bias, double rave_bias):
+        cdef double rave_beta = self.rave_beta(rave_bias)
+        return (rave_beta * self.avg_rave_reward) + ((1-rave_beta) * self.avg_reward) + self.uncertainty(exploration_bias)
+
+    @cython.wraparound(False)
+    @cython.boundscheck(False)
+    cdef Node best_child(self, double exploration_bias, double rave_bias):
+        cdef Node child, best_child = next(iter(self.children.values()))
+        cdef double score, best_score = -INFINITY
+        for move, child in self.children.items():
+            score = child.score(exploration_bias, rave_bias)
+            if score > best_score:
+                best_score = score
+                best_child = child
+        return best_child
+
+    cdef Node select(self, double exploration_bias, double rave_bias):
+        cdef Node node = self
+        while not node.is_terminal:
+            if node.is_fully_expanded:
+                node = node.best_child(exploration_bias, rave_bias)
+            else:
+                return node.expand()
+        return node
+
+    cdef Node expand(self):
+        move = self.remaining_moves.pop()
+        if len(self.remaining_moves) == 0:
+            self.is_fully_expanded = True
+        cdef Node child = Node(state=self.state.make_move(move), parent=self, move=move)
+        self.children[move] = child
+        return child
+
+    cdef void execute_round(self, double exploration_bias, double rave_bias):
+        """Step 1,2: Selection,Expansion"""
+        cdef Node node = self.select(exploration_bias, rave_bias)
+
+        """Step 3: Simulation"""
+        state = node.state
+        prev_state = None
+        moves = set()
+        if not node.is_terminal:
+            while not state.is_terminal():
+                prev_state = state
+                move = choice(state.get_legal_moves())
+                moves.add(move)
+                state = state.make_move(move)
+        reward = state.get_reward()
+        if not isinstance(reward, dict):
+            terminal_team = None
+            if node.is_terminal:
+                terminal_team = node.parent.state.get_current_team()
+            elif prev_state is not None:
+                terminal_team = prev_state.get_current_team()
+            else:
+                raise ValueError("Could not determine terminal team during simulation.")
+            reward = {terminal_team: reward}
+        cdef map[string,double] crewards = map[string,double]()
+        for team in reward:
+            if reward[team] == 0:
+                continue
+            crewards[str(team).encode()] = float(reward[team])
+
+        """Step 4: Backpropagation"""
+        while node is not None:
+            node.visit(crewards, moves)
+            node = node.parent
 
 
 cdef class MCTS:
-    cdef double exploration_bias
+    cdef double exploration_bias, rave_bias
 
-    def __init__(self, exploration_bias:float=1.414):
+    def __init__(self, exploration_bias:float=1.414, rave_bias:float=0):
         """Initializes an MCTS agent.
         Args:
             exploration_bias (float): The exploration bias, which balances exploration (favoring untested moves) and exploitation (favoring good moves).
                 The default 2 is often used in practice. However, the optimal value depends on the game and is usually found by experimentation.
         """
         self.exploration_bias = exploration_bias
+        self.rave_bias = rave_bias
 
     @property
     def exploration_bias(self) -> float: return self.exploration_bias
+    @property
+    def rave_bias(self) -> float: return self.rave_bias
 
-    def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, heuristic=None, return_type:str="state") -> Union[GameState,Move,Node]:
+    def search(self, state:GameState, *, max_time:Union[int,float]=None, max_iterations:int=None, return_type:str="state") -> Union[GameState,Move,Node]:
         """Searches for this state's best move until some limit has been reached.
         Args:
             state (GameState): The game state for which to find the best move.
             max_time (int|float): The maximum time to search, in seconds.
             max_iterations (int): The maximum number of selections/simulations to perform.
-            heuristic (callable): A function that takes a state and returns a move. See simulate() for more information.
             return_type (str): One of "state", "move", or "node".
         Returns:
             GameState: A new game state which is the result of applying the best move to the given state.
         """
-        return_type = return_type.lower()
-        VALID_RETURN_TYPES = {"state","move","node"}
-        if return_type not in VALID_RETURN_TYPES:
-            raise ValueError(f'Invalid return type: {return_type}, must be one of {VALID_RETURN_TYPES}')
-
         if max_time is None and max_iterations is None:
-            raise ValueError("One or more of max_time/max_iterations is required.")
+            raise ValueError('One or more of max_time/max_iterations is required.')
+
+        if return_type not in {'state','move','node'}:
+            raise ValueError(f'Invalid return_type "{return_type}" must be one of {{"state","move","node"}}')
 
         node = Node(state)
 
         cdef double end_time
         cdef int i = 0
         if max_time is not None:
             end_time = time() + max_time
 
         while True:
-            child = self.select(node)
-            rewards = self.simulate(child, heuristic=heuristic)
-            self.backpropagate(child, rewards)
-
-            # If there is only one legal move, we don't need to search.
-            if node.is_fully_expanded and len(node.children) == 1:
-                break
+            node.execute_round(self.exploration_bias, self.rave_bias)
 
             if max_time is not None:
                 if time() >= end_time:
                     break
             if max_iterations is not None:
                 i += 1
                 if i >= max_iterations:
                     break
 
-        cdef Node best = self.get_best_child(node)
+        # We've performed the full search above using the desired biases.
+        # For the final pick we will be a bit more exploitative and a bit less RAVEy.
+        cdef Node best = node.best_child(self.exploration_bias*0.9, self.rave_bias*0.9)
 
         if return_type == "state":
             return best.state
         elif return_type == "move":
             return best.move
         elif return_type == "node":
             return best
 
-    cdef Node select(self, Node node):
-        """Step 1: Selection
-        Traverse the tree for the node we most want to simulate.
-        Looks for an unexplored child of this node's best child's best child's...best child.
-        """
-        while not node.is_terminal:
-            if not node.is_fully_expanded:
-                return self.expand(node)
-            else:
-                node = self.get_best_child(node)
-        return node
-
-    cdef Node expand(self, Node node):
-        """Step 2: Expansion
-        Add a new child to this node.
-        """
-        move = node.remaining_moves.pop()
-        if len(node.remaining_moves) == 0:
-            node.is_fully_expanded = True
-
-        cdef Node child = Node(state=node.state.make_move(move), parent=node, move=move)
-        node.children.append(child)
-
-        return child
-
-    cdef map[string,double] simulate(self, Node node, heuristic=None):
-        """Step 3: Simulation (aka playout/rollout)
-        Play out a game, from the given node to termination, and return the final reward.
-        A heuristic function may be used to guide the simulation. Otherwise, moves are chosen randomly.
-        Args:
-            node (Node): The node from which to begin the simulation.
-            heuristic (callable): A function that takes a state and returns a move.
-        """
-        state = node.state
 
-        terminal_team = None
-        if node.is_terminal:
-            terminal_team = node.parent.team
-        else:
-            while not state.is_terminal():
-                terminal_team = state.get_current_team()
-                if heuristic is not None:
-                    move = heuristic(state)
-                else:
-                    move = choice(state.get_legal_moves())
-                state = state.make_move(move)
-
-        reward = state.get_reward()
-        if not isinstance(reward, dict):
-            reward = {terminal_team: reward}
-
-        cdef map[string,double] crewards = map[string,double]()
-        for team in reward:
-            if reward[team] == 0:
-                continue
-            crewards[str(team).encode()] = float(reward[team])
-
-        return crewards
-
-    cdef backpropagate(self, Node node, map[string,double] crewards):
-        """Step 4: Backpropagation
-        Update all ancestors with the reward from this terminal node.
-        """
-        while node is not None:
-            node.apply_rewards(crewards)
-            node = node.parent
-
-    cdef Node get_best_child(self, Node node):
-        """Find the child with the highest Upper Confidence Bound (UCB)."""
-        cdef double parent_sqrtlog_visits = node.sqrtlog_visits
-        cdef double best_score = -INFINITY
-        cdef double ucb
-        cdef Node child, best_child = node.children[0]
-        cdef pair[string,double] item
-
-        for child in node.children:
-            ucb = child.ucb(self.exploration_bias, parent_sqrtlog_visits)
-            if ucb > best_score:
-                best_score = ucb
-                best_child = child
-
-        return best_child
+# Cache some frequently calculated values to speed up Node visits.
+cdef double SQRTLOG[10000]
+cdef double INVSQRT[10000]
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+cdef double sqrtlog(int x):
+    return SQRTLOG[x] if 0 <= x < 10000 else sqrt(log(x))
+@cython.cdivision(True)
+@cython.boundscheck(False)
+@cython.wraparound(False)
+cdef double invsqrt(int x):
+    return INVSQRT[x] if 0 <= x < 10000 else 1 / sqrt(x)
+
+@cython.cdivision(True)
+@cython.boundscheck(False)
+@cython.wraparound(False)
+cdef void precalc():
+    SQRTLOG[0] = 0
+    INVSQRT[0] = 0
+    cdef int x = 0
+    for x in range(1,10000):
+        SQRTLOG[x] = sqrt(log(x))
+        INVSQRT[x] = 1 / sqrt(x)
+precalc()
```

### Comparing `multimcts-0.4.2/multimcts.egg-info/PKG-INFO` & `multimcts-0.5/multimcts.egg-info/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: multimcts
-Version: 0.4.2
+Version: 0.5
 Summary: Monte Carlo Tree Search for multiple teams
 Home-page: https://github.com/taylorvance/multimcts
 Author: Taylor Vance
 Author-email: mirrors.cities0w@icloud.com
 License: MIT
 Platform: UNKNOWN
 Description-Content-Type: text/markdown
```

### Comparing `multimcts-0.4.2/setup.py` & `multimcts-0.5/setup.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from setuptools import setup, find_packages, Extension
 from Cython.Build import cythonize
 
 setup(
     name='multimcts',
-    version='0.4.2',
+    version='0.5',
     description='Monte Carlo Tree Search for multiple teams',
     author='Taylor Vance',
     author_email='mirrors.cities0w@icloud.com',
     long_description=open('README.md').read(),
     long_description_content_type='text/markdown',
     license='MIT',
     url='https://github.com/taylorvance/multimcts',
```

