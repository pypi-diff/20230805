# Comparing `tmp/biogeme-3.2.8.tar.gz` & `tmp/biogeme-3.2.9.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "biogeme-3.2.8.tar", last modified: Mon Jul 26 15:26:31 2021, max compression
+gzip compressed data, was "biogeme-3.2.9.tar", last modified: Fri Aug 19 13:57:21 2022, max compression
```

## Comparing `biogeme-3.2.8.tar` & `biogeme-3.2.9.tar`

### file list

```diff
@@ -1,372 +1,518 @@
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.601216 biogeme-3.2.8/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      114 2020-09-28 15:20:12.000000 biogeme-3.2.8/MANIFEST.in
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1079 2021-07-26 15:26:31.600992 biogeme-3.2.8/PKG-INFO
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      508 2020-06-18 13:06:25.000000 biogeme-3.2.8/README.md
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.355819 biogeme-3.2.8/biogeme/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      179 2021-07-16 15:47:00.000000 biogeme-3.2.8/biogeme/__init__.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    66940 2021-07-17 13:34:02.000000 biogeme-3.2.8/biogeme/algorithms.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    61431 2021-07-22 09:23:14.000000 biogeme-3.2.8/biogeme/assisted.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    51096 2021-07-19 13:03:49.000000 biogeme-3.2.8/biogeme/biogeme.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    36487 2021-07-17 14:37:47.000000 biogeme-3.2.8/biogeme/database.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5425 2021-07-16 16:13:53.000000 biogeme-3.2.8/biogeme/distributions.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    18008 2021-07-16 16:20:17.000000 biogeme-3.2.8/biogeme/draws.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      243 2021-07-14 16:39:59.000000 biogeme-3.2.8/biogeme/exceptions.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)   121292 2021-07-17 14:46:54.000000 biogeme-3.2.8/biogeme/expressions.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      915 2020-06-18 12:42:41.000000 biogeme-3.2.8/biogeme/filenames.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    11411 2021-07-14 16:39:59.000000 biogeme-3.2.8/biogeme/hamabs.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3388 2021-07-16 15:49:37.000000 biogeme-3.2.8/biogeme/loglikelihood.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     6115 2021-07-17 14:48:03.000000 biogeme-3.2.8/biogeme/messaging.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    56554 2021-07-16 16:27:09.000000 biogeme-3.2.8/biogeme/models.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    22540 2021-07-17 15:20:21.000000 biogeme-3.2.8/biogeme/optimization.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    51267 2021-07-17 14:56:32.000000 biogeme-3.2.8/biogeme/results.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      422 2021-07-14 15:49:29.000000 biogeme-3.2.8/biogeme/singleton.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     8663 2021-07-16 16:40:17.000000 biogeme-3.2.8/biogeme/tools.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2525 2021-07-26 15:26:22.000000 biogeme-3.2.8/biogeme/version.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    18418 2021-07-22 09:06:40.000000 biogeme-3.2.8/biogeme/vns.py
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.358142 biogeme-3.2.8/biogeme.egg-info/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1079 2021-07-26 15:26:31.000000 biogeme-3.2.8/biogeme.egg-info/PKG-INFO
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    11207 2021-07-26 15:26:31.000000 biogeme-3.2.8/biogeme.egg-info/SOURCES.txt
--rw-r--r--   0 michelbierlaire   (501) staff       (20)        1 2021-07-26 15:26:31.000000 biogeme-3.2.8/biogeme.egg-info/dependency_links.txt
--rw-r--r--   0 michelbierlaire   (501) staff       (20)       41 2021-07-26 15:26:31.000000 biogeme-3.2.8/biogeme.egg-info/requires.txt
--rw-r--r--   0 michelbierlaire   (501) staff       (20)       21 2021-07-26 15:26:31.000000 biogeme-3.2.8/biogeme.egg-info/top_level.txt
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.359433 biogeme-3.2.8/examples/
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.369793 biogeme-3.2.8/examples/assisted/
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.372809 biogeme-3.2.8/examples/assisted/.ipynb_checkpoints/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    44826 2020-12-22 07:40:43.000000 biogeme-3.2.8/examples/assisted/.ipynb_checkpoints/paretoAirline-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    51555 2020-12-29 13:39:17.000000 biogeme-3.2.8/examples/assisted/.ipynb_checkpoints/paretoOptima-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    23154 2021-02-22 16:49:29.000000 biogeme-3.2.8/examples/assisted/.ipynb_checkpoints/paretoTest-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    12937 2021-07-22 11:30:06.000000 biogeme-3.2.8/examples/assisted/airline.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     8572 2021-07-19 16:12:47.000000 biogeme-3.2.8/examples/assisted/optima.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    93084 2021-07-23 09:29:37.000000 biogeme-3.2.8/examples/assisted/paretoAirline.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    29913 2021-07-22 09:52:34.000000 biogeme-3.2.8/examples/assisted/paretoOptima.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2020-12-21 14:58:02.000000 biogeme-3.2.8/examples/assisted/swissmetro.dat
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    10192 2021-07-19 16:13:54.000000 biogeme-3.2.8/examples/assisted/swissmetro.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3839 2021-07-26 08:30:03.000000 biogeme-3.2.8/examples/checkhtml.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1158 2021-07-21 08:57:38.000000 biogeme-3.2.8/examples/generateNotebooks.py
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.379104 biogeme-3.2.8/examples/indicators/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3016 2021-07-19 13:23:53.000000 biogeme-3.2.8/examples/indicators/01nestedEstimation.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4270 2021-07-19 13:25:32.000000 biogeme-3.2.8/examples/indicators/02nestedPlot.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     8546 2021-07-19 13:26:43.000000 biogeme-3.2.8/examples/indicators/02nestedSimulation.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     6650 2021-07-19 13:33:25.000000 biogeme-3.2.8/examples/indicators/03nestedElasticities.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     6068 2021-07-19 13:33:32.000000 biogeme-3.2.8/examples/indicators/04nestedElasticities.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5355 2021-07-19 13:31:07.000000 biogeme-3.2.8/examples/indicators/05nestedElasticities.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     8201 2021-07-19 13:23:32.000000 biogeme-3.2.8/examples/indicators/05nestedElasticitiesCI_Bootstrap.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     7449 2021-07-19 13:34:43.000000 biogeme-3.2.8/examples/indicators/05nestedElasticitiesConfidenceIntervals.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     6121 2021-07-19 13:32:42.000000 biogeme-3.2.8/examples/indicators/06nestedWTP.py
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.386006 biogeme-3.2.8/examples/latent/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2017 2021-07-19 16:20:54.000000 biogeme-3.2.8/examples/latent/00factorAnalysis.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     6397 2021-07-19 16:34:01.000000 biogeme-3.2.8/examples/latent/01oneLatentRegression.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     9478 2021-07-19 16:33:57.000000 biogeme-3.2.8/examples/latent/02oneLatentOrdered.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5642 2021-07-19 16:33:52.000000 biogeme-3.2.8/examples/latent/03choiceOnly.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5501 2021-07-19 16:33:47.000000 biogeme-3.2.8/examples/latent/03choiceOnly_mc.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     6402 2021-07-19 16:33:43.000000 biogeme-3.2.8/examples/latent/04latentChoiceSeq.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     6358 2021-07-20 06:28:37.000000 biogeme-3.2.8/examples/latent/04latentChoiceSeq_mc.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    13667 2021-07-19 16:27:17.000000 biogeme-3.2.8/examples/latent/05latentChoiceFull.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    13650 2021-07-23 09:32:58.000000 biogeme-3.2.8/examples/latent/05latentChoiceFull_mc.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    13883 2021-07-19 16:33:28.000000 biogeme-3.2.8/examples/latent/06serialCorrelation.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     9838 2021-07-19 16:33:23.000000 biogeme-3.2.8/examples/latent/07problem.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     9369 2021-07-19 16:33:17.000000 biogeme-3.2.8/examples/latent/07problem_simul.py
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.388334 biogeme-3.2.8/examples/latentbis/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4433 2021-07-19 16:38:22.000000 biogeme-3.2.8/examples/latentbis/m01_latent_variable.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     6229 2021-07-19 17:19:49.000000 biogeme-3.2.8/examples/latentbis/m02_sequential_estimation.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     9338 2021-07-19 17:25:17.000000 biogeme-3.2.8/examples/latentbis/m03_simultaneous_estimation.py
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.398269 biogeme-3.2.8/examples/montecarlo/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1544 2021-07-21 08:59:18.000000 biogeme-3.2.8/examples/montecarlo/01simpleIntegral.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4570 2021-07-21 09:00:20.000000 biogeme-3.2.8/examples/montecarlo/02simpleIntegral.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2627 2021-07-21 09:01:23.000000 biogeme-3.2.8/examples/montecarlo/03antithetic.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2619 2021-07-21 09:03:15.000000 biogeme-3.2.8/examples/montecarlo/03antitheticExplicit.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2284 2021-07-21 09:03:59.000000 biogeme-3.2.8/examples/montecarlo/04normalMixtureNumerical.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3268 2021-07-21 09:05:08.000000 biogeme-3.2.8/examples/montecarlo/05normalMixtureMonteCarlo.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2553 2021-07-21 09:05:43.000000 biogeme-3.2.8/examples/montecarlo/06estimationIntegral.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2464 2021-07-21 09:06:59.000000 biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2475 2021-07-21 09:22:16.000000 biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_500.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2506 2021-07-21 09:24:38.000000 biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_anti.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2507 2021-07-21 09:23:05.000000 biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_anti_500.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2505 2021-07-21 09:22:39.000000 biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_halton.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2510 2021-07-21 09:24:07.000000 biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_halton_500.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2525 2021-07-21 09:22:53.000000 biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_mlhs.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2532 2021-07-21 09:20:30.000000 biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_mlhs_500.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2551 2021-07-21 09:20:03.000000 biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_mlhs_anti.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2561 2021-07-21 09:09:09.000000 biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_mlhs_anti_500.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2020-06-18 12:42:41.000000 biogeme-3.2.8/examples/montecarlo/swissmetro.dat
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.420561 biogeme-3.2.8/examples/notebooks/
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.436160 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    35948 2021-07-19 09:12:03.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/FirstModelWithPandasBiogeme-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    35974 2021-07-19 09:12:20.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/My first model-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    29836 2021-07-19 09:11:03.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.algorithms-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    43201 2021-07-19 08:50:40.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.biogeme-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    71442 2021-07-19 08:55:44.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.database-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    10773 2021-07-19 08:55:58.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.distributions-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    25558 2021-07-19 08:56:17.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.draws-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    54256 2021-07-19 08:56:43.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.expressions-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4062 2021-07-19 08:56:54.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.filenames-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     7868 2021-07-19 08:57:09.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.loglikelihood-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     9309 2021-07-19 08:57:23.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.messaging-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    64467 2021-07-19 09:00:42.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.models-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    49678 2021-07-19 09:07:10.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.optimization-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    34029 2021-07-19 09:11:20.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.results-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    14881 2021-07-19 09:11:34.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.tools-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5094 2021-07-19 09:11:48.000000 biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.version-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    35948 2021-07-19 09:12:03.000000 biogeme-3.2.8/examples/notebooks/FirstModelWithPandasBiogeme.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5891 2020-06-18 12:42:41.000000 biogeme-3.2.8/examples/notebooks/Hamabs.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    35974 2021-07-19 09:12:20.000000 biogeme-3.2.8/examples/notebooks/My first model.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    29836 2021-07-19 09:11:03.000000 biogeme-3.2.8/examples/notebooks/biogeme.algorithms.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    43201 2021-07-19 08:50:40.000000 biogeme-3.2.8/examples/notebooks/biogeme.biogeme.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    71442 2021-07-19 08:55:44.000000 biogeme-3.2.8/examples/notebooks/biogeme.database.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    10773 2021-07-19 08:55:58.000000 biogeme-3.2.8/examples/notebooks/biogeme.distributions.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    25558 2021-07-19 08:56:17.000000 biogeme-3.2.8/examples/notebooks/biogeme.draws.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    54256 2021-07-19 08:56:43.000000 biogeme-3.2.8/examples/notebooks/biogeme.expressions.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4062 2021-07-19 08:56:54.000000 biogeme-3.2.8/examples/notebooks/biogeme.filenames.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     7868 2021-07-19 08:57:09.000000 biogeme-3.2.8/examples/notebooks/biogeme.loglikelihood.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     9309 2021-07-19 08:57:23.000000 biogeme-3.2.8/examples/notebooks/biogeme.messaging.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    64467 2021-07-19 09:00:42.000000 biogeme-3.2.8/examples/notebooks/biogeme.models.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    49678 2021-07-19 09:07:10.000000 biogeme-3.2.8/examples/notebooks/biogeme.optimization.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    34029 2021-07-19 09:11:20.000000 biogeme-3.2.8/examples/notebooks/biogeme.results.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    14881 2021-07-19 09:11:34.000000 biogeme-3.2.8/examples/notebooks/biogeme.tools.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5094 2021-07-19 09:11:48.000000 biogeme-3.2.8/examples/notebooks/biogeme.version.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2021-07-19 09:17:31.000000 biogeme-3.2.8/examples/notebooks/swissmetro.dat
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.460428 biogeme-3.2.8/examples/swissmetro/
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.466672 biogeme-3.2.8/examples/swissmetro/.ipynb_checkpoints/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3461 2020-06-18 12:42:41.000000 biogeme-3.2.8/examples/swissmetro/.ipynb_checkpoints/01logit-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2980 2020-08-26 13:24:44.000000 biogeme-3.2.8/examples/swissmetro/.ipynb_checkpoints/scitas-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)       72 2020-08-28 10:07:07.000000 biogeme-3.2.8/examples/swissmetro/.ipynb_checkpoints/tmp19-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2201 2021-07-19 09:40:41.000000 biogeme-3.2.8/examples/swissmetro/01logit.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4862 2021-07-19 10:21:16.000000 biogeme-3.2.8/examples/swissmetro/01logitBis.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3746 2021-07-19 12:26:25.000000 biogeme-3.2.8/examples/swissmetro/01logit_allAlgos.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3873 2021-07-19 12:25:43.000000 biogeme-3.2.8/examples/swissmetro/01logit_simul.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3743 2021-07-19 12:24:34.000000 biogeme-3.2.8/examples/swissmetro/02weight.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3643 2021-07-19 12:23:22.000000 biogeme-3.2.8/examples/swissmetro/03scale.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2850 2021-07-19 12:22:43.000000 biogeme-3.2.8/examples/swissmetro/04validation.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3913 2021-07-19 10:39:45.000000 biogeme-3.2.8/examples/swissmetro/05normalMixture.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3809 2021-07-19 10:39:21.000000 biogeme-3.2.8/examples/swissmetro/05normalMixtureIntegral.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     8053 2021-07-19 10:38:57.000000 biogeme-3.2.8/examples/swissmetro/05normalMixture_allAlgos.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5835 2021-07-19 10:38:08.000000 biogeme-3.2.8/examples/swissmetro/05normalMixture_simul.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3690 2021-07-19 10:36:31.000000 biogeme-3.2.8/examples/swissmetro/06unifMixture.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3799 2021-07-19 10:35:56.000000 biogeme-3.2.8/examples/swissmetro/06unifMixtureIntegral.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3939 2021-07-19 10:35:28.000000 biogeme-3.2.8/examples/swissmetro/06unifMixtureMHLS.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3718 2021-07-19 10:34:51.000000 biogeme-3.2.8/examples/swissmetro/07discreteMixture.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3356 2021-07-19 10:34:13.000000 biogeme-3.2.8/examples/swissmetro/08boxcox.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3493 2021-07-19 10:33:27.000000 biogeme-3.2.8/examples/swissmetro/09nested.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5435 2021-07-19 10:29:17.000000 biogeme-3.2.8/examples/swissmetro/09nested_allAlgos.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3697 2021-07-19 10:25:42.000000 biogeme-3.2.8/examples/swissmetro/10nestedBottom.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3596 2021-07-19 10:24:57.000000 biogeme-3.2.8/examples/swissmetro/11cnl.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4390 2021-07-19 10:24:04.000000 biogeme-3.2.8/examples/swissmetro/11cnl_simul.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3650 2021-07-19 10:23:16.000000 biogeme-3.2.8/examples/swissmetro/11cnl_sparse.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4557 2021-07-19 10:22:43.000000 biogeme-3.2.8/examples/swissmetro/12panel.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4744 2021-07-26 08:41:04.000000 biogeme-3.2.8/examples/swissmetro/13panelNormalized.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3970 2021-07-19 10:15:17.000000 biogeme-3.2.8/examples/swissmetro/14nestedEndogenousSampling.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5637 2021-07-19 09:55:43.000000 biogeme-3.2.8/examples/swissmetro/15panelDiscrete.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5721 2021-07-19 09:54:53.000000 biogeme-3.2.8/examples/swissmetro/15panelDiscreteBis.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5906 2021-07-19 09:53:57.000000 biogeme-3.2.8/examples/swissmetro/16panelDiscreteSocioEco.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3890 2021-07-19 09:51:19.000000 biogeme-3.2.8/examples/swissmetro/17lognormalMixture.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3988 2021-07-19 09:50:44.000000 biogeme-3.2.8/examples/swissmetro/17lognormalMixtureIntegral.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2710 2021-07-19 09:42:18.000000 biogeme-3.2.8/examples/swissmetro/18ordinalLogit.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3359 2021-07-19 09:49:42.000000 biogeme-3.2.8/examples/swissmetro/19individualLevelParameters.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3079 2021-07-19 09:49:03.000000 biogeme-3.2.8/examples/swissmetro/21probit.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4139 2021-07-19 09:47:41.000000 biogeme-3.2.8/examples/swissmetro/24haltonMixture.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4403 2021-07-19 09:46:53.000000 biogeme-3.2.8/examples/swissmetro/25triangularMixture.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5149 2021-07-19 09:45:49.000000 biogeme-3.2.8/examples/swissmetro/26triangularPanelMixture.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2020-06-18 12:42:41.000000 biogeme-3.2.8/examples/swissmetro/swissmetro.dat
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.467895 biogeme-3.2.8/examples/swissmetro_panel/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4080 2021-07-26 08:44:27.000000 biogeme-3.2.8/examples/swissmetro_panel/01logit_p.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4771 2021-07-21 09:48:28.000000 biogeme-3.2.8/examples/swissmetro_panel/12panel_p.py
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.472031 biogeme-3.2.8/examples/vns/
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.472428 biogeme-3.2.8/examples/vns/.ipynb_checkpoints/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    66989 2021-07-22 11:12:50.000000 biogeme-3.2.8/examples/vns/.ipynb_checkpoints/knapsack-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    66875 2021-07-22 11:13:31.000000 biogeme-3.2.8/examples/vns/knapsack.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     7319 2021-07-22 10:45:43.000000 biogeme-3.2.8/examples/vns/knapsack.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      791 2021-07-22 09:57:41.000000 biogeme-3.2.8/examples/vns/runknapsack.py
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.483363 biogeme-3.2.8/examples/workingNotToDistribute/
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.484448 biogeme-3.2.8/examples/workingNotToDistribute/.ipynb_checkpoints/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)       72 2021-07-21 13:53:38.000000 biogeme-3.2.8/examples/workingNotToDistribute/.ipynb_checkpoints/Untitled-checkpoint.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2175 2020-06-24 07:30:05.000000 biogeme-3.2.8/examples/workingNotToDistribute/01logit.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4331 2021-07-26 08:46:46.000000 biogeme-3.2.8/examples/workingNotToDistribute/01logit_simul.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4557 2021-07-26 08:46:55.000000 biogeme-3.2.8/examples/workingNotToDistribute/12panel.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3678 2021-07-21 14:03:39.000000 biogeme-3.2.8/examples/workingNotToDistribute/Untitled.ipynb
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1275 2020-10-05 08:14:49.000000 biogeme-3.2.8/examples/workingNotToDistribute/debug.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4093 2020-11-11 16:16:02.000000 biogeme-3.2.8/examples/workingNotToDistribute/new.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4093 2020-11-11 16:16:01.000000 biogeme-3.2.8/examples/workingNotToDistribute/old.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2020-06-24 07:30:09.000000 biogeme-3.2.8/examples/workingNotToDistribute/swissmetro.dat
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2250 2020-11-24 15:11:06.000000 biogeme-3.2.8/examples/workingNotToDistribute/threads.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)       38 2021-07-26 15:26:31.601287 biogeme-3.2.8/setup.cfg
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     7241 2021-03-09 17:06:34.000000 biogeme-3.2.8/setup.py
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.567197 biogeme-3.2.8/src/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3616 2021-06-25 15:55:42.000000 biogeme-3.2.8/src/#bioExprBoxcox.cc#
--rw-r--r--   0 michelbierlaire   (501) staff       (20)        0 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/__init__.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     8096 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioCfsqp.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2650 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioCfsqp.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      864 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioConst.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      439 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioDebug.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3019 2020-10-07 11:28:46.000000 biogeme-3.2.8/src/bioDerivatives.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      742 2020-09-26 15:19:02.000000 biogeme-3.2.8/src/bioDerivatives.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      319 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExceptions.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1410 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExceptions.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2013 2020-09-26 14:36:12.000000 biogeme-3.2.8/src/bioExprAnd.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      754 2020-09-26 14:35:08.000000 biogeme-3.2.8/src/bioExprAnd.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1320 2020-09-26 14:37:13.000000 biogeme-3.2.8/src/bioExprDerive.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      765 2020-09-26 14:36:32.000000 biogeme-3.2.8/src/bioExprDerive.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4644 2020-09-26 14:39:01.000000 biogeme-3.2.8/src/bioExprDivide.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      772 2020-09-26 14:37:30.000000 biogeme-3.2.8/src/bioExprDivide.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2031 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExprDraws.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      721 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExprDraws.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2935 2020-09-26 14:40:02.000000 biogeme-3.2.8/src/bioExprElem.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      824 2020-09-26 14:39:13.000000 biogeme-3.2.8/src/bioExprElem.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1944 2020-09-26 15:07:47.000000 biogeme-3.2.8/src/bioExprEqual.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      766 2020-09-26 14:40:16.000000 biogeme-3.2.8/src/bioExprEqual.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1787 2020-09-26 14:42:01.000000 biogeme-3.2.8/src/bioExprExp.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      712 2020-09-26 14:41:21.000000 biogeme-3.2.8/src/bioExprExp.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1357 2021-03-09 16:52:55.000000 biogeme-3.2.8/src/bioExprFixedParameter.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      834 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExprFixedParameter.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1317 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExprFreeParameter.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      692 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExprFreeParameter.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1560 2020-09-26 15:06:57.000000 biogeme-3.2.8/src/bioExprGaussHermite.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1031 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExprGaussHermite.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1675 2020-09-26 14:43:14.000000 biogeme-3.2.8/src/bioExprGreater.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      779 2020-09-26 14:42:22.000000 biogeme-3.2.8/src/bioExprGreater.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1706 2020-09-26 14:44:17.000000 biogeme-3.2.8/src/bioExprGreaterOrEqual.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      821 2020-09-26 14:43:30.000000 biogeme-3.2.8/src/bioExprGreaterOrEqual.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1851 2020-09-26 14:45:30.000000 biogeme-3.2.8/src/bioExprIntegrate.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      778 2020-09-26 14:44:31.000000 biogeme-3.2.8/src/bioExprIntegrate.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1607 2020-09-26 14:46:28.000000 biogeme-3.2.8/src/bioExprLess.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      761 2020-09-26 14:45:57.000000 biogeme-3.2.8/src/bioExprLess.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1670 2020-09-26 14:47:10.000000 biogeme-3.2.8/src/bioExprLessOrEqual.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      803 2020-09-26 14:46:39.000000 biogeme-3.2.8/src/bioExprLessOrEqual.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2341 2020-09-26 15:20:58.000000 biogeme-3.2.8/src/bioExprLinearUtility.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1014 2020-09-26 14:47:30.000000 biogeme-3.2.8/src/bioExprLinearUtility.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2548 2020-10-04 15:01:34.000000 biogeme-3.2.8/src/bioExprLiteral.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1223 2020-09-26 14:48:20.000000 biogeme-3.2.8/src/bioExprLiteral.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3515 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExprLiteral_current.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2242 2020-09-26 15:20:32.000000 biogeme-3.2.8/src/bioExprLog.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      712 2020-09-26 14:49:15.000000 biogeme-3.2.8/src/bioExprLog.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5351 2020-10-05 08:50:05.000000 biogeme-3.2.8/src/bioExprLogLogit.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      927 2020-09-26 14:51:42.000000 biogeme-3.2.8/src/bioExprLogLogit.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4100 2020-10-05 08:50:41.000000 biogeme-3.2.8/src/bioExprLogLogitFullChoiceSet.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      892 2020-09-26 14:52:44.000000 biogeme-3.2.8/src/bioExprLogLogitFullChoiceSet.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2269 2020-09-26 15:07:34.000000 biogeme-3.2.8/src/bioExprMax.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      756 2020-09-26 14:53:51.000000 biogeme-3.2.8/src/bioExprMax.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2266 2020-09-26 15:07:18.000000 biogeme-3.2.8/src/bioExprMin.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      756 2020-09-26 14:54:41.000000 biogeme-3.2.8/src/bioExprMin.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1669 2020-09-26 14:56:15.000000 biogeme-3.2.8/src/bioExprMinus.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      767 2020-09-26 14:55:35.000000 biogeme-3.2.8/src/bioExprMinus.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2289 2020-09-26 14:57:05.000000 biogeme-3.2.8/src/bioExprMontecarlo.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      776 2020-09-26 14:56:31.000000 biogeme-3.2.8/src/bioExprMontecarlo.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2614 2020-10-04 15:01:03.000000 biogeme-3.2.8/src/bioExprMultSum.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      787 2020-09-26 14:57:17.000000 biogeme-3.2.8/src/bioExprMultSum.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2103 2020-09-26 14:58:50.000000 biogeme-3.2.8/src/bioExprNormalCdf.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      807 2020-09-26 14:58:14.000000 biogeme-3.2.8/src/bioExprNormalCdf.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2170 2020-09-26 14:59:39.000000 biogeme-3.2.8/src/bioExprNormalPdf.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      752 2020-09-26 14:59:05.000000 biogeme-3.2.8/src/bioExprNormalPdf.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1646 2020-09-26 15:00:26.000000 biogeme-3.2.8/src/bioExprNotEqual.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      784 2020-09-26 14:59:55.000000 biogeme-3.2.8/src/bioExprNotEqual.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1061 2020-09-26 15:01:16.000000 biogeme-3.2.8/src/bioExprNumeric.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      718 2020-09-26 15:00:40.000000 biogeme-3.2.8/src/bioExprNumeric.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1999 2020-09-26 14:33:24.000000 biogeme-3.2.8/src/bioExprOr.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      748 2020-09-26 14:34:18.000000 biogeme-3.2.8/src/bioExprOr.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3949 2020-09-26 15:05:19.000000 biogeme-3.2.8/src/bioExprPanelTrajectory.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      976 2020-09-26 15:01:34.000000 biogeme-3.2.8/src/bioExprPanelTrajectory.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2465 2020-09-26 15:05:08.000000 biogeme-3.2.8/src/bioExprPlus.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      761 2020-09-26 15:02:06.000000 biogeme-3.2.8/src/bioExprPlus.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3505 2020-09-26 15:02:45.000000 biogeme-3.2.8/src/bioExprPower.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      765 2020-09-26 15:02:33.000000 biogeme-3.2.8/src/bioExprPower.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1087 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExprRandomVariable.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      791 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExprRandomVariable.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1833 2020-09-26 15:03:08.000000 biogeme-3.2.8/src/bioExprSum.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      798 2020-09-26 15:02:57.000000 biogeme-3.2.8/src/bioExprSum.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4048 2020-09-26 15:03:47.000000 biogeme-3.2.8/src/bioExprTimes.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      766 2020-09-26 15:03:33.000000 biogeme-3.2.8/src/bioExprTimes.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1364 2020-09-26 15:08:39.000000 biogeme-3.2.8/src/bioExprUnaryMinus.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      753 2020-09-26 15:04:07.000000 biogeme-3.2.8/src/bioExprUnaryMinus.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2557 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExprVariable.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      796 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioExprVariable.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3316 2021-03-09 16:52:02.000000 biogeme-3.2.8/src/bioExpression.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2508 2020-09-26 14:31:53.000000 biogeme-3.2.8/src/bioExpression.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    24568 2021-06-25 16:08:21.000000 biogeme-3.2.8/src/bioFormula.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1427 2021-03-08 17:39:13.000000 biogeme-3.2.8/src/bioFormula.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1607 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioGaussHermite.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4396 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioGaussHermite.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      848 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioGhFunction.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      788 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioGhFunction.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    15863 2021-03-08 11:49:22.000000 biogeme-3.2.8/src/bioMemoryManagement.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     6100 2021-03-08 11:49:05.000000 biogeme-3.2.8/src/bioMemoryManagement.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3496 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioNormalCdf.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      841 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioNormalCdf.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      263 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioPower.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2437 2021-03-09 16:46:53.000000 biogeme-3.2.8/src/bioSeveralExpressions.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1056 2021-03-08 11:18:00.000000 biogeme-3.2.8/src/bioSeveralExpressions.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1613 2021-03-09 16:58:24.000000 biogeme-3.2.8/src/bioSeveralFormulas.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      864 2021-03-08 11:52:56.000000 biogeme-3.2.8/src/bioSeveralFormulas.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2173 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioString.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      756 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioString.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4141 2021-03-09 13:00:40.000000 biogeme-3.2.8/src/bioThreadMemory.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1799 2021-03-08 13:30:14.000000 biogeme-3.2.8/src/bioThreadMemory.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3146 2021-03-09 16:57:52.000000 biogeme-3.2.8/src/bioThreadMemorySimul.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1589 2021-03-08 17:55:10.000000 biogeme-3.2.8/src/bioThreadMemorySimul.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      716 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/bioTypes.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    25819 2021-03-09 17:03:36.000000 biogeme-3.2.8/src/biogeme.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    24276 2021-03-08 18:08:25.000000 biogeme-3.2.8/src/biogeme.cc.tmp
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    20027 2020-11-09 11:33:07.000000 biogeme-3.2.8/src/biogeme.cc.work
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4508 2021-03-09 17:03:06.000000 biogeme-3.2.8/src/biogeme.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4272 2020-11-09 11:32:50.000000 biogeme-3.2.8/src/biogeme.h.work
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    11348 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/biogeme_working.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2091 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/biogeme_working.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)   998554 2021-07-20 07:02:56.000000 biogeme-3.2.8/src/cbiogeme.cpp
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4556 2021-03-09 17:07:26.000000 biogeme-3.2.8/src/cbiogeme.pyx
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3342 2020-09-25 13:45:49.000000 biogeme-3.2.8/src/cbiogeme.pyx.ok
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4037 2020-11-09 11:33:23.000000 biogeme-3.2.8/src/cbiogeme.pyx.work
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1991 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/cfsqpusr.h
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3486 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/main.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)   136222 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/mycfsqp.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    43492 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/myqld.cc
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2324 2020-08-06 15:15:13.000000 biogeme-3.2.8/src/panelbiogeme.h
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.567627 biogeme-3.2.8/src_keep/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)        0 2020-06-18 12:42:42.000000 biogeme-3.2.8/src_keep/__init__.py
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.567813 biogeme-3.2.8/tests/
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.572934 biogeme-3.2.8/tests/functions/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3251 2020-10-04 15:37:40.000000 biogeme-3.2.8/tests/functions/debug.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4438 2020-10-05 06:59:14.000000 biogeme-3.2.8/tests/functions/testBiogeme.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1199 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/functions/testData.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5513 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/functions/testDatabase.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     7003 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/functions/testDraws.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     8459 2021-07-17 15:45:28.000000 biogeme-3.2.8/tests/functions/testExpressions.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5954 2021-07-17 15:24:12.000000 biogeme-3.2.8/tests/functions/testOptimization.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      278 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/functions/test_all.py
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.580920 biogeme-3.2.8/tests/latent/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)   638103 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/latent/optima.dat
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5435 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/latent/test_01.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     8826 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/latent/test_02.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5437 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/latent/test_03.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5106 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/latent/test_04.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)    12085 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/latent/test_05.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      167 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/latent/test_all.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     5039 2021-07-17 15:18:46.000000 biogeme-3.2.8/tests/simple_test.py
-drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2021-07-26 15:26:31.600386 biogeme-3.2.8/tests/swissmetro/
--rw-r--r--   0 michelbierlaire   (501) staff       (20)        0 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/swissmetro/__init__.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/swissmetro/swissmetro.dat
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4102 2020-10-05 09:23:20.000000 biogeme-3.2.8/tests/swissmetro/test_01.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3399 2020-10-05 09:22:08.000000 biogeme-3.2.8/tests/swissmetro/test_01simul.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2844 2020-10-05 09:22:05.000000 biogeme-3.2.8/tests/swissmetro/test_02.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2857 2020-10-05 09:21:58.000000 biogeme-3.2.8/tests/swissmetro/test_03.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3182 2020-10-05 09:21:55.000000 biogeme-3.2.8/tests/swissmetro/test_04.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3564 2020-10-05 09:21:50.000000 biogeme-3.2.8/tests/swissmetro/test_05.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3656 2020-10-05 09:21:47.000000 biogeme-3.2.8/tests/swissmetro/test_05integral.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3609 2020-10-05 09:21:45.000000 biogeme-3.2.8/tests/swissmetro/test_06.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3731 2020-10-05 09:21:42.000000 biogeme-3.2.8/tests/swissmetro/test_06integral.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3203 2020-10-05 09:21:38.000000 biogeme-3.2.8/tests/swissmetro/test_07.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2834 2020-10-05 09:21:36.000000 biogeme-3.2.8/tests/swissmetro/test_08.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2946 2020-10-05 09:21:33.000000 biogeme-3.2.8/tests/swissmetro/test_09.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2914 2020-10-05 09:21:31.000000 biogeme-3.2.8/tests/swissmetro/test_10.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3682 2020-10-05 09:30:16.000000 biogeme-3.2.8/tests/swissmetro/test_11.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3696 2021-07-19 08:23:56.000000 biogeme-3.2.8/tests/swissmetro/test_11bis.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3128 2020-10-05 09:21:21.000000 biogeme-3.2.8/tests/swissmetro/test_12.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3211 2020-10-05 09:21:18.000000 biogeme-3.2.8/tests/swissmetro/test_12integral.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3282 2020-10-05 09:21:15.000000 biogeme-3.2.8/tests/swissmetro/test_13.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3235 2020-10-05 09:21:13.000000 biogeme-3.2.8/tests/swissmetro/test_14.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3828 2020-10-05 09:21:10.000000 biogeme-3.2.8/tests/swissmetro/test_15.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4365 2020-10-05 09:21:08.000000 biogeme-3.2.8/tests/swissmetro/test_16.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3609 2020-10-05 09:21:05.000000 biogeme-3.2.8/tests/swissmetro/test_17.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3716 2020-10-05 09:21:02.000000 biogeme-3.2.8/tests/swissmetro/test_17integral.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     1976 2020-10-05 09:20:59.000000 biogeme-3.2.8/tests/swissmetro/test_18.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     2822 2020-10-05 09:20:56.000000 biogeme-3.2.8/tests/swissmetro/test_21.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     4027 2020-10-05 09:20:53.000000 biogeme-3.2.8/tests/swissmetro/test_25.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)     3742 2020-10-05 09:20:44.000000 biogeme-3.2.8/tests/swissmetro/test_26.py
--rw-r--r--   0 michelbierlaire   (501) staff       (20)      172 2020-06-18 12:42:42.000000 biogeme-3.2.8/tests/swissmetro/test_all.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.974501 biogeme-3.2.9/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1297 2020-06-18 13:06:00.000000 biogeme-3.2.9/LICENSE
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      138 2022-05-28 12:22:32.000000 biogeme-3.2.9/MANIFEST.in
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1757 2022-08-19 13:57:21.974606 biogeme-3.2.9/PKG-INFO
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      513 2021-11-14 12:22:10.000000 biogeme-3.2.9/README.md
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.653195 biogeme-3.2.9/biogeme/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      179 2021-08-04 14:56:01.000000 biogeme-3.2.9/biogeme/__init__.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    67157 2022-08-19 13:13:51.000000 biogeme-3.2.9/biogeme/algorithms.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    63220 2022-08-18 16:17:21.000000 biogeme-3.2.9/biogeme/assisted.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    51894 2022-08-17 13:27:22.000000 biogeme-3.2.9/biogeme/biogeme.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    51981 2022-08-16 07:10:45.000000 biogeme-3.2.9/biogeme/biogeme_orig.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6648 2022-08-16 07:10:45.000000 biogeme-3.2.9/biogeme/cnl.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    41845 2022-08-16 07:10:45.000000 biogeme-3.2.9/biogeme/database.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5470 2022-08-16 08:54:36.000000 biogeme-3.2.9/biogeme/distributions.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    18317 2022-08-16 07:10:45.000000 biogeme-3.2.9/biogeme/draws.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      243 2021-08-04 14:56:01.000000 biogeme-3.2.9/biogeme/exceptions.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)   128810 2022-08-18 07:25:51.000000 biogeme-3.2.9/biogeme/expressions.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      915 2020-06-18 12:42:41.000000 biogeme-3.2.9/biogeme/filenames.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    11405 2022-08-16 07:10:45.000000 biogeme-3.2.9/biogeme/hamabs.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9324 2022-08-16 07:10:45.000000 biogeme-3.2.9/biogeme/idmanager.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3406 2022-08-16 07:10:45.000000 biogeme-3.2.9/biogeme/loglikelihood.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6118 2022-04-22 15:09:09.000000 biogeme-3.2.9/biogeme/messaging.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    57444 2022-08-16 07:10:45.000000 biogeme-3.2.9/biogeme/models.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    22538 2021-11-01 08:27:06.000000 biogeme-3.2.9/biogeme/optimization.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    57816 2022-08-16 07:10:45.000000 biogeme-3.2.9/biogeme/results.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6864 2022-08-16 07:13:34.000000 biogeme-3.2.9/biogeme/segmentation.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      422 2021-08-04 14:56:01.000000 biogeme-3.2.9/biogeme/singleton.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      789 2021-12-31 17:35:56.000000 biogeme-3.2.9/biogeme/tmp.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    25930 2022-08-17 13:26:31.000000 biogeme-3.2.9/biogeme/tools.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2525 2022-08-15 06:46:20.000000 biogeme-3.2.9/biogeme/version.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    18417 2021-11-01 08:27:06.000000 biogeme-3.2.9/biogeme/vns.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.655752 biogeme-3.2.9/biogeme.egg-info/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1757 2022-08-19 13:57:21.000000 biogeme-3.2.9/biogeme.egg-info/PKG-INFO
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    17177 2022-08-19 13:57:21.000000 biogeme-3.2.9/biogeme.egg-info/SOURCES.txt
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)        1 2022-08-19 13:57:21.000000 biogeme-3.2.9/biogeme.egg-info/dependency_links.txt
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)       14 2022-08-19 13:57:21.000000 biogeme-3.2.9/biogeme.egg-info/requires.txt
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)       12 2022-08-19 13:57:21.000000 biogeme-3.2.9/biogeme.egg-info/top_level.txt
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    14000 2022-07-22 06:58:25.000000 biogeme-3.2.9/cysetuptools.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.658649 biogeme-3.2.9/examples/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     7323 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/_tmp.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.674569 biogeme-3.2.9/examples/assisted/
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.677376 biogeme-3.2.9/examples/assisted/.ipynb_checkpoints/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    69003 2022-04-05 10:16:15.000000 biogeme-3.2.9/examples/assisted/.ipynb_checkpoints/paretoOptima-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9933 2022-08-02 12:52:28.000000 biogeme-3.2.9/examples/assisted/.ipynb_checkpoints/paretoSwissmetro-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1651 2022-07-14 08:22:40.000000 biogeme-3.2.9/examples/assisted/.ipynb_checkpoints/runknapsack-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    22337 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/assisted/airline.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    14980 2022-08-18 07:23:50.000000 biogeme-3.2.9/examples/assisted/airline.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    16069 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/assisted/debug.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    10322 2022-08-08 15:09:43.000000 biogeme-3.2.9/examples/assisted/debug.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    16510 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/assisted/optima.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    10537 2022-08-18 07:23:48.000000 biogeme-3.2.9/examples/assisted/optima.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    69003 2022-04-05 10:16:15.000000 biogeme-3.2.9/examples/assisted/paretoOptima.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9933 2022-08-02 12:52:28.000000 biogeme-3.2.9/examples/assisted/paretoSwissmetro.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1651 2022-07-14 08:22:40.000000 biogeme-3.2.9/examples/assisted/runknapsack.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/assisted/swissmetro.dat
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    27259 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/assisted/swissmetro.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    18290 2022-08-18 16:20:18.000000 biogeme-3.2.9/examples/assisted/swissmetro.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3839 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/checkhtml.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1158 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/generateNotebooks.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.691963 biogeme-3.2.9/examples/indicators/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2942 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/indicators/01expressions.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1638 2022-08-17 15:40:56.000000 biogeme-3.2.9/examples/indicators/01expressions.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2566 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/indicators/02estimation.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1259 2021-10-31 11:38:26.000000 biogeme-3.2.9/examples/indicators/02estimation.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4972 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/indicators/03simulation.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3030 2022-08-17 15:42:18.000000 biogeme-3.2.9/examples/indicators/03simulation.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5320 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/indicators/04market_shares.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3266 2022-08-17 15:56:04.000000 biogeme-3.2.9/examples/indicators/04market_shares.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5319 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/indicators/05revenues.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3162 2022-08-17 15:56:04.000000 biogeme-3.2.9/examples/indicators/05revenues.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     7108 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/indicators/06point_elasticities.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4335 2022-08-17 15:56:04.000000 biogeme-3.2.9/examples/indicators/06point_elasticities.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6169 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/indicators/07cross_elasticities.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3699 2022-08-17 15:56:04.000000 biogeme-3.2.9/examples/indicators/07cross_elasticities.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3847 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/indicators/08arc_elasticities.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2137 2021-10-31 11:09:40.000000 biogeme-3.2.9/examples/indicators/08arc_elasticities.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6228 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/indicators/09wtp.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3632 2022-08-17 15:56:42.000000 biogeme-3.2.9/examples/indicators/09wtp.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5982 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/indicators/scenarios.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3723 2022-08-17 15:56:04.000000 biogeme-3.2.9/examples/indicators/scenarios.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.711902 biogeme-3.2.9/examples/latent/
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.712790 biogeme-3.2.9/examples/latent/.ipynb_checkpoints/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)       72 2022-08-15 16:33:28.000000 biogeme-3.2.9/examples/latent/.ipynb_checkpoints/Untitled-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3964 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/00factorAnalysis.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2017 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/latent/00factorAnalysis.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9649 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/01oneLatentRegression.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6391 2022-08-19 06:53:37.000000 biogeme-3.2.9/examples/latent/01oneLatentRegression.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    13593 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/02oneLatentOrdered.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9424 2022-08-19 06:53:34.000000 biogeme-3.2.9/examples/latent/02oneLatentOrdered.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8484 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/03choiceOnly.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5603 2022-08-17 13:26:02.000000 biogeme-3.2.9/examples/latent/03choiceOnly.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8263 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/03choiceOnly_mc.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5460 2022-08-19 06:53:30.000000 biogeme-3.2.9/examples/latent/03choiceOnly_mc.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9564 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/04latentChoiceSeq.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6364 2022-08-17 16:16:51.000000 biogeme-3.2.9/examples/latent/04latentChoiceSeq.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9481 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/04latentChoiceSeq_mc.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6320 2022-08-19 06:53:26.000000 biogeme-3.2.9/examples/latent/04latentChoiceSeq_mc.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    19663 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/05latentChoiceFull.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    13629 2022-08-17 16:23:42.000000 biogeme-3.2.9/examples/latent/05latentChoiceFull.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    19620 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/05latentChoiceFull_mc.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    13612 2022-08-19 06:53:23.000000 biogeme-3.2.9/examples/latent/05latentChoiceFull_mc.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    20000 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/06serialCorrelation.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    13901 2022-08-19 06:53:20.000000 biogeme-3.2.9/examples/latent/06serialCorrelation.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    14092 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/07problem.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9846 2022-08-19 06:53:14.000000 biogeme-3.2.9/examples/latent/07problem.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    13367 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/latent/07problem_simul.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9342 2022-08-08 15:06:55.000000 biogeme-3.2.9/examples/latent/07problem_simul.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.718040 biogeme-3.2.9/examples/latentbis/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     7017 2022-08-17 15:19:14.000000 biogeme-3.2.9/examples/latentbis/m01_latent_variable.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4422 2022-08-08 15:15:48.000000 biogeme-3.2.9/examples/latentbis/m01_latent_variable.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9541 2022-08-17 15:19:14.000000 biogeme-3.2.9/examples/latentbis/m02_sequential_estimation.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6197 2022-08-17 16:00:08.000000 biogeme-3.2.9/examples/latentbis/m02_sequential_estimation.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    14105 2022-08-17 15:19:14.000000 biogeme-3.2.9/examples/latentbis/m03_simultaneous_estimation.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9306 2022-08-17 16:19:17.000000 biogeme-3.2.9/examples/latentbis/m03_simultaneous_estimation.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.745362 biogeme-3.2.9/examples/montecarlo/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2875 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/01simpleIntegral.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1544 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/01simpleIntegral.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6877 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/02simpleIntegral.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4570 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/02simpleIntegral.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4413 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/03antithetic.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2627 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/03antithetic.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4321 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/03antitheticExplicit.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2619 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/03antitheticExplicit.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3880 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/04normalMixtureNumerical.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2284 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/04normalMixtureNumerical.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5231 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/05normalMixtureMonteCarlo.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3268 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/05normalMixtureMonteCarlo.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4197 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/06estimationIntegral.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2553 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/06estimationIntegral.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4060 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2464 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4095 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_500.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2475 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_500.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4126 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_anti.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2506 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_anti.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4091 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_anti_500.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2507 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_anti_500.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4101 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_halton.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2505 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_halton.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4094 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_halton_500.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2510 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_halton_500.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4133 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2525 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4140 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs_500.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2532 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs_500.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4159 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs_anti.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2551 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs_anti.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4193 2022-08-17 15:19:17.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs_anti_500.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2561 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs_anti_500.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2020-06-18 12:42:41.000000 biogeme-3.2.9/examples/montecarlo/swissmetro.dat
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.771768 biogeme-3.2.9/examples/notebooks/
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.791599 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    36984 2021-10-30 07:00:27.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/Elementary expressions-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    35945 2021-08-04 14:41:09.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/FirstModelWithPandasBiogeme-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    35974 2021-08-04 14:41:24.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/My first model-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)       72 2021-10-25 06:35:04.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/Untitled-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2450 2022-08-17 12:07:45.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/Untitled1-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    29837 2021-10-26 11:15:33.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.algorithms-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    46622 2022-08-09 09:12:32.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.biogeme-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8664 2022-04-22 15:17:13.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.cnl-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    70244 2022-08-09 09:23:38.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.database-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    10773 2021-08-04 14:38:00.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.distributions-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    25558 2021-08-04 14:38:13.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.draws-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    89940 2022-08-09 16:58:59.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.expressions-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4062 2021-08-04 14:38:47.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.filenames-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8676 2022-08-09 09:13:33.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.loglikelihood-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9309 2021-08-04 14:39:13.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.messaging-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    76051 2022-08-09 09:20:15.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.models-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    49635 2021-08-04 14:40:14.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.optimization-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    39514 2022-06-29 15:08:40.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.results-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    10384 2022-04-10 16:23:50.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.segmentation-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    28223 2022-08-09 09:23:30.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.tools-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5094 2021-08-04 14:40:55.000000 biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.version-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    35349 2021-10-31 12:02:08.000000 biogeme-3.2.9/examples/notebooks/Elementary expressions.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    35946 2021-10-26 12:05:22.000000 biogeme-3.2.9/examples/notebooks/FirstModelWithPandasBiogeme.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5891 2020-06-18 12:42:41.000000 biogeme-3.2.9/examples/notebooks/Hamabs.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    35974 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/notebooks/My first model.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    17363 2022-08-02 10:49:26.000000 biogeme-3.2.9/examples/notebooks/Untitled.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2086 2022-08-17 12:45:01.000000 biogeme-3.2.9/examples/notebooks/Untitled1.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    29837 2021-10-26 11:15:33.000000 biogeme-3.2.9/examples/notebooks/biogeme.algorithms.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    46622 2022-08-09 09:12:32.000000 biogeme-3.2.9/examples/notebooks/biogeme.biogeme.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8664 2022-04-22 15:17:13.000000 biogeme-3.2.9/examples/notebooks/biogeme.cnl.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    70244 2022-08-09 09:23:38.000000 biogeme-3.2.9/examples/notebooks/biogeme.database.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    10774 2021-10-26 12:03:42.000000 biogeme-3.2.9/examples/notebooks/biogeme.distributions.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    25559 2021-10-26 12:03:54.000000 biogeme-3.2.9/examples/notebooks/biogeme.draws.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    99579 2022-08-17 13:09:12.000000 biogeme-3.2.9/examples/notebooks/biogeme.expressions.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4066 2021-10-26 12:04:44.000000 biogeme-3.2.9/examples/notebooks/biogeme.filenames.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8676 2022-08-09 09:13:33.000000 biogeme-3.2.9/examples/notebooks/biogeme.loglikelihood.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9315 2021-10-26 12:05:10.000000 biogeme-3.2.9/examples/notebooks/biogeme.messaging.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    76051 2022-08-09 09:20:15.000000 biogeme-3.2.9/examples/notebooks/biogeme.models.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    49681 2021-10-26 12:05:22.000000 biogeme-3.2.9/examples/notebooks/biogeme.optimization.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    39514 2022-06-29 15:08:40.000000 biogeme-3.2.9/examples/notebooks/biogeme.results.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     7276 2022-04-10 16:25:10.000000 biogeme-3.2.9/examples/notebooks/biogeme.segmentation.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    28223 2022-08-09 09:23:30.000000 biogeme-3.2.9/examples/notebooks/biogeme.tools.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5112 2022-08-02 08:33:20.000000 biogeme-3.2.9/examples/notebooks/biogeme.version.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2021-07-19 09:17:31.000000 biogeme-3.2.9/examples/notebooks/swissmetro.dat
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.638307 biogeme-3.2.9/examples/sampling/
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.794617 biogeme-3.2.9/examples/sampling/rico/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    10368 2020-11-08 22:00:14.000000 biogeme-3.2.9/examples/sampling/rico/ess_mnl.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    13660 2020-11-08 22:00:14.000000 biogeme-3.2.9/examples/sampling/rico/ess_nl.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6915 2020-11-08 22:00:14.000000 biogeme-3.2.9/examples/sampling/rico/soa.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2281 2020-11-08 22:00:14.000000 biogeme-3.2.9/examples/sampling/rico/soa_results.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.841812 biogeme-3.2.9/examples/swissmetro/
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.849128 biogeme-3.2.9/examples/swissmetro/.ipynb_checkpoints/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3461 2020-06-18 12:42:41.000000 biogeme-3.2.9/examples/swissmetro/.ipynb_checkpoints/01logit-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)       72 2021-10-11 07:22:54.000000 biogeme-3.2.9/examples/swissmetro/.ipynb_checkpoints/Untitled-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2980 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/swissmetro/.ipynb_checkpoints/scitas-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)       72 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/swissmetro/.ipynb_checkpoints/tmp19-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4240 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/swissmetro/01logit.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2438 2022-08-08 14:57:40.000000 biogeme-3.2.9/examples/swissmetro/01logit.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8710 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/01logitBis.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5696 2022-08-08 14:55:22.000000 biogeme-3.2.9/examples/swissmetro/01logitBis.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6292 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/01logit_allAlgos.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3983 2022-08-08 14:57:19.000000 biogeme-3.2.9/examples/swissmetro/01logit_allAlgos.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6512 2022-08-17 15:19:14.000000 biogeme-3.2.9/examples/swissmetro/01logit_simul.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4110 2022-08-08 14:54:16.000000 biogeme-3.2.9/examples/swissmetro/01logit_simul.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6299 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/02weight.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4040 2022-08-08 14:53:40.000000 biogeme-3.2.9/examples/swissmetro/02weight.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6076 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/03scale.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3882 2022-08-08 14:52:13.000000 biogeme-3.2.9/examples/swissmetro/03scale.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5047 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/swissmetro/04validation.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3087 2022-08-08 14:56:58.000000 biogeme-3.2.9/examples/swissmetro/04validation.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6250 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/05normalMixture.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4136 2022-08-17 13:20:18.000000 biogeme-3.2.9/examples/swissmetro/05normalMixture.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6134 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/05normalMixtureIntegral.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4032 2022-08-08 14:51:29.000000 biogeme-3.2.9/examples/swissmetro/05normalMixtureIntegral.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    11625 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/05normalMixture_allAlgos.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8497 2022-08-08 14:51:09.000000 biogeme-3.2.9/examples/swissmetro/05normalMixture_allAlgos.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9118 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/05normalMixture_simul.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6206 2022-08-17 13:21:12.000000 biogeme-3.2.9/examples/swissmetro/05normalMixture_simul.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5991 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/06unifMixture.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3913 2022-08-08 14:48:16.000000 biogeme-3.2.9/examples/swissmetro/06unifMixture.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6160 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/swissmetro/06unifMixtureIntegral.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4022 2022-08-08 14:47:26.000000 biogeme-3.2.9/examples/swissmetro/06unifMixtureIntegral.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6312 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/06unifMixtureMHLS.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4162 2022-08-08 14:47:06.000000 biogeme-3.2.9/examples/swissmetro/06unifMixtureMHLS.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6151 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/07discreteMixture.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3931 2022-08-08 14:45:56.000000 biogeme-3.2.9/examples/swissmetro/07discreteMixture.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5776 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/swissmetro/08boxcox.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3569 2022-08-08 14:45:26.000000 biogeme-3.2.9/examples/swissmetro/08boxcox.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6138 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/swissmetro/09nested.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3877 2022-08-08 14:44:56.000000 biogeme-3.2.9/examples/swissmetro/09nested.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8422 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/09nested_allAlgos.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5648 2022-08-08 14:44:33.000000 biogeme-3.2.9/examples/swissmetro/09nested_allAlgos.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6117 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/swissmetro/10nestedBottom.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3910 2022-08-08 14:43:49.000000 biogeme-3.2.9/examples/swissmetro/10nestedBottom.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6016 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/11cnl.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3809 2022-08-08 14:43:14.000000 biogeme-3.2.9/examples/swissmetro/11cnl.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     7651 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/swissmetro/11cnl_simul.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4935 2022-08-08 14:42:45.000000 biogeme-3.2.9/examples/swissmetro/11cnl_simul.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6083 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/11cnl_sparse.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3863 2022-08-08 14:41:48.000000 biogeme-3.2.9/examples/swissmetro/11cnl_sparse.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     7390 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/12panel.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4817 2022-08-15 07:47:17.000000 biogeme-3.2.9/examples/swissmetro/12panel.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     7977 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/swissmetro/12panel_flat.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5120 2022-08-15 07:47:12.000000 biogeme-3.2.9/examples/swissmetro/12panel_flat.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8793 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/13panel_simul.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5765 2022-08-15 15:02:00.000000 biogeme-3.2.9/examples/swissmetro/13panel_simul.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6494 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/swissmetro/14nestedEndogenousSampling.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4183 2022-08-08 14:36:51.000000 biogeme-3.2.9/examples/swissmetro/14nestedEndogenousSampling.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9060 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/15panelDiscrete.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5850 2022-08-08 14:36:27.000000 biogeme-3.2.9/examples/swissmetro/15panelDiscrete.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9144 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/15panelDiscreteBis.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5934 2022-08-08 14:32:36.000000 biogeme-3.2.9/examples/swissmetro/15panelDiscreteBis.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    10279 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/16panelDiscreteSocioEco.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6640 2022-08-08 14:31:46.000000 biogeme-3.2.9/examples/swissmetro/16panelDiscreteSocioEco.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6275 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/17lognormalMixture.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4113 2022-08-08 14:29:30.000000 biogeme-3.2.9/examples/swissmetro/17lognormalMixture.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6397 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/17lognormalMixtureIntegral.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4211 2022-08-08 14:30:20.000000 biogeme-3.2.9/examples/swissmetro/17lognormalMixtureIntegral.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4941 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/18ordinalLogit.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2929 2022-08-08 14:29:48.000000 biogeme-3.2.9/examples/swissmetro/18ordinalLogit.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5714 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/19individualLevelParameters.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3756 2022-08-15 07:46:38.000000 biogeme-3.2.9/examples/swissmetro/19individualLevelParameters.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5280 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/swissmetro/21probit.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3294 2022-08-08 14:28:39.000000 biogeme-3.2.9/examples/swissmetro/21probit.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6536 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/24haltonMixture.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4362 2022-08-08 14:28:10.000000 biogeme-3.2.9/examples/swissmetro/24haltonMixture.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6950 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/25triangularMixture.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4626 2022-08-08 14:27:11.000000 biogeme-3.2.9/examples/swissmetro/25triangularMixture.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8133 2022-08-17 15:19:15.000000 biogeme-3.2.9/examples/swissmetro/26triangularPanelMixture.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5372 2022-08-08 14:23:31.000000 biogeme-3.2.9/examples/swissmetro/26triangularPanelMixture.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1523 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/swissmetro/create_run_files.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      534 2022-08-15 07:50:21.000000 biogeme-3.2.9/examples/swissmetro/create_run_files.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2020-06-18 12:42:41.000000 biogeme-3.2.9/examples/swissmetro/swissmetro.dat
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.852199 biogeme-3.2.9/examples/swissmetro_panel/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6755 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/swissmetro_panel/01logit_p.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4056 2022-08-08 15:08:49.000000 biogeme-3.2.9/examples/swissmetro_panel/01logit_p.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     7728 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/swissmetro_panel/12panel_p.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4743 2022-08-08 15:09:24.000000 biogeme-3.2.9/examples/swissmetro_panel/12panel_p.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.855690 biogeme-3.2.9/examples/vns/
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.856866 biogeme-3.2.9/examples/vns/.ipynb_checkpoints/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    10296 2021-08-04 14:53:26.000000 biogeme-3.2.9/examples/vns/.ipynb_checkpoints/knapsack-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1638 2021-11-02 11:55:05.000000 biogeme-3.2.9/examples/vns/.ipynb_checkpoints/runknapsack-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    11394 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/vns/knapsack.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     7319 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/vns/knapsack.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1832 2022-08-17 15:19:18.000000 biogeme-3.2.9/examples/vns/runknapsack.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      791 2021-08-04 14:56:01.000000 biogeme-3.2.9/examples/vns/runknapsack.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.879581 biogeme-3.2.9/examples/workingNotToDistribute/
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.880377 biogeme-3.2.9/examples/workingNotToDistribute/.ipynb_checkpoints/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)       72 2021-07-21 13:53:38.000000 biogeme-3.2.9/examples/workingNotToDistribute/.ipynb_checkpoints/Untitled-checkpoint.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3944 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/01logit.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2175 2020-06-24 07:30:05.000000 biogeme-3.2.9/examples/workingNotToDistribute/01logit.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6856 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/01logit_simul.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4331 2021-07-26 08:46:46.000000 biogeme-3.2.9/examples/workingNotToDistribute/01logit_simul.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6968 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/12panel.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4557 2021-07-26 08:46:55.000000 biogeme-3.2.9/examples/workingNotToDistribute/12panel.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3678 2021-07-21 14:03:39.000000 biogeme-3.2.9/examples/workingNotToDistribute/Untitled.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3079 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/backward.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1712 2021-08-22 15:49:51.000000 biogeme-3.2.9/examples/workingNotToDistribute/backward.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2630 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/debug.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1393 2021-10-26 11:25:54.000000 biogeme-3.2.9/examples/workingNotToDistribute/debug.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1693 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/evaluate.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      626 2021-10-14 12:23:36.000000 biogeme-3.2.9/examples/workingNotToDistribute/evaluate.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    43425 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/latent_light_simul.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    30654 2022-08-16 11:51:57.000000 biogeme-3.2.9/examples/workingNotToDistribute/latent_light_simul.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    39910 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/mbi.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    28010 2022-08-16 13:42:01.000000 biogeme-3.2.9/examples/workingNotToDistribute/mbi.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6488 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/new.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4093 2020-11-11 16:16:02.000000 biogeme-3.2.9/examples/workingNotToDistribute/new.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6514 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/old.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4093 2020-11-11 16:16:01.000000 biogeme-3.2.9/examples/workingNotToDistribute/old.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2020-06-24 07:30:09.000000 biogeme-3.2.9/examples/workingNotToDistribute/swissmetro.dat
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1693 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/test_url_pickle.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      678 2021-09-01 09:30:34.000000 biogeme-3.2.9/examples/workingNotToDistribute/test_url_pickle.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4045 2022-08-17 15:19:16.000000 biogeme-3.2.9/examples/workingNotToDistribute/threads.ipynb
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2250 2020-11-24 15:11:06.000000 biogeme-3.2.9/examples/workingNotToDistribute/threads.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2757 2022-08-19 13:57:21.975197 biogeme-3.2.9/setup.cfg
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      334 2022-05-31 18:20:17.000000 biogeme-3.2.9/setup.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.941499 biogeme-3.2.9/src/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)        0 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/__init__.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.941729 biogeme-3.2.9/src/__pycache__/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      168 2022-08-02 16:05:40.000000 biogeme-3.2.9/src/__pycache__/__init__.cpython-310.pyc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8096 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioCfsqp.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2650 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioCfsqp.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      864 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioConst.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      439 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioDebug.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     7481 2022-08-02 10:04:11.000000 biogeme-3.2.9/src/bioDerivatives.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)       78 2021-10-15 16:38:25.000000 biogeme-3.2.9/src/bioDerivatives.cpp
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      978 2022-08-02 10:03:21.000000 biogeme-3.2.9/src/bioDerivatives.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      771 2021-10-15 16:38:26.000000 biogeme-3.2.9/src/bioDerivatives.pyx
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      319 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioExceptions.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1410 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioExceptions.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1927 2021-10-26 04:43:02.000000 biogeme-3.2.9/src/bioExprAnd.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      754 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprAnd.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1439 2022-08-02 07:02:08.000000 biogeme-3.2.9/src/bioExprDerive.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      765 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprDerive.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4629 2021-10-26 04:40:56.000000 biogeme-3.2.9/src/bioExprDivide.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      772 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprDivide.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2031 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioExprDraws.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      721 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioExprDraws.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2936 2021-10-26 04:40:32.000000 biogeme-3.2.9/src/bioExprElem.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      824 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprElem.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1893 2022-08-08 15:49:36.000000 biogeme-3.2.9/src/bioExprEqual.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      766 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprEqual.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1772 2021-10-26 04:40:03.000000 biogeme-3.2.9/src/bioExprExp.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      712 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprExp.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1357 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprFixedParameter.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      834 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioExprFixedParameter.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1317 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioExprFreeParameter.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      692 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioExprFreeParameter.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1560 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprGaussHermite.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1031 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioExprGaussHermite.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1589 2021-10-26 04:39:30.000000 biogeme-3.2.9/src/bioExprGreater.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      779 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprGreater.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1618 2021-10-26 04:39:20.000000 biogeme-3.2.9/src/bioExprGreaterOrEqual.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      821 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprGreaterOrEqual.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1852 2021-10-26 04:39:10.000000 biogeme-3.2.9/src/bioExprIntegrate.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      778 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprIntegrate.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1519 2021-10-26 04:38:58.000000 biogeme-3.2.9/src/bioExprLess.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      761 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprLess.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1583 2021-10-26 04:38:42.000000 biogeme-3.2.9/src/bioExprLessOrEqual.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      803 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprLessOrEqual.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2255 2021-10-26 04:38:27.000000 biogeme-3.2.9/src/bioExprLinearUtility.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1014 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprLinearUtility.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2461 2021-10-26 04:46:13.000000 biogeme-3.2.9/src/bioExprLiteral.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1223 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprLiteral.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3592 2021-10-20 17:15:17.000000 biogeme-3.2.9/src/bioExprLiteral_current.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2226 2021-10-26 04:37:41.000000 biogeme-3.2.9/src/bioExprLog.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      712 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprLog.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5240 2022-08-02 06:47:05.000000 biogeme-3.2.9/src/bioExprLogLogit.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      927 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprLogLogit.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4085 2021-10-26 04:37:06.000000 biogeme-3.2.9/src/bioExprLogLogitFullChoiceSet.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      892 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprLogLogitFullChoiceSet.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2270 2021-10-26 04:36:45.000000 biogeme-3.2.9/src/bioExprMax.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      756 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprMax.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2267 2021-10-26 04:36:36.000000 biogeme-3.2.9/src/bioExprMin.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      756 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprMin.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1669 2021-10-26 05:38:03.000000 biogeme-3.2.9/src/bioExprMinus.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      767 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprMinus.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2155 2021-10-26 04:36:07.000000 biogeme-3.2.9/src/bioExprMontecarlo.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      776 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprMontecarlo.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2504 2021-10-26 04:35:52.000000 biogeme-3.2.9/src/bioExprMultSum.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      787 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprMultSum.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2102 2021-10-26 04:35:36.000000 biogeme-3.2.9/src/bioExprNormalCdf.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      807 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprNormalCdf.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2169 2021-10-26 04:35:25.000000 biogeme-3.2.9/src/bioExprNormalPdf.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      752 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprNormalPdf.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1559 2021-10-26 04:35:11.000000 biogeme-3.2.9/src/bioExprNotEqual.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      784 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprNotEqual.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      946 2021-10-26 04:44:33.000000 biogeme-3.2.9/src/bioExprNumeric.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      731 2021-10-25 14:26:33.000000 biogeme-3.2.9/src/bioExprNumeric.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1913 2021-10-26 04:34:55.000000 biogeme-3.2.9/src/bioExprOr.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      748 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprOr.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3594 2021-10-26 07:16:41.000000 biogeme-3.2.9/src/bioExprPanelTrajectory.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      976 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprPanelTrajectory.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2446 2021-10-26 04:34:25.000000 biogeme-3.2.9/src/bioExprPlus.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      761 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprPlus.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3485 2021-10-26 04:44:57.000000 biogeme-3.2.9/src/bioExprPower.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      765 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprPower.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1087 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioExprRandomVariable.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      791 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioExprRandomVariable.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1786 2021-10-26 04:33:12.000000 biogeme-3.2.9/src/bioExprSum.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      798 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprSum.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3982 2021-10-26 04:46:22.000000 biogeme-3.2.9/src/bioExprTimes.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      766 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprTimes.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1350 2021-10-26 04:32:03.000000 biogeme-3.2.9/src/bioExprUnaryMinus.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      753 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioExprUnaryMinus.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2676 2021-10-27 05:16:57.000000 biogeme-3.2.9/src/bioExprVariable.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      796 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioExprVariable.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3317 2021-10-26 12:51:57.000000 biogeme-3.2.9/src/bioExpression.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2520 2021-10-26 12:52:04.000000 biogeme-3.2.9/src/bioExpression.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    24568 2022-08-03 14:32:41.000000 biogeme-3.2.9/src/bioFormula.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1427 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioFormula.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1607 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioGaussHermite.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4396 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioGaussHermite.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      848 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioGhFunction.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      788 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioGhFunction.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    15863 2022-08-02 13:06:22.000000 biogeme-3.2.9/src/bioMemoryManagement.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6100 2022-08-02 13:06:14.000000 biogeme-3.2.9/src/bioMemoryManagement.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3496 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioNormalCdf.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      841 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioNormalCdf.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      263 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioPower.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2604 2022-07-22 08:32:03.000000 biogeme-3.2.9/src/bioSeveralExpressions.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1056 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioSeveralExpressions.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1613 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioSeveralFormulas.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      864 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioSeveralFormulas.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2173 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioString.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      756 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioString.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4169 2021-10-26 11:40:05.000000 biogeme-3.2.9/src/bioThreadMemory.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1799 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioThreadMemory.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3483 2022-08-03 14:28:44.000000 biogeme-3.2.9/src/bioThreadMemoryOneExpression.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1793 2022-08-03 14:28:08.000000 biogeme-3.2.9/src/bioThreadMemoryOneExpression.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3146 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioThreadMemorySimul.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1589 2021-08-04 14:56:01.000000 biogeme-3.2.9/src/bioThreadMemorySimul.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)      716 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/bioTypes.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3335 2021-12-23 11:07:25.000000 biogeme-3.2.9/src/bioVectorOfDerivatives.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1151 2021-12-23 10:41:38.000000 biogeme-3.2.9/src/bioVectorOfDerivatives.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    27265 2022-08-15 07:42:05.000000 biogeme-3.2.9/src/biogeme.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    24276 2021-03-08 18:08:25.000000 biogeme-3.2.9/src/biogeme.cc.tmp
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    20027 2020-11-09 11:33:07.000000 biogeme-3.2.9/src/biogeme.cc.work
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4723 2021-10-13 14:58:14.000000 biogeme-3.2.9/src/biogeme.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4272 2020-11-09 11:32:50.000000 biogeme-3.2.9/src/biogeme.h.work
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    11348 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/biogeme_working.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2091 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/biogeme_working.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)  1029279 2022-07-21 16:36:37.000000 biogeme-3.2.9/src/cbiogeme.cpp
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6084 2021-10-31 13:03:13.000000 biogeme-3.2.9/src/cbiogeme.pyx
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3342 2020-09-25 13:45:49.000000 biogeme-3.2.9/src/cbiogeme.pyx.ok
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4037 2020-11-09 11:33:23.000000 biogeme-3.2.9/src/cbiogeme.pyx.work
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)   971671 2022-07-21 16:26:13.000000 biogeme-3.2.9/src/cexpressions.cpp
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3749 2021-10-26 13:24:18.000000 biogeme-3.2.9/src/cexpressions.pyx
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1991 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/cfsqpusr.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)  1119799 2022-08-19 08:30:30.000000 biogeme-3.2.9/src/cythonbiogeme.cpp
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8851 2022-07-22 07:04:29.000000 biogeme-3.2.9/src/cythonbiogeme.pyx
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     8794 2022-07-21 17:05:19.000000 biogeme-3.2.9/src/cythonbiogeme.pyx~
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9805 2022-08-03 14:25:59.000000 biogeme-3.2.9/src/evaluateExpressions.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1995 2021-10-26 13:01:10.000000 biogeme-3.2.9/src/evaluateExpressions.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3486 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/main.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)   136222 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/mycfsqp.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    43492 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/myqld.cc
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2324 2020-08-06 15:15:13.000000 biogeme-3.2.9/src/panelbiogeme.h
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)       53 2021-10-19 06:52:59.000000 biogeme-3.2.9/src/tmp.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.942513 biogeme-3.2.9/tests/
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.946304 biogeme-3.2.9/tests/functions/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5958 2022-08-02 16:57:07.000000 biogeme-3.2.9/tests/functions/test_biogeme.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4815 2022-02-14 10:45:20.000000 biogeme-3.2.9/tests/functions/test_data.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     9189 2022-08-09 09:24:53.000000 biogeme-3.2.9/tests/functions/test_database.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     6383 2022-08-02 17:01:43.000000 biogeme-3.2.9/tests/functions/test_draws.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)    35946 2022-08-17 13:06:18.000000 biogeme-3.2.9/tests/functions/test_expressions.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5959 2022-08-02 17:01:21.000000 biogeme-3.2.9/tests/functions/test_optimization.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2168 2021-10-27 06:38:49.000000 biogeme-3.2.9/tests/functions/test_results.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5392 2022-08-02 16:39:19.000000 biogeme-3.2.9/tests/functions/test_segmentation.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     5090 2022-08-02 16:22:28.000000 biogeme-3.2.9/tests/functions/test_tools.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.951288 biogeme-3.2.9/tests/optima/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)   638103 2022-08-09 07:42:06.000000 biogeme-3.2.9/tests/optima/optima.dat
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2977 2022-08-09 07:42:10.000000 biogeme-3.2.9/tests/optima/spec_optima.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1293 2022-08-09 07:59:19.000000 biogeme-3.2.9/tests/optima/test_01.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3656 2021-10-27 06:44:02.000000 biogeme-3.2.9/tests/simple_test.py
+drwxr-xr-x   0 michelbierlaire   (501) staff       (20)        0 2022-08-19 13:57:21.973948 biogeme-3.2.9/tests/swissmetro/
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)        0 2020-06-18 12:42:42.000000 biogeme-3.2.9/tests/swissmetro/__init__.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)   767932 2020-06-18 12:42:42.000000 biogeme-3.2.9/tests/swissmetro/swissmetro.dat
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3865 2022-08-08 14:18:32.000000 biogeme-3.2.9/tests/swissmetro/test_01.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3143 2022-08-08 14:18:10.000000 biogeme-3.2.9/tests/swissmetro/test_01simul.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2506 2022-08-08 14:17:50.000000 biogeme-3.2.9/tests/swissmetro/test_02.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2745 2022-08-08 14:17:30.000000 biogeme-3.2.9/tests/swissmetro/test_03.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2906 2022-08-08 14:17:10.000000 biogeme-3.2.9/tests/swissmetro/test_04.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3291 2022-08-08 14:16:26.000000 biogeme-3.2.9/tests/swissmetro/test_05.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3382 2022-08-08 14:15:50.000000 biogeme-3.2.9/tests/swissmetro/test_05integral.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3313 2022-08-08 14:15:31.000000 biogeme-3.2.9/tests/swissmetro/test_06.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3438 2022-08-08 14:14:45.000000 biogeme-3.2.9/tests/swissmetro/test_06integral.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2886 2022-08-08 14:14:17.000000 biogeme-3.2.9/tests/swissmetro/test_07.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2536 2022-08-08 14:13:55.000000 biogeme-3.2.9/tests/swissmetro/test_08.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2608 2022-08-08 14:13:32.000000 biogeme-3.2.9/tests/swissmetro/test_09.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2620 2022-08-08 14:13:10.000000 biogeme-3.2.9/tests/swissmetro/test_10.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3272 2022-08-08 14:12:38.000000 biogeme-3.2.9/tests/swissmetro/test_11.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3288 2022-08-08 14:12:12.000000 biogeme-3.2.9/tests/swissmetro/test_11bis.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2756 2022-08-08 14:11:34.000000 biogeme-3.2.9/tests/swissmetro/test_12.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2838 2022-08-08 14:10:47.000000 biogeme-3.2.9/tests/swissmetro/test_12integral.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2981 2022-08-08 14:10:25.000000 biogeme-3.2.9/tests/swissmetro/test_13.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2811 2022-08-08 14:10:03.000000 biogeme-3.2.9/tests/swissmetro/test_14.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3523 2022-08-08 14:07:02.000000 biogeme-3.2.9/tests/swissmetro/test_15.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     4766 2022-08-08 14:08:34.000000 biogeme-3.2.9/tests/swissmetro/test_16.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3253 2022-08-08 14:09:39.000000 biogeme-3.2.9/tests/swissmetro/test_17.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3349 2022-08-08 14:09:07.000000 biogeme-3.2.9/tests/swissmetro/test_17integral.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     1664 2022-08-08 14:08:14.000000 biogeme-3.2.9/tests/swissmetro/test_18.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     2195 2022-08-08 14:07:55.000000 biogeme-3.2.9/tests/swissmetro/test_21.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3690 2022-08-08 14:07:33.000000 biogeme-3.2.9/tests/swissmetro/test_25.py
+-rw-r--r--   0 michelbierlaire   (501) staff       (20)     3549 2022-08-08 14:06:29.000000 biogeme-3.2.9/tests/swissmetro/test_26.py
```

### Comparing `biogeme-3.2.8/biogeme/algorithms.py` & `biogeme-3.2.9/biogeme/algorithms.py`

 * *Files 1% similar despite different names*

```diff
@@ -145,15 +145,15 @@
             return x
 
         self.bounds = b
         """list of tuples (ell,u) containing the lower and upper bounds for
         each free parameter.
         """
 
-        self.n = len(b) #: number of optimization variables
+        self.n = len(b)  #: number of optimization variables
 
         self.lowerBounds = [noneToMinusInfinity(bb[0]) for bb in b]
         """ List of lower bounds """
 
         self.upperBounds = [noneToPlusInfinity(bb[1]) for bb in b]
         """ List of upper bounds """
 
@@ -748,30 +748,30 @@
     deriv = np.inner(g, d)
 
     if deriv >= 0:
         raise excep.biogemeError(f'd is not a descent direction: {deriv} >= 0')
 
     alpha = alpha0
     alphal = 0
-    alphar = np.finfo(np.float128).max
+    alphar = np.finfo(float).max
     finished = False
     while not finished:
         xnew = x + alpha * d
         fct.setVariables(xnew)
         fnew, gnew = fct.f_g()
         nfev += 1
         finished = True
         # First Wolfe condition violated?
         if fnew > f + alpha * beta1 * deriv:
             alphar = alpha
             alpha = (alphal + alphar) / 2.0
             finished = False
         elif np.inner(gnew, d) < beta2 * deriv:
             alphal = alpha
-            if alphar == np.finfo(np.float128).max:
+            if alphar == np.finfo(float).max:
                 alpha = lbd * alpha
             else:
                 alpha = (alphal + alphar) / 2.0
             finished = False
     return alpha, nfev
 
 
@@ -929,15 +929,15 @@
               \\lambda (d_d - d_c)\\| = \\delta`
 
     :rtype: float
 
     """
     a = np.inner(d, d)
     b = 2 * np.inner(dc, d)
-    c = np.inner(dc, dc) - delta ** 2
+    c = np.inner(dc, dc) - delta**2
     discriminant = b * b - 4.0 * a * c
     return (-b + np.sqrt(discriminant)) / (2 * a)
 
 
 def cauchyNewtonDogleg(g, H):
     """Calculate the Cauchy, the Newton and the dogleg points.
 
@@ -1862,14 +1862,15 @@
 
     :rtype: numpay.array, dict(str:object)
 
     :raises biogeme.exceptions.biogemeError: if the dimensions of the
              matrix initBfgs do not match the length of x0.
 
     """
+
     if len(x0) != bounds.n:
         raise excep.biogemeError(
             f'Incompatible size:' f' {len(x0)} and {len(bounds)}'
         )
 
     if not bounds.feasible(x0):
         logger.warning(
@@ -1952,24 +1953,31 @@
             xk, g, H, delta, bounds, infeasibleConjugateGradient, cgtol
         )
 
         if np.isnan(xc).any():
             delta = delta / 2.0
             status = '-'
         else:
-            fct.setVariables(xc)
-            fc = fct.f()
-            nfev += 1
+            failed = False
+            try:
+                fct.setVariables(xc)
+                fc = fct.f()
+                nfev += 1
 
-            num = f - fc
-            step = xc - xk
-            denom = -np.inner(step, g) - 0.5 * np.inner(step, H @ step)
-            rho = num / denom
+                num = f - fc
+                step = xc - xk
+                denom = -np.inner(step, g) - 0.5 * np.inner(step, H @ step)
+                rho = num / denom
+                failed = rho < eta1
+            except RuntimeError as e:
+                raise e
+                logger.debug(xc)
+                failed = True
 
-            if rho < eta1:
+            if failed:
                 # Failure: reduce the trust region
                 delta = min(delta / 2.0, la.norm(step, np.inf) / 2.0)
                 status = '-'
             else:
                 # Candidate accepted
                 if (
                     proportionTrueHessian > 0
```

### Comparing `biogeme-3.2.8/biogeme/assisted.py` & `biogeme-3.2.9/biogeme/assisted.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,55 +6,65 @@
 """
 
 # pylint: disable=too-many-lines, invalid-name, too-many-instance-attributes
 # pylint: disable=too-many-arguments, too-many-locals
 # pylint: disable=too-many-public-methods, too-many-branches
 # pylint: disable=too-many-statements
 
+from collections import namedtuple
 import random
 import copy
 import html
 import biogeme.biogeme as bio
 import biogeme.messaging as msg
 import biogeme.exceptions as excep
 from biogeme import vns
 from biogeme.expressions import Beta, bioMultSum
 
+# This tuple is imported here, so that it can be imported from here later on.
+from biogeme.segmentation import DiscreteSegmentationTuple, segment_parameter
+
 logger = msg.bioMessage()
 
 
+TermTuple = namedtuple('TermTuple', 'attribute segmentation bounds validity')
+SegmentedParameterTuple = namedtuple(
+    'SegmentedParameterTuple', 'dict combinatorial'
+)
+
+
 class variable:
     """
     Class representing the possible specifications of a variable
     """
 
     def __init__(self, name, expression):
         """
         :param name: name of the variable
         :type name: str
 
         :param expression: Biogeme expression of the variable.
         :type expression: :class:`biogeme.expressions.Expression`
         """
 
-        self.name = name #: name of the variable
+        self.name = name  #: name of the variable
 
-        self.expression = expression #: Biogeme expression for the variable
+        self.expression = expression  #: Biogeme expression for the variable
 
-        self.active = False #: True if variable is active
+        self.active = False  #: True if variable is active
 
-        self.generic = False #: True if the variable is generic.
+        self.generic = False  #: True if the variable is generic.
 
-        self.genericName = None #: Name of the generic variable
+        self.genericName = None  #: Name of the generic variable
 
         self.nonlinearSpec = None
         """ Function with the nonlinear specifications.
         """
 
-        self.used = False #: True if variable used in the model.
+        self.used = False  #: True if variable used in the model.
 
     def __str__(self):
         """
         Print the specification of the variable
         """
         if not self.active:
             return f'{self.name} [deactivated]'
@@ -121,41 +131,41 @@
 
         :param variables: list of variables in the group
         :type varariables: list(variable)
 
         :param nonlinearSpecs: list of possible nonlinear specifications
         :type nonlinearSpecs: list(function)
         """
-        self.name = name #: name of the group of variables.
+        self.name = name  #: name of the group of variables.
 
-        self.variables = variables #: list of variables in the group.
+        self.variables = variables  #: list of variables in the group.
 
         self.genericForbiden = len(self.variables) <= 1
         """ True of the group cannot be made generic
         """
 
         self.generic = not self.genericForbiden
         """ True if the group is generic.
         """
 
         self.alwaysActive = False
         """ True if the group is always active.
         """
 
-        self.active = False #: True if the group is active.
+        self.active = False  #: True if the group is active.
 
         self.nonlinearSpecs = nonlinearSpecs
         """ list of possible nonlinear specifications
         """
 
         self.selection = 0
         """Index of the selected non linear specification.
         """
 
-        self.linear = True #: True if linear specification.
+        self.linear = True  #: True if linear specification.
 
     def __str__(self):
         v = [s.__str__() for s in self.variables]
         if self.generic:
             return f'{self.name}: {v}  [generic][active:{self.active}]'
 
         return f'{self.name}: {v} [not generic][active:{self.active}]'
@@ -373,30 +383,30 @@
         :param bounds: bounds on the coefficient
         :type bounds: tuple(float, float)
 
         :param validity: function checking the validity of the coefficient.
         :type validity: bool f(float)
 
         """
-        self.var = var #: variable of the term
+        self.var = var  #: variable of the term
 
         self.segmentation = aSegmentation
         """ discrete segmentation of the parameter
         """
 
         self.coef_names = None
         """names of the Beta parameters involved in the specification of the
         term.
         """
 
         self.validity = validity
         """ function checking the validity of the coefficient.
         """
 
-        self.bounds = bounds #: bounds on the coefficient
+        self.bounds = bounds  #: bounds on the coefficient
 
         if self.var is not None:
             self.var.used = True
 
         if self.segmentation is not None:
             self.segmentation.used = True
 
@@ -461,32 +471,31 @@
         :raise biogemeError: if the parameter has not be estimated.
         """
         if self.validity is None:
             return True, None
         if not self.var.active:
             return True, None
         estimatedValues = estimationResults.getBetaValues()
-        betaName = self.getBeta(altname)
         status_msg = None
-        for b in self.segmentation.getBetaNames(betaName):
-            val = estimatedValues.get(b)
+        for the_beta in self.coef_names:
+            print(f'Check validity of {the_beta=}')
+            val = estimatedValues.get(the_beta)
             if val is None:
                 p = list(estimatedValues.keys())
                 raise excep.biogemeError(
                     f'Parameter {b}'
                     f' has not been estimated. '
                     f'Estimated parameters: '
                     f'{p}'
                 )
 
-            ok = self.validity(val)
-            if not ok:
+            if not self.validity(val):
                 if status_msg is None:
                     status_msg = 'Invalid parameter(s):'
-                status_msg += f' {b} in alternative {altname}: {val}'
+                status_msg += f' {the_beta} in alternative {altname}: {val}'
 
         return status_msg is None, status_msg
 
     def getExpression(self, altname):
         """
         Build the Biogeme expression for the term
 
@@ -552,19 +561,19 @@
         :param name: name of the alternative
         :type name: str
 
         :param terms: terms of the utility function.
         :type terms: list(term)
 
         """
-        self.name = name #: name of the alternative
+        self.name = name  #: name of the alternative
 
-        self.id = alternativeId #: id of the alternative
+        self.id = alternativeId  #: id of the alternative
 
-        self.terms = terms #: list of terms in the utility function
+        self.terms = terms  #: list of terms in the utility function
 
     def getExpression(self):
         """
         Obtain the Biogeme expression for the utility function.
 
         :return: Biogeme expression
         :rtype: :class:`biogeme.expressions.Expression`
@@ -590,24 +599,24 @@
         :type expression: meth:`biogeme.expressions.Expression`
 
         :param values: dict with values that it can take as keys, and a name
             describing them as values.
         :type values: dict(int: str)
 
         """
-        self.name = name #: name of the segmentation variable
+        self.name = name  #: name of the segmentation variable
 
-        self.expression = expression #: Biogeme expression of the variable
+        self.expression = expression  #: Biogeme expression of the variable
 
         self.values = values
         """dict with values that it can take as keys, and a name
         describing them as values.
         """
 
-        self.active = False #: True if the segmentation variable is active.
+        self.active = False  #: True if the segmentation variable is active.
 
     def combine(self, existingValues):
         """Generates the possible combinations of values,
         corresponding to segments.
         """
         if existingValues is None:
             return [
@@ -626,30 +635,35 @@
                 )
         return combination
 
 
 class segmentation:
     """Class representing the possible segmentations"""
 
-    def __init__(self, dictOfSocioEco):
+    def __init__(self, name, dictOfSocioEco, combinatorial):
         """
         Ctor
         """
         self.dictOfSocioEco = {
             k: socioEconomic(k, v[0], v[1]) for k, v in dictOfSocioEco.items()
         }
         """dict of object of class socioEconomic characterizing the
         segmentation.
         """
 
-        self.listOfVariables = [] #: list of variables involved
+        self.combinatorial = combinatorial
+        """True if all combinations are considered"""
+
+        self.listOfVariables = []  #: list of variables involved
 
-        self.alwaysActive = False #: True if it must always be active
+        self.alwaysActive = False  #: True if it must always be active
 
-        self.used = False #: True if used.
+        self.name = name  #: name of the segmentation
+
+        self.used = False  #: True if used.
 
     def __str__(self):
         return f'{self.dictOfSocioEco}'
 
     def getDecisions(self):
         """The decision is a dict, where the keys are the name of the
         socioeconomic variables, and the value are a boolean mentioning
@@ -686,20 +700,24 @@
                 raise excep.biogemeError(error_msg) from e
 
     def isActive(self):
         """Check if there are active variables for this segmentation."""
         if self.alwaysActive:
             return True
         activeVariables = sum(
-            [v.active if v is not None else True for v in self.listOfVariables]
+            v.active if v is not None else True for v in self.listOfVariables
         )
         return activeVariables > 0
 
     def getBetaNames(self, coef_name):
         """Get the name of the parameters for all combinations."""
+
+        expr = self.getExpression(coef_name, (None, None))
+        betas = expr.setOfBetas()
+        return [betas]
         combinations = None
         for v in self.dictOfSocioEco.values():
             if v.active:
                 combinations = v.combine(combinations)
 
         if combinations is None:
             return [coef_name]
@@ -720,34 +738,45 @@
 
         :param bounds: bounds on the coefficient
         :type bounds: tuple(float, float)
 
         :return: biogeme  expression for the segmentation
         :rtype: :class:`biogeme.expressions.bioMultSum`
         """
-        combinations = None
-        for v in self.dictOfSocioEco.values():
-            if v.active:
-                combinations = v.combine(combinations)
 
-        if combinations is None:
-            return Beta(coef_name, 0, bounds[0], bounds[1], 0)
-
-        listOfTerms = []
-        for triplet in combinations:
-            theCoefName = coef_name
-            listOfConditions = []
-            for var, value, name in zip(triplet[0], triplet[1], triplet[2]):
-                theCoefName = f'{theCoefName}_{name}'
-                listOfConditions.append(var == value)
-            aTerm = Beta(theCoefName, 0, bounds[0], bounds[1], 0)
-            for t in listOfConditions:
-                aTerm = aTerm * t
-            listOfTerms.append(aTerm)
-        return bioMultSum(listOfTerms)
+        #        combinations = None
+        #        for v in self.dictOfSocioEco.values():
+        #            if v.active:
+        #                combinations = v.combine(combinations)
+        #
+        #        if combinations is None:
+        #            return Beta(coef_name, 0, bounds[0], bounds[1], 0)
+        #
+        #        listOfTerms = []
+        #        for triplet in combinations:
+        #            theCoefName = coef_name
+        #            listOfConditions = []
+        #            for var, value, name in zip(triplet[0], triplet[1], triplet[2]):
+        #                theCoefName = f'{theCoefName}_{name}'
+        #                listOfConditions.append(var == value)
+        #            aTerm = Beta(theCoefName, 0, bounds[0], bounds[1], 0)
+        #            for t in listOfConditions:
+        #                aTerm = aTerm * t
+        #            listOfTerms.append(aTerm)
+        #        before =  bioMultSum(listOfTerms)
+
+        the_coef = Beta(coef_name, 0, bounds[0], bounds[1], 0)
+        list_of_segmentations = [
+            DiscreteSegmentationTuple(variable=v.expression, mapping=v.values)
+            for v in self.dictOfSocioEco.values()
+            if v.active
+        ]
+        return segment_parameter(
+            the_coef, list_of_segmentations, self.combinatorial
+        )
 
     def describe(self):
         """Description of the segmentation
 
         :return: description
         :rtype: str
         """
@@ -804,15 +833,15 @@
             variable with a list of possible nonlinear
             transformations. Each transformation is a function that takes
             one argument (the variable), and return a tuple with
 
             - the name of the nonlinear transform
             - the expression of the transform.
 
-            Examples of such a function::
+             Examples of such a function::
 
                 def sqrt(x):
                     return 'sqrt', x**0.5
 
                 def boxcox(x):
                     ell = Beta(f'lambda', 1, 0.0001, 3.0, 0)
                     return 'Box-Cox', models.boxcox(x, ell)
@@ -891,15 +920,16 @@
 
         :type utilities: dict(int, tuple(str,
                          list(tuple(str, str, tuple(float, float),function))))
 
         :param availabilities: dict describing the availability of the
             alternatives.
 
-        :type availabilities: dict(int, :class:`biogeme.expressions.Expression`)
+        :type availabilities:
+            dict(int, :class:`biogeme.expressions.Expression`)
 
         :param choice: expression for the observed choice
         :type choice: :class:`biogeme.expressions.Expression`
 
         :param models: dict of possible models. A model is a function
             that takes the utilities and the availabilities, and return
             the loglikelihood expression.
@@ -930,15 +960,15 @@
         self.archive = {}
         """Dictionary, where the keys are solutions (objects of type
         :class:`biogeme.vns.solutionClass`) and the values are the
         estimation results (objects of type
         :class:`biogeme.results.bioResults`).
         """
 
-        self.name = name #: name of the problem.
+        self.name = name  #: name of the problem.
 
         self.database = database
         """object of type :class:`biogeme.database.Database`, containing the
         data.
         """
 
         # First check if all the variables are in a group. For those
@@ -1008,26 +1038,27 @@
                 error_msg = (
                     f'Variables not in any group: '
                     f'{[k for k, c in check.items() if not c]}'
                 )
                 raise excep.biogemeError(error_msg)
 
         self.theSegmentations = {
-            k: segmentation(v) for k, v in theSegmentations.items()
+            k: segmentation(k, v.dict, v.combinatorial)
+            for k, v in theSegmentations.items()
         }
         """dict of segmentations, where the keys are the names, and the
         values are objects of class ``segmentation``
         """
 
         self.utilities = utilities
         """specification of the utility functions. See
         :class:`biogeme.assisted.specificationProblem.__init__`
         """
 
-        self.choice = choice #: expression for the observed choice
+        self.choice = choice  #: expression for the observed choice
 
         self.availability = availabilities
         """dict describing the availability of the alternatives.
         """
 
         self.theAlternatives = {}
         """Dict of utility functions, where the keys are the id of the
@@ -1040,23 +1071,23 @@
 
         self.models = list(models.items())
         """ List tuple (name, model).  A model is a function
         that takes the utilities and the availabilities, and return
         the loglikelihood expression.
         """
 
-        self.selectedModel = 0 #: index of the selected model
+        self.selectedModel = 0  #: index of the selected model
 
         self.maximumNumberOfParameters = 200
         """maximum number of parameters allowed in a specification. If the
         current model has more parameters, it is declared invalid and
         rejected by the algorithm.
         """
 
-        self.lastOperator = None #: Last operator used
+        self.lastOperator = None  #: Last operator used
 
         self.operators = {
             'Change segmentation': self.changeSegmentation,
             'Increase segmentation': self.increaseSegmentation,
             'Decrease segmentation': self.decreaseSegmentation,
             'Change linearity': self.changeLinearity,
             'Change variables': self.changeVariables,
@@ -1072,90 +1103,101 @@
             self.operators.keys()
         )
         """ Object of type :class:`biogeme.vns.operatorsManagement`
         """
 
         # Check the consistency of the input
         for k, u in self.utilities.items():
+            # First check that the tuples have the correct length
+            for t in u[1]:
+                if len(t) != 4:
+                    err_msg = f'tuple must contain 4 elements: {t}'
+                    raise excep.biogemeError(err_msg)
             # All segmentations must exist
             for t in u[1]:
-                # t[0] name of the variable
+                # t[0] name of the attribute
                 # t[1] name of the segmentation
                 # t[2] bounds
                 # t[3] function checking validity
                 if (
-                    t[1] is not None
-                    and self.theSegmentations.get(t[1]) is None
+                    t.segmentation is not None
+                    and self.theSegmentations.get(t.segmentation) is None
+                ):
+                    raise excep.biogemeError(
+                        f'Segmentation {t.segmentation} ' f'does not exist'
+                    )
+                if (
+                    t.attribute is not None
+                    and self.theVariables.get(t.attribute) is None
                 ):
                     raise excep.biogemeError(
-                        f'Segmentation {t[1]} ' f'does not exist'
+                        f'Attribute {t.attribute} does not exist'
                     )
-                if t[0] is not None and self.theVariables.get(t[0]) is None:
-                    raise excep.biogemeError(f'Variable {t[0]} does not exist')
                 self.theAlternatives[k] = utility(
                     k,
                     u[0],
                     [
                         term(
-                            self.theVariables.get(t[0]),
-                            self.theSegmentations.get(t[1]),
-                            t[2],
-                            t[3],
+                            self.theVariables.get(tt.attribute),
+                            self.theSegmentations.get(tt.segmentation),
+                            tt.bounds,
+                            tt.validity,
                         )
-                        for t in u[1]
+                        for tt in u[1]
                     ],
                 )
-                if t[1] is not None:
-                    self.theSegmentations[t[1]].listOfVariables.append(
-                        self.theVariables.get(t[0])
+                if t.segmentation is not None:
+                    self.theSegmentations[
+                        t.segmentation
+                    ].listOfVariables.append(
+                        self.theVariables.get(t.attribute)
                     )
                 # If the segmentation is not associated with a
                 # variable, it must always be active
-                if t[2] is None:
-                    self.theSegmentations[t[1]].alwaysActive = True
+                if t.attribute is None:
+                    self.theSegmentations[t.segmentation].alwaysActive = True
 
         self.decisions = self.getDecisions()
         """
         The decisions consist of:
 
         - a dict of decisions for each group of variables.
         - for each utility, a list of decisions for each term.
         - the selected model
 
         Type: tuple(dict(str: int), dict(str: list(dict(str: bool))), int)
         """
 
-        unused = list()
+        unused = []
         for v in self.theVariables.values():
             if not v.used:
                 unused.append(v.name)
         if unused:
             raise excep.biogemeError(
                 f'The following variables ' f'are not used: {unused}'
             )
-        unused = list()
+        unused = []
         for s in self.theSegmentations.values():
             if not s.used:
                 unused.append(s.name)
         if unused:
             raise excep.biogemeError(
-                f'The following variables ' f'are not used: {unused}'
+                f'The following segmentations ' f'are not used: {unused}'
             )
 
     def getBiogemeModel(self):
         """Build the Biogeme expressions of a given specification"""
         V = {k: v.getExpression() for k, v in self.theAlternatives.items()}
         logprob = self.models[self.selectedModel][1](
             V, self.availability, self.choice
         )
         b = bio.BIOGEME(
             self.database,
             logprob,
             suggestScales=False,
-            numberOfThreads=10,
             userNotes=self.describeHtml(),
         )
         b.generateHtml = False
         b.generatePickle = False
         return b
 
     def getDecisions(self):
@@ -1497,30 +1539,30 @@
         if estimationResults is not None:
             return estimationResults
 
         self.setSolution(aSolution)
 
         b = self.getBiogemeModel()
         logger.detailed(
-            f'Evaluate model with ' f'{len(b.freeBetaNames)} parameters.'
+            f'Evaluate model with ' f'{len(b.id_manager.free_betas.names)} parameters.'
         )
-        if len(b.freeBetaNames) == 0:
+        if len(b.id_manager.free_betas.names) == 0:
             estimationResults = None
             self.archive[aSolution] = estimationResults
             aSolution.valid = False
             aSolution.causeInvalidity = 'Model with 0 parameters'
             return estimationResults
 
-        if len(b.freeBetaNames) > self.maximumNumberOfParameters:
+        if len(b.id_manager.free_betas.names) > self.maximumNumberOfParameters:
             estimationResults = None
             self.archive[aSolution] = estimationResults
             aSolution.valid = False
             aSolution.causeInvalidity = (
                 f'More than {self.maximumNumberOfParameters}'
-                f' parameters: {len(b.freeBetaNames)}'
+                f' parameters: {len(b.id_manager.free_betas.names)}'
             )
             return estimationResults
 
         algoParameters = {'proportionAnalyticalHessian': 0.0, 'maxiter': 200}
         try:
             logger.temporarySilence()
             estimationResults = b.quickEstimate(algoParameters=algoParameters)
@@ -1767,15 +1809,15 @@
 
         return changes
 
     def changeModel(self, size=1, audit=False):
         """
         Select randomly another model from the list
 
-        :param size: not used here. Muxt be there for compliance with the
+        :param size: not used here. Must be there for compliance with the
             call of operators.
         :type size: int
 
         :param audit: if True, returns the number of changes without
             actually implementing them.
         :type audit: bool
 
@@ -1799,17 +1841,17 @@
     def __init__(self):
         super().__init__()
 
         self.objectivesNames = ['Neg. log likelihood', '#parameters']
         """ Names of the objective functions
         """
 
-        self.objectives = None #: values of the objectives
+        self.objectives = None  #: values of the objectives
 
-        self.valid = None #: True if the solution is valid
+        self.valid = None  #: True if the solution is valid
 
         self.causeInvalidity = None
         """If the solution is invalid, contains the cause of the invalidity
         """
 
         self.decisions = None
         """
@@ -1818,15 +1860,15 @@
         - a dict of decisions for each group of variables.
         - for each utility, a list of decisions for each term.
         - the selected model
 
         Type: tuple(dict(str: int), dict(str: list(dict(str: bool))), int)
         """
 
-        self.description = None #: description of the solution
+        self.description = None  #: description of the solution
 
     def __repr__(self):
         return str(self.decisions)
 
     def __str__(self):
         if self.description is None:
             raise excep.biogemeError(
@@ -1834,13 +1876,11 @@
             )
         res = self.description
         if self.objectivesNames is None:
             raise excep.biogemeError(
                 'The attribute objectivesNames is not defined'
             )
         if self.objectives is None:
-            raise excep.biogemeError(
-                'The attribute objectives is not defined'
-            )
+            raise excep.biogemeError('The attribute objectives is not defined')
         for t, r in zip(self.objectivesNames, self.objectives):
             res += f'\n{t}: {r}'
         return res
```

### Comparing `biogeme-3.2.8/biogeme/biogeme.py` & `biogeme-3.2.9/biogeme/biogeme_orig.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 from datetime import datetime
 import pickle
 import numpy as np
 import pandas as pd
 import tqdm
 
 import biogeme.database as db
-import biogeme.cbiogeme as cb
+import biogeme.cythonbiogeme as cb
 import biogeme.expressions as eb
 import biogeme.results as res
 import biogeme.exceptions as excep
 import biogeme.filenames as bf
 import biogeme.messaging as msg
 import biogeme.optimization as opt
 from biogeme import tools
@@ -48,16 +48,14 @@
         database,
         formulas,
         userNotes=None,
         numberOfThreads=None,
         numberOfDraws=1000,
         seed=None,
         skipAudit=False,
-        removeUnusedVariables=True,
-        displayUsedVariables=False,
         suggestScales=True,
         missingData=99999,
     ):
         """Constructor
 
         :param database: choice data.
         :type database: :class:`biogeme.database.Database`
@@ -97,23 +95,14 @@
         :type seed: int
 
         :param skipAudit: if True, does not check the validity of the
             formulas. It may save significant amount of time for large
             models and large data sets. Default: False.
         :type skipAudit: bool
 
-        :param removeUnusedVariables: if True, all variables not used
-            in the expression are removed from the database. Default:
-            True.
-        :type removeUnusedVariables: bool
-
-        :param displayUsedVariables: if True, displays all the
-            variables used in the formulas. Default: False.
-        :type displayUsedVariables: bool
-
         :param suggestScales: if True, Biogeme suggests the scaling of
             the variables in the database. Default: True.
             See also :func:`biogeme.database.Database.suggestScaling`
 
         :type suggestScales: bool.
 
         :param missingData: if one variable has this value, it is
@@ -141,15 +130,14 @@
                 self.logger.warning('\n'.join(listOfErrors))
                 raise excep.biogemeError('\n'.join(listOfErrors))
 
         self.loglikeName = 'loglike'
         """ Keyword used for the name of the loglikelihood formula.
         Default: 'loglike'"""
 
-
         self.weightName = 'weight'
         """Keyword used for the name of the weight formula. Default: 'weight'
         """
 
         self.modelName = 'biogemeModelDefaultName'
         """Name of the model. Default: 'biogemeModelDefaultName'
         """
@@ -165,27 +153,49 @@
         """If True, the current iterate is saved after each iteration, in a
         file named ``__[modelName].iter``, where ``[modelName]`` is the
         name given to the model. If such a file exists, the starting
         values for the estimation are replaced by the values saved in
         the file.
         """
 
+        self.missingData = missingData  #: code for missing data
+
+        self.database = database  #: :class:`biogeme.database.Database` object
+
         if not isinstance(formulas, dict):
             if not isinstance(formulas, eb.Expression):
                 raise excep.biogemeError(
                     f'Expression {formulas} is not of type '
                     f'biogeme.expressions.Expression. '
                     f'It is of type {type(formulas)}'
                 )
 
             self.loglike = formulas
             """ Object of type :class:`biogeme.expressions.Expression`
             calculating the formula for the loglikelihood
             """
 
+            if self.database.isPanel():
+                dict_of_variables = (
+                    formulas.dictOfVariablesOutsidePanelTrajectory()
+                )
+                if dict_of_variables:
+                    err_msg = (
+                        f'Error in the loglikelihood function. '
+                        f'Some variables are not inside PanelLikelihoodTrajectory: '
+                        f'{dict_of_variables.keys()} .'
+                        f'If the database is organized as panel data, '
+                        f'all variables must be used inside a '
+                        f'PanelLikelihoodTrajectory. '
+                        f'If it is not consistent with your model, generate a flat '
+                        f'version of the data using the function '
+                        f'`generateFlatPanelDataframe`.'
+                    )
+                    raise excep.biogemeError(err_msg)
+
             self.weight = None
             """ Object of type :class:`biogeme.expressions.Expression`
             calculating the weight of each observation in the
             sample.
             """
 
             self.formulas = dict({self.loglikeName: formulas})
@@ -202,67 +212,30 @@
                         f'biogeme.expressions.Expression. '
                         f'It is of type {type(f)}'
                     )
             self.loglike = formulas.get(self.loglikeName)
             self.weight = formulas.get(self.weightName)
             self.formulas = formulas
 
-        self.database = database #: :class:`biogeme.database.Database` object
-
-        self.userNotes = userNotes #: User notes
-
-        self.missingData = missingData #: code for missing data
+        for f in self.formulas.values():
+            f.missingData = self.missingData
 
+        self.userNotes = userNotes  #: User notes
 
         self.lastSample = None
         """ keeps track of the sample of data used to calculate the
         stochastic gradient / hessian
         """
 
-        self.initLogLike = None #: Init value of the likelihood function
-
-        self.nullLogLike = None #: Log likelihood of the null model
+        self.initLogLike = None  #: Init value of the likelihood function
 
-        self.usedVariables = set() #: set of variables used in the formulas.
-        for k, f in self.formulas.items():
-            myvars = f.setOfVariables()
-            missingVariables = [
-                v for v in myvars if v not in self.database.data
-            ]
-            if missingVariables:
-                errorMsg = (
-                    f'Variables in formula {k} missing in the database: '
-                    f'{missingVariables}'
-                )
-                raise excep.biogemeError(errorMsg)
-            self.usedVariables |= f.setOfVariables()
-        if self.database.isPanel():
-            self.usedVariables.add(self.database.panelColumn)
-        if displayUsedVariables:
-            self.logger.general(
-                f'List of used variables: {self.usedVariables}'
-            )
-        if removeUnusedVariables:
-            unusedVariables = (
-                set(self.database.data.columns) - self.usedVariables
-            )
-            error_msg = (
-                f'Remove {len(unusedVariables)} '
-                'unused variables from the database '
-                f'as only {len(self.usedVariables)} are used.'
-            )
-            self.logger.general(error_msg)
-            self.database.data = self.database.data.drop(
-                columns=list(unusedVariables)
-            )
+        self.nullLogLike = None  #: Log likelihood of the null model
 
         if suggestScales:
-            suggestedScales = self.database.suggestScaling(
-                columns=self.usedVariables
-            )
+            suggestedScales = self.database.suggestScaling()
             if not suggestedScales.empty:
                 self.logger.detailed(
                     'It is suggested to scale the following variables.'
                 )
                 for _, row in suggestedScales.iterrows():
                     error_msg = (
                         f'Multiply {row["Column"]} by\t{row["Scale"]} '
@@ -323,43 +296,41 @@
 
             self.loglikeSignatures = self.loglike.getSignature()
             """ Internal signature of the formula for the loglikelihood."""
             if self.weight is None:
                 self.theC.setExpressions(
                     self.loglikeSignatures, self.numberOfThreads
                 )
+
             else:
                 self.weightSignatures = self.weight.getSignature()
                 """ Internal signature of the formula for the weight."""
                 self.theC.setExpressions(
                     self.loglikeSignatures,
                     self.numberOfThreads,
                     self.weightSignatures,
                 )
 
         self.bootstrap_time = None
         """ Time needed to calculate the bootstrap standard errors"""
 
-
-        self.bootstrap_results = None #: Results of the bootstrap calculation.
+        self.bootstrap_results = None  #: Results of the bootstrap calculation.
 
         self.optimizationMessages = None
         """ Information provided by the optimization algorithm
         after completion.
         """
 
         self.algoParameters = None
         """ Parameters to be transferred to the optimization algorithm
         """
 
+        self.algorithm = None  #: Optimization algorithm
 
-        self.algorithm = None #: Optimization algorithm
-
-        self.bestIteration = None #: Store the best iteration found so far.
-
+        self.bestIteration = None  #: Store the best iteration found so far.
 
     def _saveIterationsFileName(self):
         """
         :return: The name of the file where the iterations are saved.
         :rtype: str
         """
         return f'__{self.modelName}.iter'
@@ -376,14 +347,27 @@
 
         listOfErrors = []
         listOfWarnings = []
         for v in self.formulas.values():
             err, war = v.audit(self.database)
             listOfErrors += err
             listOfWarnings += war
+        if self.weight is not None:
+            total = self.weight.getValue_c(
+                database=self.database, aggregation=True
+            )
+            s_size = self.database.getSampleSize()
+            ratio = s_size / total
+            if np.abs(ratio - 1) >= 0.01:
+                theWarning = (
+                    f'The sum of the weights ({total}) is different from '
+                    f'the sample size ({self.database.getSampleSize()}). '
+                    f'Multiply the weights by {ratio} to reconcile the two.'
+                )
+                listOfWarnings.append(theWarning)
         if listOfWarnings:
             self.logger.warning('\n'.join(listOfWarnings))
         if listOfErrors:
             self.logger.warning('\n'.join(listOfErrors))
             raise excep.biogemeError('\n'.join(listOfErrors))
 
     def _generateDraws(self, numberOfDraws):
@@ -474,15 +458,15 @@
             self.drawNames,
         ) = eb.defineNumberingOfElementaryExpressions(
             collectionOfFormulas, variableNames
         )
 
         # List of tuples (ell, u) containing the lower and upper bounds
         # for each free parameter
-        self.bounds = list()
+        self.bounds = []
         for x in self.freeBetaNames:
             self.bounds.append(
                 (self.allFreeBetas[x].lb, self.allFreeBetas[x].ub)
             )
         # List of ids of the free beta parameters (those to be estimated)
         self.betaIds = list(range(len(self.freeBetaNames)))
 
@@ -496,35 +480,39 @@
             float(self.allFixedBetas[x].initValue) for x in self.fixedBetaNames
         ]
 
     def calculateNullLoglikelihood(self, avail):
         """Calculate the log likelihood of the null model that predicts equal
         probability for each alternative
 
-        :param avail: list of expressions to evaluate the
-                      availability conditions for each alternative.
+        :param avail: list of expressions to evaluate the availability
+                      conditions for each alternative. If None, all
+                      alternatives are always available.
         :type avail: list of :class:`biogeme.expressions.Expression`
 
         :return: value of the log likelihood
         :rtype: float
 
         """
         expression = -eb.log(eb.bioMultSum(avail))
-        self.nullLogLike = self.database.sumFromDatabase(expression)
+
+        self.nullLogLike = expression.getValue_c(
+            database=self.database,
+            aggregation=True,
+        )
         return self.nullLogLike
 
     def calculateInitLikelihood(self):
         """Calculate the value of the log likelihood function
 
         The default values of the parameters are used.
 
         :return: value of the log likelihood.
         :rtype: float.
         """
-
         # Value of the loglikelihood for the default values of the parameters.
         self.initLogLike = self.calculateLikelihood(
             self.betaInitValues, scaled=False
         )
         return self.initLogLike
 
     def calculateLikelihood(self, x, scaled, batch=None):
@@ -610,15 +598,14 @@
         :rtype: tuple  float, numpy.array, numpy.array, numpy.array
 
         :raises ValueError: if the length of the list x is incorrect
 
         :raises biogemeError: if the norm of the gradient is not finite, an
             error is raised.
         """
-
         n = len(x)
         if n != len(self.betaInitValues):
             error_msg = (
                 f'Input vector must be of length '
                 f'{len(self.betaInitValues)} and not {len(x)}'
             )
             raise ValueError(error_msg)
@@ -839,18 +826,17 @@
 
             # Estimate the parameters
             results = biogeme.estimate()
 
         :raises biogemeError: if no expression has been provided for the
             likelihood
         """
-
         if self.loglike is None:
             raise excep.biogemeError(
-                'No log likelihood function has been specificed'
+                'No log likelihood function has been specified'
             )
         if len(self.freeBetaNames) == 0:
             raise excep.biogemeError(
                 f'There is no parameter to estimate'
                 f' in the formula: {self.loglike}.'
             )
 
@@ -892,20 +878,22 @@
             if not np.isfinite(fgHb[2]).all():
                 self.logger.warning(
                     'Numerical problems with finite '
                     'difference hessian as well.'
                 )
             else:
                 fgHb = fgHb[0], fgHb[1], finDiffHessian, fgHb[3]
+
         # numpy array, of size B x K,
         # where
         #        - B is the number of bootstrap iterations
         #        - K is the number pf parameters to estimate
         self.bootstrap_results = None
         if bootstrap > 0:
+
             start_time = datetime.now()
 
             self.logger.general(
                 f'Re-estimate the model {bootstrap} times for bootstrapping'
             )
             self.bootstrap_results = np.empty(shape=[bootstrap, len(xstar)])
             hideProgress = self.logger.screenLevel == 0
@@ -1036,23 +1024,25 @@
             )
 
         keepDatabase = self.database
 
         allSimulationResults = []
         for v in validationData:
             # v[0] is the estimation data set
-            self.database = db.Database('Estimation data', v[0])
+            database = db.Database('Estimation data', v.estimation)
             self.loglike.changeInitValues(estimationResults.getBetaValues())
-            results = self.estimate()
+            estBiogeme = BIOGEME(database, self.loglike)
+            results = estBiogeme.estimate()
             simulate = {'Loglikelihood': self.loglike}
             simBiogeme = BIOGEME(
-                db.Database('Validation data', v[1]), simulate
+                db.Database('Validation data', v.validation), simulate
             )
             simResult = simBiogeme.simulate(results.getBetaValues())
             allSimulationResults.append(simResult)
+
         self.database = keepDatabase
         if self.generatePickle:
             fname = f'{self.modelName}_validation'
             pickleFileName = bf.getNewFileName(fname, 'pickle')
             with open(pickleFileName, 'wb') as f:
                 pickle.dump(allSimulationResults, f)
             self.logger.general(
@@ -1095,14 +1085,15 @@
                 'is not available anymore.'
             )
             raise excep.biogemeError(err)
 
         results = self.algorithm(
             theFunction, startingValues, self.bounds, self.algoParameters
         )
+
         return results
 
     def simulate(self, theBetaValues=None):
         """Applies the formulas to each row of the database.
 
         :param theBetaValues: values of the parameters to be used in
                 the calculations. If None, the default values are
@@ -1122,48 +1113,67 @@
               # Simulate the formulas using the nominal values
               simulatedValues = biogeme.simulate(betaValues)
 
         :raises biogemeError: if the number of parameters is incorrect
 
         """
 
-        if self.database.isPanel():
-            error_msg = (
-                'Simulation for panel data is not yet'
-                ' implemented. Remove the "panel" '
-                'statement to simulate each observation.'
-            )
-            raise excep.biogemeError(error_msg)
-
         if theBetaValues is None:
             betaValues = self.betaInitValues
         else:
             if not isinstance(theBetaValues, dict):
                 err = (
                     'Deprecated. A dictionary must be provided. '
                     'It can be obtained from results.getBetaValues()'
                 )
                 raise excep.biogemeError(err)
             for x in theBetaValues.keys():
                 if x not in self.freeBetaNames:
-                    self.logger.warning(f'Parameter {x} not present in the model')
-            betaValues = list()
+                    self.logger.warning(
+                        f'Parameter {x} not present in the model'
+                    )
+            betaValues = []
             for i, x in enumerate(self.freeBetaNames):
                 if x in theBetaValues:
                     betaValues.append(theBetaValues[x])
                 else:
                     self.logger.warning(
                         f'Simulation: initial value of {x} not provided.'
                     )
                     betaValues.append(self.betaInitValues[i])
 
+        if self.database.isPanel():
+            for f in self.formulas.values():
+                count = f.countPanelTrajectoryExpressions()
+                if count != 1:
+                    theError = (
+                        f'For panel data, the expression must '
+                        f'contain exactly one PanelLikelihoodTrajectory '
+                        f'operator. It contains {count}: {f}'
+                    )
+                    raise excep.biogemeError(theError)
+
         output = pd.DataFrame(index=self.database.data.index)
-        formulas = [v.getSignature() for v in self.formulas.values()]
+        formulas_signature = [v.getSignature() for v in self.formulas.values()]
+
+        if self.database.isPanel():
+            self.database.buildPanelMap()
+            self.theC.setDataMap(self.database.individualMap)
+
+        for v in self.formulas.values():
+            self.logger.debug(f'Audit {v}')
+            listOfErrors, listOfWarnings = v.audit(database=self.database)
+            if listOfWarnings:
+                self.logger.warning('\n'.join(listOfWarnings))
+            if listOfErrors:
+                self.logger.warning('\n'.join(listOfErrors))
+                raise excep.biogemeError('\n'.join(listOfErrors))
+
         result = self.theC.simulateSeveralFormulas(
-            formulas,
+            formulas_signature,
             betaValues,
             self.fixedBetaValues,
             self.database.data,
             self.numberOfThreads,
         )
         for key, r in zip(self.formulas.keys(), result):
             output[key] = r
@@ -1203,15 +1213,17 @@
                 err = (
                     'Deprecated. A dictionary must be provided. '
                     'It can be obtained from results.getBetaValues()'
                 )
                 raise excep.biogemeError(err)
             for x in theBetaValues.keys():
                 if x not in self.freeBetaNames:
-                    self.logger.warning(f'Parameter {x} not present in the model')
+                    self.logger.warning(
+                        f'Parameter {x} not present in the model'
+                    )
             betaValues = list()
             for i, x in enumerate(self.freeBetaNames):
                 if x in theBetaValues:
                     betaValues.append(theBetaValues[x])
                 else:
                     self.logger.warning(
                         f'Simulation: initial value of {x} not provided.'
@@ -1317,31 +1329,31 @@
 
     def __init__(self, like, like_deriv, scaled):
         """Constructor"""
         self.recalculate = True
         """True if the log likelihood must be recalculated
         """
 
-        self.x = None #: Vector of unknown parameters values
+        self.x = None  #: Vector of unknown parameters values
 
         self.batch = None
         """Value betwen 0 and 1 defining the size of the batch, that is the
         percentage of the data that should be used to approximate the
         log likelihood.
         """
 
-        self.fv = None #: value of the function
+        self.fv = None  #: value of the function
 
-        self.gv = None #: vector with the gradient
+        self.gv = None  #: vector with the gradient
 
-        self.hv = None #: second derivatives matrix
+        self.hv = None  #: second derivatives matrix
 
-        self.bhhhv = None #: BHHH matrix
+        self.bhhhv = None  #: BHHH matrix
 
-        self.like = like #: function calculating the log likelihood
+        self.like = like  #: function calculating the log likelihood
 
         self.like_deriv = like_deriv
         """function calculating the log likelihood and its derivatives.
         """
 
         self.scaled = scaled
         """if True, the value of the log likelihood is divided by the number
@@ -1393,14 +1405,15 @@
             )
             self.hv = None
             self.bhhhv = None
 
         return -self.fv, -self.gv
 
     def f_g_h(self, batch=None):
+        logger = msg.bioMessage()
         if self.x is None:
             raise excep.biogemeError('The variables must be set first.')
 
         if batch is not None or self.batch is not None:
             self.batch = batch
             self.recalculate = True
```

### Comparing `biogeme-3.2.8/biogeme/database.py` & `biogeme-3.2.9/biogeme/database.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,27 +7,42 @@
 
 """
 
 # There seems to be a bug in PyLint.
 # pylint: disable=invalid-unary-operand-type, too-many-function-args
 
 # Too constraining
-# pylint: disable=invalid-name, too-many-arguments, too-many-locals, too-many-statements, too-many-branches, too-many-instance-attributes, too-many-lines, too-many-public-methods
+
+# pylint: disable=invalid-name, too-many-arguments, too-many-locals,
+# pylint: disable=too-many-statements, too-many-branches,
+# pylint: disable=too-many-instance-attributes, too-many-lines,
+# pylint: disable=too-many-public-methods
 
 import numpy as np
 import pandas as pd
+from collections import namedtuple
 
 import biogeme.exceptions as excep
 import biogeme.filenames as bf
 import biogeme.messaging as msg
 from biogeme import tools
 from biogeme import draws
 
 from biogeme.expressions import Variable, isNumeric, Numeric
 
+EstimationValidation = namedtuple(
+    'EstimationValidation', 'estimation validation'
+)
+
+logger = msg.bioMessage()
+"""Logger that controls the output of
+        messages to the screen and log file.
+        Type: class :class:`biogeme.messaging.bioMessage`.
+        """
+
 
 class Database:
     """Class that contains and prepare the database."""
 
     def __init__(self, name, pandasDatabase):
         """Constructor
 
@@ -35,26 +50,21 @@
         :type name: string
 
         :param pandasDatabase: data stored in a pandas data frame.
         :type pandasDatabase: pandas.DataFrame
 
         :raise biogemeError: if the audit function detects errors.
         """
-        self.logger = msg.bioMessage()
-        """Logger that controls the output of
-        messages to the screen and log file.
-        Type: class :class:`biogeme.messaging.bioMessage`.
-        """
-        
+
         self.name = name
         """ Name of the database. Used mainly for the file name when
         dumping data.
         """
 
-        self.data = pandasDatabase #: Pandas data frame containing the data.
+        self.data = pandasDatabase  #: Pandas data frame containing the data.
 
         self.fullData = pandasDatabase
         """Pandas data frame containing the full data. Useful when batches of
         the sample are used for approximating the log likelihood.
         """
 
         self.variables = None
@@ -81,51 +91,51 @@
         """
 
         self.fullIndividualMap = None
         """complete map identifying the range of observations for each
         individual in a panel data context. None if data is not
         panel. Useful when batches of the sample are used to
         approximate the log likelihood function.
-        """ 
+        """
 
-        ## Initialize the dictionary containing random number
-        ## generators with a series of native generators.
+        # Initialize the dictionary containing random number
+        # generators with a series of native generators.
         self._initNativeRandomNumberGenerators()
 
         self.userRandomNumberGenerators = dict()
         """Dictionary containing user defined random number
         generators. Defined by the function
         Database.setRandomNumberGenerators that checks that reserved
         keywords are not used. The element of the dictionary is a
         tuple with two elements: (0) the function generating the
         draws, and (1) a string describing the type of draws
         """
-        
+
         self.numberOfDraws = 0
         """Number of draws generated by the function Database.generateDraws.
         Value 0 if this function is not called.
         """
 
-        self.typesOfDraws = {} #: Types of draws for Monte Carlo integration
+        self.typesOfDraws = {}  #: Types of draws for Monte Carlo integration
 
         self._auditDone = False
 
-        self.theDraws = None #:Draws for Monte-Carlo integration
+        self.theDraws = None  #: Draws for Monte-Carlo integration
 
-        self._avail = None #: Availability expression to check
+        self._avail = None  #: Availability expression to check
 
-        self._choice = None #: Choice expression to check
+        self._choice = None  #: Choice expression to check
 
-        self._expression = None #: Expression to check
+        self._expression = None  #: Expression to check
 
         listOfErrors, listOfWarnings = self._audit()
         if listOfWarnings:
-            self.logger.warning('\n'.join(listOfWarnings))
+            logger.warning('\n'.join(listOfWarnings))
         if listOfErrors:
-            self.logger.warning('\n'.join(listOfErrors))
+            logger.warning('\n'.join(listOfErrors))
             raise excep.biogemeError('\n'.join(listOfErrors))
 
     def _initNativeRandomNumberGenerators(self):
         def uniform_antithetic(sampleSize, numberOfDraws):
             return draws.getAntithetic(
                 draws.getUniform, sampleSize, numberOfDraws
             )
@@ -236,15 +246,15 @@
             unif = draws.getLatinHypercubeDraws(
                 sampleSize, int(numberOfDraws / 2)
             )
             return draws.getNormalWichuraDraws(
                 sampleSize, numberOfDraws, uniformNumbers=unif, antithetic=True
             )
 
-        ## Dictionary containing native random number generators.
+        # Dictionary containing native random number generators.
         self.nativeRandomNumberGenerators = {
             'UNIFORM': (draws.getUniform, 'Uniform U[0, 1]'),
             'UNIFORM_ANTI': (uniform_antithetic, 'Antithetic uniform U[0, 1]'),
             'UNIFORM_HALTON2': (
                 halton2,
                 'Halton draws with base 2, skipping the first 10',
             ),
@@ -382,23 +392,16 @@
         :type expression:  biogeme.expressions.Expression.
 
         :return: numpy series, long as the number of entries
                  in the database, containing the calculated quantities.
         :rtype: numpy.Series
 
         """
-        self._expression = expression
-
-        def functionToApply(row):
-            self._expression.setRow(row)
-            res = self._expression.getValue()
-            return res
 
-        res = self.data.apply(functionToApply, axis=1)
-        return res
+        return expression.getValue_c(database=self, prepareIds=True)
 
     def checkAvailabilityOfChosenAlt(self, avail, choice):
         """Check if the chosen alternative is available for each entry
         in the database.
 
         :param avail: list of expressions to evaluate the
                       availability conditions for each alternative.
@@ -407,33 +410,42 @@
         :type choice: biogeme.expressions.Expression
 
         :return: numpy series of bool, long as the number of entries
                  in the database, containing True is the chosen alternative is
                  available, False otherwise.
         :rtype: numpy.Series
 
+        :raise biogemeError: if the chosen alternative does not appear
+            in the availability dict
         """
         self._avail = avail
         self._choice = choice
 
-        def functionToApply(row):
-            self._choice.setRow(row)
-            chosen = self._choice.getValue()
-            try:
-                avExpression = self._avail[chosen]
-            except IndexError:
-                return False
-            except KeyError:
-                return False
-            avExpression.setRow(row)
-            av = avExpression.getValue()
-            return av != 0
-
-        res = self.data.apply(functionToApply, axis=1)
-        return res
+        choice_array = choice.getValue_c(
+            database=self, aggregation=False, prepareIds=True
+        )
+        calculated_avail = {}
+        for key, expression in avail.items():
+            calculated_avail[key] = expression.getValue_c(
+                database=self, aggregation=False, prepareIds=True
+            )
+        try:
+            avail_chosen = np.array(
+                [calculated_avail[c][i] for i, c in enumerate(choice_array)]
+            )
+        except KeyError as e:
+            for c in choice_array:
+                err_msg = ''
+                if c not in calculated_avail:
+                    err_msg = (
+                        f'Chosen alternative {c} does not appear in '
+                        f'availability dict: {calculated_avail.keys()}'
+                    )
+                    raise excep.biogemeError(err_msg)
+        return avail_chosen != 0
 
     def choiceAvailabilityStatistics(self, avail, choice):
         """Calculates the number of time an alternative is chosen and available
 
         :param avail: list of expressions to evaluate the
                       availability conditions for each alternative.
         :type avail: list of biogeme.expressions.Expression
@@ -444,51 +456,50 @@
             it is chosen, and the number of time it is available.
         :rtype: dict(int: (int, int))
 
         """
         self._avail = avail
         self._choice = choice
 
-        def functionToApply(row):
-            self._choice.setRow(row)
-            chosen = self._choice.getValue()
-            results = [chosen]
-            for v in self._avail.values():
-                v.setRow(row)
-                av = v.getValue()
-                results.append(av)
-            return pd.Series(
-                results, index=['Chosen'] + list(self._avail.keys())
-            )
-
-        res = self.data.apply(functionToApply, axis=1)
-        theResults = dict()
-        for k in self._avail:
-            c = (res['Chosen'] == k).sum()
-            theResults[k] = c, res[k].sum()
+        choice_array = choice.getValue_c(
+            database=self,
+            aggregation=False,
+            prepareIds=True,
+        )
+        unique = np.unique(choice_array, return_counts=True)
+        choice_stat = {alt: unique[1][i] for i, alt in enumerate(unique[0])}
+        calculated_avail = {}
+        for key, expression in avail.items():
+            calculated_avail[key] = expression.getValue_c(
+                database=self,
+                aggregation=False,
+                prepareIds=True,
+            )
+        avail_stat = {k: sum(a) for k, a in calculated_avail.items()}
+        theResults = {
+            alt: (c, avail_stat[alt]) for alt, c in choice_stat.items()
+        }
         return theResults
 
     def sumFromDatabase(self, expression):
         """Calculates the value of an expression for each entry
         in the database, and returns the sum.
 
+        Obsolete since 3.2.9.
+
         :param expression: expression to evaluate
         :type expression: biogeme.expressions.Expression
+
         :return: sum of the expressions over the database.
         :rtype: float
-        """
-        self._expression = expression
-
-        def functionToApply(row):
-            self._expression.setRow(row)
-            res = self._expression.getValue()
-            return res
 
-        res = np.nansum(self.data.apply(functionToApply, axis=1))
-        return res
+        :raise biogemeError: if called.
+        """
+        error_msg = 'Obsolete: use expression.getValue_c(database) instead'
+        raise excep.biogemeError(error_msg)
 
     def scaleColumn(self, column, scale):
         """Multiply an entire column by a scale value
 
         :param column: name of the column
         :type column: string
         :param scale: value of the scale. All values of the column will
@@ -526,15 +537,15 @@
 
         :raise biogemeError: if a variable in ``columns`` is unknown.
         """
         if columns is None:
             columns = self.data.columns
         else:
             for c in columns:
-                if not c in self.data:
+                if c not in self.data:
                     errorMsg = f'Variable {c} not found.'
                     raise excep.biogemeError(errorMsg)
 
         largestValue = [
             max(np.abs(self.data[col].max()), np.abs(self.data[col].min()))
             for col in columns
         ]
@@ -638,19 +649,14 @@
                     if right:
                         message += f' Columns that were added: {right}'
                     raise excep.biogemeError(message)
 
             self.individualMap = self.fullIndividualMap.sample(
                 frac=samplingRate, weights=columnWithSamplingWeights
             )
-            theMsg = (
-                f'Full data: {self.fullIndividualMap.shape} '
-                f'Sampled data: {self.individualMap.shape}'
-            )
-            self.logger.debug(theMsg)
 
         else:
             # Cross sectional data
             if self.fullData is None:
                 self.fullData = self.data
             else:
                 # Check if the structure has not been modified since
@@ -671,18 +677,14 @@
                     if right:
                         message += f' Columns that were added: {right}'
                     raise excep.biogemeError(message)
 
             self.data = self.fullData.sample(
                 frac=samplingRate, weights=columnWithSamplingWeights
             )
-            self.logger.debug(
-                f'Full data: {self.fullData.shape} '
-                f'Sampled data: {self.data.shape}'
-            )
 
     def useFullSample(self):
         """Re-establish the full sample for calculation of the likelihood"""
         if self.isPanel():
             if self.fullIndividualMap is None:
                 raise excep.biogemeError(
                     'Full panel data set has not been saved.'
@@ -709,23 +711,27 @@
 
         """
         if column in self.data.columns:
             raise ValueError(
                 f'Column {column} already exists in the database {self.name}'
             )
 
-        def functionToApply(row):
-            self._expression.setRow(row)
-            return self._expression.getValue()
-
         self._expression = expression
-        self.data[column] = self.data.apply(functionToApply, axis=1)
+        new_column = self._expression.getValue_c(
+            database=self, aggregation=False, prepareIds=True
+        )
+        self.data[column] = new_column
         self.variables[column] = Variable(column)
         return self.data[column]
 
+    def DefineVariable(self, name, expression):
+        """Insert a new column in the database and define it as a variable."""
+        self.addColumn(expression, name)
+        return Variable(name)
+
     def remove(self, expression):
         """Removes from the database all entries such that the value
         of the expression is not 0.
 
         :param expression: expression to evaluate
         :type expression: biogeme.expressions.Expression
 
@@ -746,24 +752,25 @@
 
         :return:  name of the file
         :rtype: string
         """
         theName = f'{self.name}_dumped'
         dataFileName = bf.getNewFileName(theName, 'dat')
         self.data.to_csv(dataFileName, sep='\t', index_label='__rowId')
-        self.logger.general(f'File {dataFileName} has been created')
+        logger.general(f'File {dataFileName} has been created')
         return dataFileName
 
     def setRandomNumberGenerators(self, rng):
         """Defines user-defined random numbers generators.
 
         :param rng: a dictionary of generators. The keys of the dictionary
            characterize the name of the generators, and must be
-           different from the pre-defined generators in Biogeme:
-           NORMAL, UNIFORM and UNIFORMSYM. The elements of the
+           different from the pre-defined generators in Biogeme
+           (see :func:`~biogeme.database.Database.generateDraws` for the list).
+           The elements of the
            dictionary are functions that take two arguments: the
            number of series to generate (typically, the size of the
            database), and the number of draws per series.
         :type rng: dict
 
         Example::
 
@@ -798,15 +805,60 @@
     def generateDraws(self, types, names, numberOfDraws):
         """Generate draws for each variable.
 
 
         :param types: A dict indexed by the names of the variables,
                       describing the types of draws. Each of them can
                       be a native type or any type defined by the
-                      function database.setRandomNumberGenerators
+                      function :func:`~biogeme.database.Database.setRandomNumberGenerators`.
+
+                      Native types:
+
+                      - ``'UNIFORM'``: Uniform U[0, 1],
+                      - ``'UNIFORM_ANTI``: Antithetic uniform U[0, 1]',
+                      - ``'UNIFORM_HALTON2'``: Halton draws with base 2,
+                        skipping the first 10,
+                      - ``'UNIFORM_HALTON3'``: Halton draws with base 3,
+                        skipping the first 10,
+                      - ``'UNIFORM_HALTON5'``: Halton draws with base 5,
+                        skipping  the first 10,
+                      - ``'UNIFORM_MLHS'``: Modified Latin Hypercube
+                        Sampling on [0, 1],
+                      - ``'UNIFORM_MLHS_ANTI'``: Antithetic Modified
+                        Latin Hypercube Sampling on [0, 1],
+                      - ``'UNIFORMSYM'``: Uniform U[-1, 1],
+                      - ``'UNIFORMSYM_ANTI'``: Antithetic uniform U[-1, 1],
+                      - ``'UNIFORMSYM_HALTON2'``: Halton draws on [-1, 1]
+                        with base 2, skipping the first 10,
+                      - ``'UNIFORMSYM_HALTON3'``: Halton draws on [-1, 1]
+                        with base 3, skipping the first 10,
+                      - ``'UNIFORMSYM_HALTON5'``: Halton draws on [-1, 1]
+                        with base 5, skipping the first 10,
+                      - ``'UNIFORMSYM_MLHS'``: Modified Latin Hypercube
+                        Sampling on [-1, 1],
+                      - ``'UNIFORMSYM_MLHS_ANTI'``: Antithetic Modified
+                        Latin Hypercube Sampling on [-1, 1],
+                      - ``'NORMAL'``: Normal N(0, 1) draws,
+                      - ``'NORMAL_ANTI'``: Antithetic normal draws,
+                      - ``'NORMAL_HALTON2'``: Normal draws from Halton
+                        base 2 sequence,
+                      - ``'NORMAL_HALTON3'``: Normal draws from Halton
+                        base 3 sequence,
+                      - ``'NORMAL_HALTON5'``: Normal draws from Halton
+                        base 5 sequence,
+                      - ``'NORMAL_MLHS'``: Normal draws from Modified
+                        Latin Hypercube Sampling,
+                      - ``'NORMAL_MLHS_ANTI'``: Antithetic normal draws
+                        from Modified Latin Hypercube Sampling]
+
+                      For an updated description of the native types, call the function
+                      :func:`~biogeme.database.Database.descriptionOfNativeDraws`.
+
+
+
         :type types: dict
 
         :param names: the list of names of the variables that require draws
             to be generated.
         :type names: list of strings
 
         :param numberOfDraws: number of draws to generate.
@@ -825,20 +877,19 @@
               types = {'randomDraws1': 'NORMAL_MLHS_ANTI',
                        'randomDraws2': 'UNIFORM_MLHS_ANTI',
                        'randomDraws3': 'UNIFORMSYM_MLHS_ANTI'}
               theDrawsTable = myData.generateDraws(types,
                   ['randomDraws1', 'randomDraws2', 'randomDraws3'], 10)
 
 
-        :raise biogemeError: if a type of sdraw is unknown.
+        :raise biogemeError: if a type of draw is unknown.
 
         :raise biogemeError: if the output of the draw generator does not
             have the requested dimensions.
         """
-
         self.numberOfDraws = numberOfDraws
         # Dimensions of the draw table:
         # 1. number of variables
         # 2. number of individuals
         # 3. number of draws
         listOfDraws = [None] * len(names)
         for i, v in enumerate(names):
@@ -867,16 +918,16 @@
                     f' generate a numpy array of dimensions'
                     f' ({self.getSampleSize()}, {numberOfDraws})'
                     f' instead of {listOfDraws[i].shape}'
                 )
                 raise excep.biogemeError(errorMsg)
 
         self.theDraws = np.array(listOfDraws)
-        ## Draws as a three-dimensional numpy series. The dimensions
-        ## are organized to be more suited for calculation.
+        # Draws as a three-dimensional numpy series. The dimensions
+        # are organized to be more suited for calculation.
         # 1. number of individuals
         # 2. number of draws
         # 3. number of variables
         self.theDraws = np.moveaxis(self.theDraws, 0, -1)
         return self.theDraws
 
     def getNumberOfObservations(self):
@@ -907,33 +958,72 @@
 
         """
         if self.isPanel():
             return self.individualMap.shape[0]
 
         return self.data.shape[0]
 
-    def split(self, slices):
+    def split(self, slices, groups=None):
         """Prepare estimation and validation sets for validation.
 
         :param slices: number of slices
         :type slices: int
 
+        :param groups: name of the column that defines the ID of the
+            groups. Data belonging to the same groups will be maintained
+            together.
+        :type groups: str
+
         :return: list of estimation and validation data sets
         :rtype: list(tuple(pandas.DataFrame, pandas.DataFrame))
+
+        :raise biogemeError: if the number of slices is less than two
+
         """
-        shuffled = self.data.sample(frac=1)
-        theSlices = np.array_split(shuffled, slices)
+        if slices < 2:
+            error_msg = (
+                f'The number of slices is {slices}. It must be greater '
+                f'or equal to 2.'
+            )
+            raise excep.biogemeError(error_msg)
+
+        if groups is not None and self.isPanel():
+            if groups != self.panelColumn:
+                error_msg = (
+                    f'The data is already organized by groups on '
+                    f'{self.panelColumn}. The grouping by {groups} '
+                    f'cannot be done.'
+                )
+                raise excep.biogemeError(error_msg)
+
+        if self.isPanel():
+            groups = self.panelColumn
+
+        if groups is None:
+            shuffled = self.data.sample(frac=1)
+            theSlices = np.array_split(shuffled, slices)
+        else:
+            ids = self.data[groups].unique()
+            np.random.shuffle(ids)
+            the_slices_ids = np.array_split(ids, slices)
+            theSlices = [
+                self.data[self.data[groups].isin(ids)]
+                for ids in the_slices_ids
+            ]
         estimationSets = []
         validationSets = []
         for i, v in enumerate(theSlices):
             estimationSets.append(
                 pd.concat(theSlices[:i] + theSlices[i + 1 :])
             )
             validationSets.append(v)
-        return zip(estimationSets, validationSets)
+        return [
+            EstimationValidation(estimation=e, validation=v)
+            for e, v in zip(estimationSets, validationSets)
+        ]
 
     def isPanel(self):
         """Tells if the data is panel or not.
 
         :return: True if the data is panel.
         :rtype: bool
         """
@@ -996,13 +1086,45 @@
         :type value: float
 
         :return: Number of times that the value appears in the column.
         :rtype: int
         """
         return self.data[self.data[columnName] == value].count()[columnName]
 
+    def generateFlatPanelDataframe(
+        self, saveOnFile=None, identical_columns=[]
+    ):
+        """Generate a flat version of the panel data
+
+        :param saveOnFile: if True, the flat database is saved on file.
+        :type saveOnFile: bool
+
+        :param identical_columns: list of columns that contain the
+            same values for all observations of the same individual. If
+            None, these columns are automatically detected. Default: empty
+            list.
+        :type identical_columns: list(str)
+
+        :return: the flatten database, in Pandas format
+        :rtype: pandas.DataFrame
+
+        :raise biogemeError: if the database in not panel
+
+        """
+        if not self.isPanel():
+            error_msg = 'This function can only be called for panel data'
+            raise excep.biogemeError(error_msg)
+        flat_data = tools.flatten_database(
+            self.data, self.panelColumn, identical_columns=identical_columns
+        )
+        if saveOnFile:
+            file_name = f'{self.name}_flatten.csv'
+            flat_data.to_csv(file_name)
+            logger.general(f'File {file_name} has been created.')
+        return flat_data
+
     def __str__(self):
         """Allows to print the dabase"""
         result = f'biogeme database {self.name}:\n{self.data}'
         if self.isPanel():
             result += f'\nPanel data\n{self.individualMap}'
         return result
```

### Comparing `biogeme-3.2.8/biogeme/distributions.py` & `biogeme-3.2.9/biogeme/distributions.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,18 +10,18 @@
 # pylint: disable=invalid-unary-operand-type, too-many-function-args
 
 # Too constraining
 # pylint: disable=invalid-name, too-many-arguments, too-many-locals, too-many-statements,
 # pylint: disable=too-many-branches, too-many-instance-attributes, too-many-lines,
 # pylint: disable=too-many-public-methods
 
-from biogeme.expressions import log, exp
+from biogeme.expressions import log, exp, Numeric
 
 
-def normalpdf(x, mu=0.0, s=1.0):
+def normalpdf(x, mu=Numeric(0.0), s=Numeric(1.0)):
     """
     Normal pdf
 
     Probability density function of a normal distribution
 
     .. math:: f(x;\\mu, \\sigma) =
         \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp{-\\frac{(x-\\mu)^2}{2\\sigma^2}}
@@ -148,15 +148,15 @@
         * 2.0
         * (b - x)
         / ((b - a) * (b - c))
     )
     return result
 
 
-def logisticcdf(x, mu=0.0, s=1.0):
+def logisticcdf(x, mu=Numeric(0.0), s=Numeric(1.0)):
     """
     Logistic CDF
 
     Cumulative distribution function of a logistic distribution
 
     .. math:: f(x;\\mu, \\sigma) = \\frac{1}
         {1+\\exp\\left(-\\frac{x-\\mu}{\\sigma} \\right)}
```

### Comparing `biogeme-3.2.8/biogeme/draws.py` & `biogeme-3.2.9/biogeme/draws.py`

 * *Files 6% similar despite different names*

```diff
@@ -147,15 +147,16 @@
     numbers.shape = (sampleSize, numberOfDraws)
     return numbers
 
 
 def getHaltonDraws(
     sampleSize, numberOfDraws, symmetric=False, base=2, skip=0, shuffled=False
 ):
-    """Generate Halton draws
+    """Generate Halton draws.
+    Implementation by Cristian Arteaga, University of Nevada Las Vegas,
 
     :param sampleSize: number of observations for which draws must be
                        generated. If None, a one dimensional array
                        will be generated. If it has a values k, then k
                        series of draws will be generated
     :type sampleSize: int
 
@@ -194,30 +195,34 @@
     if numberOfDraws <= 0:
         raise excep.biogemeError(f'Invalid number of draws: {numberOfDraws}.')
 
     if sampleSize <= 0:
         raise excep.biogemeError(
             f'Invalid sample size: {sampleSize} when generating draws.'
         )
-    totalSize = numberOfDraws * sampleSize
+    length = numberOfDraws * sampleSize
+    req_length = length + skip + 1
+    numbers = np.empty(req_length)
+    numbers[0] = 0
+    numbers_idx = 1
+    t = 1
+    while numbers_idx < req_length:
+        d = 1 / base**t
+        numbers_size = numbers_idx
+        i = 1
+        while i < base and numbers_idx < req_length:
+            max_numbers = min(req_length - numbers_idx, numbers_size)
+            numbers[numbers_idx : numbers_idx + max_numbers] = (
+                numbers[:max_numbers] + d * i
+            )
+            numbers_idx += max_numbers
+            i += 1
+        t += 1
+    numbers = numbers[skip + 1 : length + skip + 1]
 
-    numbers = []
-    skipped = 0
-    for i in range(totalSize + 1 + skip):
-        n, denom = 0.0, 1.0
-        while i > 0:
-            i, remainder = divmod(i, base)
-            denom *= base
-            n += remainder / denom
-        if skipped < skip:
-            skipped += 1
-        else:
-            numbers.append(n)
-
-    numbers = np.array(numbers[1:])
     if shuffled:
         np.random.shuffle(numbers)
 
     if symmetric:
         numbers = 2.0 * numbers - 1.0
 
     numbers.shape = (sampleSize, numberOfDraws)
@@ -268,15 +273,15 @@
     """Generate pseudo-random numbers from a normal distribution N(0, 1)
 
     It uses the Algorithm AS241 by `Wichura (1988)`_
     which produces the normal deviate z corresponding to a given lower
     tail area of p; z is accurate to about 1 part in :math:`10^{16}`.
 
     .. _`Wichura (1988)`:
-       http://www.jstor.org/stable/2347330 
+       http://www.jstor.org/stable/2347330
 
     :param sampleSize: number of observations for which draws must be
                        generated. If None, a one dimensional array
                        will be generated. If it has a values k, then k
                        series of draws will be generated
     :type sampleSize: int
```

### Comparing `biogeme-3.2.8/biogeme/expressions.py` & `biogeme-3.2.9/biogeme/expressions.py`

 * *Files 15% similar despite different names*

```diff
@@ -9,18 +9,22 @@
 # Too constraining
 # pylint: disable=invalid-name
 
 # Too constraining
 # pylint: disable=invalid-name, too-many-locals, too-many-arguments
 # pylint: disable=too-many-instance-attributes, too-many-lines
 
+from itertools import chain
 import numpy as np
 import biogeme.exceptions as excep
-import biogeme.cbiogeme as cb
 import biogeme.messaging as msg
+import biogeme.cythonbiogeme as ee
+from biogeme.idmanager import IdManager
+
+logger = msg.bioMessage()
 
 
 def isNumeric(obj):
     """Identifies if an object is numeric, that is int, float or bool.
 
     :param obj: any object
     :type obj: object
@@ -35,60 +39,119 @@
     """This is the general arithmetic expression in biogeme.
     It serves as a base class for concrete expressions.
     """
 
     def __init__(self):
         """Constructor"""
 
-        self.logger = msg.bioMessage()
-        """Logger that controls the output of
-        messages to the screen and log file.
-        Type: class :class:`biogeme.messaging.bioMessage`.
-        """
-
-        self.parent = None #: Parent expression
+        self.children = []  #: List of children expressions
 
-        self.children = list() #: List of children expressions
+        self.id_manager = None  #: in charge of the IDs
+        self.keep_id_manager = None  #: a copy of the ID manager
 
-        self.elementaryExpressionIndex = None
-        """Indices of the elementary expressions (dict)"""
+        self.fixedBetaValues = None
+        """values of the Beta that are not estimated
+        """
 
-        self.allFreeBetas = dict() #: dict of free parameters
+        self.numberOfDraws = None
+        """number of draws for Monte Carlo integration
+        """
 
-        self.freeBetaNames = list() #: list of names of free parameters
+        self._row = None
+        """Row of the database where the values of the variables are found
+        """
 
-        self.allFixedBetas = dict() #: dict of fixed parameters
+        self.cpp = ee.pyEvaluateOneExpression()
+        """ Interface to the C++ implementation
+        """
 
-        self.fixedBetaNames = list() #: list of names of fixed parameters
+        self.missingData = 99999
+        """ Value interpreted as missing data
+        """
 
-        self.allRandomVariables = None #: dict of random variables
+    def check_panel_trajectory(self):
+        """Set of variables defined outside of 'PanelLikelihoodTrajectory'
 
-        self.variableNames = None #: list of variables names
+        :return: List of names of variables
+        :rtype: set(str)
+        """
+        check_children = set(
+            chain.from_iterable(
+                [e.check_panel_trajectory() for e in self.children]
+            )
+        )
+        return check_children
 
-        self.randomVariableNames = None #: list of random variables names
+    def check_draws(self):
+        """Set of draws defined outside of 'MonteCarlo'
 
-        self.allDraws = None #: dict of draws
+        :return: List of names of variables
+        :rtype: set(str)
+        """
+        check_children = set(
+            chain.from_iterable([e.check_draws() for e in self.children])
+        )
+        return check_children
 
-        self.drawNames = None #: list of draw types
+    def check_rv(self):
+        """Set of random variables defined outside of 'Integrate'
 
-        self._row = None
-        """Row of the database where the values of the variables are found
+        :return: List of names of variables
+        :rtype: set(str)
         """
+        check_children = set(
+            chain.from_iterable([e.check_rv() for e in self.children])
+        )
+        return check_children
 
-        self.betaIds = None
-        """List of ids of the free beta parameters (those to be estimated)
+    def getStatusIdManager(self):
+        """Check the elementary expressions that are associated with
+        an ID manager.
+
+        :return: two sets of elementary expressions, those with and
+            without an ID manager.
+        :rtype: tuple(set(str), set(str))
         """
+        with_id = set()
+        without_id = set()
+        for e in self.children:
+            yes, no = e.getStatusIdManager()
+            with_id.update(yes)
+            without_id.update(no)
+        return with_id, without_id
 
-        self.freeBetaValues = None
-        """List of values of the free beta parameters (those to be estimated)
-        """
+    def prepare(self, database, numberOfDraws=1000):
+        """Prepare the expression to be evaluated
 
-        self.fixedBetaValues = None
-        """ List of values of the fixed beta parameters (those to be estimated)
+        :param database: Biogeme database
+        :type database: biogeme.database.Database
+
+        :param numberOfDraws: number of draws for Monte-Carlo integration
+        :type numberOfDraws: int
+        """
+        # First, we reset the IDs, if any
+        self.setIdManager(None)
+        # Second, we calculate a new set of IDs.
+        id_manager = IdManager([self], database, numberOfDraws)
+        self.setIdManager(id_manager)
+
+    def setIdManager(self, id_manager):
+        """The ID manager contains the IDs of the elementary expressions.
+
+        It is externally created, as it may nee to coordinate the
+        numbering of several expressions. It is stored only in the
+        expressions of type Elementary.
+
+        :param id_manager: ID manager to be propagated to the
+            elementary expressions. If None, all the IDs are set to None.
+        :type id_manager: class IdManager
         """
+        self.id_manager = id_manager
+        for e in self.children:
+            e.setIdManager(id_manager)
 
     def __repr__(self):
         """built-in function used to compute the 'official' string reputation
         of an object
 
         :return: description of the expression
         :rtype: string
@@ -379,14 +442,34 @@
         """
         if not (isNumeric(other) or isinstance(other, Expression)):
             raise excep.biogemeError(
                 f'This is not a valid expression: {other}'
             )
         return And(self, other)
 
+    def __rand__(self, other):
+        """
+        Operator overloading. Generate an expression for logical and.
+
+        :param other: expression for logical and
+        :type other: biogeme.expressions.Expression
+
+        :return: other and self
+        :rtype: biogeme.expressions.Expression
+
+        :raise biogemeError: if one of the expressions is invalid, that is
+            neither a numeric value or a
+            biogeme.expressions.Expression object.
+        """
+        if not (isNumeric(other) or isinstance(other, Expression)):
+            raise excep.biogemeError(
+                f'This is not a valid expression: {other}'
+            )
+        return And(other, self)
+
     def __or__(self, other):
         """
         Operator overloading. Generate an expression for logical or.
 
         :param other: expression for logical or
         :type other: biogeme.expressions.Expression
 
@@ -399,14 +482,34 @@
         """
         if not (isNumeric(other) or isinstance(other, Expression)):
             raise excep.biogemeError(
                 f'This is not a valid expression: {other}'
             )
         return Or(self, other)
 
+    def __ror__(self, other):
+        """
+        Operator overloading. Generate an expression for logical or.
+
+        :param other: expression for logical or
+        :type other: biogeme.expressions.Expression
+
+        :return: other or self
+        :rtype: biogeme.expressions.Expression
+
+        :raise biogemeError: if one of the expressions is invalid, that is
+            neither a numeric value or a
+            biogeme.expressions.Expression object.
+        """
+        if not (isNumeric(other) or isinstance(other, Expression)):
+            raise excep.biogemeError(
+                f'This is not a valid expression: {other}'
+            )
+        return Or(other, self)
+
     def __eq__(self, other):
         """
         Operator overloading. Generate an expression for comparison.
 
         :param other: expression for equality
         :type other: biogeme.expressions.Expression
 
@@ -519,88 +622,352 @@
         """
         if not (isNumeric(other) or isinstance(other, Expression)):
             raise excep.biogemeError(
                 f'This is not a valid expression: {other}'
             )
         return Greater(self, other)
 
-    def _prepareFormulaForEvaluation(self, database):
-        """Extract from the formula the elementary expressions (parameters,
-        variables, random parameters) and decide a numbering convention.
-        """
-
-        self.variableNames = list(database.data.columns.values)
-
-        (
-            self.elementaryExpressionIndex,
-            self.allFreeBetas,
-            self.freeBetaNames,
-            self.allFixedBetas,
-            self.fixedBetaNames,
-            self.allRandomVariables,
-            self.randomVariableNames,
-            self.allDraws,
-            self.drawNames,
-        ) = defineNumberingOfElementaryExpressions([self], self.variableNames)
-
-        # List of ids of the free beta parameters (those to be estimated)
-        self.betaIds = list(range(len(self.freeBetaNames)))
-
-        # List of values of the free beta parameters (those to be estimated)
-        self.freeBetaValues = [
-            self.allFreeBetas[x].initValue for x in self.freeBetaNames
-        ]
-        # List of values of the fixed beta parameters (those to be estimated)
-        self.fixedBetaValues = [
-            self.allFixedBetas[x].initValue for x in self.fixedBetaNames
-        ]
+    def createFunction(
+        self,
+        database=None,
+        numberOfDraws=1000,
+        gradient=True,
+        hessian=True,
+        bhhh=False,
+    ):
+        """Create a function based on the expression. The function takes as
+        argument an array for the free parameters, and return the
+        value of the function, the gradient, the hessian and the BHHH. The
+        calculation of the derivatives is optional.
+
+        :param database: database. If no database is provided, the
+            expression must not contain any variable.
+        :type database:  biogeme.database.Database
+
+        :param numberOfDraws: number of draws if needed by Monte-Carlo
+            integration.
+        :type numberOfDraws: int
+
+        :param gradient: if True, the gradient is calculated.
+        :type gradient: bool
+
+        :param hessian: if True, the hessian is calculated.
+        :type hessian: bool
+
+        :param bhhh: if True, the BHHH matrix is calculated.
+        :type bhhh: bool
+
+        :return: the function. It will return, in that order, the
+            value of the function, the gradient, the hessian and the
+            BHHH matrix. Only requested quantities will be
+            returned. For instance, if the gradient and the BHHH
+            matrix are requested, and not the hessian, the tuple that
+            is returned is f, g, bhhh.
+
+        :rtype: fct(np.array)
+
+        :raise biogemeError: if gradient is False and hessian or BHHH is True.
+
+        """
+        if (hessian or bhhh) and not gradient:
+            raise excep.biogemeError(
+                'If the hessian or BHHH is calculated, so is the gradient. '
+                'The provided parameters are inconsistent.'
+            )
+
+        with_id, without_id = self.getStatusIdManager()
+        if len(without_id) > 0:
+            if len(with_id) > 0:
+                error_msg = (
+                    f'IDs are defined for some expressions '
+                    f'[{with_id}] but not for some [{without_id}]'
+                )
+                raise excep.biogemeError(error_msg)
+            self.setIdManager(IdManager([self], database, numberOfDraws))
+
+        def my_function(x):
+            if isinstance(x, (float, int, np.float64)):
+                x = [float(x)]
+            if len(x) != len(self.id_manager.free_betas_values):
+                error_msg = (
+                    f'Function is expecting an array of length '
+                    f'{len(self.id_manager.free_betas_values)}, not {len(x)}'
+                )
+                excep.biogemeError(error_msg)
+
+            self.id_manager.free_betas_values = x
+            f, g, h, b = self.getValueAndDerivatives(
+                database=database,
+                numberOfDraws=numberOfDraws,
+                gradient=gradient,
+                hessian=hessian,
+                bhhh=bhhh,
+                aggregation=True,
+                prepareIds=False,
+            )
+
+            results = [f]
+            if gradient:
+                results.append(g)
+                if hessian:
+                    results.append(h)
+                if bhhh:
+                    results.append(b)
+                return tuple(results)
+            return f
+
+        return my_function
+
+    def getValue_c(
+        self,
+        database=None,
+        betas=None,
+        numberOfDraws=1000,
+        aggregation=False,
+        prepareIds=False,
+    ):
+
+        """Evaluation of the expression, without the derivatives
+
+        :param betas: values of the free parameters
+        :type betas: list(float)
+
+        :param database: database. If no database is provided, the
+            expression must not contain any variable.
+        :type database:  biogeme.database.Database
+
+        :param numberOfDraws: number of draws if needed by Monte-Carlo
+            integration.
+        :type numberOfDraws: int
+
+        :param aggregation: if a database is provided, and this
+            parameter is True, the expression is applied on each entry
+            of the database, and all values are aggregated, so that
+            the sum is returned. If False, the list of all values is returned.
+        :type aggregation: bool
+
+        :param prepareIds: if True, it means that the IDs of the
+            expression must be constructed before the evaluation of
+            the expression.
+        :type prepareIds: bool
+
+        :return: if a database is provided, a list where each entry is
+            the result of applying the expression on one entry of the
+            dsatabase. It returns a float.
+
+        :rtype: np.array or float
+
+        :raise biogemeError: if no database is given, and the number
+            of returned values is different from one.
 
-    def getValue_c(self, database, numberOfDraws=1000):
         """
-        Evaluation of the expression
+        if self.requiresDraws() and database is None:
+            error_msg = (
+                'An expression involving MonteCarlo integration '
+                'must be associated with a database.'
+            )
+            raise excep.biogemeError(error_msg)
+
+        f, _, _, _ = self.getValueAndDerivatives(
+            betas=betas,
+            database=database,
+            numberOfDraws=numberOfDraws,
+            gradient=False,
+            hessian=False,
+            bhhh=False,
+            aggregation=aggregation,
+            prepareIds=prepareIds,
+        )
+        if database is None:
+            if len(f) != 1:
+                error_msg = 'Incorrect number of return values'
+                raise excep.biogemeError(error_msg)
+            return f[0]
+        return f
+
+    def getValueAndDerivatives(
+        self,
+        betas=None,
+        database=None,
+        numberOfDraws=1000,
+        gradient=True,
+        hessian=True,
+        bhhh=True,
+        aggregation=True,
+        prepareIds=False,
+    ):
+        """Evaluation of the expression
 
         In Biogeme the complexity of some expressions requires a
         specific implementation, in C++. This function invokes the
         C++ code to evaluate the value of the expression for a
         series of entries in a database. Note that this function
         will generate draws if needed.
 
+        :param betas: values of the free parameters
+        :type betas: list(float)
 
-        :param database: database
+        :param database: database. If no database is provided, the
+            expression must not contain any variable.
         :type database:  biogeme.database.Database
+
         :param numberOfDraws: number of draws if needed by Monte-Carlo
             integration.
         :type numberOfDraws: int
 
-        :return: a list where each entry is the result of applying the
-                 expression on one entry of the dsatabase.
-        :rtype: numpy.array
-        """
-        self._prepareFormulaForEvaluation(database)
-
-        if database.isPanel():
-            # Object containing the C++ implementation used by Biogeme.
-            theC = cb.pyPanelBiogeme()
-            theC.setDataMap(database.individualMap)
-        else:
-            theC = cb.pyBiogeme()
-        theC.setData(database.data)
-        if self.allDraws:
-            database.generateDraws(
-                self.allDraws, self.drawNames, numberOfDraws
-            )
-            theC.setDraws(database.theDraws)
-
-        result = theC.simulateFormula(
-            self.getSignature(),
-            self.freeBetaValues,
-            self.fixedBetaValues,
-            database.data,
+        :param gradient: If True, the gradient is calculated.
+        :type gradient: bool
+
+        :param hessian: if True, the hessian is  calculated.
+        :type hessian: bool
+
+        :param bhhh: if True, the BHHH matrix is calculated.
+        :type bhhh: bool
+
+        :param aggregation: if a database is provided, and this
+            parameter is True, the expression is applied on each entry
+            of the database, and all values are aggregated, so that
+            the sum is returned. If False, the list of all values is returned.
+        :type aggregation: bool
+
+        :param prepareIds: if True, it means that the IDs of the
+            expression must be constructed before the evaluation of
+            the expression.
+        :type prepareIds: bool
+
+        :return: if a database is provided, a list where each entry is
+            the result of applying the expression on one entry of the
+            dsatabase. It returns a float, a vector, and a matrix,
+            depedending if derivatives are requested.
+
+        :rtype: np.array or float, numpy.array, numpy.array
+
+        :raise biogemeError: if no database is given and the
+            expressions involves variables.
+
+        :raise biogemeError: if gradient is False and hessian or BHHH is True.
+
+        :raise biogemeError: if derivatives are asked, and the expression
+            is not simple.
+
+        :raise biogemeError: if the expression involves MonteCarlo integration,
+           and no database is provided.
+        """
+        if prepareIds:
+            self.keep_id_manager = self.id_manager
+            self.prepare(database, numberOfDraws)
+        elif self.id_manager is None:
+            error_msg = (
+                'Expression evaluated out of context. Set prepareIds to True.'
+            )
+            raise excep.biogemeError(error_msg)
+
+        errors, warnings = self.audit(database)
+        if warnings:
+            logger.warning('\n'.join(warnings))
+        if errors:
+            error_msg = '\n'.join(errors)
+            logger.warning(error_msg)
+            raise excep.biogemeError(error_msg)
+
+        if (hessian or bhhh) and not gradient:
+            raise excep.biogemeError(
+                'If the hessian or the BHHH matrix is calculated, '
+                'so is the gradient. The provided parameters are inconsistent.'
+            )
+        if database is None:
+            variables = self.setOfVariables()
+            if variables:
+                raise excep.biogemeError(
+                    f'No database is provided and the expression '
+                    f'contains variables: {variables}'
+                )
+
+        self.numberOfDraws = numberOfDraws
+
+        if database is not None:
+            self.cpp.setData(database.data)
+            if self.embedExpression('PanelLikelihoodTrajectory'):
+                if database.isPanel():
+                    database.buildPanelMap()
+                    self.cpp.setDataMap(database.individualMap)
+                else:
+                    error_msg = (
+                        'The expression involves '
+                        '"PanelLikelihoodTrajectory" '
+                        'that requires panel data'
+                    )
+                    raise excep.biogemeError(error_msg)
+
+        if betas is not None:
+            self.id_manager.free_betas_values = [
+                betas[x]
+                if x in betas
+                else self.id_manager.free_betas.expressions[x].initValue
+                for x in self.id_manager.free_betas.names
+            ]
+            # List of values of the fixed beta parameters (those not estimated)
+            self.fixedBetaValues = [
+                betas[x]
+                if x in betas
+                else self.id_manager.fixed_betas.expressions[x].initValue
+                for x in self.id_manager.fixed_betas.names
+            ]
+
+        self.cpp.setExpression(self.getSignature())
+        self.cpp.setFreeBetas(self.id_manager.free_betas_values)
+        self.cpp.setFixedBetas(self.id_manager.fixed_betas_values)
+        self.cpp.setMissingData(self.missingData)
+
+        if self.requiresDraws():
+            if database is None:
+                error_msg = (
+                    'An expression involving MonteCarlo integration '
+                    'must be associated with a database.'
+                )
+                raise excep.biogemeError(error_msg)
+            self.cpp.setDraws(database.theDraws)
+
+        self.cpp.calculate(
+            gradient=gradient,
+            hessian=hessian,
+            bhhh=bhhh,
+            aggregation=aggregation,
         )
-        return result
+
+        f, g, h, b = self.cpp.getResults()
+
+        gres = g if gradient else None
+        hres = h if hessian else None
+        bhhhres = b if bhhh else None
+
+        if aggregation:
+            results = (
+                f[0],
+                None if gres is None else g[0],
+                None if hres is None else h[0],
+                None if bhhhres is None else b[0],
+            )
+        else:
+            results = (f, gres, hres, bhhhres)
+
+        # Now, if we had to set the IDS, we reset them as they cannot
+        # be used in another context.
+        if prepareIds:
+            # We restore the previous Id manager
+            self.setIdManager(self.keep_id_manager)
+        return results
+
+    def requiresDraws(self):
+        """Checks if the expression requires draws
+
+        :return: True if it requires draws.
+        :rtype: bool
+        """
+        return self.embedExpression('MonteCarlo')
 
     def setOfBetas(self, free=True, fixed=False):
         """
         Extract the set of parameters from the expression.
 
         :param free: if True, the free parameters are included. Default: True.
         :type free: bool
@@ -622,14 +989,15 @@
 
         :return: returns a set with the variables appearing in the expression.
         :rtype: set(biogeme.expressions.Expression)
         """
         return set(self.dictOfVariables().keys())
 
     def dictOfBetas(self, free=True, fixed=False):
+
         """
         Extract the set of parameters from the expression.
 
         :param free: if True, the free parameters are included. Default: True.
         :type free: bool
         :param fixed: if True, the fixed parameters are included.
              Default: False.
@@ -688,25 +1056,24 @@
         """
         for e in self.children:
             if e.getElementaryExpression(name) is not None:
                 return e.getElementaryExpression(name)
         return None
 
     def setRow(self, row):
-        """This function identifies the row of the database from which the
+        """Obsolete function.
+        This function identifies the row of the database from which the
         values of the variables must be obtained.
 
-        :param row: id of the row.
-        :type row: int
+        :param row: row from the database
+        :type row: pandas.core.series.Serie
 
+        :raise biogemeError: if the function is called, because it is obsolete.
         """
-        # Row of the database where the values of the variables are found
-        self._row = row
-        for e in self.children:
-            e.setRow(row)
+        raise excep.biogemeError("The function setRow is now obsolete.")
 
     def dictOfDraws(self):
         """Recursively extract the random variables
         (draws for Monte-Carlo)
         appearing in the expression, and store them in a dictionary.
 
         :return: dict where the keys are the random variables and the elements
@@ -716,70 +1083,50 @@
         draws = {}
         for e in self.children:
             d = e.dictOfDraws()
             if d:
                 draws = dict(draws, **d)
         return draws
 
-    def setUniqueId(self, idsOfElementaryExpressions):
-        """Provides a unique id to the elementary expressions.
+    def rename_elementary(self, names, prefix=None, suffix=None):
+        """Rename elementary expressions by adding a prefix and/or a suffix
 
-        :param idsOfElementaryExpressions: dictionary mapping the name
-              of the elementary expression with their id.
-        :type idsOfElementaryExpressions: dict(string:int)
+        :param names: names of expressions to rename
+        :type names: list(str)
 
+        :param prefix: if not None, the expression is renamed, with a
+            prefix defined by this argument.
+        :type prefix: str
+
+        :param suffix: if not None, the expression is renamed, with a
+            suffix defined by this argument.
+        :type suffix: str
         """
         for e in self.children:
-            e.setUniqueId(idsOfElementaryExpressions)
-
-    def setSpecificIndices(
-        self,
-        indicesOfFreeBetas,
-        indicesOfFixedBetas,
-        indicesOfRandomVariables,
-        indicesOfDraws,
-    ):
-        """Provides an index to all elementary expressions,
-        specific to their type
+            e.rename_elementary(names, prefix=prefix, suffix=suffix)
 
-        :param indicesOfFreeBetas: dictionary mapping the name of the
-                               free betas with their index
-        :type indicesOfFreeBetas: dict(string:int)
-
-        :param indicesOfFixedBetas: dictionary mapping the name of the
-                                fixed betas with their index
-        :type indicesOfFixedBetas: dict(string:int)
-
-        :param indicesOfRandomVariables: dictionary mapping the name of the
-                                random variables with their index
-        :type indicesOfRandomVariables: dict(string:int)
-        :param indicesOfDraws: dictionary mapping the name of the draws with
-                            their index
-        :type indicesOfDraws: dict(string:int)
+    def fix_betas(self, beta_values, prefix=None, suffix=None):
+        """Fix all the values of the beta parameters appearing in the
+        dictionary
+
+        :param beta_values: dictionary containing the betas to be
+            fixed (as key) and their value.
+        :type beta_values: dict(str: float)
+
+        :param prefix: if not None, the parameter is renamed, with a
+            prefix defined by this argument.
+        :type prefix: str
+
+        :param suffix: if not None, the parameter is renamed, with a
+            suffix defined by this argument.
+        :type suffix: str
 
         """
         for e in self.children:
-            e.setSpecificIndices(
-                indicesOfFreeBetas,
-                indicesOfFixedBetas,
-                indicesOfRandomVariables,
-                indicesOfDraws,
-            )
-
-    def setVariableIndices(self, indicesOfVariables):
-        """
-        Provide an index to all variables
-
-        :param indicesOfVariables: dictionary mapping the name of the
-                                variables with their index
-        :type indicesOfVariables: dict(string:int)
-
-        """
-        for e in self.children:
-            e.setVariableIndices(indicesOfVariables)
+            e.fix_betas(beta_values, prefix=prefix, suffix=suffix)
 
     def getClassName(self):
         """
         Obtain the name of the top class of the expression structure
 
         :return: the name of the class
         :rtype: string
@@ -843,43 +1190,23 @@
         mysignature += f'{{{id(self)}}}'
         mysignature += f'({len(self.children)})'
         for e in self.children:
             mysignature += f',{id(e)}'
         listOfSignatures += [mysignature.encode()]
         return listOfSignatures
 
-    def isContainedIn(self, t):
-        """Check if the expression is contained in an expression of type t.
-
-        Typically, this would be used to check that a bioDraws
-        expression is contained in a MonteCarlo expression. If not, it
-        cannot be evaluated.
-
-        :return: True if the expression is contained in an expression
-            of type t.
-        :rtype: bool.
-
-        See: :func:`biogeme.expressions.Expression.embedExpression`
-        """
-        if self.parent is None:
-            return False
-        if self.parent.getClassName() == t:
-            return True
-        return self.parent.isContainedIn(t)
-
     def embedExpression(self, t):
         """Check if the expression contains an expression of type t.
 
         Typically, this would be used to check that a MonteCarlo
         expression contains a bioDraws expression.
 
         :return: True if the expression contains an expression of type t.
         :rtype: bool
 
-        See: Expression.isContainedIn
         """
         if self.getClassName() == t:
             return True
         for e in self.children:
             if e.embedExpression(t):
                 return True
         return False
@@ -907,14 +1234,17 @@
         :return: tuple listOfErrors, listOfWarnings
         :rtype: list(string), list(string)
         """
         listOfErrors = []
         listOfWarnings = []
 
         for e in self.children:
+            if not isinstance(e, Expression):
+                theError = f'Invalid expression: {e}'
+                listOfErrors.append(theError)
             err, war = e.audit(database)
             listOfErrors += err
             listOfWarnings += war
         return listOfErrors, listOfWarnings
 
     def changeInitValues(self, betas):
         """Modifies the initial values of the Beta parameters.
@@ -950,31 +1280,29 @@
         :raise biogemeError: if one of the expressions is invalid, that is
             neither a numeric value or a
             biogeme.expressions.Expression object.
 
         """
         Expression.__init__(self)
         if isNumeric(left):
-            self.left = Numeric(left) #: left parent
+            self.left = Numeric(left)  #: left child
         else:
             if not isinstance(left, Expression):
                 raise excep.biogemeError(
                     f'This is not a valid expression: {left}'
                 )
             self.left = left
         if isNumeric(right):
-            self.right = Numeric(right) #: right parent
+            self.right = Numeric(right)  #: right child
         else:
             if not isinstance(right, Expression):
                 raise excep.biogemeError(
                     f'This is not a valid expression: {right}'
                 )
             self.right = right
-        self.left.parent = self
-        self.right.parent = self
         self.children.append(self.left)
         self.children.append(self.right)
 
 
 class Plus(BinaryOperator):
     """
     Addition expression
@@ -1239,175 +1567,217 @@
         if self.left.getValue() != 0.0:
             return 1.0
         if self.right.getValue() != 0.0:
             return 1.0
         return 0.0
 
 
-class Equal(BinaryOperator):
+class ComparisonOperator(BinaryOperator):
+    """Base class for comparison expressions."""
+
+    def __init__(self, left, right):
+        """Constructor
+
+        :param left: first arithmetic expression
+        :type left: biogeme.expressions.Expression
+
+        :param right: second arithmetic expression
+        :type right: biogeme.expressions.Expression
+        """
+        BinaryOperator.__init__(self, left, right)
+
+    def audit(self, database=None):
+        """Performs various checks on the expression."""
+        listOfErrors = []
+        listOfWarnings = []
+        if isinstance(self.left, ComparisonOperator) or isinstance(
+            self.right, ComparisonOperator
+        ):
+            print(f'Current expression: {self}')
+            print(
+                f'Left expression: {self.left} '
+                f'[{isinstance(self.left, ComparisonOperator)}]'
+            )
+            print(
+                f'Right expression: {self.right} '
+                f'[{isinstance(self.right, ComparisonOperator)}]'
+            )
+            print(f'Type left expression: {type(self.left)}')
+            the_warning = (
+                f'Chaining two comparisons expressions is not recommended'
+                f' as it may be ambiguous. '
+                f'Keep in mind that, for Biogeme, the '
+                f'expression (a <= x <= b) is not equivalent to (a <= x) '
+                f'and (x <= b) [{self}]'
+            )
+            listOfWarnings.append(the_warning)
+        return listOfErrors, listOfWarnings
+
+
+class Equal(ComparisonOperator):
     """
     Logical equal
     """
 
     def __init__(self, left, right):
         """Constructor
 
         :param left: first arithmetic expression
         :type left: biogeme.expressions.Expression
 
         :param right: second arithmetic expression
         :type right: biogeme.expressions.Expression
         """
-        BinaryOperator.__init__(self, left, right)
+        ComparisonOperator.__init__(self, left, right)
 
     def __str__(self):
         return f'({self.left} == {self.right})'
 
     def getValue(self):
         """Evaluates the value of the expression
 
         :return: value of the expression
         :rtype: float
         """
         r = 1 if self.left.getValue() == self.right.getValue() else 0
         return r
 
 
-class NotEqual(BinaryOperator):
+class NotEqual(ComparisonOperator):
     """
     Logical not equal
     """
 
     def __init__(self, left, right):
         """Constructor
 
         :param left: first arithmetic expression
         :type left: biogeme.expressions.Expression
 
         :param right: second arithmetic expression
         :type right: biogeme.expressions.Expression
         """
-        BinaryOperator.__init__(self, left, right)
+        ComparisonOperator.__init__(self, left, right)
 
     def __str__(self):
         return f'({self.left} != {self.right})'
 
     def getValue(self):
         """Evaluates the value of the expression
 
         :return: value of the expression
         :rtype: float
         """
         r = 1 if self.left.getValue() != self.right.getValue() else 0
         return r
 
 
-class LessOrEqual(BinaryOperator):
+class LessOrEqual(ComparisonOperator):
     """
     Logical less or equal
     """
 
     def __init__(self, left, right):
         """Constructor
 
         :param left: first arithmetic expression
         :type left: biogeme.expressions.Expression
 
         :param right: second arithmetic expression
         :type right: biogeme.expressions.Expression
 
         """
-        BinaryOperator.__init__(self, left, right)
+        ComparisonOperator.__init__(self, left, right)
 
     def __str__(self):
         return f'({self.left} <= {self.right})'
 
     def getValue(self):
         """Evaluates the value of the expression
 
         :return: value of the expression
         :rtype: float
         """
         r = 1 if self.left.getValue() <= self.right.getValue() else 0
         return r
 
 
-class GreaterOrEqual(BinaryOperator):
+class GreaterOrEqual(ComparisonOperator):
     """
     Logical greater or equal
     """
 
     def __init__(self, left, right):
         """Constructor
 
         :param left: first arithmetic expression
         :type left: biogeme.expressions.Expression
 
         :param right: second arithmetic expression
         :type right: biogeme.expressions.Expression
         """
-        BinaryOperator.__init__(self, left, right)
+        ComparisonOperator.__init__(self, left, right)
 
     def __str__(self):
         return f'({self.left} >= {self.right})'
 
     def getValue(self):
         """Evaluates the value of the expression
 
         :return: value of the expression
         :rtype: float
         """
         r = 1 if self.left.getValue() >= self.right.getValue() else 0
         return r
 
 
-class Less(BinaryOperator):
+class Less(ComparisonOperator):
     """
     Logical less
     """
 
     def __init__(self, left, right):
         """Constructor
 
         :param left: first arithmetic expression
         :type left: biogeme.expressions.Expression
 
         :param right: second arithmetic expression
         :type right: biogeme.expressions.Expression
         """
-        BinaryOperator.__init__(self, left, right)
+        ComparisonOperator.__init__(self, left, right)
 
     def __str__(self):
         return f'({self.left} < {self.right})'
 
     def getValue(self):
         """Evaluates the value of the expression
 
         :return: value of the expression
         :rtype: float
         """
         r = 1 if self.left.getValue() < self.right.getValue() else 0
         return r
 
 
-class Greater(BinaryOperator):
+class Greater(ComparisonOperator):
     """
     Logical greater
     """
 
     def __init__(self, left, right):
         """Constructor
 
         :param left: first arithmetic expression
         :type left: biogeme.expressions.Expression
 
         :param right: second arithmetic expression
         :type right: biogeme.expressions.Expression
         """
-        BinaryOperator.__init__(self, left, right)
+        ComparisonOperator.__init__(self, left, right)
 
     def __str__(self):
         return f'({self.left} > {self.right})'
 
     def getValue(self):
         """Evaluates the value of the expression
 
@@ -1435,22 +1805,21 @@
         :raise biogemeError: if one of the expressions is invalid, that is
             neither a numeric value or a
             biogeme.expressions.Expression object.
 
         """
         Expression.__init__(self)
         if isNumeric(child):
-            self.child = Numeric(child) #: child
+            self.child = Numeric(child)  #: child
         else:
             if not isinstance(child, Expression):
                 raise excep.biogemeError(
                     f'This is not a valid expression: {child}'
                 )
             self.child = child
-        self.child.parent = self
         self.children.append(self.child)
 
 
 class UnaryMinus(UnaryOperator):
     """
     Unary minus expression
     """
@@ -1487,34 +1856,50 @@
         :type child: biogeme.expressions.Expression
         """
         UnaryOperator.__init__(self, child)
 
     def __str__(self):
         return f'MonteCarlo({self.child})'
 
+    def check_draws(self):
+        """List of draws defined outside of 'MonteCarlo'
+
+        :return: List of names of variables
+        :rtype: list(str)
+        """
+        return set()
+
     def audit(self, database=None):
         """Performs various checks on the expressions.
 
         :param database: database object
         :type database: biogeme.database.Database
 
         :return: tuple listOfErrors, listOfWarnings
         :rtype: list(string), list(string)
 
         """
         listOfErrors, listOfWarnings = self.child.audit(database)
-        if database.isPanel() and not self.child.embedExpression(
-            'PanelLikelihoodTrajectory'
-        ):
-            theError = (
-                f'As the database is panel, the argument '
-                f'of MonteCarlo must contain a'
-                f' PanelLikelihoodTrajectory: {self}'
-            )
-            listOfErrors.append(theError)
+        if database is None:
+            if self.child.embedExpression('PanelLikelihoodTrajectory'):
+                theWarning = (
+                    'The formula contains a PanelLikelihoodTrajectory '
+                    'expression, and no database is given'
+                )
+                listOfWarnings.append(theWarning)
+        else:
+            if database.isPanel() and not self.child.embedExpression(
+                'PanelLikelihoodTrajectory'
+            ):
+                theError = (
+                    f'As the database is panel, the argument '
+                    f'of MonteCarlo must contain a'
+                    f' PanelLikelihoodTrajectory: {self}'
+                )
+                listOfErrors.append(theError)
 
         if not self.child.embedExpression('bioDraws'):
             theError = (
                 f'The argument of MonteCarlo must contain a'
                 f' bioDraws: {self}'
             )
             listOfErrors.append(theError)
@@ -1556,14 +1941,22 @@
         :type child: biogeme.expressions.Expression
         """
         UnaryOperator.__init__(self, child)
 
     def __str__(self):
         return f'PanelLikelihoodTrajectory({self.child})'
 
+    def check_panel_trajectory(self):
+        """List of variables defined outside of 'PanelLikelihoodTrajectory'
+
+        :return: List of names of variables
+        :rtype: list(str)
+        """
+        return set()
+
     def countPanelTrajectoryExpressions(self):
         """Count the number of times the PanelLikelihoodTrajectory
         is used in the formula.
         """
         return 1 + self.child.countPanelTrajectoryExpressions()
 
     def audit(self, database=None):
@@ -1572,16 +1965,15 @@
         :param database: database object
         :type database: biogeme.database.Database
 
         :return: tuple listOfErrors, listOfWarnings
         :rtype: list(string), list(string)
 
         """
-        listOfErrors = []
-        listOfWarnings = []
+        listOfErrors, listOfWarnings = self.child.audit(database)
         if not database.isPanel():
             theError = (
                 f'Expression PanelLikelihoodTrajectory can '
                 f'only be used with panel data. Use the statement '
                 f'database.panel("IndividualId") to declare the '
                 f'panel structure of the data: {self}'
             )
@@ -1649,38 +2041,14 @@
 
         :param child: first arithmetic expression
         :type child: biogeme.expressions.Expression
         """
         UnaryOperator.__init__(self, child)
         # Name of the elementary expression by which the derivative is taken
         self.elementaryName = name
-        # Unique ID of the expression
-        self.elementaryIndex = None
-
-    def setUniqueId(self, idsOfElementaryExpressions):
-        """
-        Provides a unique id to the elementary expressions.
-
-        :param idsOfElementaryExpressions: dictionary mapping the name
-                of the elementary expression with their id.
-        :type idsOfElementaryExpressions: dict(string:int)
-
-        :raise biogemeError: if no index is available for an expression.
-        """
-        if self.elementaryName in idsOfElementaryExpressions:
-            self.elementaryIndex = idsOfElementaryExpressions[
-                self.elementaryName
-            ]
-        else:
-            error_msg = (
-                f'No index is available for elementary '
-                f'expression {self.elementaryName}.'
-            )
-            raise excep.biogemeError(error_msg)
-        self.child.setUniqueId(idsOfElementaryExpressions)
 
     def getSignature(self):
         """The signature of a string characterizing an expression.
 
         This is designed to be communicated to C++, so that the
         expression can be reconstructed in this environment.
 
@@ -1720,20 +2088,23 @@
              b'<Times>{4780527344}(2),4780277264,4780527288',
              b'<Divide>{4780527400}(2),4780527232,4780527344',
              b'<Minus>{4780527456}(2),4780527064,4780527400']
 
         :return: list of the signatures of an expression and its children.
         :rtype: list(string)
         """
+        elementaryIndex = self.id_manager.elementary_expressions.indices[
+            self.elementaryName
+        ]
         listOfSignatures = []
         listOfSignatures += self.child.getSignature()
         mysignature = f'<{self.getClassName()}>'
         mysignature += f'{{{id(self)}}}'
         mysignature += f',{id(self.child)}'
-        mysignature += f',{self.elementaryIndex}'
+        mysignature += f',{elementaryIndex}'
         listOfSignatures += [mysignature.encode()]
         return listOfSignatures
 
     def __str__(self):
         return 'Derive({self.child}, "{self.elementName}")'
 
 
@@ -1748,15 +2119,22 @@
         :param child: first arithmetic expression
         :type child: biogeme.expressions.Expression
         :param name: name of the random variable for the integration.
         :type name: string
         """
         UnaryOperator.__init__(self, child)
         self.randomVariableName = name
-        self.randomVariableIndex = None
+
+    def check_rv(self):
+        """List of random variables defined outside of 'Integrate'
+
+        :return: List of names of variables
+        :rtype: list(str)
+        """
+        return set()
 
     def audit(self, database=None):
         """Performs various checks on the expressions.
 
         :param database: database object
         :type database: biogeme.database.Database
 
@@ -1769,83 +2147,14 @@
             theError = (
                 f'The argument of Integrate must contain a '
                 f'RandomVariable: {self}'
             )
             listOfErrors.append(theError)
         return listOfErrors, listOfWarnings
 
-    def setUniqueId(self, idsOfElementaryExpressions):
-        """Provides a unique id to the elementary expressions. Overloads the
-        generic function
-
-        :param idsOfElementaryExpressions: dictionary mapping the name of
-                the elementary expression with their id.
-        :type idsOfElementaryExpressions: dict(string:int)
-
-        :raise biogemeError: if no index is available for a random variable.
-        """
-        if self.randomVariableName in idsOfElementaryExpressions:
-            self.randomVariableIndex = idsOfElementaryExpressions[
-                self.randomVariableName
-            ]
-        else:
-            error_msg = (
-                f'No index is available for random variable '
-                f'{self.randomVariableName}.'
-            )
-            raise excep.biogemeError(error_msg)
-        self.child.setUniqueId(idsOfElementaryExpressions)
-
-    def setSpecificIndices(
-        self,
-        indicesOfFreeBetas,
-        indicesOfFixedBetas,
-        indicesOfRandomVariables,
-        indicesOfDraws,
-    ):
-        """
-        Provide an index to all elementary expressions, specific to their type
-        Overloads the generic function.
-
-        :param indicesOfFreeBetas: dictionary mapping the name of the
-                               free betas with their index
-        :type indicesOfFreeBetas: dict(string:int)
-
-        :param indicesOfFixedBetas: dictionary mapping the name of the
-                                fixed betas with their index
-        :type indicesOfFixedBetas: dict(string:int)
-
-        :param indicesOfRandomVariables: dictionary mapping the name of the
-                                random variables with their index
-        :type indicesOfRandomVariables: dict(string:int)
-        :param indicesOfDraws: dictionary mapping the name of the draws with
-                            their index
-        :type indicesOfDraws: dict(string:int)
-
-        :raise biogemeError: if no index is available for a random variable.
-
-        """
-        if self.randomVariableName in indicesOfRandomVariables:
-            self.randomVariableIndex = indicesOfRandomVariables[
-                self.randomVariableName
-            ]
-        else:
-            error_msg = (
-                f'No index is available for random variable '
-                f'{self.randomVariableName}. Known random variables:'
-                f' {indicesOfRandomVariables.keys()}'
-            )
-            raise excep.biogemeError(error_msg)
-        self.child.setSpecificIndices(
-            indicesOfFreeBetas,
-            indicesOfFixedBetas,
-            indicesOfRandomVariables,
-            indicesOfDraws,
-        )
-
     def getSignature(self):
         """The signature of a string characterizing an expression.
 
         This is designed to be communicated to C++, so that the
         expression can be reconstructed in this environment.
 
         The list contains the following elements:
@@ -1886,20 +2195,23 @@
              b'<Times>{4780527344}(2),4780277264,4780527288',
              b'<Divide>{4780527400}(2),4780527232,4780527344',
              b'<Minus>{4780527456}(2),4780527064,4780527400']
 
         :return: list of the signatures of an expression and its children.
         :rtype: list(string)
         """
+        randomVariableIndex = self.id_manager.random_variables.indices[
+            self.randomVariableName
+        ]
         listOfSignatures = []
         listOfSignatures += self.child.getSignature()
         mysignature = f'<{self.getClassName()}>'
         mysignature += f'{{{id(self)}}}'
         mysignature += f',{id(self.child)}'
-        mysignature += f',{self.randomVariableIndex}'
+        mysignature += f',{randomVariableIndex}'
         listOfSignatures += [mysignature.encode()]
         return listOfSignatures
 
     def __str__(self):
         return f'Integrate({self.child}, "{self.randomVariableName}")'
 
 
@@ -1917,61 +2229,72 @@
         """Constructor
 
         :param name: name of the elementary experession.
         :type name: string
 
         """
         Expression.__init__(self)
-        self.name = name #: name of the elementary expressiom
+        self.name = name  #: name of the elementary expressiom
 
-        self.uniqueId = None
+        self.elementaryIndex = None
         """The id should be unique for all elementary expressions
         appearing in a given set of formulas.
         """
 
     def __str__(self):
         """string method
 
         :return: name of the expression
         :rtype: str
         """
-        return self.name
+        return f'{self.name}'
+
+    def getStatusIdManager(self):
+        """Check the elementary expressions that are associated with
+        an ID manager.
+
+        :return: two lists of elementary expressions, those with and
+            without an ID manager.
+        :rtype: tuple(list(str), list(str))
+        """
+        if self.id_manager is None:
+            return [], [self.name]
+        return [self.name], []
 
     def getElementaryExpression(self, name):
         """
 
         :return: an elementary expression from its name if it appears in the
             expression. None otherwise.
         :rtype: biogeme.Expression
         """
         if self.name == name:
             return self
 
         return None
 
-    def setUniqueId(self, idsOfElementaryExpressions):
-        """
-        Provides a unique id to the elementary expressions. Overloads the
-        generic function
+    def rename_elementary(self, names, prefix=None, suffix=None):
+        """Rename elementary expressions by adding a prefix and/or a suffix
 
-        :param idsOfElementaryExpressions: dictionary mapping the name
-              of the elementary expression with their id.
-        :type idsOfElementaryExpressions: dict(string:int)
+        :param names: names of expressions to rename
+        :type names: list(str)
 
-        :raise biogemeError: if no index is available for an expression.
-        """
-        if self.name in idsOfElementaryExpressions:
-            self.uniqueId = idsOfElementaryExpressions[self.name]
-        else:
-            error_msg = (
-                f'No index is available for expression {self.name}.'
-                f' List of available indices: '
-                f'{[n for n, i in idsOfElementaryExpressions.items() ]}'
-            )
-            raise excep.biogemeError(error_msg)
+        :param prefix: if not None, the expression is renamed, with a
+            prefix defined by this argument.
+        :type prefix: str
+
+        :param suffix: if not None, the expression is renamed, with a
+            suffix defined by this argument.
+        :type suffix: str
+        """
+        if self.name in names:
+            if prefix is not None:
+                self.name = f'{prefix}{self.name}'
+            if suffix is not None:
+                self.name = f'{self.name}{suffix}'
 
 
 class bioDraws(Elementary):
     """
     Draws for Monte-Carlo integration
     """
 
@@ -1986,50 +2309,42 @@
         Elementary.__init__(self, name)
         self.drawType = drawType
         self.drawId = None
 
     def __str__(self):
         return f'bioDraws("{self.name}", "{self.drawType}")'
 
-    def setSpecificIndices(
-        self,
-        indicesOfFreeBetas,
-        indicesOfFixedBetas,
-        indicesOfRandomVariables,
-        indicesOfDraws,
-    ):
-        """
-        Provide an index to all elementary expressions, specific to their type
-        Overloads the generic function.
-
-        :param indicesOfFreeBetas: dictionary mapping the name of the
-                               free betas with their index
-        :type indicesOfFreeBetas: dict(string:int)
-
-        :param indicesOfFixedBetas: dictionary mapping the name of the
-                                fixed betas with their index
-        :type indicesOfFixedBetas: dict(string:int)
-
-        :param indicesOfRandomVariables: dictionary mapping the name of the
-                                random variables with their index
-        :type indicesOfRandomVariables: dict(string:int)
-        :param indicesOfDraws: dictionary mapping the name of the draws with
-                            their index
-        :type indicesOfDraws: dict(string:int)
+    def check_draws(self):
+        """List of draws defined outside of 'MonteCarlo'
 
-        :raise biogemeError: if no index is available for one draw type.
+        :return: List of names of variables
+        :rtype: list(str)
         """
-        if self.name in indicesOfDraws:
-            self.drawId = indicesOfDraws[self.name]
-        else:
-            error_msg = (
-                f'No index is available for draw {self.drawType}.'
-                f' Known types of draws: {indicesOfDraws.keys()}'
-            )
-            raise excep.biogemeError(error_msg)
+        return {self.name}
+
+    def setIdManager(self, id_manager=None):
+        """The ID manager contains the IDs of the elementary expressions.
+
+        It is externally created, as it may nee to coordinate the
+        numbering of several expressions. It is stored only in the
+        expressions of type Elementary.
+
+        :param id_manager: ID manager to be propagated to the
+            elementary expressions. If None, all the IDs are set to None.
+        :type id_manager: class IdManager
+        """
+        self.id_manager = id_manager
+        if id_manager is None:
+            self.elementaryIndex = None
+            self.drawId = None
+            return
+        self.elementaryIndex = self.id_manager.elementary_expressions.indices[
+            self.name
+        ]
+        self.drawId = self.id_manager.draws.indices[self.name]
 
     def getSignature(self):
         """The signature of a string characterizing an expression.
 
         This is designed to be communicated to C++, so that the
         expression can be reconstructed in this environment.
 
@@ -2075,94 +2390,53 @@
         :rtype: list(string)
 
         :raise biogeme.exceptions.biogemeError: if no id has been defined for
             elementary expression
         :raise biogeme.exceptions.biogemeError: if no id has been defined for
             draw
         """
-        if self.uniqueId is None:
+        if self.elementaryIndex is None:
             error_msg = (
                 f'No id has been defined for elementary '
                 f'expression {self.name}.'
             )
             raise excep.biogemeError(error_msg)
         if self.drawId is None:
             error_msg = f'No id has been defined for draw {self.name}.'
             raise excep.biogemeError(error_msg)
         signature = f'<{self.getClassName()}>'
         signature += f'{{{id(self)}}}'
-        signature += f'"{self.name}",{self.uniqueId},{self.drawId}'
+        signature += f'"{self.name}",{self.elementaryIndex},{self.drawId}'
         return [signature.encode()]
 
     def dictOfDraws(self):
         """Recursively extract the random variables
         (draws for Monte-Carlo).  Overloads the generic function.
         appearing in the expression, and store them in a dictionary.
 
         :return: dict where the keys are the random variables and the
                  elements the type of draws. Here, contains only one element.
         :rtype: dict(string:string)
         """
         return {self.name: self.drawType}
 
-    def setDrawIndex(self, idsOfDraws):
-        """
-        Provide an index to a series of draw for a random variable. Overload
-        the generic function.
-
-        :param idsOfDraws: dictionary mapping the name of the draws with
-            their id.
-        :type idsOfDraws: dict(string:int)
-
-        :raise biogemeError: if no id is available for a draw.
-        """
-        if self.name in idsOfDraws:
-            self.drawId = idsOfDraws[self.name]
-        else:
-            error_msg = (
-                f'No id is available for draw {self.name}. '
-                f'List of available indices: '
-                f'{[n for n, i in idsOfDraws.items()]}'
-            )
-            raise excep.biogemeError(error_msg)
-
-    def audit(self, database=None):
-        """Performs various checks on the expressions.
-
-        :param database: database object
-        :type database: biogeme.database.Database
-
-        :return: tuple listOfErrors, listOfWarnings
-        :rtype: list(string), list(string)
-
-        """
-        listOfErrors = []
-        listOfWarnings = []
-        if not self.isContainedIn('MonteCarlo'):
-            theError = (
-                f'bioDraws expression must be embedded into a '
-                f'MonteCarlo: {self}'
-            )
-            listOfErrors.append(theError)
-        return listOfErrors, listOfWarnings
-
 
 class Numeric(Expression):
     """
     Numerical expression for a simple number
     """
 
     def __init__(self, value):
         """Constructor
 
         :param value: numerical value
         :type value: float
         """
         Expression.__init__(self)
-        self.value = value #: numeric value
+        self.value = float(value)  #: numeric value
 
     def __str__(self):
         return '`' + str(self.value) + '`'
 
     def getValue(self):
         """Evaluates the value of the expression
 
@@ -2235,21 +2509,56 @@
         :param name: name of the variable.
         :type name: string
         """
         Elementary.__init__(self, name)
         # Index of the variable
         self.variableId = None
 
+    def check_panel_trajectory(self):
+        """List of variables defined outside of 'PanelLikelihoodTrajectory'
+
+        :return: List of names of variables
+        :rtype: list(str)
+        """
+        return {self.name}
+
     def getValue(self):
-        """Evaluates the value of the expression
+        """The evaluation of a Variable requires a database. Therefore, this
+            function triggers an exception.
+
+        :raise biogemeError: each time the function is calles
 
-        :return: value of the expression
-        :rtype: float
         """
-        return self._row[self.name]
+        error_msg = (
+            f'Evaluating Variable {self.name} requires a database. Use the '
+            f'function getValue_c instead.'
+        )
+        raise excep.biogemeError(error_msg)
+
+    def setIdManager(self, id_manager=None):
+        """The ID manager contains the IDs of the elementary expressions.
+
+        It is externally created, as it may need to coordinate the
+        numbering of several expressions. It is stored only in the
+        expressions of type Elementary.
+
+        :param id_manager: ID manager to be propagated to the
+            elementary expressions. If None, all the IDs are set to None.
+        :type id_manager: class IdManager
+        """
+
+        self.id_manager = id_manager
+        if id_manager is None:
+            self.elementaryIndex = None
+            self.variableId = None
+            return
+        self.elementaryIndex = self.id_manager.elementary_expressions.indices[
+            self.name
+        ]
+        self.variableId = self.id_manager.variables.indices[self.name]
 
     def dictOfVariables(self):
         """Recursively extract the variables appearing in the expression, and
         store them in a dictionary.
 
         Overload the generic function.
 
@@ -2277,31 +2586,20 @@
         """
         listOfErrors = []
         listOfWarnings = []
         if database is None:
             raise excep.biogemeError(
                 'The database must be provided to audit the variable.'
             )
+
         if self.name not in database.data.columns:
             theError = f'Variable {self.name} not found in the database.'
             listOfErrors.append(theError)
         return listOfErrors, listOfWarnings
 
-    def setVariableIndices(self, indicesOfVariables):
-        """
-        Provide an index to all variables
-
-        :param indicesOfVariables: dictionary mapping the name of the
-                                variables with their index
-        :type indicesOfVariables: dict(string:int)
-
-        """
-        if self.name in indicesOfVariables:
-            self.variableId = indicesOfVariables[self.name]
-
     def getSignature(self):
         """The signature of a string characterizing an expression.
 
         This is designed to be communicated to C++, so that the
         expression can be reconstructed in this environment.
 
         The list contains the following elements:
@@ -2346,26 +2644,26 @@
         :rtype: list(string)
 
         :raise biogeme.exceptions.biogemeError: if no id has been defined for
             elementary expression
         :raise biogeme.exceptions.biogemeError: if no id has been defined for
             variable
         """
-        if self.uniqueId is None:
+        if self.elementaryIndex is None:
             error_msg = (
                 f'No id has been defined for elementary expression '
                 f'{self.name}.'
             )
             raise excep.biogemeError(error_msg)
         if self.variableId is None:
             error_msg = f'No id has been defined for variable {self.name}.'
             raise excep.biogemeError(error_msg)
         signature = f'<{self.getClassName()}>'
         signature += f'{{{id(self)}}}'
-        signature += f'"{self.name}",{self.uniqueId},{self.variableId}'
+        signature += f'"{self.name}",{self.elementaryIndex},{self.variableId}'
         return [signature.encode()]
 
 
 class DefineVariable(Variable):
     """Expression that defines a new variable and add a column in the database.
 
     This expression allows the use to define a new variable that
@@ -2383,23 +2681,20 @@
         :param database: object identifying the database.
         :type database: biogeme.database.Database
 
         :raise biogemeError: if the expression is invalid, that is
             neither a numeric value or a
             biogeme.expressions.Expression object.
         """
-        Variable.__init__(self, name)
-        if isNumeric(expression):
-            database.addColumn(Numeric(expression), name)
-        else:
-            if not isinstance(expression, Expression):
-                raise excep.biogemeError(
-                    f'This is not a valid expression: {expression}'
-                )
-            database.addColumn(expression, name)
+        raise excep.biogemeError(
+            'This expression is obsolete. Use the same function in the '
+            'database object. Replace "new_var = DefineVariable(\'NEW_VAR\','
+            ' expression, database)" by  "new_var = database.DefineVariable'
+            '(\'NEW_VAR\', expression)"'
+        )
 
 
 class RandomVariable(Elementary):
     """
     Random variable for numerical integration
     """
 
@@ -2409,85 +2704,56 @@
         :param name: name of the random variable involved in the integration.
         :type name: string.
         """
         Elementary.__init__(self, name)
         # Index of the random variable
         self.rvId = None
 
-    def audit(self, database=None):
-        """Performs various checks on the expressions.
-
-        :param database: database object
-        :type database: biogeme.database.Database
-
-        :return: tuple listOfErrors, listOfWarnings
-        :rtype: list(string), list(string)
+    def check_rv(self):
+        """List of random variables defined outside of 'Integrate'
 
+        :return: List of names of variables
+        :rtype: list(str)
         """
-        listOfErrors = []
-        listOfWarnings = []
-        if not self.isContainedIn('Integrate'):
-            theError = (
-                f'RandomVariable expression must be embedded into '
-                f'a integrate: {self}'
-            )
-            listOfErrors.append(theError)
-        return listOfErrors, listOfWarnings
+        return {self.name}
+
+    def setIdManager(self, id_manager=None):
+        """The ID manager contains the IDs of the elementary expressions.
+
+        It is externally created, as it may nee to coordinate the
+        numbering of several expressions. It is stored only in the
+        expressions of type Elementary.
+
+        :param id_manager: ID manager to be propagated to the
+            elementary expressions. If None, all the IDs are set to None.
+        :type id_manager: class IdManager
+        """
+        self.id_manager = id_manager
+        if id_manager is None:
+            self.elementaryIndex = None
+            self.rvId = None
+            return
+        self.elementaryIndex = self.id_manager.elementary_expressions.indices[
+            self.name
+        ]
+        self.rvId = self.id_manager.random_variables.indices[self.name]
 
     def dictOfRandomVariables(self):
         """Recursively extract the random variables appearing in
         the expression, and store them in a dictionary.
 
         Overloads the generic function.
 
         :return: returns a dict with the random variables appearing in
                  the expression the keys being their names.
 
         :rtype: dict(string:biogeme.expressions.Expression)
         """
         return {self.name: self}
 
-    def setSpecificIndices(
-        self,
-        indicesOfFreeBetas,
-        indicesOfFixedBetas,
-        indicesOfRandomVariables,
-        indicesOfDraws,
-    ):
-        """
-        Provide an index to all elementary expressions, specific to their type
-        Overloads the generic function.
-
-        :param indicesOfFreeBetas: dictionary mapping the name of the
-                               free betas with their index
-        :type indicesOfFreeBetas: dict(string:int)
-
-        :param indicesOfFixedBetas: dictionary mapping the name of the
-                                fixed betas with their index
-        :type indicesOfFixedBetas: dict(string:int)
-
-        :param indicesOfRandomVariables: dictionary mapping the name of the
-                                random variables with their index
-        :type indicesOfRandomVariables: dict(string:int)
-        :param indicesOfDraws: dictionary mapping the name of the draws with
-                            their index
-        :type indicesOfDraws: dict(string:int)
-
-        :raise biogemeError: if no index is available for a random variable.
-        """
-        if self.name in indicesOfRandomVariables:
-            self.rvId = indicesOfRandomVariables[self.name]
-        else:
-            error_msg = (
-                f'No index is available for random variable '
-                f'{self.name}. Known random variables: '
-                f'{indicesOfRandomVariables.keys()}'
-            )
-            raise excep.biogemeError(error_msg)
-
     def getSignature(self):
         """The signature of a string characterizing an expression.
 
         This is designed to be communicated to C++, so that the
         expression can be reconstructed in this environment.
 
         The list contains the following elements:
@@ -2532,29 +2798,29 @@
         :rtype: list(string)
 
         :raise biogeme.exceptions.biogemeError: if no id has been defined for
             elementary expression
         :raise biogeme.exceptions.biogemeError: if no id has been defined for
             random variable
         """
-        if self.uniqueId is None:
+        if self.elementaryIndex is None:
             error_msg = (
                 f'No id has been defined for elementary '
                 f'expression {self.name}.'
             )
             raise excep.biogemeError(error_msg)
         if self.rvId is None:
             error_msg = (
                 f'No id has been defined for random variable {self.name}.'
             )
             raise excep.biogemeError(error_msg)
 
         signature = f'<{self.getClassName()}>'
         signature += f'{{{id(self)}}}'
-        signature += f'"{self.name}",{self.uniqueId},{self.rvId}'
+        signature += f'"{self.name}",{self.elementaryIndex},{self.rvId}'
         return [signature.encode()]
 
 
 class Beta(Elementary):
     """
     Unknown parameters to be estimated from data.
     """
@@ -2596,16 +2862,67 @@
         Elementary.__init__(self, name)
         self.initValue = value
         self.lb = lowerbound
         self.ub = upperbound
         self.status = status
         self.betaId = None
 
+    def setIdManager(self, id_manager=None):
+        """The ID manager contains the IDs of the elementary expressions.
+
+        It is externally created, as it may nee to coordinate the
+        numbering of several expressions. It is stored only in the
+        expressions of type Elementary.
+
+        :param id_manager: ID manager to be propagated to the
+            elementary expressions. If None, all the IDs are set to None.
+        :type id_manager: class IdManager
+        """
+        self.id_manager = id_manager
+        if id_manager is None:
+            self.elementaryIndex = None
+            self.betaId = None
+            return
+        self.elementaryIndex = self.id_manager.elementary_expressions.indices[
+            self.name
+        ]
+        if self.status != 0:
+            self.betaId = self.id_manager.fixed_betas.indices[self.name]
+        else:
+            self.betaId = self.id_manager.free_betas.indices[self.name]
+
     def __str__(self):
-        return f'{self.name}({self.initValue})'
+        if self.status == 0:
+            return f'{self.name}(init={self.initValue})'
+        return f'{self.name}(fixed={self.initValue})'
+
+    def fix_betas(self, beta_values, prefix=None, suffix=None):
+        """Fix all the values of the beta parameters appearing in the
+        dictionary
+
+        :param beta_values: dictionary containing the betas to be
+            fixed (as key) and their value.
+        :type beta_values: dict(str: float)
+
+        :param prefix: if not None, the parameter is renamed, with a
+            prefix defined by this argument.
+        :type prefix: str
+
+        :param suffix: if not None, the parameter is renamed, with a
+            suffix defined by this argument.
+        :type suffix: str
+
+        """
+        if self.name in beta_values:
+            self.initValue = beta_values[self.name]
+            self.status = 1
+            if prefix is not None:
+                self.name = f'{prefix}{self.name}'
+            if suffix is not None:
+                self.name = f'{self.name}{suffix}'
 
     def setOfBetas(self, free=True, fixed=False):
         """Extract the set of parameters from the expression. Overload the
         generic function.
 
         :param free: if True, the free parameters are included. Default: True.
         :type free: bool
@@ -2621,64 +2938,14 @@
             return set([self.name])
 
         if free and self.status == 0:
             return set([self.name])
 
         return set()
 
-    def setSpecificIndices(
-        self,
-        indicesOfFreeBetas,
-        indicesOfFixedBetas,
-        indicesOfRandomVariables,
-        indicesOfDraws,
-    ):
-        """
-        Provide an index to all elementary expressions, specific to their type
-
-        :param indicesOfFreeBetas: dictionary mapping the name of the
-                               free betas with their index
-        :type indicesOfFreeBetas: dict(string:int)
-
-        :param indicesOfFixedBetas: dictionary mapping the name of the
-                                fixed betas with their index
-        :type indicesOfFixedBetas: dict(string:int)
-
-        :param indicesOfRandomVariables: dictionary mapping the name of the
-                                random variables with their index
-        :type indicesOfRandomVariables: dict(string:int)
-        :param indicesOfDraws: dictionary mapping the name of the draws with
-                            their index
-        :type indicesOfDraws: dict(string:int)
-
-        :raise biogemeError: if no index is available for one of the parameters
-
-        """
-
-        if self.status != 0:
-            if self.name in indicesOfFixedBetas:
-                self.betaId = indicesOfFixedBetas[self.name]
-            else:
-                error_msg = (
-                    f'No index is available for fixed parameter '
-                    f'{self.name}. Known fixed parameters: '
-                    '{indicesOfFixedBetas.keys()}'
-                )
-                raise excep.biogemeError(error_msg)
-        else:
-            if self.name in indicesOfFreeBetas:
-                self.betaId = indicesOfFreeBetas[self.name]
-            else:
-                error_msg = (
-                    f'No index is available for free parameter '
-                    f'{self.name}. Known free parameters: '
-                    f'{indicesOfFreeBetas.keys()}'
-                )
-                raise excep.biogemeError(error_msg)
-
     def dictOfBetas(self, free=True, fixed=False):
         """Extract the set of parameters from the expression. Overload the
         generic function.
 
         :param free: if True, the free parameters are included. Default: True.
         :type free: bool
         :param fixed: if True, the fixed parameters are included.
@@ -2691,15 +2958,15 @@
         """
         if fixed and self.status != 0:
             return {self.name: self}
 
         if free and self.status == 0:
             return {self.name: self}
 
-        return dict()
+        return {}
 
     def getValue(self):
         """Evaluates the value of the expression
 
         :return: value of the expression
         :rtype: float
         """
@@ -2769,29 +3036,30 @@
         :rtype: list(string)
 
         :raise biogeme.exceptions.biogemeError: if no id has been defined for
             elementary expression
         :raise biogeme.exceptions.biogemeError: if no id has been defined for
             parameter
         """
-        if self.uniqueId is None:
+        if self.elementaryIndex is None:
             error_msg = (
                 f'No id has been defined for elementary '
                 f'expression {self.name}.'
             )
             raise excep.biogemeError(error_msg)
         if self.betaId is None:
             raise excep.biogemeError(
                 f'No id has been defined for parameter {self.name}.'
             )
 
         signature = f'<{self.getClassName()}>'
         signature += f'{{{id(self)}}}'
         signature += (
-            f'"{self.name}"[{self.status}],{self.uniqueId},{self.betaId}'
+            f'"{self.name}"[{self.status}],'
+            f'{self.elementaryIndex},{self.betaId}'
         )
         return [signature.encode()]
 
 
 class LogLogit(Expression):
     """Expression capturing the logit formula.
 
@@ -2823,25 +3091,25 @@
         :type choice: biogeme.expressions.Expression
 
         :raise biogemeError: if one of the expressions is invalid, that is
             neither a numeric value or a
             biogeme.expressions.Expression object.
         """
         Expression.__init__(self)
-        self.util = {} #: dict of utility functions
+        self.util = {}  #: dict of utility functions
         for i, e in util.items():
             if isNumeric(e):
                 self.util[i] = Numeric(e)
             else:
                 if not isinstance(e, Expression):
                     raise excep.biogemeError(
                         f'This is not a valid expression: {e}'
                     )
                 self.util[i] = e
-        self.av = {} #: dict of availability formulas
+        self.av = {}  #: dict of availability formulas
         if av is None:
             self.av = {k: Numeric(1) for k, v in util.items()}
         else:
             for i, e in av.items():
                 if isNumeric(e):
                     self.av[i] = Numeric(e)
                 else:
@@ -2856,21 +3124,18 @@
         else:
             if not isinstance(choice, Expression):
                 raise excep.biogemeError(
                     f'This is not a valid expression: {choice}'
                 )
             self.choice = choice
 
-        self.choice.parent = self
         self.children.append(self.choice)
         for i, e in self.util.items():
-            e.parent = self
             self.children.append(e)
         for i, e in self.av.items():
-            e.parent = self
             self.children.append(e)
 
     def audit(self, database=None):
         """Performs various checks on the expressions.
 
         :param database: database object
         :type database: biogeme.database.Database
@@ -2903,20 +3168,21 @@
                 theError += (
                     ' Id(s) used for availabilities and not ' 'for utilities: '
                 ) + mysetContent
             listOfErrors.append(theError)
         else:
             consistent = True
         listOfAlternatives = list(self.util)
-        choices = database.valuesFromDatabase(self.choice)
-        correctChoices = choices.isin(listOfAlternatives)
-        indexOfIncorrectChoices = correctChoices.index[
-            correctChoices == False
-        ].tolist()
-        if indexOfIncorrectChoices:
+        if database is None:
+            choices = np.array([self.choice.getValue_c()])
+        else:
+            choices = database.valuesFromDatabase(self.choice)
+        correctChoices = np.isin(choices, listOfAlternatives)
+        indexOfIncorrectChoices = np.argwhere(~correctChoices)
+        if indexOfIncorrectChoices.any():
             incorrectChoices = choices[indexOfIncorrectChoices]
             content = '-'.join(
                 '{}[{}]'.format(*t)
                 for t in zip(indexOfIncorrectChoices, incorrectChoices)
             )
             truncate = 100
             if len(content) > truncate:
@@ -2925,71 +3191,103 @@
                 f'The choice variable [{self.choice}] does not '
                 f'correspond to a valid alternative for the '
                 f'following observations (rownumber[choice]): '
             ) + content
             listOfErrors.append(theError)
 
         if consistent:
-            choiceAvailability = database.checkAvailabilityOfChosenAlt(
-                self.av, self.choice
-            )
-            indexOfUnavailableChoices = choiceAvailability.index[
-                choiceAvailability == False
-            ].tolist()
-            if indexOfUnavailableChoices:
-                incorrectChoices = choices[indexOfUnavailableChoices]
-                content = '-'.join(
-                    '{}[{}]'.format(*t)
-                    for t in zip(indexOfUnavailableChoices, incorrectChoices)
+            if database is None:
+                value_choice = self.choice.getValue_c()
+                if not value_choice in self.av.keys():
+                    theError = (
+                        f'The chosen alternative [{value_choice}] '
+                        f'is not available'
+                    )
+                    listOfWarnings.append(theError)
+            else:
+                choiceAvailability = database.checkAvailabilityOfChosenAlt(
+                    self.av, self.choice
                 )
-                truncate = 100
-                if len(content) > truncate:
-                    content = f'{content[:truncate]}...'
-                theError = (
-                    f'The chosen alternative [{self.choice}] '
-                    f'is not available for the following '
-                    f'observations (rownumber[choice]): '
-                ) + content
-                listOfWarnings.append(theError)
+                indexOfUnavailableChoices = np.where(~choiceAvailability)[0]
+                if indexOfUnavailableChoices.size > 0:
+                    incorrectChoices = choices[indexOfUnavailableChoices]
+                    content = '-'.join(
+                        '{}[{}]'.format(*t)
+                        for t in zip(
+                            indexOfUnavailableChoices, incorrectChoices
+                        )
+                    )
+                    truncate = 100
+                    if len(content) > truncate:
+                        content = f'{content[:truncate]}...'
+                    theError = (
+                        f'The chosen alternative [{self.choice}] '
+                        f'is not available for the following '
+                        f'observations (rownumber[choice]): '
+                    ) + content
+                    listOfWarnings.append(theError)
 
         return listOfErrors, listOfWarnings
 
     def getValue(self):
         """Evaluates the value of the expression
 
         :return: value of the expression
         :rtype: float
+
+        :raise biogemeError: if the chosen alternative does not correspond
+            to any of the utility functions
+
+        :raise biogemeError: if the chosen alternative does not correspond
+            to any of entry in the availability condition
+
         """
         choice = int(self.choice.getValue())
         if choice not in self.util:
-            self.logger.warning(
-                f'Choice is {choice}. List of alternatives '
-                f'is {self.util.keys()}'
+            error_msg = (
+                f'Alternative {choice} does not appear in the list '
+                f'of utility functions: {self.util.keys()}'
             )
-            return np.nan
+            raise excep.biogemeError(error_msg)
+        if choice not in self.av:
+            error_msg = (
+                f'Alternative {choice} does not appear in the list '
+                f'of availabilities: {self.av.keys()}'
+            )
+            raise excep.biogemeError(error_msg)
         if self.av[choice].getValue() == 0.0:
             return -np.log(0)
         Vchosen = self.util[choice].getValue()
         denom = 0.0
         for i, V in self.util.items():
             if self.av[i].getValue() != 0.0:
                 denom += np.exp(V.getValue() - Vchosen)
         return -np.log(denom)
 
     def __str__(self):
         s = self.getClassName()
-        s += '('
+        s += f'[choice={self.choice}]'
+        s += 'U=('
         first = True
         for i, e in self.util.items():
             if first:
                 s += f'{int(i)}:{e}'
                 first = False
             else:
                 s += f', {int(i)}:{e}'
         s += ')'
+        s += 'av=('
+        first = True
+        for i, e in self.av.items():
+            if first:
+                s += f'{int(i)}:{e}'
+                first = False
+            else:
+                s += f', {int(i)}:{e}'
+        s += ')'
         return s
 
     def getSignature(self):
         """The signature of a string characterizing an expression.
 
         This is designed to be communicated to C++, so that the
         expression can be reconstructed in this environment.
@@ -3059,24 +3357,77 @@
 
     This expression captures the logarithm of the logit formula. It
     contains one formula for the target alternative, a dict of formula
     for the availabilities and a dict of formulas for the utilities It
     uses only the C++ implementation.
     """
 
+    def __init__(self, util, av, choice):
+        """Constructor
+
+        :param util: dictionary where the keys are the identifiers of
+                     the alternatives, and the elements are objects
+                     defining the utility functions.
+
+        :type util: dict(int:biogeme.expressions.Expression)
+
+        :param av: dictionary where the keys are the identifiers of
+                   the alternatives, and the elements are object of
+                   type biogeme.expressions.Expression defining the
+                   availability conditions. If av is None, all the
+                   alternatives are assumed to be always available
+
+        :type av: dict(int:biogeme.expressions.Expression)
+
+        :param choice: formula to obtain the alternative for which the
+                       logit probability must be calculated.
+        :type choice: biogeme.expressions.Expression
+
+        :raise biogemeError: if one of the expressions is invalid, that is
+            neither a numeric value or a
+            biogeme.expressions.Expression object.
+        """
+        super().__init__(util, av, choice)
 
 class _bioLogLogitFullChoiceSet(LogLogit):
     """This expression captures the logarithm of the logit formula, where
     all alternatives are supposed to be always available.
 
        It contains one formula for the target alternative and a dict of
        formulas for the utilities. It uses only the C++ implementation.
 
     """
 
+    def __init__(self, util, av, choice):
+        """Constructor
+
+        :param util: dictionary where the keys are the identifiers of
+                     the alternatives, and the elements are objects
+                     defining the utility functions.
+
+        :type util: dict(int:biogeme.expressions.Expression)
+
+        :param av: dictionary where the keys are the identifiers of
+                   the alternatives, and the elements are object of
+                   type biogeme.expressions.Expression defining the
+                   availability conditions. If av is None, all the
+                   alternatives are assumed to be always available
+
+        :type av: dict(int:biogeme.expressions.Expression)
+
+        :param choice: formula to obtain the alternative for which the
+                       logit probability must be calculated.
+        :type choice: biogeme.expressions.Expression
+
+        :raise biogemeError: if one of the expressions is invalid, that is
+            neither a numeric value or a
+            biogeme.expressions.Expression object.
+        """
+        super().__init__(util, av, choice)
+
 
 class bioMultSum(Expression):
     """This expression returns the sum of several other expressions.
 
     It is a generalization of 'Plus' for more than two terms
     """
 
@@ -3093,35 +3444,31 @@
             biogeme.expressions.Expression object.
         """
         Expression.__init__(self)
         if isinstance(listOfExpressions, dict):
             for e in listOfExpressions.values():
                 if isNumeric(e):
                     theExpression = Numeric(e)
-                    theExpression.parent = self
                     self.children.append(theExpression)
                 else:
                     if not isinstance(e, Expression):
                         raise excep.biogemeError(
                             f'This is not a valid expression: {e}'
                         )
-                    e.parent = self
                     self.children.append(e)
         elif isinstance(listOfExpressions, list):
             for e in listOfExpressions:
                 if isNumeric(e):
                     theExpression = Numeric(e)
-                    theExpression.parent = self
                     self.children.append(theExpression)
                 else:
                     if not isinstance(e, Expression):
                         raise excep.biogemeError(
                             f'This is not a valid expression: {e}'
                         )
-                    e.parent = self
                     self.children.append(e)
         else:
             raise excep.biogemeError(
                 'Argument of bioMultSum must be a dict or a list.'
             )
 
     def getValue(self):
@@ -3158,62 +3505,67 @@
 
         :raise biogemeError: if one of the expressions is invalid, that is
             neither a numeric value or a
             biogeme.expressions.Expression object.
         """
         Expression.__init__(self)
 
-        self.dictOfExpressions = {} #: dict of expressions
-        for k, v in dictOfExpressions.items():
-            if isNumeric(v):
-                self.dictOfExpressions[k] = Numeric(v)
-            else:
-                if not isinstance(v, Expression):
-                    raise excep.biogemeError(
-                        f'This is not a valid expression: {v}'
-                    )
-                self.dictOfExpressions[k] = v
-            self.dictOfExpressions[k].parent = self
-            self.children.append(self.dictOfExpressions[k])
-
         if isinstance(keyExpression, bool):
             self.keyExpression = Numeric(1) if keyExpression else Numeric(0)
         elif isNumeric(keyExpression):
             self.keyExpression = Numeric(keyExpression)
         else:
             if not isinstance(keyExpression, Expression):
                 raise excep.biogemeError(
                     f'This is not a valid expression: {keyExpression}'
                 )
-            self.keyExpression = keyExpression #: expression for the key
-        self.keyExpression.parent = self
+            self.keyExpression = keyExpression  #: expression for the key
         self.children.append(self.keyExpression)
 
+        self.dictOfExpressions = {}  #: dict of expressions
+        for k, v in dictOfExpressions.items():
+            if isNumeric(v):
+                self.dictOfExpressions[k] = Numeric(v)
+            else:
+                if not isinstance(v, Expression):
+                    raise excep.biogemeError(
+                        f'This is not a valid expression: {v}'
+                    )
+                self.dictOfExpressions[k] = v
+            self.children.append(self.dictOfExpressions[k])
+
     def getValue(self):
         """Evaluates the value of the expression
 
         :return: value of the expression
         :rtype: float
+
+        :raise biogemeError: if the calcuated key is not present in
+            the dictionary.
         """
         key = int(self.keyExpression.getValue())
         if key in self.dictOfExpressions:
             return self.dictOfExpressions[key].getValue()
 
-        return 0.0
+        error_msg = (
+            f'Key {key} is not present in the dictionary. '
+            f'Available keys: {self.dictOfExpressions.keys()}'
+        )
+        raise excep.biogemeError(error_msg)
 
     def __str__(self):
         s = '{{'
         first = True
         for k, v in self.dictOfExpressions.items():
             if first:
-                s += '{}:{}'.format(k, v)
+                s += f'{k}:{v}'
                 first = False
             else:
-                s += ', {}:{}'.format(k, v)
-        s += '}}[{}]'.format(self.keyExpression)
+                s += f', {k}:{v}'
+        s += f'}}[{self.keyExpression}]'
         return s
 
     def getSignature(self):
         """The signature of a string characterizing an expression.
 
         This is designed to be communicated to C++, so that the
         expression can be reconstructed in this environment.
@@ -3262,18 +3614,18 @@
         :return: list of the signatures of an expression and its children.
         :rtype: list(string)
         """
         listOfSignatures = []
         listOfSignatures += self.keyExpression.getSignature()
         for i, e in self.dictOfExpressions.items():
             listOfSignatures += e.getSignature()
-        signature = '<{}>'.format(self.getClassName())
-        signature += '{{{}}}'.format(id(self))
-        signature += '({})'.format(len(self.dictOfExpressions))
-        signature += ',{}'.format(id(self.keyExpression))
+        signature = f'<{self.getClassName()}>'
+        signature += f'{{{id(self)}}}'
+        signature += f'({len(self.dictOfExpressions)})'
+        signature += f',{id(self.keyExpression)}'
         for i, e in self.dictOfExpressions.items():
             signature += f',{i},{id(e)}'
         listOfSignatures += [signature.encode()]
         return listOfSignatures
 
 
 class bioLinearUtility(Expression):
@@ -3316,17 +3668,17 @@
                     first = False
                 theError += f' Expression {v} is not a variable.'
         if not first:
             raise excep.biogemeError(theError)
 
         self.betas, self.variables = zip(*listOfTerms)
 
-        self.betas = list(self.betas) #: list of parameters
+        self.betas = list(self.betas)  #: list of parameters
 
-        self.variables = list(self.variables) #: list of variables
+        self.variables = list(self.variables)  #: list of variables
 
         self.listOfTerms = list(zip(self.betas, self.variables))
         """ List of terms """
 
         self.children += self.betas + self.variables
 
     def __str__(self):
@@ -3371,15 +3723,15 @@
         if free and fixed:
             allnames = {**freenames, **fixednames}
             return allnames
         if free:
             return freenames
         if fixed:
             return fixednames
-        return dict()
+        return {}
 
     def dictOfVariables(self):
         """Recursively extract the variables appearing in the expression, and
         store them in a dictionary.
 
         Overloads the generic function.
 
@@ -3396,26 +3748,26 @@
 
         :return: returns a dict with the random variables appearing in
                  the expression the keys being their names.
 
         :rtype: dict(string:biogeme.expressions.Expression)
 
         """
-        return dict()
+        return {}
 
     def dictOfDraws(self):
         """Recursively extract the random variables
         (draws for Monte-Carlo).  Overloads the generic function.
         appearing in the expression, and store them in a dictionary.
 
         :return: dict where the keys are the random variables and
              the elements the type of draws. Here, returns an empty dict.
         :rtype: dict(string:string)
         """
-        return dict()
+        return {}
 
     def getSignature(self):
         """The signature of a string characterizing an expression.
 
         This is designed to be communicated to C++, so that the
         expression can be reconstructed in this environment.
 
@@ -3468,157 +3820,15 @@
         :rtype: list(string)
         """
         listOfSignatures = []
         for e in self.children:
             listOfSignatures += e.getSignature()
         signature = f'<{self.getClassName()}>'
         signature += f'{{{id(self)}}}'
-        signature += '({})'.format(len(self.listOfTerms))
+        signature += f'({len(self.listOfTerms)})'
         for b, v in self.listOfTerms:
             signature += (
-                f',{id(b)},{b.uniqueId},{b.name},{id(v)},{v.uniqueId},{v.name}'
+                f',{id(b)},{b.elementaryIndex},{b.name},'
+                f'{id(v)},{v.elementaryIndex},{v.name}'
             )
         listOfSignatures += [signature.encode()]
         return listOfSignatures
-
-
-def defineNumberingOfElementaryExpressions(
-    collectionOfFormulas, variableNames
-):
-    """Provides indices for elementary expressions
-
-    The numbering is done in the following order:
-
-        (i) free betas,
-        (ii) fixed betas,
-        (iii) random variables for numrerical integration,
-        (iv) random variables for Monte-Carlo integration,
-        (v) variables
-
-    The numbering convention will be performed for all expressions
-    together, so that the same elementary expressions in several
-    expressions will have the same index.
-
-    :param collectionOfFormulas: collection of Biogeme expressions.
-    :type collectionOfFormulas: list(biogeme.expressions.Expression)
-    :param variableNames: list of the names of the variables
-    :type variableNames: list(string)
-    :return: dict, free, freeNames, fixed, fixedNames, rv, rvNames, draws,
-        drawsNames where
-
-         - dict is a dictionary mapping the names of the elementary
-           expressions with their index,
-         - free is a dict with the free betas,
-         - freeNames is a list of the names of the free betas,
-         - fixed is a dict with the fixed betas,
-         - fixedNames is the list of the names of the fixed betas,
-         - rv is a dict with the random variables for numerical integration,
-         - rvNames is a list with their names,
-         - draws is a dict of the draws, and
-         - drawsNames is a list with their names.
-
-    :rtype: tuple(dict(str: class Expression),
-                  dict(str: class Beta),
-                  list(str),
-                  dict(str: class Beta),
-                  list(str),
-                  dict(str: class RandomVariable),
-                  list(str),
-                  dict(str: class bioDraws),
-                  list(str))
-
-    :raise biogemeError: if some elementary expressions are defined
-        more than once.
-    """
-    # Free parameters (to be estimated), sorted by alphatical order.
-    allFreeBetas = dict()
-    freeBetaIndex = {}
-    for f in collectionOfFormulas:
-        d = f.dictOfBetas(free=True, fixed=False)
-        allFreeBetas = dict(allFreeBetas, **d)
-    freeBetaNames = sorted(allFreeBetas)
-    #    for i in range(len(freeBetaNames)):
-    for i, v in enumerate(freeBetaNames):
-        freeBetaIndex[v] = i
-
-    # Fixed parameters (not to be estimated), sorted by alphatical order.
-    allFixedBetas = dict()
-    fixedBetaIndex = {}
-    for f in collectionOfFormulas:
-        d = f.dictOfBetas(free=False, fixed=True)
-        allFixedBetas = dict(allFixedBetas, **d)
-    fixedBetaNames = sorted(allFixedBetas)
-    #    for i in range(len(fixedBetaNames)):
-    for i, v in enumerate(fixedBetaNames):
-        fixedBetaIndex[v] = i
-
-    # Random variables for numerical integration
-    allRandomVariables = dict()
-    randomVariableIndex = {}
-    for f in collectionOfFormulas:
-        d = f.dictOfRandomVariables()
-        allRandomVariables = dict(allRandomVariables, **d)
-    randomVariableNames = sorted(allRandomVariables)
-    #    for i in range(len(randomVariableNames)):
-    for i, v in enumerate(randomVariableNames):
-        randomVariableIndex[v] = i
-
-    # Draws
-    allDraws = dict()
-    drawIndex = {}
-    for f in collectionOfFormulas:
-        d = f.dictOfDraws()
-        allDraws = dict(allDraws, **d)
-    drawNames = sorted(allDraws)
-    #    for i in range(len(drawNames)):
-    for i, v in enumerate(drawNames):
-        drawIndex[v] = i
-
-    # Variables
-    variableIndex = {}
-    #    for i in range(len(variableNames)):
-    for i, v in enumerate(variableNames):
-        variableIndex[v] = i
-
-    # Merge all the names
-    allElementaryExpressions = (
-        freeBetaNames
-        + fixedBetaNames
-        + randomVariableNames
-        + drawNames
-        + variableNames
-    )
-
-    if len(allElementaryExpressions) != len(set(allElementaryExpressions)):
-        duplicates = {
-            x
-            for x in allElementaryExpressions
-            if allElementaryExpressions.count(x) > 1
-        }
-        error_msg = (
-            f'The following elementary expressions are defined '
-            f'more than once: {duplicates}.'
-        )
-        raise excep.biogemeError(error_msg)
-
-    elementaryExpressionIndex = {}
-    for i, v in enumerate(allElementaryExpressions):
-        elementaryExpressionIndex[v] = i
-
-    for f in collectionOfFormulas:
-        f.setUniqueId(elementaryExpressionIndex)
-        f.setSpecificIndices(
-            freeBetaIndex, fixedBetaIndex, randomVariableIndex, drawIndex
-        )
-        f.setVariableIndices(variableIndex)
-
-    return (
-        elementaryExpressionIndex,
-        allFreeBetas,
-        freeBetaNames,
-        allFixedBetas,
-        fixedBetaNames,
-        allRandomVariables,
-        randomVariableNames,
-        allDraws,
-        drawNames,
-    )
```

### Comparing `biogeme-3.2.8/biogeme/filenames.py` & `biogeme-3.2.9/biogeme/filenames.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/biogeme/hamabs.py` & `biogeme-3.2.9/biogeme/hamabs.py`

 * *Files 1% similar despite different names*

```diff
@@ -65,15 +65,15 @@
         if self.batch[-1] == 1.0:
             return self.f[-1], self.g[-1], self.h[-1]
 
         # The last value has a weight proportional to the batch that
         # was used.  Each other value has a weight proportional to one
         # minus the batch of the last value, times a discounted factor
         scale = [self.batch[-1]] + [
-            discount ** k * (1.0 - self.batch[-1]) / (self.windowSize - 1)
+            discount**k * (1.0 - self.batch[-1]) / (self.windowSize - 1)
             for k in range(1, min(len(self.f), self.windowSize))
         ]
         normscale = [x / sum(scale) for x in scale]
         f = 0.0
         for k in range(0, min(len(self.f), self.windowSize)):
             f += normscale[k] * self.f[len(self.f) - k - 1]
 
@@ -206,17 +206,17 @@
                 'This algorithm does not handle bound constraints. Remove the '
                 'bounds, or select another algorithm.'
             )
 
     tol = np.finfo(np.float64).eps ** 0.3333
     maxiter = 1000
     # The size of the first batch is such that it can be increased 5 times
-    firstBatch = 1.0 / 2.0 ** 4
+    firstBatch = 1.0 / 2.0**4
     # The critical of the batch when BFGS is applied allows for 2 increases
-    hybrid = 1.0 / 2.0 ** 2
+    hybrid = 1.0 / 2.0**2
     firstRadius = 1.0
     # Premature convergence for small batch sizes
     # scaleEps = 10.0
     # Maximum number of iterations before updating the batch size
     maxFailure = 2
 
     dogleg = False
```

### Comparing `biogeme-3.2.8/biogeme/loglikelihood.py` & `biogeme-3.2.9/biogeme/loglikelihood.py`

 * *Files 3% similar despite different names*

```diff
@@ -37,15 +37,15 @@
     .. math:: P(i|\\xi_1,\\ldots,\\xi_L)
 
 
     :type prob: biogeme.expressions.Expression
 
     :return: the simulated loglikelihood, given by
 
-        .. math:: \\ln\\left(\\sum_{r=1}^R 
+        .. math:: \\ln\\left(\\sum_{r=1}^R
             P(i|\\xi^r_1,\\ldots,\\xi^r_L) \\right)
 
         where :math:`R` is the number of draws, and :math:`\\xi_j^r`
         is the rth draw of the random variable :math:`\\xi_j`.
 
     :rtype: biogeme.expressions.Expression
 
@@ -93,14 +93,14 @@
                   the standard error :math:`\\sigma` of the error term.
     :type sigma: biogeme.expressions.Expression
 
     :return: the likelihood of the regression, assuming a normal distribution,
         that is
 
     .. math:: -\\left( \\frac{(y-m)^2}{2\\sigma^2} \\right) -
-              \\log(\\sigma) - \\frac{1}{2}\\log(2\\pi)
+              \\frac{1}{2}\\log(\\sigma^2) - \\frac{1}{2}\\log(2\\pi)
 
     :rtype: biogeme.expressions.Expression
     """
     t = (meas - model) / sigma
-    f = -(t ** 2) / 2 - log(sigma) - 0.9189385332
+    f = -(t**2) / 2 - log(sigma**2) / 2 - 0.9189385332
     return f
```

### Comparing `biogeme-3.2.8/biogeme/messaging.py` & `biogeme-3.2.9/biogeme/messaging.py`

 * *Files 1% similar despite different names*

```diff
@@ -13,41 +13,41 @@
 import biogeme.version as bv
 from biogeme.singleton import Singleton
 
 
 class bioMessage(metaclass=Singleton):
     """Manages the Biogeme messages"""
 
-    def __init__(self, screenLevel=0):
+    def __init__(self, screenLevel=1):
         """Constructor
 
         :param screenLevel: level of message that must be displayed on the
             screen:
 
             - 0: no output (default)
             - 1: warnings only
             - 2: only warnings and general information
             - 3: more verbose
             - 4: debug messages
 
 
         :type screenLevel: int
         """
-        self.screenLevel = screenLevel #: screen verbosity level
+        self.screenLevel = screenLevel  #: screen verbosity level
         self.types = {
             0: 'Silent',
             1: 'Warning',
             2: 'General',
             3: 'Detailed',
             4: 'Debug',
-        } #: names of verbosity levels
+        }  #: names of verbosity levels
 
         self.resetMessages()
 
-        self.lastLevel = None #: last level used
+        self.lastLevel = None  #: last level used
 
     def resetMessages(self):
         """Erase all messages"""
         self.messages = []
 
     def allMessages(self, screenLevel=None):
         """Report all the messages up to a given level.
```

### Comparing `biogeme-3.2.8/biogeme/models.py` & `biogeme-3.2.9/biogeme/models.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,98 +7,85 @@
 # Too constraining
 # pylint: disable=invalid-name
 # pylint: disable=too-many-lines
 
 import biogeme.exceptions as excep
 import biogeme.messaging as msg
 
-from biogeme.expressions import (
-    _bioLogLogit,
-    _bioLogLogitFullChoiceSet,
-    exp,
-    log,
-    Elem,
-    bioMin,
-    bioMax,
-    Numeric,
-    Beta,
-    bioMultSum,
-    Variable,
-    Expression,
-)
+import biogeme.expressions as expr
 
 logger = msg.bioMessage()
 
 
 def loglogit(V, av, i):
     """The logarithm of the logit model
 
     The model is defined as
 
     .. math:: \\frac{a_i e^{V_i}}{\\sum_{i=1}^J a_j e^{V_j}}
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
 
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param av: dict of objects representing the availability of each
                alternative (:math:`a_i` in the above formula), indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type av: dict(int:biogeme.expressions.Expression)
+    :type av: dict(int:biogeme.expressions.expr.Expression)
 
     :param i: id of the alternative for which the probability must be
               calculated.
     :type i: int
 
     :return: choice probability of alternative number i.
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
     """
 
     if av is None:
-        return _bioLogLogitFullChoiceSet(V, av=None, choice=i)
+        return expr._bioLogLogitFullChoiceSet(V, av=None, choice=i)
 
-    return _bioLogLogit(V, av, i)
+    return expr._bioLogLogit(V, av, i)
 
 
 def logit(V, av, i):
     """The logit model
 
     The model is defined as
 
     .. math:: \\frac{a_i e^{V_i}}{\\sum_{i=1}^J a_j e^{V_j}}
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
 
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param av: dict of objects representing the availability of each
                alternative (:math:`a_i` in the above formula), indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type av: dict(int:biogeme.expressions.Expression)
+    :type av: dict(int:biogeme.expressions.expr.Expression)
 
     :param i: id of the alternative for which the probability must be
               calculated.
     :type i: int
 
     :return: choice probability of alternative number i.
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     """
     if av is None:
-        return exp(_bioLogLogitFullChoiceSet(V, av=None, choice=i))
+        return expr.exp(expr._bioLogLogitFullChoiceSet(V, av=None, choice=i))
 
-    return exp(_bioLogLogit(V, av, i))
+    return expr.exp(expr._bioLogLogit(V, av, i))
 
 
 def boxcox(x, ell):
     """Box-Cox transform
 
     .. math:: B(x, \\ell) = \\frac{x^{\\ell}-1}{\\ell}.
 
@@ -109,30 +96,31 @@
     To avoid numerical difficulties, if :math:`\\ell < 10^{-5}`,
     the McLaurin approximation is used:
 
     .. math:: \\log(x) + \\ell \\log(x)^2 + \\frac{1}{6} \\ell^2 \\log(x)^3
               + \\frac{1}{24} \\ell^3 \\log(x)^4.
 
     :param x: a variable to transform.
-    :type x: biogeme.expressions.Expression
+    :type x: biogeme.expressions.expr.Expression
     :param ell: parameter of the transformation.
-    :type ell: biogeme.expressions.Expression
+    :type ell: biogeme.expressions.expr.Expression
 
     :return: the Box-Cox transform
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
     """
 
-    regular = (x ** ell - 1.0) / ell
+    regular = (x**ell - 1.0) / ell
     mclaurin = (
-        log(x)
-        + ell * log(x) ** 2
-        + ell ** 2 * log(x) ** 3 / 6.0
-        + ell ** 3 * log(x) ** 4 / 24.0
+        expr.log(x)
+        + ell * expr.log(x) ** 2
+        + ell**2 * expr.log(x) ** 3 / 6.0
+        + ell**3 * expr.log(x) ** 4 / 24.0
     )
-    return Elem({0: regular, 1: mclaurin}, ell < Numeric(1.0e-5))
+    smooth = expr.Elem({0: regular, 1: mclaurin}, ell < expr.Numeric(1.0e-5))
+    return expr.Elem({0: smooth, 1: expr.Numeric(0)}, x == 0)
 
 
 def piecewise(variable, thresholds):
     """Obsolete function. Present for compatibility only"""
     errorMsg = (
         'The function "piecewise" is obsolete and has been replaced '
         'by "piecewiseVariables". Its use has changed. Please refer '
@@ -154,21 +142,21 @@
               t < a \\\\ t-a & \\text{if } a \\leq t < a+b \\\\ b  &
               \\text{otherwise}  \\end{array}\\right. \\;\\;\\;x_{Ti} =
               \\max(0, \\min(t-a, b))
 
     :param variable: variable for which we need the piecewise linear
        transform. The expression itself or the name of the variable
        can be given.
-    :type variable: biogeme.expressions.Expression or str
+    :type variable: biogeme.expressions.expr.Expression or str
 
     :param thresholds: list of thresholds
     :type thresholds: list(float)
 
     :return: list of variables to for the piecewise linear specification.
-    :rtype: list(biogeme.expressions.Expression)
+    :rtype: list(biogeme.expressions.expr.Expression)
 
     :raise biogemeError: if the thresholds are not defined properly,
         as only the first and the last thresholds can be set
         to None.
 
     .. seealso:: :meth:`piecewiseFormula`
 
@@ -185,37 +173,49 @@
             'For piecewise linear specification, only the first and '
             'the last thresholds can be None'
         )
         raise excep.biogemeError(errorMsg)
 
     # If the name of the variable is given, we transform it into an expression.
     if isinstance(variable, str):
-        variable = Variable(variable)
+        variable = expr.Variable(variable)
 
     # First variable
     if thresholds[0] is None:
-        results = [bioMin(variable, thresholds[1])]
+        results = [expr.bioMin(variable, thresholds[1])]
     else:
         b = thresholds[1] - thresholds[0]
-        results = [bioMax(Numeric(0), bioMin(variable - thresholds[0], b))]
+        results = [
+            expr.bioMax(
+                expr.Numeric(0), expr.bioMin(variable - thresholds[0], b)
+            )
+        ]
 
     for i in range(1, eye - 2):
         b = thresholds[i + 1] - thresholds[i]
-        results += [bioMax(Numeric(0), bioMin(variable - thresholds[i], b))]
+        results += [
+            expr.bioMax(
+                expr.Numeric(0), expr.bioMin(variable - thresholds[i], b)
+            )
+        ]
 
     # Last variable
     if thresholds[-1] is None:
-        results += [bioMax(0, variable - thresholds[-2])]
+        results += [expr.bioMax(0, variable - thresholds[-2])]
     else:
         b = thresholds[-1] - thresholds[-2]
-        results += [bioMax(Numeric(0), bioMin(variable - thresholds[-2], b))]
+        results += [
+            expr.bioMax(
+                expr.Numeric(0), expr.bioMin(variable - thresholds[-2], b)
+            )
+        ]
     return results
 
 
-def piecewiseFormula(variable, thresholds, initialBetas=None):
+def piecewiseFormula(variable, thresholds, betas=None):
     """Generate the formula for a piecewise linear specification.
 
     If there are K thresholds, K-1 variables are generated. The first
     and last thresholds can be defined as None, corresponding to
     :math:`-\\infty` and :math:`+\\infty`, respectively. If :math:`t` is
     the variable of interest, for each interval :math:`[a:a+b[`, we
     define a variable defined as:
@@ -230,113 +230,87 @@
     :param variable: name of the variable for which we need the
         piecewise linear transform.
     :type variable: string
 
     :param thresholds: list of thresholds
     :type thresholds: list(float)
 
-    :param initialBetas: list of values to initialize the beta
-                         parameters.  The number of entries should be
-                         the number of thresholds, plus one. If None,
-                         the value of zero is used. Default: none.
-    :type initialBetas: list(float)
+    :param betas: list of beta parameters to be used in the
+        specification.  The number of entries should be the number of
+        thresholds, minus one. If None, for each interval, the
+        parameter Beta('beta_VAR_interval',0, None, None, 0) is used,
+        where var is the name of the variable. Default: none.
+    :type betas:
+        list(biogeme.expresssions.Beta)
 
     :return: expression of  the piecewise linear specification.
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     :raise biogemeError: if the thresholds are not defined properly,
         which means that only the first and the last threshold can be set
         to None.
 
-    :raise biogemeError: if the length of list ``initialBetas`` is not equal to
-        the length of ``thresholds`` minus one.
+    :raise biogemeError: if the length of list ``initialexpr.Betas`` is
+        not equal to the length of ``thresholds`` minus one.
 
     .. seealso:: :meth:`piecewiseVariables`
 
     """
+    if isinstance(variable, expr.Variable):
+        the_variable = variable
+        the_name = variable.name
+    elif isinstance(variable, str):
+        the_name = variable
+        the_valiable = expr.Variable(f'{variable}')
+    else:
+        errorMsg = (
+            'The first argument of piecewiseFormula must be the '
+            'name of a variable, or the variable itself..'
+        )
+        raise excep.biogemeError(errorMsg)
 
     eye = len(thresholds)
     if all(t is None for t in thresholds):
         errorMsg = (
             'All thresholds for the piecewise linear specification '
             'are set to None.'
         )
         raise excep.biogemeError(errorMsg)
     if None in thresholds[1:-1]:
         errorMsg = (
             'For piecewise linear specification, only the first and '
             'the last thresholds can be None'
         )
         raise excep.biogemeError(errorMsg)
-    if initialBetas is not None:
-        if len(initialBetas) != eye - 1:
+    if betas is not None:
+        if len(betas) != eye - 1:
             errorMsg = (
                 f'As there are {eye} thresholds, a total of {eye-1} '
-                f'values are needed to initialize the parameters. '
-                f'But {len(initialBetas)} are provided'
+                f'Beta parameters are needed, and not {len(betas)}.'
             )
             raise excep.biogemeError(errorMsg)
 
-    theVars = piecewiseVariables(Variable(f'{variable}'), thresholds)
-    terms = []
-
-    # First term
-    betaValues = [
-        0 if initialBetas is None else initialBetas[i] for i in range(eye - 1)
-    ]
-    if thresholds[0] is None:
-        beta = Beta(
-            f'beta_{variable}_lessthan_{thresholds[1]}',
-            betaValues[0],
-            None,
-            None,
-            0,
-        )
-    else:
-        beta = Beta(
-            f'beta_{variable}_{thresholds[0]}_{thresholds[1]}',
-            betaValues[0],
-            None,
-            None,
-            0,
-        )
-
-    terms = [beta * theVars[0]]
-
-    # All terms, except the last
-    for i in range(1, eye - 2):
-        beta = Beta(
-            f'beta_{variable}_{thresholds[i]}_{thresholds[i+1]}',
-            betaValues[i],
-            None,
-            None,
-            0,
-        )
+    theVars = piecewiseVariables(expr.Variable(f'{variable}'), thresholds)
+    if betas is None:
+        betas = []
+        for i, a_threshold in enumerate(thresholds[:-1]):
+            next_threshold = thresholds[i + 1]
+            a_name = 'minus_inf' if a_threshold is None else f'{a_threshold}'
+            next_name = (
+                'inf' if next_threshold is None else f'{next_threshold}'
+            )
+            betas.append(
+                expr.Beta(
+                    f'beta_{variable}_{a_name}_{next_name}', 0, None, None, 0
+                )
+            )
 
-        terms += [beta * theVars[i]]
+    terms = [beta * theVars[i] for i, beta in enumerate(betas)]
 
-    # Last term
-    if thresholds[-1] is None:
-        beta = Beta(
-            f'beta_{variable}_{thresholds[-2]}_more',
-            betaValues[-2],
-            None,
-            None,
-            0,
-        )
-    else:
-        beta = Beta(
-            f'beta_{variable}_{thresholds[-2]}_{thresholds[-1]}',
-            betaValues[-2],
-            None,
-            None,
-            0,
-        )
-    terms += [beta * theVars[-1]]
-    return bioMultSum(terms)
+    return expr.bioMultSum(terms)
 
 
 def piecewiseFunction(x, thresholds, betas):
     """Plot a piecewise linear specification.
 
     If there are K thresholds, K-1 variables are generated. The first
     and last thresholds can be defined as None, corresponding to
@@ -413,226 +387,228 @@
 
 def logmev(V, logGi, av, choice):
     """Log of the choice probability for a MEV model.
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
 
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param logGi: a dictionary mapping each alternative id with the function
 
         .. math:: \\ln \\frac{\\partial G}{\\partial y_i}
             (e^{V_1},\\ldots,e^{V_J})
 
         where :math:`G` is the MEV generating function. If an alternative
         :math:`i` is not available, then :math:`G_i = 0`.
 
-    :type logGi: dict(int:biogeme.expressions.Expression)
+    :type logGi: dict(int:biogeme.expressions.expr.Expression)
 
     :param av: dict of objects representing the availability of each
                alternative (:math:`a_i` in the above formula), indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type av: dict(int:biogeme.expressions.Expression)
+    :type av: dict(int:biogeme.expressions.expr.Expression)
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :return: log of the choice probability of the MEV model, given by
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     .. math:: V_i + \\ln G_i(e^{V_1},\\ldots,e^{V_J}) -
               \\ln\\left(\\sum_j e^{V_j + \\ln G_j(e^{V_1},
               \\ldots,e^{V_J})}\\right)
 
     """
     H = {i: v + logGi[i] for i, v in V.items()}
     if av is None:
-        logP = _bioLogLogitFullChoiceSet(H, av=None, choice=choice)
+        logP = expr._bioLogLogitFullChoiceSet(H, av=None, choice=choice)
     else:
-        logP = _bioLogLogit(H, av, choice)
+        logP = expr._bioLogLogit(H, av, choice)
     return logP
 
 
 def mev(V, logGi, av, choice):
     """Choice probability for a MEV model.
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
 
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
 
     :param logGi: a dictionary mapping each alternative id with the function
 
         .. math:: \\ln \\frac{\\partial G}{\\partial y_i}
               (e^{V_1}, \\ldots, e^{V_J})
 
         where :math:`G` is the MEV generating function. If an alternative
         :math:`i` is not available, then :math:`G_i = 0`.
 
-    :type logGi: dict(int:biogeme.expressions.Expression)
+    :type logGi: dict(int:biogeme.expressions.expr.Expression)
 
     :param av: dict of objects representing the availability of each
                alternative (:math:`a_i` in the above formula), indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type av: dict(int:biogeme.expressions.Expression)
+    :type av: dict(int:biogeme.expressions.expr.Expression)
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :return: Choice probability of the MEV model, given by
 
     .. math:: \\frac{e^{V_i + \\ln G_i(e^{V_1},
               \\ldots,e^{V_J})}}{\\sum_j e^{V_j +
               \\ln G_j(e^{V_1},\\ldots,e^{V_J})}}
 
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
     """
-    return exp(logmev(V, logGi, av, choice))
+    return expr.exp(logmev(V, logGi, av, choice))
 
 
 def logmev_endogenousSampling(V, logGi, av, correction, choice):
 
     """Log of choice probability for a MEV model, including the
     correction for endogenous sampling as proposed by `Bierlaire, Bolduc
     and McFadden (2008)`_.
 
     .. _`Bierlaire, Bolduc and McFadden (2008)`:
        http://dx.doi.org/10.1016/j.trb.2007.09.003
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
 
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param logGi: a dictionary mapping each alternative id with the function
 
         .. math:: \\ln \\frac{\\partial G}{\\partial y_i}
                   (e^{V_1}, \\ldots, e^{V_J})
 
         where :math:`G` is the MEV generating function. If an alternative
         :math:`i` is not available, then :math:`G_i = 0`.
 
-    :type logGi: dict(int:biogeme.expressions.Expression)
+    :type logGi: dict(int:biogeme.expressions.expr.Expression)
 
     :param av: dict of objects representing the availability of each
                alternative (:math:`a_i` in the above formula), indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type av: dict(int:biogeme.expressions.Expression)
+    :type av: dict(int:biogeme.expressions.expr.Expression)
 
 
     :param correction: a dict of expressions for the correstion terms
                        of each alternative.
-    :type correction: dict(int:biogeme.expressions.Expression)
+    :type correction: dict(int:biogeme.expressions.expr.Expression)
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :return: log of the choice probability of the MEV model, given by
 
     .. math:: V_i + \\ln G_i(e^{V_1}, \\ldots,e^{V_J}) + \\omega_i -
               \\ln\\left(\\sum_j e^{V_j +
               \\ln G_j(e^{V_1}, \\ldots, e^{V_J})+ \\omega_j}\\right)
 
     where :math:`\\omega_i` is the correction term for alternative :math:`i`.
 
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     """
     H = {i: v + logGi[i] + correction[i] for i, v in V.items()}
-    logP = _bioLogLogit(H, av, choice)
+    logP = expr._bioLogLogit(H, av, choice)
     return logP
 
 
 def mev_endogenousSampling(V, logGi, av, correction, choice):
     """Choice probability for a MEV model, including the correction
     for endogenous sampling as proposed by
     `Bierlaire, Bolduc and McFadden (2008)`_.
 
     .. _`Bierlaire, Bolduc and McFadden (2008)`:
            http://dx.doi.org/10.1016/j.trb.2007.09.003
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
 
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param logGi: a dictionary mapping each alternative id with the function
 
         .. math:: \\ln \\frac{\\partial G}{\\partial y_i}
               (e^{V_1}, \\ldots, e^{V_J})
 
         where :math:`G` is the MEV generating function. If an alternative
         :math:`i` is not available, then :math:`G_i = 0`.
 
-    :type logGi: dict(int:biogeme.expressions.Expression)
+    :type logGi: dict(int:biogeme.expressions.expr.Expression)
 
     :param av: dict of objects representing the availability of each
                alternative (:math:`a_i` in the above formula), indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type av: dict(int:biogeme.expressions.Expression)
+    :type av: dict(int:biogeme.expressions.expr.Expression)
 
 
     :param correction: a dict of expressions for the correstion terms
                        of each alternative.
-    :type correction: dict(int:biogeme.expressions.Expression)
+    :type correction: dict(int:biogeme.expressions.expr.Expression)
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :return: log of the choice probability of the MEV model, given by
 
     .. math:: V_i + \\ln G_i(e^{V_1}, \\ldots, e^{V_J}) + \\omega_i -
               \\ln\\left(\\sum_j e^{V_j + \\ln G_j(e^{V_1},\\ldots,e^{V_J})+
               \\omega_j}\\right)
 
     where :math:`\\omega_i` is the correction term for alternative :math:`i`.
 
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     """
-    return exp(logmev_endogenousSampling(V, logGi, av, correction, choice))
+    return expr.exp(
+        logmev_endogenousSampling(V, logGi, av, correction, choice)
+    )
 
 
 def getMevGeneratingForNested(V, availability, nests):
     """Implements the  MEV generating function for the nested logit model
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
                alternative, indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: A tuple containing as many items as nests.
         Each item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions.Expression representing
+        - an object of type biogeme.expressions.expr.Expression representing
           the nest parameter,
         - a list containing the list of identifiers of the alternatives
           belonging to the nest.
 
         Example::
 
             nesta = MUA ,[1, 2, 3]
@@ -645,55 +621,55 @@
 
     .. math:: G(e^{V_1},
               \\ldots,e^{V_J}) =  \\sum_m \\left( \\sum_{\\ell \\in C_m}
               y_\\ell^{\\mu_m}\\right)^{\\frac{\\mu}{\\mu_m}}
 
     where :math:`G` is the MEV generating function.
 
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     """
 
     termsForNests = []
     for m in nests:
         if availability is None:
-            sumdict = [exp(m[0] * V[i]) for i in m[1]]
+            sumdict = [expr.exp(m[0] * V[i]) for i in m[1]]
         else:
             sumdict = [
-                Elem(
-                    {0: 0.0, 1: exp(m[0] * V[i])},
-                    availability[i] != Numeric(0),
+                expr.Elem(
+                    {0: 0.0, 1: expr.exp(m[0] * V[i])},
+                    availability[i] != expr.Numeric(0),
                 )
                 for i in m[1]
             ]
-        theSum = bioMultSum(sumdict)
-        termsForNests.append(theSum ** 1.0 / m[0])
-    return bioMultSum(termsForNests)
+        theSum = expr.bioMultSum(sumdict)
+        termsForNests.append(theSum**1.0 / m[0])
+    return expr.bioMultSum(termsForNests)
 
 
 def getMevForNested(V, availability, nests):
     """Implements the derivatives of MEV generating function for the
     nested logit model
 
     :param V: dict of objects representing the utility functions of
         each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
                alternative, indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: A tuple containing as many items as nests.
         Each item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions.Expression representing
+        - an object of type biogeme.expressions.expr.Expression representing
           the nest parameter,
         - a list containing the list of identifiers of the alternatives
           belonging to the nest.
 
         Example::
 
             nesta = MUA ,[1, 2, 3]
@@ -708,142 +684,148 @@
               \\ldots,e^{V_J}) = e^{(\\mu_m-1)V_i}
               \\left(\\sum_{i=1}^{J_m} e^{\\mu_m V_i}\\right)^
               {\\frac{1}{\\mu_m}-1}
 
         where :math:`m` is the (only) nest containing alternative :math:`i`,
         and :math:`G` is the MEV generating function.
 
-    :rtype: dict(int:biogeme.expressions.Expression)
+    :rtype: dict(int:biogeme.expressions.expr.Expression)
 
     """
 
     logGi = {}
     for m in nests:
         if availability is None:
-            sumdict = [exp(m[0] * V[i]) for i in m[1]]
+            sumdict = [expr.exp(m[0] * V[i]) for i in m[1]]
         else:
             sumdict = [
-                Elem(
-                    {0: 0.0, 1: exp(m[0] * V[i])},
-                    availability[i] != Numeric(0),
+                expr.Elem(
+                    {0: 0.0, 1: expr.exp(m[0] * V[i])},
+                    availability[i] != expr.Numeric(0),
                 )
                 for i in m[1]
             ]
-        theSum = bioMultSum(sumdict)
+        theSum = expr.bioMultSum(sumdict)
         for i in m[1]:
-            logGi[i] = (m[0] - 1.0) * V[i] + (1.0 / m[0] - 1.0) * log(theSum)
+            logGi[i] = (m[0] - 1.0) * V[i] + (1.0 / m[0] - 1.0) * expr.log(
+                theSum
+            )
     return logGi
 
 
 def getMevForNestedMu(V, availability, nests, mu):
     """Implements the MEV generating function for the nested logit model,
     including the scale parameter
 
     :param V: dict of objects representing the utility functions of
         each alternative, indexed by numerical ids.
 
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability
         of each alternative, indexed
         by numerical ids. Must be consistent with V, or
         None. In this case, all alternatives are supposed to be
         always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: A tuple containing as many items as nests.
         Each item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions. Expression
+        - an object of type biogeme.expressions. expr.Expression
           representing the nest parameter,
         - a list containing the list of identifiers of the alternatives
           belonging to the nest.
 
         Example::
 
             nesta = MUA, [1, 2, 3]
            nestb = MUB, [4, 5, 6]
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param mu: scale parameter
-    :type mu: biogeme.expressions.Expression
+    :type mu: biogeme.expressions.expr.Expression
 
     :return: a dictionary mapping each alternative id with the function
 
         .. math:: \\frac{\\partial G}{\\partial y_i}(e^{V_1},\\ldots,e^{V_J}) =
                   \\mu e^{(\\mu_m-1)V_i} \\left(\\sum_{i=1}^{J_m}
                   e^{\\mu_m V_i}\\right)^{\\frac{\\mu}{\\mu_m}-1}
 
         where :math:`m` is the (only) nest containing alternative :math:`i`,
         and :math:`G` is the MEV generating function.
 
-    :rtype: dict(int:biogeme.expressions.Expression)
+    :rtype: dict(int:biogeme.expressions.expr.Expression)
 
     """
 
     logGi = {}
     for m in nests:
         if availability is None:
-            sumdict = [exp(m[0] * V[i]) for i in m[1]]
+            sumdict = [expr.exp(m[0] * V[i]) for i in m[1]]
         else:
             sumdict = [
-                Elem({0: 0.0, 1: exp(m[0] * V[i])}, availability[i] != 0)
+                expr.Elem(
+                    {0: 0.0, 1: expr.exp(m[0] * V[i])}, availability[i] != 0
+                )
                 for i in m[1]
             ]
-        theSum = bioMultSum(sumdict)
+        theSum = expr.bioMultSum(sumdict)
         for i in m[1]:
             logGi[i] = (
-                log(mu) + (m[0] - 1.0) * V[i] + (mu / m[0] - 1.0) * log(theSum)
+                expr.log(mu)
+                + (m[0] - 1.0) * V[i]
+                + (mu / m[0] - 1.0) * expr.log(theSum)
             )
     return logGi
 
 
 def nested(V, availability, nests, choice):
     """Implements the nested logit model as a MEV model.
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability
                          of each alternative, indexed by numerical
                          ids. Must be consistent with V, or None. In
                          this case, all alternatives are supposed to
                          be always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: A tuple containing as many items as nests. Each item is also
         a tuple containing two items:
 
-        - an object of type biogeme.expressions. Expression
+        - an object of type biogeme.expressions. expr.Expression
           representing the nest parameter,
         - a list containing the list of identifiers of the
           alternatives belonging to the nest.
 
         Example::
 
             nesta = MUA, [1, 2, 3]
             nestb = MUB, [4, 5, 6]
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :return: choice probability for the nested logit model,
              based on the derivatives of the MEV generating function produced
              by the function getMevForNested
 
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     :raise biogemeError: if the definition of the nests is invalid.
     """
 
     ok, message = checkValidityNestedLogit(V, nests)
     if not ok:
         raise excep.biogemeError(message)
@@ -855,49 +837,49 @@
 
 def lognested(V, availability, nests, choice):
     """Implements the log of a nested logit model as a MEV model.
 
     :param V: dict of objects representing the utility functions of
         each alternative, indexed by numerical ids.
 
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
         alternative (:math:`a_i` in the above formula), indexed
         by numerical ids. Must be consistent with V, or
         None. In this case, all alternatives are supposed to be
         always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: A tuple containing as many items as nests.
         Each item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions. Expression representing
+        - an object of type biogeme.expressions. expr.Expression representing
           the nest parameter,
         - a list containing the list of identifiers of the alternatives
           belonging to the nest.
 
         Example::
 
             nesta = MUA, [1, 2, 3]
             nestb = MUB, [4, 5, 6]
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :return: log of choice probability for the nested logit model,
              based on the derivatives of the MEV generating function produced
              by the function getMevForNested
 
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     :raise biogemeError: if the definition of the nests is invalid.
     """
     ok, message = checkValidityNestedLogit(V, nests)
     if not ok:
         raise excep.biogemeError(message)
     logGi = getMevForNested(V, availability, nests)
@@ -909,143 +891,143 @@
     """Implements the nested logit model as a MEV model, where mu is also
     a parameter, if the user wants to test different normalization
     schemes.
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
 
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
                alternative (:math:`a_i` in the above formula), indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: A tuple containing as many items as nests.
         Each item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions.Expression  representing
+        - an object of type biogeme.expressions.expr.Expression  representing
           the nest parameter,
         - a list containing the list of identifiers of the alternatives
           belonging to the nest.
 
         Example::
 
             nesta = MUA ,[1, 2, 3]
             nestb = MUB ,[4, 5, 6]
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :param mu: expression producing the value of the top-level scale parameter.
-    :type mu:  biogeme.expressions.Expression
+    :type mu:  biogeme.expressions.expr.Expression
 
     :return: the nested logit choice probability based on the following
              derivatives of the MEV generating function:
 
     .. math:: \\frac{\\partial G}{\\partial y_i}(e^{V_1},\\ldots,e^{V_J}) =
               \\mu e^{(\\mu_m-1)V_i} \\left(\\sum_{i=1}^{J_m}
               e^{\\mu_m V_i}\\right)^{\\frac{\\mu}{\\mu_m}-1}
 
     Where :math:`m` is the (only) nest containing alternative :math:`i`, and
     :math:`G` is the MEV generating function.
 
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     """
-    return exp(lognestedMevMu(V, availability, nests, choice, mu))
+    return expr.exp(lognestedMevMu(V, availability, nests, choice, mu))
 
 
 def lognestedMevMu(V, availability, nests, choice, mu):
     """Implements the log of the nested logit model as a MEV model, where
     mu is also a parameter, if the user wants to test different
     normalization schemes.
 
 
     :param V: dict of objects representing the utility functions of
         each alternative, indexed by numerical ids.
 
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
                alternative (:math:`a_i` in the above formula), indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: A tuple containing as many items as nests.
         Each item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions.Expression  representing
+        - an object of type biogeme.expressions.expr.Expression  representing
           the nest parameter,
         - a list containing the list of identifiers of the alternatives
           belonging to the nest.
 
         Example::
 
             nesta = MUA, [1, 2, 3]
             nestb = MUB, [4, 5, 6]
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :param mu: expression producing the value of the top-level scale parameter.
-    :type mu:  biogeme.expressions.Expression
+    :type mu:  biogeme.expressions.expr.Expression
 
     :return: the log of the nested logit choice probability based on the
         following derivatives of the MEV generating function:
 
         .. math:: \\frac{\\partial G}{\\partial y_i}(e^{V_1},\\ldots,e^{V_J}) =
                   \\mu e^{(\\mu_m-1)V_i} \\left(\\sum_{i=1}^{J_m}
                   e^{\\mu_m V_i}\\right)^{\\frac{\\mu}{\\mu_m}-1}
 
         where :math:`m` is the (only) nest containing alternative :math:`i`,
         and :math:`G` is the MEV generating function.
 
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     """
 
     logGi = getMevForNestedMu(V, availability, nests, mu)
     logP = logmev(V, logGi, availability, choice)
     return logP
 
 
 def cnl_avail(V, availability, nests, choice):
     """Same as cnl. Maintained for backward compatibility
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
                alternative, indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: a tuple containing as many items as nests. Each item is
         also a tuple containing two items
 
-        - an object of type biogeme.expressions.Expression  representing
+        - an object of type biogeme.expressions.expr.Expression  representing
           the nest parameter,
         - a dictionary mapping the alternative ids with the cross-nested
           parameters for the corresponding nest. If an alternative is
           missing in the dictionary, the corresponding alpha is set to zero.
 
         Example::
 
@@ -1065,45 +1047,45 @@
             nestb = MUB, alphaB
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :return: choice probability for the cross-nested logit model.
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
     """
     return cnl(V, availability, nests, choice)
 
 
 def cnl(V, availability, nests, choice):
     """Implements the cross-nested logit model as a MEV model.
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
                alternative, indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: a tuple containing as many items as nests.
         Each item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions. Expression
+        - an object of type biogeme.expressions. expr.Expression
           representing the nest parameter,
         - a dictionary mapping the alternative ids with the cross-nested
           parameters for the corresponding nest. If an alternative is
-          missing in the dictionaray, the corresponding alpha is set to zero.
+          missing in the dictionary, the corresponding alpha is set to zero.
 
         Example::
 
             alphaA = {1: alpha1a,
                       2: alpha2a,
                       3: alpha3a,
                       4: alpha4a,
@@ -1119,43 +1101,43 @@
             nestb = MUB, alphaB
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :return: choice probability for the cross-nested logit model.
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
 
     """
-    return exp(logcnl(V, availability, nests, choice))
+    return expr.exp(logcnl(V, availability, nests, choice))
 
 
 def logcnl_avail(V, availability, nests, choice):
     """Same as logcnl. Maintained for backward compatibility
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
                alternative, indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: a tuple containing as many items as nests.
         Each item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions. Expression
+        - an object of type biogeme.expressions. expr.Expression
           representing the nest parameter,
         - a dictionary mapping the alternative ids with the cross-nested
           parameters for the corresponding nest. If an alternative is
           missing in the dictionary, the corresponding alpha is set to zero.
 
         Example::
 
@@ -1175,42 +1157,42 @@
             nestb = MUB, alphaB
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :return: log of choice probability for the cross-nested logit model.
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
     """
     return logcnl(V, availability, nests, choice)
 
 
 def getMevForCrossNested(V, availability, nests):
     """Implements the MEV generating function for the cross nested logit
     model as a MEV model.
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int: biogeme.expressions.Expression)
+    :type V: dict(int: biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
         alternative, indexed
         by numerical ids. Must be consistent with V, or
         None. In this case, all alternatives are supposed to be
         always available.
 
-    :type availability: dict(int: biogeme.expressions.Expression)
+    :type availability: dict(int: biogeme.expressions.expr.Expression)
 
     :param nests: a tuple containing as many items as nests.
         Each item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions. Expression
+        - an object of type biogeme.expressions. expr.Expression
           representing the nest parameter,
         - a dictionary mapping the alternative ids with the cross-nested
           parameters for the corresponding nest. If an alternative is
           missing in the dictionary, the corresponding alpha is set to zero.
 
         Example::
 
@@ -1229,69 +1211,72 @@
             nesta = MUA, alphaA
             nestb = MUB, alphaB
             nests = nesta, nestb
 
     :type nests: tuple
 
     :return: log of the choice probability for the cross-nested logit model.
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     """
 
     Gi_terms = {}
     logGi = {}
     for i in V:
-        Gi_terms[i] = list()
+        Gi_terms[i] = []
     biosum = {}
     for m in nests:
         if availability is None:
-            biosum = bioMultSum(
-                [a ** (m[0]) * exp(m[0] * (V[i])) for i, a in m[1].items()]
+            biosum = expr.bioMultSum(
+                [
+                    a ** (m[0]) * expr.exp(m[0] * (V[i]))
+                    for i, a in m[1].items()
+                ]
             )
         else:
-            biosum = bioMultSum(
+            biosum = expr.bioMultSum(
                 [
-                    availability[i] * a ** (m[0]) * exp(m[0] * (V[i]))
+                    availability[i] * a ** (m[0]) * expr.exp(m[0] * (V[i]))
                     for i, a in m[1].items()
                 ]
             )
         for i, a in m[1].items():
             Gi_terms[i] += [
                 a ** (m[0])
-                * exp((m[0] - 1) * (V[i]))
+                * expr.exp((m[0] - 1) * (V[i]))
                 * biosum ** ((1.0 / m[0]) - 1.0)
             ]
     for k in V:
-        logGi[k] = log(bioMultSum(Gi_terms[k]))
+        logGi[k] = expr.log(expr.bioMultSum(Gi_terms[k]))
     return logGi
 
 
 def logcnl(V, availability, nests, choice):
     """Implements the log of the cross-nested logit model as a MEV model.
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
                alternative, indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: a tuple containing as many items as nests.
         Each item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions. Expression
+        - an object of type biogeme.expressions. expr.Expression
           representing the nest parameter,
         - a dictionary mapping the alternative ids with the cross-nested
           parameters for the corresponding nest. If an alternative is
-          missing in the dictionaray, the corresponding alpha is set to zero.
+          missing in the dictionary, the corresponding alpha is set to zero.
 
         Example::
 
             alphaA = {1: alpha1a,
                       2: alpha2a,
                       3: alpha3a,
                       4: alpha4a,
@@ -1307,18 +1292,18 @@
             nestb = MUB , alphaB
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :return: log of the choice probability for the cross-nested logit model.
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     :raise biogemeError: if the definition of the nests is invalid.
     """
     ok, message = checkValidityCNL(V, nests)
     if not ok:
         raise excep.biogemeError(message)
     if message != '':
@@ -1330,28 +1315,28 @@
 
 def cnlmu(V, availability, nests, choice, mu):
     """Implements the cross-nested logit model as a MEV model with
     the homogeneity parameters is explicitly involved
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
                alternative, indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: a tuple containing as many items as nests. Each
         item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions. Expression representing
+        - an object of type biogeme.expressions. expr.Expression representing
           the nest parameter,
         - a dictionary mapping the alternative ids with the cross-nested
           parameters for the corresponding nest. If an alternative is
           missing in the dictionary, the corresponding alpha is set to zero.
 
         Example::
 
@@ -1371,46 +1356,46 @@
             nestb = MUB, alphaB
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :param mu: Homogeneity parameter :math:`\\mu`.
-    :type mu: biogeme.expressions.Expression
+    :type mu: biogeme.expressions.expr.Expression
 
     :return: choice probability for the cross-nested logit model.
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
     """
-    return exp(logcnlmu(V, availability, nests, choice, mu))
+    return expr.exp(logcnlmu(V, availability, nests, choice, mu))
 
 
 def getMevForCrossNestedMu(V, availability, nests, mu):
     """Implements the MEV generating function for the cross-nested logit
     model as a MEV model with the homogeneity parameters is explicitly
     involved.
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
                alternative, indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: a tuple containing as many items as nests.
         Each item is also a tuple containing two items:
 
-        - an object of type biogeme.expressions. Expression representing
+        - an object of type biogeme.expressions. expr.Expression representing
           the nest parameter,
         - a dictionary mapping the alternative ids with the cross-nested
           parameters for the corresponding nest. If an alternative is
           missing in the dictionary, the corresponding alpha is set to zero.
 
         Example::
 
@@ -1429,72 +1414,74 @@
             nesta = MUA, alphaA
             nestb = MUB, alphaB
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param mu: Homogeneity parameter :math:`\\mu`.
-    :type mu: biogeme.expressions.Expression
+    :type mu: biogeme.expressions.expr.Expression
 
     :return: log of the choice probability for the cross-nested logit model.
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     """
     Gi_terms = {}
     logGi = {}
     for i in V:
-        Gi_terms[i] = list()
+        Gi_terms[i] = []
     biosum = {}
     for m in nests:
         if availability is None:
-            biosum = bioMultSum(
+            biosum = expr.bioMultSum(
                 [
-                    a ** (m[0] / mu) * exp(m[0] * (V[i]))
+                    a ** (m[0] / mu) * expr.exp(m[0] * (V[i]))
                     for i, a in m[1].items()
                 ]
             )
         else:
-            biosum = bioMultSum(
+            biosum = expr.bioMultSum(
                 [
-                    availability[i] * a ** (m[0] / mu) * exp(m[0] * (V[i]))
+                    availability[i]
+                    * a ** (m[0] / mu)
+                    * expr.exp(m[0] * (V[i]))
                     for i, a in m[1].items()
                 ]
             )
         for i, a in m[1].items():
             Gi_terms[i] += [
                 a ** (m[0] / mu)
-                * exp((m[0] - 1) * (V[i]))
+                * expr.exp((m[0] - 1) * (V[i]))
                 * biosum ** ((mu / m[0]) - 1.0)
             ]
     for k in V:
-        logGi[k] = log(mu * bioMultSum(Gi_terms[k]))
+        logGi[k] = expr.log(mu * expr.bioMultSum(Gi_terms[k]))
     return logGi
 
 
 def logcnlmu(V, availability, nests, choice, mu):
     """Implements the log of the cross-nested logit model as a MEV model
     with the homogeneity parameters is explicitly involved.
 
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param availability: dict of objects representing the availability of each
                alternative, indexed
                by numerical ids. Must be consistent with V, or
                None. In this case, all alternatives are supposed to be
                always available.
 
-    :type availability: dict(int:biogeme.expressions.Expression)
+    :type availability: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: a tuple containing as many items as nests. Each item is
         also a tuple containing two items
 
-        - an object of type biogeme.expressions. Expression representing
+        - an object of type biogeme.expressions. expr.Expression representing
           the nest parameter,
         - a dictionary mapping the alternative ids with the cross-nested
           parameters for the corresponding nest. If an alternative is
           missing in the dictionary, the corresponding alpha is set to zero.
 
         Example::
 
@@ -1514,21 +1501,21 @@
             nestb = MUB , alphaB
             nests = nesta, nestb
 
     :type nests: tuple
 
     :param choice: id of the alternative for which the probability must be
               calculated.
-    :type choice: biogeme.expressions.Expression
+    :type choice: biogeme.expressions.expr.Expression
 
     :param mu: Homogeneity parameter :math:`\\mu`.
-    :type mu: biogeme.expressions.Expression
+    :type mu: biogeme.expressions.expr.Expression
 
     :return: log of the choice probability for the cross-nested logit model.
-    :rtype: biogeme.expressions.Expression
+    :rtype: biogeme.expressions.expr.Expression
 
     :raise biogemeError: if the definition of the nests is invalid.
 
     """
     ok, message = checkValidityCNL(V, nests)
     if not ok:
         raise excep.biogemeError(message)
@@ -1539,20 +1526,20 @@
 
 def checkValidityNestedLogit(V, nests):
     """Verifies if the nested logit model is indeed based on a partition
     of the choice set.
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
     :param nests: A tuple containing as many items as nests. Each item is also
         a tuple containing two items:
 
-        - an object of type biogeme.expressions. Expression representing the
-          nest parameter,
+        - an object of type biogeme.expressions. expr.Expression
+          representing the nest parameter,
         - a list containing the list of identifiers of the alternatives
           belonging to the nest.
 
         Example::
 
           nesta = MUA, [1, 2, 3]
           nestb = MUB, [4, 5, 6]
@@ -1560,14 +1547,15 @@
 
     :type nests: tuple
 
 
     :return: a tuple ok, message, where the message explains the
              problem is the nested structure is not OK.
     :rtype: tuple(bool, str)
+
     """
 
     ok = True
     message = ''
 
     fullChoiceSet = {i for i, v in V.items()}
     unionOfNests = set.union(*[set(n[1]) for n in nests])
@@ -1605,20 +1593,20 @@
 
 
 def checkValidityCNL(V, nests):
     """Verifies if the cross-nested logit specifciation is valid
 
     :param V: dict of objects representing the utility functions of
               each alternative, indexed by numerical ids.
-    :type V: dict(int:biogeme.expressions.Expression)
+    :type V: dict(int:biogeme.expressions.expr.Expression)
 
     :param nests: a tuple containing as many items as nests.
         Each item is also a tuple containing two items
 
-        - an object of type biogeme.expressions.Expression  representing
+        - an object of type biogeme.expressions.expr.Expression  representing
           the nest parameter,
         - a dictionary mapping the alternative ids with the cross-nested
           parameters for the corresponding nest. If an alternative is
           missing in the dictionary, the corresponding alpha is set to zero.
 
         Example::
 
@@ -1644,29 +1632,29 @@
              problem is the nested structure is not OK.
     :rtype: tuple(bool, str)
     """
 
     ok = True
     message = ''
 
-    alt = {i: list() for i in V}
+    alt = {i: [] for i in V}
     number = 0
     for mu, alpha in nests:
         for i, a in alpha.items():
             if a != 0.0:
                 alt[i].append(a)
         number += 1
 
     problems_zero = []
     problems_one = []
     for i, ell in alt.items():
         if not ell:
             problems_zero.append(i)
             ok = False
-        if len(ell) == 1 and isinstance(ell[0], Expression):
+        if len(ell) == 1 and isinstance(ell[0], expr.Expression):
             problems_one.append(i)
 
     if problems_zero:
         message += f'Alternative(s) not in any nest: {problems_zero}'
 
     if problems_one:
         message += (
```

### Comparing `biogeme-3.2.8/biogeme/optimization.py` & `biogeme-3.2.9/biogeme/optimization.py`

 * *Files 0% similar despite different names*

```diff
@@ -25,15 +25,15 @@
 
 
 logger = msg.bioMessage()
 
 
 def scipy(fct, initBetas, bounds, parameters=None):
 
-    """Optimization interface for Biogeme, based on the scipy 
+    """Optimization interface for Biogeme, based on the scipy
     minimize function.
 
     :param fct: object to calculate the objective function and its derivatives.
     :type fct: algorithms.functionToMinimize
 
     :param initBetas: initial value of the beta parameters
     :type initBetas: numpy.array
@@ -427,15 +427,14 @@
 
         - x is the solution generated by the algorithm,
         - messages is a dictionary describing information about the lagorithm
 
     :rtype: numpay.array, dict(str:object)
 
     """
-
     tol = np.finfo(np.float64).eps ** 0.3333
     steptol = 1.0e-5
     cgtol = np.finfo(np.float64).eps ** 0.3333
     maxiter = 1000
     radius = 1.0
     eta1 = 0.1
     eta2 = 0.9
```

### Comparing `biogeme-3.2.8/biogeme/results.py` & `biogeme-3.2.9/biogeme/results.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,22 +13,29 @@
 # pylint: disable=too-many-branches
 # pylint: disable=too-many-statements, too-few-public-methods
 # pylint: disable=too-many-lines
 #
 
 import pickle
 import datetime
+from collections import namedtuple
+import urllib.request as urlr
 import pandas as pd
 import numpy as np
 from scipy import linalg
 from scipy import stats
 import biogeme.version as bv
 import biogeme.filenames as bf
 import biogeme.exceptions as excep
 import biogeme.messaging as msg
+from biogeme import tools
+
+logger = msg.bioMessage()
+
+GeneralStatistic = namedtuple('GeneralStatistic', 'value format')
 
 
 def calcPValue(t):
     """Calculates the p value of a parameter from its t-statistic.
 
     The formula is
 
@@ -59,39 +66,39 @@
         :type name: string
         :param value: value of the parameter.
         :type value: float
         :param bounds: tuple (l,b) with lower and upper bounds
         :type bounds: float,float
         """
 
-        self.name = name #: Name of the parameter
+        self.name = name  #: Name of the parameter
 
-        self.value = value #: Current value
+        self.value = value  #: Current value
 
-        self.lb = bounds[0] #: Lower bound
+        self.lb = bounds[0]  #: Lower bound
 
-        self.ub = bounds[1] #: Upper bound
+        self.ub = bounds[1]  #: Upper bound
 
-        self.stdErr = None #: Standard error
+        self.stdErr = None  #: Standard error
 
-        self.tTest = None #: t-test
+        self.tTest = None  #: t-test
 
-        self.pValue = None #: p-value
+        self.pValue = None  #: p-value
 
-        self.robust_stdErr = None #: Robust standard error
+        self.robust_stdErr = None  #: Robust standard error
 
-        self.robust_tTest = None #: Robust t-test
+        self.robust_tTest = None  #: Robust t-test
 
-        self.robust_pValue = None #: Robust p-value
+        self.robust_pValue = None  #: Robust p-value
 
-        self.bootstrap_stdErr = None #: Std error calculated from bootstrap
+        self.bootstrap_stdErr = None  #: Std error calculated from bootstrap
 
-        self.bootstrap_tTest = None #: t-test calculated from bootstrap
+        self.bootstrap_tTest = None  #: t-test calculated from bootstrap
 
-        self.bootstrap_pValue = None #: p-value calculated from bootstrap
+        self.bootstrap_pValue = None  #: p-value calculated from bootstrap
 
     def isBoundActive(self, threshold=1.0e-6):
         """Check if one of the two bound is 'numerically' active. Being
         numerically active means that the distance between the value of
         the parameter and one of its bounds is below the threshold.
 
         :param threshold: distance below which the bound is considered to be
@@ -203,50 +210,51 @@
             - B is the number of bootstrap iterations
             - K is the number of parameters to estimate
 
             Default: None.
         :type bootstrap: numpy.array
         """
 
+        self.modelName = theModel.modelName  #: Name of the model
 
-        self.modelName = theModel.modelName #: Name of the model
-
-        self.userNotes = theModel.userNotes #: User notes
+        self.userNotes = theModel.userNotes  #: User notes
 
-        self.nparam = len(betaValues) #: Number of parameters
+        self.nparam = len(betaValues)  #: Number of parameters
 
-        self.betaValues = betaValues #: Values of the parameters
+        self.betaValues = betaValues  #: Values of the parameters
 
-        self.betaNames = theModel.freeBetaNames #: Names of the parameters
+        self.betaNames = (
+            theModel.id_manager.free_betas.names
+        )  #: Names of the parameters
 
         self.initLogLike = theModel.initLogLike
         """Value of the likelihood function with the initial value of the
         parameters
         """
 
         self.nullLogLike = theModel.nullLogLike
         """Value of the likelihood function with equal probability model
         """
 
-        self.betas = list() #: List of objects of type results.beta
+        self.betas = []  #: List of objects of type results.beta
 
         for b, n in zip(betaValues, self.betaNames):
             bounds = theModel.getBoundsOnBeta(n)
             self.betas.append(beta(n, b, bounds))
 
-        self.logLike = fgHb[0] #: Value of the loglikelihood function
+        self.logLike = fgHb[0]  #: Value of the loglikelihood function
 
-        self.g = fgHb[1] #: Value of the gradient of the loglikelihood function
+        self.g = fgHb[1]  #: Value of the gradient of the loglik. function
 
-        self.H = fgHb[2] #: Value of the hessian of the loglikelihood function
+        self.H = fgHb[2]  #: Value of the hessian of the loglik. function
 
         self.bhhh = fgHb[3]
         """Value of the BHHH matrix of the loglikelihood function"""
 
-        self.dataname = theModel.database.name #: Name of the database
+        self.dataname = theModel.database.name  #: Name of the database
 
         self.sampleSize = theModel.database.getSampleSize()
         """Sample size (number of individuals if panel data)"""
 
         self.numberOfObservations = theModel.database.getNumberOfObservations()
         """Number of observations"""
 
@@ -270,64 +278,71 @@
 
         self.optimizationMessages = theModel.optimizationMessages
         """Diagnostics given by the optimization algorithm"""
 
         self.numberOfThreads = theModel.numberOfThreads
         """Number of threads used for parallel computing"""
 
-        self.htmlFileName = None #: Name of the HTML output file
+        self.htmlFileName = None  #: Name of the HTML output file
 
-        self.F12FileName = None #: Name of the F12 output file
+        self.F12FileName = None  #: Name of the F12 output file
 
-        self.latexFileName = None #: Name of the LaTeX output file
+        self.latexFileName = None  #: Name of the LaTeX output file
 
-        self.pickleFileName = None #: Name of the pickle outpt file
+        self.pickleFileName = None  #: Name of the pickle outpt file
 
         self.bootstrap = bootstrap
         """output of the bootstrapping. numpy array, of size B x K,
         where
 
         - B is the number of bootstrap iterations
         - K is the number of parameters to estimate
         """
 
         if bootstrap is not None:
             self.bootstrap_time = theModel.bootstrap_time
             """ Time needed to perform the bootstrap"""
 
-        self.secondOrderTable = None #: Second order statistics
-
+        self.secondOrderTable = None  #: Second order statistics
 
 
 class bioResults:
     """Class managing the estimation results"""
 
     def __init__(self, theRawResults=None, pickleFile=None):
         """Constructor
 
         :param theRawResults: object with the results of the estimation.
             Default: None.
         :type theRawResults: biogeme.results.rawResults
         :param pickleFile: name of the file containing the raw results in
-            pickle format. Default: None.
+            pickle format. It can be a URL. Default: None.
         :type pickleFile: string
 
         :raise biogeme.exceptions.biogemeError: if no data is provided.
         """
 
-        self.logger = msg.bioMessage()
-
         if theRawResults is not None:
             self.data = theRawResults
             """Object of type :class:`biogeme.results.rawResults` contaning the
             raw estimation results.
             """
         elif pickleFile is not None:
-            with open(pickleFile, 'rb') as f:
-                self.data = pickle.load(f)
+            try:
+                with urlr.urlopen(pickleFile) as p:
+                    self.data = pickle.load(p)
+            except Exception:
+                pass
+            try:
+                with open(pickleFile, 'rb') as f:
+                    self.data = pickle.load(f)
+            except FileNotFoundError as e:
+                error_msg = f'File {pickleFile} not found'
+                raise excep.biogemeError(error_msg) from e
+
         else:
             raise excep.biogemeError('No data provided.')
 
         self._calculateStats()
 
     def writePickle(self):
         """Dump the data in a file in pickle format.
@@ -337,17 +352,15 @@
         """
         self.data.pickleFileName = bf.getNewFileName(
             self.data.modelName, 'pickle'
         )
         with open(self.data.pickleFileName, 'wb') as f:
             pickle.dump(self.data, f)
 
-        self.logger.general(
-            f'Results saved in file {self.data.pickleFileName}'
-        )
+        logger.general(f'Results saved in file {self.data.pickleFileName}')
         return self.data.pickleFileName
 
     def _calculateTest(self, i, j, matrix):
         """Calculates a t-test comparing two coefficients
 
         Args:
            i: index of first coefficient \f$\\beta_i\f$.
@@ -518,15 +531,15 @@
                         self.data.bootstrap_varCovar.dot(diagInv)
                     )
                 else:
                     self.data.bootstrap_correlation = np.full_like(
                         self.data.bootstrap_varCovar, np.finfo(float).max
                     )
 
-            self.data.secondOrderTable = dict()
+            self.data.secondOrderTable = {}
             for i in range(self.data.nparam):
                 for j in range(i):
                     t = self._calculateTest(i, j, self.data.varCovar)
                     p = calcPValue(t)
                     trob = self._calculateTest(i, j, self.data.robust_varCovar)
                     prob = calcPValue(trob)
                     if self.data.bootstrap is not None:
@@ -666,17 +679,20 @@
             f'biogeme {bv.getVersion()} '
             f'[{bv.versionDate}]\n'
         )
 
         h += bv.getLaTeX()
         return h
 
-    def getLaTeX(self):
+    def getLaTeX(self, onlyRobust=True):
         """Get the results coded in LaTeX
 
+        :param onlyRobust: if True, only the robust statistics are included
+        :type onlyRobust: bool
+
         :return: LaTeX code
         :rtype: string
         """
         now = datetime.datetime.now()
         h = self._getLaTeXHeader()
         if self.data.latexFileName is not None:
             h += '\n%% File ' + self.data.latexFileName + '\n'
@@ -703,87 +719,133 @@
                 h += f'{k} & \\verb${v:.7g}$ \\\\\n'
             else:
                 h += f'{k} & \\verb${v}$ \\\\\n'
         h += '\\end{tabular}\n'
 
         h += '\n%%Parameter estimates\n'
         h += '\\section{Parameter estimates}\n'
-        table = self.getEstimatedParameters()
+        table = self.getEstimatedParameters(onlyRobust)
 
         def formatting(x):
             """Defines the formatting for the to_latex function of pandas"""
             res = f'{x:.3g}'
             if '.' in res:
                 return res
 
             return f'{res}.0'
 
-        h += table.to_latex(float_format=formatting)
+        ## Need to check for old versions of Pandas.
+        try:
+            h += table.style.format(formatting).to_latex()
+        except AttributeError:
+            h += table.to_latex(float_format=formatting)
 
         h += '\n%%Correlation\n'
         h += '\\section{Correlation}\n'
         table = self.getCorrelationResults()
-        h += table.to_latex(float_format=formatting)
+        ## Need to check for old versions of Pandas.
+        try:
+            h += table.style.format(formatting).to_latex()
+        except AttributeError:
+            h += table.to_latex(float_format=formatting)
+
         return h
 
     def getGeneralStatistics(self):
         """Format the results in a dict
 
         :return: dict with the results. The keys describe each
-                 content. Each element is a tuple, with the value and its
-                 preferred formatting.
+                 content. Each element is a GeneralStatistic tuple,
+                 with the value and its preferred formatting.
 
         Example::
 
                      'Init log likelihood': (-115.30029248549191, '.7g')
 
         :rtype: dict(string:float,string)
+
         """
         d = {}
-        d['Number of estimated parameters'] = self.data.nparam, ''
+        d['Number of estimated parameters'] = GeneralStatistic(
+            value=self.data.nparam, format=''
+        )
         nf = self.numberOfFreeParameters()
         if nf != self.data.nparam:
-            d['Number of free parameters'] = nf, ''
-        d['Sample size'] = self.data.sampleSize, ''
+            d['Number of free parameters'] = GeneralStatistic(
+                value=nf, format=''
+            )
+        d['Sample size'] = GeneralStatistic(
+            value=self.data.sampleSize, format=''
+        )
         if self.data.sampleSize != self.data.numberOfObservations:
-            d['Observations'] = self.data.numberOfObservations, ''
-        d['Excluded observations'] = self.data.excludedData, ''
+            d['Observations'] = GeneralStatistic(
+                value=self.data.numberOfObservations, format=''
+            )
+        d['Excluded observations'] = GeneralStatistic(
+            value=self.data.excludedData, format=''
+        )
         if self.data.nullLogLike is not None:
-            d['Null log likelihood'] = self.data.nullLogLike, '.7g'
-        d['Init log likelihood'] = self.data.initLogLike, '.7g'
-        d['Final log likelihood'] = self.data.logLike, '.7g'
+            d['Null log likelihood'] = GeneralStatistic(
+                value=self.data.nullLogLike, format='.7g'
+            )
+        d['Init log likelihood'] = GeneralStatistic(
+            value=self.data.initLogLike, format='.7g'
+        )
+        d['Final log likelihood'] = GeneralStatistic(
+            value=self.data.logLike, format='.7g'
+        )
         if self.data.nullLogLike is not None:
-            d['Likelihood ratio test for the null model'] = (
-                self.data.likelihoodRatioTestNull,
-                '.7g',
-            )
-            d['Rho-square for the null model'] = self.data.rhoSquareNull, '.3g'
-            d['Rho-square-bar for the null model'] = (
-                self.data.rhoBarSquareNull,
-                '.3g',
-            )
-        d['Likelihood ratio test for the init. model'] = (
-            self.data.likelihoodRatioTest,
-            '.7g',
-        )
-        d['Rho-square for the init. model'] = self.data.rhoSquare, '.3g'
-        d['Rho-square-bar for the init. model'] = self.data.rhoBarSquare, '.3g'
-        d['Akaike Information Criterion'] = self.data.akaike, '.7g'
-        d['Bayesian Information Criterion'] = self.data.bayesian, '.7g'
-        d['Final gradient norm'] = self.data.gradientNorm, '.4E'
+            d['Likelihood ratio test for the null model'] = GeneralStatistic(
+                value=self.data.likelihoodRatioTestNull,
+                format='.7g',
+            )
+            d['Rho-square for the null model'] = GeneralStatistic(
+                value=self.data.rhoSquareNull, format='.3g'
+            )
+            d['Rho-square-bar for the null model'] = GeneralStatistic(
+                value=self.data.rhoBarSquareNull,
+                format='.3g',
+            )
+        d['Likelihood ratio test for the init. model'] = GeneralStatistic(
+            value=self.data.likelihoodRatioTest,
+            format='.7g',
+        )
+        d['Rho-square for the init. model'] = GeneralStatistic(
+            value=self.data.rhoSquare, format='.3g'
+        )
+        d['Rho-square-bar for the init. model'] = GeneralStatistic(
+            value=self.data.rhoBarSquare, format='.3g'
+        )
+        d['Akaike Information Criterion'] = GeneralStatistic(
+            value=self.data.akaike, format='.7g'
+        )
+        d['Bayesian Information Criterion'] = GeneralStatistic(
+            value=self.data.bayesian, format='.7g'
+        )
+        d['Final gradient norm'] = GeneralStatistic(
+            value=self.data.gradientNorm, format='.4E'
+        )
         if self.data.monteCarlo:
-            d['Number of draws'] = self.data.numberOfDraws, ''
-            d['Draws generation time'] = self.data.drawsProcessingTime, ''
-            d['Types of draws'] = (
-                [f'{i}: {k}' for i, k in self.data.typesOfDraws.items()],
-                '',
+            d['Number of draws'] = GeneralStatistic(
+                value=self.data.numberOfDraws, format=''
+            )
+            d['Draws generation time'] = GeneralStatistic(
+                value=self.data.drawsProcessingTime, format=''
+            )
+            d['Types of draws'] = GeneralStatistic(
+                value=[f'{i}: {k}' for i, k in self.data.typesOfDraws.items()],
+                format='',
             )
         if self.data.bootstrap is not None:
-            d['Bootstrapping time'] = self.data.bootstrap_time, ''
-        d['Nbr of threads'] = self.data.numberOfThreads, ''
+            d['Bootstrapping time'] = GeneralStatistic(
+                value=self.data.bootstrap_time, format=''
+            )
+        d['Nbr of threads'] = GeneralStatistic(
+            value=self.data.numberOfThreads, format=''
+        )
         return d
 
     def printGeneralStatistics(self):
         """Print the general statistics of the estimation.
 
         :return: general statistics
 
@@ -814,78 +876,119 @@
 
     def numberOfFreeParameters(self):
         """This is the number of estimated parameters, minus those that are at
         their bounds
         """
         return sum([not b.isBoundActive() for b in self.data.betas])
 
-    def getEstimatedParameters(self):
+    def getEstimatedParameters(self, onlyRobust=True):
         """Gather the estimated parameters and the corresponding statistics in
         a Pandas dataframe.
 
+        :param onlyRobust: if True, only the robust statistics are included
+        :type onlyRobust: bool
+
         :return: Pandas dataframe with the results
         :rtype: pandas.DataFrame
 
         """
         # There should be a more 'Pythonic' way to do this.
         anyActiveBound = False
         for b in self.data.betas:
             if b.isBoundActive():
                 anyActiveBound = True
         if anyActiveBound:
-            columns = [
-                'Value',
-                'Active bound',
-                'Std err',
-                't-test',
-                'p-value',
-                'Rob. Std err',
-                'Rob. t-test',
-                'Rob. p-value',
-            ]
+            if onlyRobust:
+                columns = [
+                    'Value',
+                    'Active bound',
+                    'Rob. Std err',
+                    'Rob. t-test',
+                    'Rob. p-value',
+                ]
+            else:
+                columns = [
+                    'Value',
+                    'Active bound',
+                    'Std err',
+                    't-test',
+                    'p-value',
+                    'Rob. Std err',
+                    'Rob. t-test',
+                    'Rob. p-value',
+                ]
         else:
-            columns = [
-                'Value',
-                'Std err',
-                't-test',
-                'p-value',
-                'Rob. Std err',
-                'Rob. t-test',
-                'Rob. p-value',
-            ]
-        if self.data.bootstrap is not None:
+            if onlyRobust:
+                columns = [
+                    'Value',
+                    'Rob. Std err',
+                    'Rob. t-test',
+                    'Rob. p-value',
+                ]
+            else:
+                columns = [
+                    'Value',
+                    'Std err',
+                    't-test',
+                    'p-value',
+                    'Rob. Std err',
+                    'Rob. t-test',
+                    'Rob. p-value',
+                ]
+        if self.data.bootstrap is not None and not onlyRobust:
             columns += [
                 f'Bootstrap[{len(self.data.bootstrap)}] Std err',
                 'Bootstrap t-test',
                 'Bootstrap p-value',
             ]
         table = pd.DataFrame(columns=columns)
         for b in self.data.betas:
             if anyActiveBound:
-                arow = {
-                    'Value': b.value,
-                    'Active bound': {True: 1.0, False: 0.0}[b.isBoundActive()],
-                    'Std err': b.stdErr,
-                    't-test': b.tTest,
-                    'p-value': b.pValue,
-                    'Rob. Std err': b.robust_stdErr,
-                    'Rob. t-test': b.robust_tTest,
-                    'Rob. p-value': b.robust_pValue,
-                }
+                if onlyRobust:
+                    arow = {
+                        'Value': b.value,
+                        'Active bound': {True: 1.0, False: 0.0}[
+                            b.isBoundActive()
+                        ],
+                        'Rob. Std err': b.robust_stdErr,
+                        'Rob. t-test': b.robust_tTest,
+                        'Rob. p-value': b.robust_pValue,
+                    }
+                else:
+                    arow = {
+                        'Value': b.value,
+                        'Active bound': {True: 1.0, False: 0.0}[
+                            b.isBoundActive()
+                        ],
+                        'Std err': b.stdErr,
+                        't-test': b.tTest,
+                        'p-value': b.pValue,
+                        'Rob. Std err': b.robust_stdErr,
+                        'Rob. t-test': b.robust_tTest,
+                        'Rob. p-value': b.robust_pValue,
+                    }
             else:
-                arow = {
-                    'Value': b.value,
-                    'Std err': b.stdErr,
-                    't-test': b.tTest,
-                    'p-value': b.pValue,
-                    'Rob. Std err': b.robust_stdErr,
-                    'Rob. t-test': b.robust_tTest,
-                    'Rob. p-value': b.robust_pValue,
-                }
-            if self.data.bootstrap is not None:
+                if onlyRobust:
+                    arow = {
+                        'Value': b.value,
+                        'Rob. Std err': b.robust_stdErr,
+                        'Rob. t-test': b.robust_tTest,
+                        'Rob. p-value': b.robust_pValue,
+                    }
+                else:
+                    arow = {
+                        'Value': b.value,
+                        'Std err': b.stdErr,
+                        't-test': b.tTest,
+                        'p-value': b.pValue,
+                        'Rob. Std err': b.robust_stdErr,
+                        'Rob. t-test': b.robust_tTest,
+                        'Rob. p-value': b.robust_pValue,
+                    }
+            if self.data.bootstrap is not None and not onlyRobust:
                 arow[
                     f'Bootstrap[{len(self.data.bootstrap)}] Std err'
                 ] = b.bootstrap_stdErr
                 arow['Bootstrap t-test'] = b.bootstrap_tTest
                 arow['Bootstrap p-value'] = b.bootstrap_pValue
 
             table.loc[b.name] = pd.Series(arow)
@@ -904,17 +1007,15 @@
         """
         if subset is not None:
             unknown = []
             for p in subset:
                 if p not in self.data.betaNames:
                     unknown.append(p)
             if unknown:
-                self.logger.warning(
-                    f'Unknown parameters are ignored: {unknown}'
-                )
+                logger.warning(f'Unknown parameters are ignored: {unknown}')
         columns = [
             'Covariance',
             'Correlation',
             't-test',
             'p-value',
             'Rob. cov.',
             'Rob. corr.',
@@ -1043,23 +1144,23 @@
             n = name.split('-')
             h += f'<tr class=biostyle><td>{n[0]}</td><td>{n[1]}</td>'
             for k, v in values.items():
                 h += f'<td>{v:.3g}</td>'
             h += '</tr>\n'
         h += '</table>\n'
 
-        h += '<p>Smallest eigenvalue: {:.6g}</p>\n'.format(
-            self.data.smallestEigenValue
-        )
-        h += '<p>Largest eigenvalue: {:.6g}</p>\n'.format(
-            self.data.largestEigenValue
+        h += (
+            f'<p>Smallest eigenvalue: '
+            f'{self.data.smallestEigenValue:.6g}</p>\n'
         )
-        h += '<p>Condition number: {:.6g}</p>\n'.format(
-            self.data.conditionNumber
+        h += (
+            f'<p>Largest eigenvalue: '
+            f'{self.data.largestEigenValue:.6g}</p>\n'
         )
+        h += f'<p>Condition number: ' f'{self.data.conditionNumber:.6g}</p>\n'
         if np.abs(self.data.smallestEigenValue) <= 1.0e-5:
             h += (
                 '<p>The second derivatives matrix is close to singularity. '
                 'Variables involved:'
             )
             h += '<table>'
             for i, ev in enumerate(self.data.smallestEigenVector):
@@ -1085,15 +1186,15 @@
         :return: dict containing the values, where the keys are the names.
         :rtype: dict(string:float)
 
 
         :raise biogeme.exceptions.biogemeError: if some requested parameters
             are not available.
         """
-        values = dict()
+        values = {}
         if myBetas is None:
             myBetas = self.data.betaNames
         for b in myBetas:
             try:
                 index = self.data.betaNames.index(b)
                 values[b] = self.data.betas[index].value
             except KeyError as e:
@@ -1154,22 +1255,22 @@
         return vc
 
     def writeHtml(self):
         """Write the results in an HTML file."""
         self.data.htmlFileName = bf.getNewFileName(self.data.modelName, 'html')
         with open(self.data.htmlFileName, 'w') as f:
             f.write(self.getHtml())
-        self.logger.general(f'Results saved in file {self.data.htmlFileName}')
+        logger.general(f'Results saved in file {self.data.htmlFileName}')
 
     def writeLaTeX(self):
         """Write the results in a LaTeX file."""
         self.data.latexFileName = bf.getNewFileName(self.data.modelName, 'tex')
         with open(self.data.latexFileName, 'w') as f:
             f.write(self.getLaTeX())
-        self.logger.general(f'Results saved in file {self.data.latexFileName}')
+        logger.general(f'Results saved in file {self.data.latexFileName}')
 
     def _getHtmlHeader(self):
         """Prepare the header for the HTML file, containing comments and the
         version of Biogeme.
 
         :return: string containing the header.
         :rtype: str
@@ -1322,15 +1423,15 @@
         #      characters of label in R
         #  characters 16-17, " F" (this indicates whether or not the
         #      coefficient is constrained)
         #  characters 19-38, coefficient value   20 chars
         #  characters 39-58, standard error      20 chars
 
         mystats = self.getGeneralStatistics()
-        table = self.getEstimatedParameters()
+        table = self.getEstimatedParameters(onlyRobust=False)
         coefNames = list(table.index.values)
         for name in coefNames:
             values = table.loc[name]
             results += '   0 '
             results += f'{name[:10]: >10}'
             if 'Active bound' in values:
                 if values['Active bound'] == 1:
@@ -1410,8 +1511,90 @@
         return results
 
     def writeF12(self, robustStdErr=True):
         """Write the results in F12 file."""
         self.data.F12FileName = bf.getNewFileName(self.data.modelName, 'F12')
         with open(self.data.F12FileName, 'w') as f:
             f.write(self.getF12(robustStdErr))
-        self.logger.general(f'Results saved in file {self.data.F12FileName}')
+        logger.general(f'Results saved in file {self.data.F12FileName}')
+
+    def likelihood_ratio_test(self, other_model, significance_level=0.05):
+        """This function performs a likelihood ratio test between a restricted
+        and an unrestricted model. The "self" model can be either the
+        restricted or the unrestricted.
+
+        :param other_model: other model to perform the test.
+        :type other_model: biogeme.results.bioResults
+
+        :param significance_level: level of significance of the test. Default: 0.05
+        :type significance_level: float
+
+        :return: a tuple containing:
+
+                  - a message with the outcome of the test
+                  - the statistic, that is minus two times the difference
+                    between the loglikelihood  of the two models
+                  - the threshold of the chi square distribution.
+
+        :rtype: LRTuple(str, float, float)
+
+        """
+        LR = self.data.logLike
+        LU = other_model.data.logLike
+        KR = self.data.nparam
+        KU = other_model.data.nparam
+        return tools.likelihood_ratio_test(
+            (LU, KU), (LR, KR), significance_level
+        )
+
+
+def compileEstimationResults(
+    dict_of_results,
+    statistics=(
+        'Number of estimated parameters',
+        'Sample size',
+        'Final log likelihood',
+        'Akaike Information Criterion',
+        'Bayesian Information Criterion',
+    ),
+    include_parameter_estimates=True,
+):
+
+    """Compile estimation results into a common table
+
+    :param dict_of_results: dictionary where the keys are the names of
+        the models, and the values are either the estimation results,
+        or the name of the pickle file where to find them.
+    :type dict_of_results: dict(str:bioResults) or dict(str:str)
+
+    :param statistics: list of statistics to include in the summary
+        table
+    :type statistics: tuple(str)
+
+    :param include_parameter_estimates: if True, the parameter
+        estimates are included.
+    :type include_parameter_estimates: bool
+
+    :return: pandas dataframe with the requested results.
+    :rtype: pandas.DataFrame
+
+    """
+    df = pd.DataFrame(columns=dict_of_results.keys())
+
+    for col, res in dict_of_results.items():
+        if not isinstance(res, bioResults):
+            try:
+                res = bioResults(pickleFile=res)
+            except excep.biogemeError:
+                warning = f'Impossible to access result file {res}'
+                logger.warning(warning)
+                res = None
+        if res is not None:
+            stats_results = res.getGeneralStatistics()
+            for s in statistics:
+                df.loc[s, col] = stats_results[s][0]
+            if include_parameter_estimates:
+                betas = res.getBetaValues()
+                for name, value in betas.items():
+                    df.loc[name, col] = value
+
+    return df.fillna('')
```

### Comparing `biogeme-3.2.8/biogeme/version.py` & `biogeme-3.2.9/biogeme/version.py`

 * *Files 0% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 # Release date
 versionDate = f'{datetime.date.today()}'
 # Major version number
 versionMajor = 3
 # Minor version number
 versionMinor = 2
 # Release name
-versionRelease = '8'
+versionRelease = '9'
 author = 'Michel Bierlaire'
 urlAuthor = 'http://people.epfl.ch/michel.bierlaire'
 department = 'Transport and Mobility Laboratory'
 urlDepartment = 'http://transp-or.epfl.ch'
 university = 'Ecole Polytechnique Fédérale de Lausanne (EPFL)'
 urlUniversity = 'http://www.epfl.ch'
 urlBiogeme = 'http://biogeme.epfl.ch'
```

### Comparing `biogeme-3.2.8/biogeme/vns.py` & `biogeme-3.2.9/biogeme/vns.py`

 * *Files 0% similar despite different names*

```diff
@@ -373,16 +373,17 @@
             if elem.dominates(k):
                 D_dominating.add(k)
             if k.dominates(elem):
                 S_dominated.add(k)
         if S_dominated:
             return False
         self.pareto[elem] = 1
-        self.pareto = {k: v for k, v in self.pareto.items()
-                       if k not in D_dominating}
+        self.pareto = {
+            k: v for k, v in self.pareto.items() if k not in D_dominating
+        }
         self.removed |= D_dominating
         return True
 
     def select(self):
         """
         Select a candidate to be modified during the next iteration.
```

### Comparing `biogeme-3.2.8/biogeme.egg-info/SOURCES.txt` & `biogeme-3.2.9/biogeme.egg-info/SOURCES.txt`

 * *Files 20% similar despite different names*

```diff
@@ -1,186 +1,322 @@
+LICENSE
 MANIFEST.in
 README.md
+cysetuptools.py
+setup.cfg
 setup.py
 biogeme/__init__.py
 biogeme/algorithms.py
 biogeme/assisted.py
 biogeme/biogeme.py
+biogeme/biogeme_orig.py
+biogeme/cnl.py
 biogeme/database.py
 biogeme/distributions.py
 biogeme/draws.py
 biogeme/exceptions.py
 biogeme/expressions.py
 biogeme/filenames.py
 biogeme/hamabs.py
+biogeme/idmanager.py
 biogeme/loglikelihood.py
 biogeme/messaging.py
 biogeme/models.py
 biogeme/optimization.py
 biogeme/results.py
+biogeme/segmentation.py
 biogeme/singleton.py
+biogeme/tmp.py
 biogeme/tools.py
 biogeme/version.py
 biogeme/vns.py
 biogeme.egg-info/PKG-INFO
 biogeme.egg-info/SOURCES.txt
 biogeme.egg-info/dependency_links.txt
 biogeme.egg-info/requires.txt
 biogeme.egg-info/top_level.txt
+examples/_tmp.py
 examples/checkhtml.py
 examples/generateNotebooks.py
+examples/assisted/airline.ipynb
 examples/assisted/airline.py
+examples/assisted/debug.ipynb
+examples/assisted/debug.py
+examples/assisted/optima.ipynb
 examples/assisted/optima.py
-examples/assisted/paretoAirline.ipynb
 examples/assisted/paretoOptima.ipynb
+examples/assisted/paretoSwissmetro.ipynb
+examples/assisted/runknapsack.ipynb
 examples/assisted/swissmetro.dat
+examples/assisted/swissmetro.ipynb
 examples/assisted/swissmetro.py
-examples/assisted/.ipynb_checkpoints/paretoAirline-checkpoint.ipynb
 examples/assisted/.ipynb_checkpoints/paretoOptima-checkpoint.ipynb
-examples/assisted/.ipynb_checkpoints/paretoTest-checkpoint.ipynb
-examples/indicators/01nestedEstimation.py
-examples/indicators/02nestedPlot.py
-examples/indicators/02nestedSimulation.py
-examples/indicators/03nestedElasticities.py
-examples/indicators/04nestedElasticities.py
-examples/indicators/05nestedElasticities.py
-examples/indicators/05nestedElasticitiesCI_Bootstrap.py
-examples/indicators/05nestedElasticitiesConfidenceIntervals.py
-examples/indicators/06nestedWTP.py
+examples/assisted/.ipynb_checkpoints/paretoSwissmetro-checkpoint.ipynb
+examples/assisted/.ipynb_checkpoints/runknapsack-checkpoint.ipynb
+examples/indicators/01expressions.ipynb
+examples/indicators/01expressions.py
+examples/indicators/02estimation.ipynb
+examples/indicators/02estimation.py
+examples/indicators/03simulation.ipynb
+examples/indicators/03simulation.py
+examples/indicators/04market_shares.ipynb
+examples/indicators/04market_shares.py
+examples/indicators/05revenues.ipynb
+examples/indicators/05revenues.py
+examples/indicators/06point_elasticities.ipynb
+examples/indicators/06point_elasticities.py
+examples/indicators/07cross_elasticities.ipynb
+examples/indicators/07cross_elasticities.py
+examples/indicators/08arc_elasticities.ipynb
+examples/indicators/08arc_elasticities.py
+examples/indicators/09wtp.ipynb
+examples/indicators/09wtp.py
+examples/indicators/scenarios.ipynb
+examples/indicators/scenarios.py
+examples/latent/00factorAnalysis.ipynb
 examples/latent/00factorAnalysis.py
+examples/latent/01oneLatentRegression.ipynb
 examples/latent/01oneLatentRegression.py
+examples/latent/02oneLatentOrdered.ipynb
 examples/latent/02oneLatentOrdered.py
+examples/latent/03choiceOnly.ipynb
 examples/latent/03choiceOnly.py
+examples/latent/03choiceOnly_mc.ipynb
 examples/latent/03choiceOnly_mc.py
+examples/latent/04latentChoiceSeq.ipynb
 examples/latent/04latentChoiceSeq.py
+examples/latent/04latentChoiceSeq_mc.ipynb
 examples/latent/04latentChoiceSeq_mc.py
+examples/latent/05latentChoiceFull.ipynb
 examples/latent/05latentChoiceFull.py
+examples/latent/05latentChoiceFull_mc.ipynb
 examples/latent/05latentChoiceFull_mc.py
+examples/latent/06serialCorrelation.ipynb
 examples/latent/06serialCorrelation.py
+examples/latent/07problem.ipynb
 examples/latent/07problem.py
+examples/latent/07problem_simul.ipynb
 examples/latent/07problem_simul.py
+examples/latent/.ipynb_checkpoints/Untitled-checkpoint.ipynb
+examples/latentbis/m01_latent_variable.ipynb
 examples/latentbis/m01_latent_variable.py
+examples/latentbis/m02_sequential_estimation.ipynb
 examples/latentbis/m02_sequential_estimation.py
+examples/latentbis/m03_simultaneous_estimation.ipynb
 examples/latentbis/m03_simultaneous_estimation.py
+examples/montecarlo/01simpleIntegral.ipynb
 examples/montecarlo/01simpleIntegral.py
+examples/montecarlo/02simpleIntegral.ipynb
 examples/montecarlo/02simpleIntegral.py
+examples/montecarlo/03antithetic.ipynb
 examples/montecarlo/03antithetic.py
+examples/montecarlo/03antitheticExplicit.ipynb
 examples/montecarlo/03antitheticExplicit.py
+examples/montecarlo/04normalMixtureNumerical.ipynb
 examples/montecarlo/04normalMixtureNumerical.py
+examples/montecarlo/05normalMixtureMonteCarlo.ipynb
 examples/montecarlo/05normalMixtureMonteCarlo.py
+examples/montecarlo/06estimationIntegral.ipynb
 examples/montecarlo/06estimationIntegral.py
+examples/montecarlo/07estimationMonteCarlo.ipynb
 examples/montecarlo/07estimationMonteCarlo.py
+examples/montecarlo/07estimationMonteCarlo_500.ipynb
 examples/montecarlo/07estimationMonteCarlo_500.py
+examples/montecarlo/07estimationMonteCarlo_anti.ipynb
 examples/montecarlo/07estimationMonteCarlo_anti.py
+examples/montecarlo/07estimationMonteCarlo_anti_500.ipynb
 examples/montecarlo/07estimationMonteCarlo_anti_500.py
+examples/montecarlo/07estimationMonteCarlo_halton.ipynb
 examples/montecarlo/07estimationMonteCarlo_halton.py
+examples/montecarlo/07estimationMonteCarlo_halton_500.ipynb
 examples/montecarlo/07estimationMonteCarlo_halton_500.py
+examples/montecarlo/07estimationMonteCarlo_mlhs.ipynb
 examples/montecarlo/07estimationMonteCarlo_mlhs.py
+examples/montecarlo/07estimationMonteCarlo_mlhs_500.ipynb
 examples/montecarlo/07estimationMonteCarlo_mlhs_500.py
+examples/montecarlo/07estimationMonteCarlo_mlhs_anti.ipynb
 examples/montecarlo/07estimationMonteCarlo_mlhs_anti.py
+examples/montecarlo/07estimationMonteCarlo_mlhs_anti_500.ipynb
 examples/montecarlo/07estimationMonteCarlo_mlhs_anti_500.py
 examples/montecarlo/swissmetro.dat
+examples/notebooks/Elementary expressions.ipynb
 examples/notebooks/FirstModelWithPandasBiogeme.ipynb
 examples/notebooks/Hamabs.ipynb
 examples/notebooks/My first model.ipynb
+examples/notebooks/Untitled.ipynb
+examples/notebooks/Untitled1.ipynb
 examples/notebooks/biogeme.algorithms.ipynb
 examples/notebooks/biogeme.biogeme.ipynb
+examples/notebooks/biogeme.cnl.ipynb
 examples/notebooks/biogeme.database.ipynb
 examples/notebooks/biogeme.distributions.ipynb
 examples/notebooks/biogeme.draws.ipynb
 examples/notebooks/biogeme.expressions.ipynb
 examples/notebooks/biogeme.filenames.ipynb
 examples/notebooks/biogeme.loglikelihood.ipynb
 examples/notebooks/biogeme.messaging.ipynb
 examples/notebooks/biogeme.models.ipynb
 examples/notebooks/biogeme.optimization.ipynb
 examples/notebooks/biogeme.results.ipynb
+examples/notebooks/biogeme.segmentation.ipynb
 examples/notebooks/biogeme.tools.ipynb
 examples/notebooks/biogeme.version.ipynb
 examples/notebooks/swissmetro.dat
+examples/notebooks/.ipynb_checkpoints/Elementary expressions-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/FirstModelWithPandasBiogeme-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/My first model-checkpoint.ipynb
+examples/notebooks/.ipynb_checkpoints/Untitled-checkpoint.ipynb
+examples/notebooks/.ipynb_checkpoints/Untitled1-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.algorithms-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.biogeme-checkpoint.ipynb
+examples/notebooks/.ipynb_checkpoints/biogeme.cnl-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.database-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.distributions-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.draws-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.expressions-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.filenames-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.loglikelihood-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.messaging-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.models-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.optimization-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.results-checkpoint.ipynb
+examples/notebooks/.ipynb_checkpoints/biogeme.segmentation-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.tools-checkpoint.ipynb
 examples/notebooks/.ipynb_checkpoints/biogeme.version-checkpoint.ipynb
+examples/sampling/rico/ess_mnl.py
+examples/sampling/rico/ess_nl.py
+examples/sampling/rico/soa.py
+examples/sampling/rico/soa_results.py
+examples/swissmetro/01logit.ipynb
 examples/swissmetro/01logit.py
+examples/swissmetro/01logitBis.ipynb
 examples/swissmetro/01logitBis.py
+examples/swissmetro/01logit_allAlgos.ipynb
 examples/swissmetro/01logit_allAlgos.py
+examples/swissmetro/01logit_simul.ipynb
 examples/swissmetro/01logit_simul.py
+examples/swissmetro/02weight.ipynb
 examples/swissmetro/02weight.py
+examples/swissmetro/03scale.ipynb
 examples/swissmetro/03scale.py
+examples/swissmetro/04validation.ipynb
 examples/swissmetro/04validation.py
+examples/swissmetro/05normalMixture.ipynb
 examples/swissmetro/05normalMixture.py
+examples/swissmetro/05normalMixtureIntegral.ipynb
 examples/swissmetro/05normalMixtureIntegral.py
+examples/swissmetro/05normalMixture_allAlgos.ipynb
 examples/swissmetro/05normalMixture_allAlgos.py
+examples/swissmetro/05normalMixture_simul.ipynb
 examples/swissmetro/05normalMixture_simul.py
+examples/swissmetro/06unifMixture.ipynb
 examples/swissmetro/06unifMixture.py
+examples/swissmetro/06unifMixtureIntegral.ipynb
 examples/swissmetro/06unifMixtureIntegral.py
+examples/swissmetro/06unifMixtureMHLS.ipynb
 examples/swissmetro/06unifMixtureMHLS.py
+examples/swissmetro/07discreteMixture.ipynb
 examples/swissmetro/07discreteMixture.py
+examples/swissmetro/08boxcox.ipynb
 examples/swissmetro/08boxcox.py
+examples/swissmetro/09nested.ipynb
 examples/swissmetro/09nested.py
+examples/swissmetro/09nested_allAlgos.ipynb
 examples/swissmetro/09nested_allAlgos.py
+examples/swissmetro/10nestedBottom.ipynb
 examples/swissmetro/10nestedBottom.py
+examples/swissmetro/11cnl.ipynb
 examples/swissmetro/11cnl.py
+examples/swissmetro/11cnl_simul.ipynb
 examples/swissmetro/11cnl_simul.py
+examples/swissmetro/11cnl_sparse.ipynb
 examples/swissmetro/11cnl_sparse.py
+examples/swissmetro/12panel.ipynb
 examples/swissmetro/12panel.py
-examples/swissmetro/13panelNormalized.py
+examples/swissmetro/12panel_flat.ipynb
+examples/swissmetro/12panel_flat.py
+examples/swissmetro/13panel_simul.ipynb
+examples/swissmetro/13panel_simul.py
+examples/swissmetro/14nestedEndogenousSampling.ipynb
 examples/swissmetro/14nestedEndogenousSampling.py
+examples/swissmetro/15panelDiscrete.ipynb
 examples/swissmetro/15panelDiscrete.py
+examples/swissmetro/15panelDiscreteBis.ipynb
 examples/swissmetro/15panelDiscreteBis.py
+examples/swissmetro/16panelDiscreteSocioEco.ipynb
 examples/swissmetro/16panelDiscreteSocioEco.py
+examples/swissmetro/17lognormalMixture.ipynb
 examples/swissmetro/17lognormalMixture.py
+examples/swissmetro/17lognormalMixtureIntegral.ipynb
 examples/swissmetro/17lognormalMixtureIntegral.py
+examples/swissmetro/18ordinalLogit.ipynb
 examples/swissmetro/18ordinalLogit.py
+examples/swissmetro/19individualLevelParameters.ipynb
 examples/swissmetro/19individualLevelParameters.py
+examples/swissmetro/21probit.ipynb
 examples/swissmetro/21probit.py
+examples/swissmetro/24haltonMixture.ipynb
 examples/swissmetro/24haltonMixture.py
+examples/swissmetro/25triangularMixture.ipynb
 examples/swissmetro/25triangularMixture.py
+examples/swissmetro/26triangularPanelMixture.ipynb
 examples/swissmetro/26triangularPanelMixture.py
+examples/swissmetro/create_run_files.ipynb
+examples/swissmetro/create_run_files.py
 examples/swissmetro/swissmetro.dat
 examples/swissmetro/.ipynb_checkpoints/01logit-checkpoint.ipynb
+examples/swissmetro/.ipynb_checkpoints/Untitled-checkpoint.ipynb
 examples/swissmetro/.ipynb_checkpoints/scitas-checkpoint.ipynb
 examples/swissmetro/.ipynb_checkpoints/tmp19-checkpoint.ipynb
+examples/swissmetro_panel/01logit_p.ipynb
 examples/swissmetro_panel/01logit_p.py
+examples/swissmetro_panel/12panel_p.ipynb
 examples/swissmetro_panel/12panel_p.py
 examples/vns/knapsack.ipynb
 examples/vns/knapsack.py
+examples/vns/runknapsack.ipynb
 examples/vns/runknapsack.py
 examples/vns/.ipynb_checkpoints/knapsack-checkpoint.ipynb
+examples/vns/.ipynb_checkpoints/runknapsack-checkpoint.ipynb
+examples/workingNotToDistribute/01logit.ipynb
 examples/workingNotToDistribute/01logit.py
+examples/workingNotToDistribute/01logit_simul.ipynb
 examples/workingNotToDistribute/01logit_simul.py
+examples/workingNotToDistribute/12panel.ipynb
 examples/workingNotToDistribute/12panel.py
 examples/workingNotToDistribute/Untitled.ipynb
+examples/workingNotToDistribute/backward.ipynb
+examples/workingNotToDistribute/backward.py
+examples/workingNotToDistribute/debug.ipynb
 examples/workingNotToDistribute/debug.py
+examples/workingNotToDistribute/evaluate.ipynb
+examples/workingNotToDistribute/evaluate.py
+examples/workingNotToDistribute/latent_light_simul.ipynb
+examples/workingNotToDistribute/latent_light_simul.py
+examples/workingNotToDistribute/mbi.ipynb
+examples/workingNotToDistribute/mbi.py
+examples/workingNotToDistribute/new.ipynb
 examples/workingNotToDistribute/new.py
+examples/workingNotToDistribute/old.ipynb
 examples/workingNotToDistribute/old.py
 examples/workingNotToDistribute/swissmetro.dat
+examples/workingNotToDistribute/test_url_pickle.ipynb
+examples/workingNotToDistribute/test_url_pickle.py
+examples/workingNotToDistribute/threads.ipynb
 examples/workingNotToDistribute/threads.py
 examples/workingNotToDistribute/.ipynb_checkpoints/Untitled-checkpoint.ipynb
-src/#bioExprBoxcox.cc#
 src/__init__.py
 src/bioCfsqp.cc
 src/bioCfsqp.h
 src/bioConst.h
 src/bioDebug.h
 src/bioDerivatives.cc
+src/bioDerivatives.cpp
 src/bioDerivatives.h
+src/bioDerivatives.pyx
 src/bioExceptions.cc
 src/bioExceptions.h
 src/bioExprAnd.cc
 src/bioExprAnd.h
 src/bioExprDerive.cc
 src/bioExprDerive.h
 src/bioExprDivide.cc
@@ -273,50 +409,59 @@
 src/bioSeveralExpressions.h
 src/bioSeveralFormulas.cc
 src/bioSeveralFormulas.h
 src/bioString.cc
 src/bioString.h
 src/bioThreadMemory.cc
 src/bioThreadMemory.h
+src/bioThreadMemoryOneExpression.cc
+src/bioThreadMemoryOneExpression.h
 src/bioThreadMemorySimul.cc
 src/bioThreadMemorySimul.h
 src/bioTypes.h
+src/bioVectorOfDerivatives.cc
+src/bioVectorOfDerivatives.h
 src/biogeme.cc
 src/biogeme.cc.tmp
 src/biogeme.cc.work
 src/biogeme.h
 src/biogeme.h.work
 src/biogeme_working.cc
 src/biogeme_working.h
 src/cbiogeme.cpp
 src/cbiogeme.pyx
 src/cbiogeme.pyx.ok
 src/cbiogeme.pyx.work
+src/cexpressions.cpp
+src/cexpressions.pyx
 src/cfsqpusr.h
+src/cythonbiogeme.cpp
+src/cythonbiogeme.pyx
+src/cythonbiogeme.pyx~
+src/evaluateExpressions.cc
+src/evaluateExpressions.h
 src/main.cc
 src/mycfsqp.cc
 src/myqld.cc
 src/panelbiogeme.h
-src_keep/__init__.py
+src/tmp.py
+src/__pycache__/__init__.cpython-310.pyc
 tests/simple_test.py
-tests/functions/debug.py
-tests/functions/testBiogeme.py
-tests/functions/testData.py
-tests/functions/testDatabase.py
-tests/functions/testDraws.py
-tests/functions/testExpressions.py
-tests/functions/testOptimization.py
-tests/functions/test_all.py
-tests/latent/optima.dat
-tests/latent/test_01.py
-tests/latent/test_02.py
-tests/latent/test_03.py
-tests/latent/test_04.py
-tests/latent/test_05.py
-tests/latent/test_all.py
+tests/functions/test_biogeme.py
+tests/functions/test_data.py
+tests/functions/test_database.py
+tests/functions/test_draws.py
+tests/functions/test_expressions.py
+tests/functions/test_optimization.py
+tests/functions/test_results.py
+tests/functions/test_segmentation.py
+tests/functions/test_tools.py
+tests/optima/optima.dat
+tests/optima/spec_optima.py
+tests/optima/test_01.py
 tests/swissmetro/__init__.py
 tests/swissmetro/swissmetro.dat
 tests/swissmetro/test_01.py
 tests/swissmetro/test_01simul.py
 tests/swissmetro/test_02.py
 tests/swissmetro/test_03.py
 tests/swissmetro/test_04.py
@@ -337,9 +482,8 @@
 tests/swissmetro/test_15.py
 tests/swissmetro/test_16.py
 tests/swissmetro/test_17.py
 tests/swissmetro/test_17integral.py
 tests/swissmetro/test_18.py
 tests/swissmetro/test_21.py
 tests/swissmetro/test_25.py
-tests/swissmetro/test_26.py
-tests/swissmetro/test_all.py
+tests/swissmetro/test_26.py
```

### Comparing `biogeme-3.2.8/examples/assisted/.ipynb_checkpoints/paretoOptima-checkpoint.ipynb` & `biogeme-3.2.9/examples/assisted/.ipynb_checkpoints/paretoOptima-checkpoint.ipynb`

 * *Files 13% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9780544391257225%*

 * *Differences: {"'cells'": '{4: {\'source\': {insert: [(0, "df = pd.read_csv(\'optima.dat\', '*

 * *            'sep=\'\\\\t\')\\n")], delete: [0]}}, 8: {\'source\': [\'pareto = vns.paretoClass(_, '*

 * *            "archiveInputFile=pickleFile)']}, 9: {'outputs': {0: {'text': ['Number of pareto "*

 * *            "solutions: 34\\n']}}}, 15: {'outputs': {0: {'text': ['  1    Neg. log likelihood: "*

 * *            "1235.742810736561\\t#parameters: 4\\tBIC = 2501.697\\tAIC = 2479.486\\n', '  2    "*

 * *            'Neg. log likelihood: 1127.41854 […]*

```diff
@@ -48,15 +48,15 @@
                     },
                     "execution_count": 2,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "df = pd.read_csv('optima.dat', '\\t')\n",
+                "df = pd.read_csv('optima.dat', sep='\\t')\n",
                 "\n",
                 "database = db.Database('optima', df)\n",
                 "\n",
                 "globals().update(database.variables)\n",
                 "\n",
                 "exclude = ((Choice == -1) + (CostCarCHF < 0)) > 0\n",
                 "database.remove(exclude)\n",
@@ -78,32 +78,39 @@
             "metadata": {},
             "outputs": [],
             "source": [
                 "pickleFile = 'optimaPareto.pickle'"
             ]
         },
         {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "The first argument is the largest size of neighborhood used by the algorithm. It is irrelevant when the algorithm is not executed. Here, we simply display the Pareto solutions. So it is not needed."
+            ]
+        },
+        {
             "cell_type": "code",
             "execution_count": 4,
             "metadata": {},
             "outputs": [],
             "source": [
-                "pareto = vns.paretoClass(20, archiveInputFile=pickleFile)"
+                "pareto = vns.paretoClass(_, archiveInputFile=pickleFile)"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 5,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "Number of pareto solutions: 25\n"
+                        "Number of pareto solutions: 34\n"
                     ]
                 }
             ],
             "source": [
                 "print(f'Number of pareto solutions: {len(pareto.pareto)}')"
             ]
         },
@@ -140,47 +147,71 @@
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## List of Pareto solutions: performance measures"
             ]
         },
         {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "For each model in the Pareto set, we display:\n",
+                "\n",
+                "- an id,\n",
+                "- the negative log likelihood,\n",
+                "- the number of parameters,\n",
+                "- the Bayesian information criterion (BIC), \n",
+                "- the Akaike informatoin criterion (AIC).\n",
+                "\n",
+                "The models with the best BIC (B*) and the best AIC (A*) are identified. If the same model has both the best BIC and AIC, it is labeled (**). "
+            ]
+        },
+        {
             "cell_type": "code",
             "execution_count": 8,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "  1    Neg. log likelihood: 1074.1542520705061\t#parameters: 8\tBIC = 2208.731\tAIC = 2164.309\n",
-                        "  2    Neg. log likelihood: 1066.3386558792204\t#parameters: 9\tBIC = 2200.652\tAIC = 2150.677\n",
-                        "  3    Neg. log likelihood: 1103.069792717828\t#parameters: 6\tBIC = 2251.456\tAIC = 2218.140\n",
-                        "  4    Neg. log likelihood: 1004.6038828259387\t#parameters: 27\tBIC = 2213.132\tAIC = 2063.208\n",
-                        "  5    Neg. log likelihood: 1001.5840164166052\t#parameters: 28\tBIC = 2214.645\tAIC = 2059.168\n",
-                        "  6    Neg. log likelihood: 988.1598698795049\t#parameters: 33\tBIC = 2225.561\tAIC = 2042.320\n",
-                        "  7    Neg. log likelihood: 1051.6507992220459\t#parameters: 11\tBIC = 2186.382\tAIC = 2125.302\n",
-                        "  8    Neg. log likelihood: 972.8562165159028\t#parameters: 42\tBIC = 2262.928\tAIC = 2029.712\n",
-                        "  9    Neg. log likelihood: 1058.963534623781\t#parameters: 10\tBIC = 2193.455\tAIC = 2137.927\n",
-                        " 10    Neg. log likelihood: 1045.8386334483741\t#parameters: 12\tBIC = 2182.310\tAIC = 2115.677\n",
-                        " 11    Neg. log likelihood: 972.3151295005208\t#parameters: 45\tBIC = 2284.505\tAIC = 2034.630\n",
-                        " 12    Neg. log likelihood: 973.810478995911\t#parameters: 40\tBIC = 2249.731\tAIC = 2027.621\n",
-                        " 13    Neg. log likelihood: 1087.4629397853657\t#parameters: 7\tBIC = 2227.795\tAIC = 2188.926\n",
-                        " 14    Neg. log likelihood: 1028.6019327359625\t#parameters: 15\tBIC = 2170.495\tAIC = 2087.204\n",
-                        " 15    Neg. log likelihood: 1006.9612262846324\t#parameters: 21\tBIC = 2172.530\tAIC = 2055.922\n",
-                        " 16    Neg. log likelihood: 1115.4429769999947\t#parameters: 5\tBIC = 2268.650\tAIC = 2240.886\n",
-                        " 17    Neg. log likelihood: 1040.1722519056575\t#parameters: 13\tBIC = 2178.530\tAIC = 2106.345\n",
-                        " 18    Neg. log likelihood: 968.2641219742045\t#parameters: 47\tBIC = 2291.508\tAIC = 2030.528\n",
-                        " 19    Neg. log likelihood: 1006.0615350749068\t#parameters: 22\tBIC = 2178.284\tAIC = 2056.123\n",
-                        " 20    Neg. log likelihood: 947.8309446046067\t#parameters: 68\tBIC = 2409.250\tAIC = 2031.662\n",
-                        " 21 A* Neg. log likelihood: 977.7990203118986\t#parameters: 34\tBIC = 2212.392\tAIC = 2023.598\n",
-                        " 22    Neg. log likelihood: 1019.9924490869894\t#parameters: 18\tBIC = 2175.935\tAIC = 2075.985\n",
-                        " 23 B* Neg. log likelihood: 1020.6516279266862\t#parameters: 16\tBIC = 2162.147\tAIC = 2073.303\n",
-                        " 24    Neg. log likelihood: 989.1104419315169\t#parameters: 31\tBIC = 2212.357\tAIC = 2040.221\n",
-                        " 25    Neg. log likelihood: 1031.1234226425945\t#parameters: 14\tBIC = 2167.986\tAIC = 2090.247\n"
+                        "  1    Neg. log likelihood: 1235.742810736561\t#parameters: 4\tBIC = 2501.697\tAIC = 2479.486\n",
+                        "  2    Neg. log likelihood: 1127.4185480533592\t#parameters: 5\tBIC = 2292.601\tAIC = 2264.837\n",
+                        "  3    Neg. log likelihood: 1104.8322909668\t#parameters: 6\tBIC = 2254.981\tAIC = 2221.665\n",
+                        "  4    Neg. log likelihood: 1060.9350080934967\t#parameters: 10\tBIC = 2197.398\tAIC = 2141.870\n",
+                        "  5    Neg. log likelihood: 1080.2041035076786\t#parameters: 8\tBIC = 2220.830\tAIC = 2176.408\n",
+                        "  6    Neg. log likelihood: 1049.3525193818766\t#parameters: 11\tBIC = 2181.785\tAIC = 2120.705\n",
+                        "  7    Neg. log likelihood: 969.9960089497033\t#parameters: 30\tBIC = 2166.575\tAIC = 1999.992\n",
+                        "  8    Neg. log likelihood: 1069.2360853787256\t#parameters: 9\tBIC = 2206.447\tAIC = 2156.472\n",
+                        "  9    Neg. log likelihood: 1093.1358215961525\t#parameters: 7\tBIC = 2239.141\tAIC = 2200.272\n",
+                        " 10    Neg. log likelihood: 1040.6455154331948\t#parameters: 12\tBIC = 2171.924\tAIC = 2105.291\n",
+                        " 11    Neg. log likelihood: 1028.608553639897\t#parameters: 14\tBIC = 2162.956\tAIC = 2085.217\n",
+                        " 12    Neg. log likelihood: 955.3042745395616\t#parameters: 47\tBIC = 2265.588\tAIC = 2004.609\n",
+                        " 13    Neg. log likelihood: 957.2703876422391\t#parameters: 46\tBIC = 2261.968\tAIC = 2006.541\n",
+                        " 14    Neg. log likelihood: 986.5140034154439\t#parameters: 24\tBIC = 2154.294\tAIC = 2021.028\n",
+                        " 15    Neg. log likelihood: 989.3488049644388\t#parameters: 23\tBIC = 2152.411\tAIC = 2024.698\n",
+                        " 16    Neg. log likelihood: 1021.2018607631908\t#parameters: 15\tBIC = 2155.695\tAIC = 2072.404\n",
+                        " 17    Neg. log likelihood: 1002.7856262675178\t#parameters: 19\tBIC = 2149.074\tAIC = 2043.571\n",
+                        " 18    Neg. log likelihood: 975.0199650758397\t#parameters: 26\tBIC = 2146.412\tAIC = 2002.040\n",
+                        " 19    Neg. log likelihood: 1000.2092228663688\t#parameters: 20\tBIC = 2151.474\tAIC = 2040.418\n",
+                        " 20    Neg. log likelihood: 1018.7485594338414\t#parameters: 16\tBIC = 2158.341\tAIC = 2069.497\n",
+                        " 21    Neg. log likelihood: 991.4516698116273\t#parameters: 22\tBIC = 2149.064\tAIC = 2026.903\n",
+                        " 22    Neg. log likelihood: 1009.1570917624189\t#parameters: 18\tBIC = 2154.264\tAIC = 2054.314\n",
+                        " 23 B* Neg. log likelihood: 992.5308465026035\t#parameters: 21\tBIC = 2143.670\tAIC = 2027.062\n",
+                        " 24    Neg. log likelihood: 980.5442183028409\t#parameters: 25\tBIC = 2149.907\tAIC = 2011.088\n",
+                        " 25    Neg. log likelihood: 965.1337245957665\t#parameters: 37\tBIC = 2209.720\tAIC = 2004.267\n",
+                        " 26    Neg. log likelihood: 1036.0947951464968\t#parameters: 13\tBIC = 2170.375\tAIC = 2098.190\n",
+                        " 27    Neg. log likelihood: 952.7982053710521\t#parameters: 51\tBIC = 2290.787\tAIC = 2007.596\n",
+                        " 28    Neg. log likelihood: 951.8215302128433\t#parameters: 52\tBIC = 2296.387\tAIC = 2007.643\n",
+                        " 29 A* Neg. log likelihood: 957.742583540515\t#parameters: 38\tBIC = 2202.490\tAIC = 1991.485\n",
+                        " 30    Neg. log likelihood: 932.6343661265355\t#parameters: 77\tBIC = 2446.831\tAIC = 2019.269\n",
+                        " 31    Neg. log likelihood: 930.7564974747635\t#parameters: 78\tBIC = 2450.628\tAIC = 2017.513\n",
+                        " 32    Neg. log likelihood: 950.5572917890883\t#parameters: 53\tBIC = 2301.411\tAIC = 2007.115\n",
+                        " 33    Neg. log likelihood: 947.6854098185937\t#parameters: 54\tBIC = 2303.220\tAIC = 2003.371\n",
+                        " 34    Neg. log likelihood: 1013.0358279293548\t#parameters: 17\tBIC = 2154.469\tAIC = 2060.072\n"
                     ]
                 }
             ],
             "source": [
                 "bestBIC = None\n",
                 "bestAIC = None\n",
                 "summary = []\n",
@@ -219,620 +250,843 @@
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## List of Pareto solutions: model specifications"
             ]
         },
         {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "For each model in the Pareto set, we provide a description of the model specification."
+            ]
+        },
+        {
             "cell_type": "code",
             "execution_count": 9,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "*************** Model 1 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
                         "Cte. \n",
-                        "PT travel time_sqrt [alt. spec.] <CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [generic] \n",
+                        "PT travel time_sqrt [generic] \n",
+                        "\n",
                         "\n",
                         "\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
                         "Cte. \n",
-                        "Car travel time_sqrt [alt. spec.] <CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [generic] \n",
+                        "Car travel time_sqrt [generic] \n",
+                        "\n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose>\n",
+                        "Distance [alt. spec.] \n",
                         "\n",
-                        "Neg. log likelihood: 1074.1542520705061\n",
-                        "#parameters: 8\n",
+                        "Neg. log likelihood: 1235.742810736561\n",
+                        "#parameters: 4\n",
                         "\n",
                         "\n",
                         "*************** Model 2 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
                         "Cte. \n",
-                        "PT travel time_sqrt [alt. spec.] <CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [generic] \n",
+                        "PT travel time_sqrt [generic] \n",
+                        "PT travel cost_sqrt [generic] \n",
+                        "\n",
                         "\n",
-                        "PT Waiting time [alt. spec.] \n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
                         "Cte. \n",
-                        "Car travel time_sqrt [alt. spec.] <CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [generic] \n",
+                        "Car travel time_sqrt [generic] \n",
+                        "Car travel cost_sqrt [generic] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose>\n",
+                        "Distance [alt. spec.] \n",
                         "\n",
-                        "Neg. log likelihood: 1066.3386558792204\n",
-                        "#parameters: 9\n",
+                        "Neg. log likelihood: 1127.4185480533592\n",
+                        "#parameters: 5\n",
                         "\n",
                         "\n",
                         "*************** Model 3 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
                         "Cte. \n",
-                        "PT travel time_sqrt [generic] <CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [generic] \n",
-                        "Transfers [alt. spec.] \n",
+                        "PT travel time [generic] \n",
+                        "PT travel cost_sqrt [alt. spec.] \n",
+                        "\n",
                         "\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
                         "Cte. \n",
-                        "Car travel time_sqrt [generic] <CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [generic] \n",
+                        "Car travel time [generic] \n",
+                        "Car travel cost_sqrt [alt. spec.] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
                         "Distance [alt. spec.] \n",
                         "\n",
-                        "Neg. log likelihood: 1103.069792717828\n",
+                        "Neg. log likelihood: 1104.8322909668\n",
                         "#parameters: 6\n",
                         "\n",
                         "\n",
                         "*************** Model 4 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "PT travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [generic] <Gender>\n",
+                        "Cte. <Language>\n",
+                        "PT travel time [generic] \n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] \n",
                         "\n",
                         "\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "Car travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [generic] <Gender>\n",
+                        "Cte. <Language>\n",
+                        "Car travel time [generic] \n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "Distance [alt. spec.] <TripPurpose>\n",
                         "\n",
-                        "Neg. log likelihood: 1004.6038828259387\n",
-                        "#parameters: 27\n",
+                        "Neg. log likelihood: 1060.9350080934967\n",
+                        "#parameters: 10\n",
                         "\n",
                         "\n",
                         "*************** Model 5 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "PT travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [generic] <Gender>\n",
-                        "Transfers [alt. spec.] \n",
+                        "Cte. <Language>\n",
+                        "PT travel time [generic] \n",
+                        "PT travel cost_sqrt [alt. spec.] \n",
+                        "\n",
                         "\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "Car travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [generic] <Gender>\n",
+                        "Cte. <Language>\n",
+                        "Car travel time [generic] \n",
+                        "Car travel cost_sqrt [alt. spec.] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "Distance [alt. spec.] \n",
                         "\n",
-                        "Neg. log likelihood: 1001.5840164166052\n",
-                        "#parameters: 28\n",
+                        "Neg. log likelihood: 1080.2041035076786\n",
+                        "#parameters: 8\n",
                         "\n",
                         "\n",
                         "*************** Model 6 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "PT travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language>\n",
+                        "PT travel time [alt. spec.] \n",
+                        "PT travel cost_Box-Cox_cost [generic] <CarAvail>\n",
+                        "\n",
                         "\n",
-                        "PT Waiting time [alt. spec.] <TripPurpose, Subscription>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "Car travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language>\n",
+                        "Car travel time [alt. spec.] \n",
+                        "Car travel cost_Box-Cox_cost [generic] <CarAvail>\n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "Distance [alt. spec.] <TripPurpose>\n",
                         "\n",
-                        "Neg. log likelihood: 988.1598698795049\n",
-                        "#parameters: 33\n",
+                        "Neg. log likelihood: 1049.3525193818766\n",
+                        "#parameters: 11\n",
                         "\n",
                         "\n",
                         "*************** Model 7 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. \n",
-                        "PT travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [generic] \n",
+                        "Cte. <Language, Occupation>\n",
+                        "PT travel time_sqrt [alt. spec.] <TripPurpose>\n",
+                        "PT travel cost_Box-Cox_cost [generic] <TripPurpose, CarAvail>\n",
                         "\n",
-                        "PT Waiting time [alt. spec.] \n",
+                        "PT Waiting time_log [alt. spec.] \n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. \n",
-                        "Car travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [generic] \n",
+                        "Cte. <Language, Occupation>\n",
+                        "Car travel time_sqrt [alt. spec.] <TripPurpose>\n",
+                        "Car travel cost_Box-Cox_cost [generic] <TripPurpose, CarAvail>\n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose>\n",
+                        "Distance [alt. spec.] <TripPurpose, Education>\n",
                         "\n",
-                        "Neg. log likelihood: 1051.6507992220459\n",
-                        "#parameters: 11\n",
+                        "Neg. log likelihood: 969.9960089497033\n",
+                        "#parameters: 30\n",
                         "\n",
                         "\n",
                         "*************** Model 8 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "PT travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language>\n",
+                        "PT travel time [generic] \n",
+                        "PT travel cost_sqrt [alt. spec.] \n",
+                        "\n",
                         "\n",
-                        "PT Waiting time [alt. spec.] <TripPurpose, Occupation, Subscription>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "Car travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language>\n",
+                        "Car travel time [generic] \n",
+                        "Car travel cost_sqrt [alt. spec.] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "Distance [alt. spec.] <TripPurpose>\n",
                         "\n",
-                        "Neg. log likelihood: 972.8562165159028\n",
-                        "#parameters: 42\n",
+                        "Neg. log likelihood: 1069.2360853787256\n",
+                        "#parameters: 9\n",
                         "\n",
                         "\n",
                         "*************** Model 9 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
                         "Cte. \n",
-                        "PT travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
-                        "PT travel cost_sqrt [generic] \n",
+                        "PT travel time [generic] \n",
+                        "PT travel cost_sqrt [alt. spec.] \n",
+                        "\n",
                         "\n",
-                        "PT Waiting time [alt. spec.] \n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
                         "Cte. \n",
-                        "Car travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
-                        "Car travel cost_sqrt [generic] \n",
+                        "Car travel time [generic] \n",
+                        "Car travel cost_sqrt [alt. spec.] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
                         "Distance [alt. spec.] <TripPurpose>\n",
                         "\n",
-                        "Neg. log likelihood: 1058.963534623781\n",
-                        "#parameters: 10\n",
+                        "Neg. log likelihood: 1093.1358215961525\n",
+                        "#parameters: 7\n",
                         "\n",
                         "\n",
                         "*************** Model 10 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. \n",
-                        "PT travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [generic] \n",
-                        "Transfers [alt. spec.] <Occupation>\n",
+                        "Cte. <Language>\n",
+                        "PT travel time_sqrt [alt. spec.] \n",
+                        "PT travel cost_Box-Cox_cost [generic] <CarAvail>\n",
                         "\n",
+                        "PT Waiting time [alt. spec.] \n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. \n",
-                        "Car travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [generic] \n",
+                        "Cte. <Language>\n",
+                        "Car travel time_sqrt [alt. spec.] \n",
+                        "Car travel cost_Box-Cox_cost [generic] <CarAvail>\n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
                         "Distance [alt. spec.] <TripPurpose>\n",
                         "\n",
-                        "Neg. log likelihood: 1045.8386334483741\n",
+                        "Neg. log likelihood: 1040.6455154331948\n",
                         "#parameters: 12\n",
                         "\n",
                         "\n",
                         "*************** Model 11 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "PT travel time_sqrt [alt. spec.] <TripPurpose, Subscription, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language>\n",
+                        "PT travel time_sqrt [alt. spec.] \n",
+                        "PT travel cost_Box-Cox_cost [generic] <CarAvail>\n",
                         "\n",
-                        "PT Waiting time [alt. spec.] <TripPurpose, Occupation>\n",
+                        "PT Waiting time [alt. spec.] \n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "Car travel time_sqrt [alt. spec.] <TripPurpose, Subscription, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language>\n",
+                        "Car travel time_sqrt [alt. spec.] \n",
+                        "Car travel cost_Box-Cox_cost [generic] <CarAvail>\n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "Distance [alt. spec.] <Education>\n",
                         "\n",
-                        "Neg. log likelihood: 972.3151295005208\n",
-                        "#parameters: 45\n",
+                        "Neg. log likelihood: 1028.608553639897\n",
+                        "#parameters: 14\n",
                         "\n",
                         "\n",
                         "*************** Model 12 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "PT travel time_sqrt [alt. spec.] <TripPurpose, Subscription, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Urban, Language, Occupation>\n",
+                        "PT travel time_Box-Cox_time [alt. spec.] <TripPurpose>\n",
+                        "PT travel cost_Box-Cox_cost [generic] <CarAvail>\n",
                         "\n",
-                        "PT Waiting time [alt. spec.] <Occupation>\n",
+                        "PT Waiting time [alt. spec.] <Income>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "Car travel time_sqrt [alt. spec.] <TripPurpose, Subscription, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Urban, Language, Occupation>\n",
+                        "Car travel time_Box-Cox_time [alt. spec.] <TripPurpose>\n",
+                        "Car travel cost_Box-Cox_cost [generic] <CarAvail>\n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
                         "Distance [alt. spec.] <TripPurpose, Education>\n",
                         "\n",
-                        "Neg. log likelihood: 973.810478995911\n",
-                        "#parameters: 40\n",
+                        "Neg. log likelihood: 955.3042745395616\n",
+                        "#parameters: 47\n",
                         "\n",
                         "\n",
                         "*************** Model 13 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. \n",
-                        "PT travel time_sqrt [alt. spec.] <CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [generic] \n",
-                        "\n",
+                        "Cte. <Language, Occupation>\n",
+                        "PT travel time_sqrt [alt. spec.] <TripPurpose>\n",
+                        "PT travel cost_Box-Cox_cost [generic] <TripPurpose, CarAvail>\n",
                         "\n",
+                        "PT Waiting time [alt. spec.] \n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. \n",
-                        "Car travel time_sqrt [alt. spec.] <CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [generic] \n",
+                        "Cte. <Language, Occupation>\n",
+                        "Car travel time_sqrt [alt. spec.] <TripPurpose>\n",
+                        "Car travel cost_Box-Cox_cost [generic] <TripPurpose, CarAvail>\n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] \n",
+                        "Distance [alt. spec.] <TripPurpose, Occupation, Education>\n",
                         "\n",
-                        "Neg. log likelihood: 1087.4629397853657\n",
-                        "#parameters: 7\n",
+                        "Neg. log likelihood: 957.2703876422391\n",
+                        "#parameters: 46\n",
                         "\n",
                         "\n",
                         "*************** Model 14 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. \n",
-                        "PT travel time_Box-Cox_time [alt. spec.] <Language, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [generic] \n",
-                        "Transfers [alt. spec.] <Occupation>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "PT travel time_sqrt [alt. spec.] \n",
+                        "PT travel cost_Box-Cox_cost [generic] <TripPurpose>\n",
                         "\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. \n",
-                        "Car travel time_Box-Cox_time [alt. spec.] <Language, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [generic] \n",
+                        "Cte. <Language, CarAvail>\n",
+                        "Car travel time_sqrt [alt. spec.] \n",
+                        "Car travel cost_Box-Cox_cost [generic] <TripPurpose>\n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose>\n",
+                        "Distance [alt. spec.] <TripPurpose, Education>\n",
                         "\n",
-                        "Neg. log likelihood: 1028.6019327359625\n",
-                        "#parameters: 15\n",
+                        "Neg. log likelihood: 986.5140034154439\n",
+                        "#parameters: 24\n",
                         "\n",
                         "\n",
                         "*************** Model 15 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. \n",
-                        "PT travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "PT travel time_sqrt [alt. spec.] \n",
                         "PT travel cost_Box-Cox_cost [generic] \n",
                         "\n",
-                        "PT Waiting time [alt. spec.] <Income>\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. \n",
-                        "Car travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "Car travel time_sqrt [alt. spec.] \n",
                         "Car travel cost_Box-Cox_cost [generic] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
                         "Distance [alt. spec.] <TripPurpose, Education>\n",
                         "\n",
-                        "Neg. log likelihood: 1006.9612262846324\n",
-                        "#parameters: 21\n",
+                        "Neg. log likelihood: 989.3488049644388\n",
+                        "#parameters: 23\n",
                         "\n",
                         "\n",
                         "*************** Model 16 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. \n",
-                        "PT travel time_sqrt [generic] <CarAvail>\n",
-                        "PT travel cost_sqrt [generic] \n",
-                        "\n",
+                        "Cte. <Language>\n",
+                        "PT travel time [generic] \n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] \n",
                         "\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. \n",
-                        "Car travel time_sqrt [generic] <CarAvail>\n",
-                        "Car travel cost_sqrt [generic] \n",
+                        "Cte. <Language>\n",
+                        "Car travel time [generic] \n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] \n",
+                        "Distance [alt. spec.] <Education>\n",
                         "\n",
-                        "Neg. log likelihood: 1115.4429769999947\n",
-                        "#parameters: 5\n",
+                        "Neg. log likelihood: 1021.2018607631908\n",
+                        "#parameters: 15\n",
                         "\n",
                         "\n",
                         "*************** Model 17 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. \n",
-                        "PT travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [generic] \n",
-                        "Transfers [alt. spec.] <Occupation>\n",
-                        "PT Waiting time [alt. spec.] \n",
+                        "Cte. <Language, CarAvail>\n",
+                        "PT travel time [generic] \n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] \n",
+                        "\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. \n",
-                        "Car travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [generic] \n",
+                        "Cte. <Language, CarAvail>\n",
+                        "Car travel time [generic] \n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose>\n",
+                        "Distance [alt. spec.] <Education>\n",
                         "\n",
-                        "Neg. log likelihood: 1040.1722519056575\n",
-                        "#parameters: 13\n",
+                        "Neg. log likelihood: 1002.7856262675178\n",
+                        "#parameters: 19\n",
                         "\n",
                         "\n",
                         "*************** Model 18 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "PT travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [alt. spec.] <Language, Gender>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "PT travel time_sqrt [generic] <TripPurpose>\n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] <TripPurpose>\n",
                         "\n",
-                        "PT Waiting time [alt. spec.] <TripPurpose, Occupation, Subscription>\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "Car travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [alt. spec.] <Language, Gender>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "Car travel time_sqrt [generic] <TripPurpose>\n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] <TripPurpose>\n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
                         "Distance [alt. spec.] <TripPurpose, Education>\n",
                         "\n",
-                        "Neg. log likelihood: 968.2641219742045\n",
-                        "#parameters: 47\n",
+                        "Neg. log likelihood: 975.0199650758397\n",
+                        "#parameters: 26\n",
                         "\n",
                         "\n",
                         "*************** Model 19 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. \n",
-                        "PT travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "PT travel time [generic] <TripPurpose>\n",
                         "PT travel cost_Box-Cox_cost [alt. spec.] \n",
                         "\n",
-                        "PT Waiting time [alt. spec.] <Income>\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. \n",
-                        "Car travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "Car travel time [generic] <TripPurpose>\n",
                         "Car travel cost_Box-Cox_cost [alt. spec.] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "Distance [alt. spec.] <Education>\n",
                         "\n",
-                        "Neg. log likelihood: 1006.0615350749068\n",
-                        "#parameters: 22\n",
+                        "Neg. log likelihood: 1000.2092228663688\n",
+                        "#parameters: 20\n",
                         "\n",
                         "\n",
                         "*************** Model 20 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. <Language, Occupation, Subscription>\n",
-                        "PT travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language>\n",
+                        "PT travel time [generic] <TripPurpose>\n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] \n",
                         "\n",
-                        "PT Waiting time [alt. spec.] <TripPurpose, Income>\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. <Language, Occupation, Subscription>\n",
-                        "Car travel time_sqrt [alt. spec.] <TripPurpose, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language>\n",
+                        "Car travel time [generic] <TripPurpose>\n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "Distance [alt. spec.] <Education>\n",
                         "\n",
-                        "Neg. log likelihood: 947.8309446046067\n",
-                        "#parameters: 68\n",
+                        "Neg. log likelihood: 1018.7485594338414\n",
+                        "#parameters: 16\n",
                         "\n",
                         "\n",
                         "*************** Model 21 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "PT travel time_sqrt [generic] <TripPurpose, Subscription, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "PT travel time [alt. spec.] <TripPurpose>\n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] \n",
                         "\n",
-                        "PT Waiting time [alt. spec.] <Occupation>\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "Car travel time_sqrt [generic] <TripPurpose, Subscription, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "Car travel time [alt. spec.] <TripPurpose>\n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "Distance [alt. spec.] <Education>\n",
                         "\n",
-                        "Neg. log likelihood: 977.7990203118986\n",
-                        "#parameters: 34\n",
+                        "Neg. log likelihood: 991.4516698116273\n",
+                        "#parameters: 22\n",
                         "\n",
                         "\n",
                         "*************** Model 22 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. \n",
-                        "PT travel time_Box-Cox_time [alt. spec.] <Language, CarAvail>\n",
+                        "Cte. <Language>\n",
+                        "PT travel time [alt. spec.] <TripPurpose>\n",
                         "PT travel cost_Box-Cox_cost [alt. spec.] \n",
-                        "Transfers [alt. spec.] <Occupation>\n",
                         "\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. \n",
-                        "Car travel time_Box-Cox_time [alt. spec.] <Language, CarAvail>\n",
+                        "Cte. <Language>\n",
+                        "Car travel time [alt. spec.] <TripPurpose>\n",
                         "Car travel cost_Box-Cox_cost [alt. spec.] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose, Urban>\n",
+                        "Distance [alt. spec.] <Education>\n",
                         "\n",
-                        "Neg. log likelihood: 1019.9924490869894\n",
+                        "Neg. log likelihood: 1009.1570917624189\n",
                         "#parameters: 18\n",
                         "\n",
                         "\n",
                         "*************** Model 23 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. \n",
-                        "PT travel time_Box-Cox_time [alt. spec.] <Language, CarAvail>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "PT travel time_sqrt [alt. spec.] <TripPurpose>\n",
                         "PT travel cost_Box-Cox_cost [generic] \n",
-                        "Transfers [alt. spec.] <Occupation>\n",
-                        "PT Waiting time [alt. spec.] \n",
+                        "\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. \n",
-                        "Car travel time_Box-Cox_time [alt. spec.] <Language, CarAvail>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "Car travel time_sqrt [alt. spec.] <TripPurpose>\n",
                         "Car travel cost_Box-Cox_cost [generic] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose>\n",
+                        "Distance [alt. spec.] <Education>\n",
                         "\n",
-                        "Neg. log likelihood: 1020.6516279266862\n",
-                        "#parameters: 16\n",
+                        "Neg. log likelihood: 992.5308465026035\n",
+                        "#parameters: 21\n",
                         "\n",
                         "\n",
                         "*************** Model 24 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "PT travel time_sqrt [generic] <TripPurpose, CarAvail>\n",
-                        "PT travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "PT travel time [generic] \n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] <Urban>\n",
                         "\n",
-                        "PT Waiting time [alt. spec.] <TripPurpose, Subscription>\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. <Language, Subscription>\n",
-                        "Car travel time_sqrt [generic] <TripPurpose, CarAvail>\n",
-                        "Car travel cost_Box-Cox_cost [alt. spec.] <Gender>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "Car travel time [generic] \n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] <Urban>\n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
                         "Distance [alt. spec.] <TripPurpose, Education>\n",
                         "\n",
-                        "Neg. log likelihood: 989.1104419315169\n",
-                        "#parameters: 31\n",
+                        "Neg. log likelihood: 980.5442183028409\n",
+                        "#parameters: 25\n",
                         "\n",
                         "\n",
                         "*************** Model 25 ************************\n",
                         "Logit-------------------\n",
                         "Alternative pt [0]\n",
                         "-------------------\n",
-                        "Cte. \n",
-                        "PT travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "PT travel time_sqrt [generic] \n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
+                        "--------------------\n",
+                        "Alternative car [1]\n",
+                        "--------------------\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "Car travel time_sqrt [generic] \n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "-------------------\n",
+                        "Alternative sm [2]\n",
+                        "-------------------\n",
+                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "\n",
+                        "Neg. log likelihood: 965.1337245957665\n",
+                        "#parameters: 37\n",
+                        "\n",
+                        "\n",
+                        "*************** Model 26 ************************\n",
+                        "Logit-------------------\n",
+                        "Alternative pt [0]\n",
+                        "-------------------\n",
+                        "Cte. <Language>\n",
+                        "PT travel time [generic] \n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] \n",
+                        "\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
+                        "--------------------\n",
+                        "Alternative car [1]\n",
+                        "--------------------\n",
+                        "Cte. <Language>\n",
+                        "Car travel time [generic] \n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] \n",
+                        "-------------------\n",
+                        "Alternative sm [2]\n",
+                        "-------------------\n",
+                        "Distance [alt. spec.] <TripPurpose>\n",
+                        "\n",
+                        "Neg. log likelihood: 1036.0947951464968\n",
+                        "#parameters: 13\n",
+                        "\n",
+                        "\n",
+                        "*************** Model 27 ************************\n",
+                        "Logit-------------------\n",
+                        "Alternative pt [0]\n",
+                        "-------------------\n",
+                        "Cte. <Language, Occupation, CarAvail>\n",
+                        "PT travel time_sqrt [generic] \n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "\n",
+                        "PT Waiting time_sqrt [alt. spec.] \n",
+                        "--------------------\n",
+                        "Alternative car [1]\n",
+                        "--------------------\n",
+                        "Cte. <Language, Occupation, CarAvail>\n",
+                        "Car travel time_sqrt [generic] \n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "-------------------\n",
+                        "Alternative sm [2]\n",
+                        "-------------------\n",
+                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "\n",
+                        "Neg. log likelihood: 952.7982053710521\n",
+                        "#parameters: 51\n",
+                        "\n",
+                        "\n",
+                        "*************** Model 28 ************************\n",
+                        "Logit-------------------\n",
+                        "Alternative pt [0]\n",
+                        "-------------------\n",
+                        "Cte. <Language, Occupation, CarAvail>\n",
+                        "PT travel time_sqrt [generic] \n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "\n",
+                        "PT Waiting time_Box-Cox_time [alt. spec.] \n",
+                        "--------------------\n",
+                        "Alternative car [1]\n",
+                        "--------------------\n",
+                        "Cte. <Language, Occupation, CarAvail>\n",
+                        "Car travel time_sqrt [generic] \n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "-------------------\n",
+                        "Alternative sm [2]\n",
+                        "-------------------\n",
+                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "\n",
+                        "Neg. log likelihood: 951.8215302128433\n",
+                        "#parameters: 52\n",
+                        "\n",
+                        "\n",
+                        "*************** Model 29 ************************\n",
+                        "Logit-------------------\n",
+                        "Alternative pt [0]\n",
+                        "-------------------\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "PT travel time_sqrt [generic] <TripPurpose>\n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "\n",
+                        "PT Waiting time [alt. spec.] <Occupation>\n",
+                        "--------------------\n",
+                        "Alternative car [1]\n",
+                        "--------------------\n",
+                        "Cte. <Language, CarAvail>\n",
+                        "Car travel time_sqrt [generic] <TripPurpose>\n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "-------------------\n",
+                        "Alternative sm [2]\n",
+                        "-------------------\n",
+                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "\n",
+                        "Neg. log likelihood: 957.742583540515\n",
+                        "#parameters: 38\n",
+                        "\n",
+                        "\n",
+                        "*************** Model 30 ************************\n",
+                        "Logit-------------------\n",
+                        "Alternative pt [0]\n",
+                        "-------------------\n",
+                        "Cte. <TripPurpose, Language, Occupation, CarAvail>\n",
+                        "PT travel time_sqrt [generic] \n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "\n",
+                        "PT Waiting time [alt. spec.] <Occupation>\n",
+                        "--------------------\n",
+                        "Alternative car [1]\n",
+                        "--------------------\n",
+                        "Cte. <TripPurpose, Language, Occupation, CarAvail>\n",
+                        "Car travel time_sqrt [generic] \n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "-------------------\n",
+                        "Alternative sm [2]\n",
+                        "-------------------\n",
+                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "\n",
+                        "Neg. log likelihood: 932.6343661265355\n",
+                        "#parameters: 77\n",
+                        "\n",
+                        "\n",
+                        "*************** Model 31 ************************\n",
+                        "Logit-------------------\n",
+                        "Alternative pt [0]\n",
+                        "-------------------\n",
+                        "Cte. <TripPurpose, Language, Occupation, CarAvail>\n",
+                        "PT travel time_sqrt [alt. spec.] \n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "\n",
+                        "PT Waiting time [alt. spec.] <Occupation>\n",
+                        "--------------------\n",
+                        "Alternative car [1]\n",
+                        "--------------------\n",
+                        "Cte. <TripPurpose, Language, Occupation, CarAvail>\n",
+                        "Car travel time_sqrt [alt. spec.] \n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "-------------------\n",
+                        "Alternative sm [2]\n",
+                        "-------------------\n",
+                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "\n",
+                        "Neg. log likelihood: 930.7564974747635\n",
+                        "#parameters: 78\n",
+                        "\n",
+                        "\n",
+                        "*************** Model 32 ************************\n",
+                        "Logit-------------------\n",
+                        "Alternative pt [0]\n",
+                        "-------------------\n",
+                        "Cte. <Language, Occupation, CarAvail>\n",
+                        "PT travel time_sqrt [alt. spec.] \n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "\n",
+                        "PT Waiting time [alt. spec.] <TripPurpose>\n",
+                        "--------------------\n",
+                        "Alternative car [1]\n",
+                        "--------------------\n",
+                        "Cte. <Language, Occupation, CarAvail>\n",
+                        "Car travel time_sqrt [alt. spec.] \n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "-------------------\n",
+                        "Alternative sm [2]\n",
+                        "-------------------\n",
+                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "\n",
+                        "Neg. log likelihood: 950.5572917890883\n",
+                        "#parameters: 53\n",
+                        "\n",
+                        "\n",
+                        "*************** Model 33 ************************\n",
+                        "Logit-------------------\n",
+                        "Alternative pt [0]\n",
+                        "-------------------\n",
+                        "Cte. <Language, Occupation, CarAvail>\n",
+                        "PT travel time_sqrt [generic] <Education>\n",
+                        "PT travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "\n",
+                        "PT Waiting time_sqrt [alt. spec.] \n",
+                        "--------------------\n",
+                        "Alternative car [1]\n",
+                        "--------------------\n",
+                        "Cte. <Language, Occupation, CarAvail>\n",
+                        "Car travel time_sqrt [generic] <Education>\n",
+                        "Car travel cost_Box-Cox_cost [alt. spec.] <Urban, Education>\n",
+                        "-------------------\n",
+                        "Alternative sm [2]\n",
+                        "-------------------\n",
+                        "Distance [alt. spec.] <TripPurpose, Education>\n",
+                        "\n",
+                        "Neg. log likelihood: 947.6854098185937\n",
+                        "#parameters: 54\n",
+                        "\n",
+                        "\n",
+                        "*************** Model 34 ************************\n",
+                        "Logit-------------------\n",
+                        "Alternative pt [0]\n",
+                        "-------------------\n",
+                        "Cte. <Language>\n",
+                        "PT travel time [alt. spec.] <TripPurpose>\n",
                         "PT travel cost_Box-Cox_cost [generic] \n",
-                        "Transfers [alt. spec.] <Occupation>\n",
                         "\n",
+                        "PT Waiting time_sqrt [alt. spec.] <Occupation>\n",
                         "--------------------\n",
                         "Alternative car [1]\n",
                         "--------------------\n",
-                        "Cte. \n",
-                        "Car travel time_sqrt [alt. spec.] <Language, CarAvail>\n",
+                        "Cte. <Language>\n",
+                        "Car travel time [alt. spec.] <TripPurpose>\n",
                         "Car travel cost_Box-Cox_cost [generic] \n",
                         "-------------------\n",
                         "Alternative sm [2]\n",
                         "-------------------\n",
-                        "Distance [alt. spec.] <TripPurpose, Language>\n",
+                        "Distance [alt. spec.] <Education>\n",
                         "\n",
-                        "Neg. log likelihood: 1031.1234226425945\n",
-                        "#parameters: 14\n",
+                        "Neg. log likelihood: 1013.0358279293548\n",
+                        "#parameters: 17\n",
                         "\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "counter = 0 \n",
@@ -854,17 +1108,17 @@
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The plot below illustrates all models considered by the algorithm. Each model corresponds to one point in the graph. \n",
                 "\n",
                 "- The x-coordinate corresponds to the negative log likelihood of the model, and the y-coordinate to the number of parameters. \n",
-                "- The larger circles correspond to all models that are not dominated. \n",
+                "- The larger circles correspond to all models that are not dominated. They are in the Pareto set.\n",
                 "- The crosses corresponds to model that happened to be non dominated at some point during the course of the algorithm, but have been removed from the Pareto set afterwards, as a dominating model has been identified.\n",
-                "- Finally, the small dots corresponds to models that have been considered, but rejected because dominated by another model already in the set. "
+                "- Finally, the small dots corresponds to models that have been considered, but rejected because dominated by another model already in the set."
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 10,
             "metadata": {},
             "outputs": [
@@ -928,24 +1182,24 @@
             "cell_type": "code",
             "execution_count": 15,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "<matplotlib.legend.Legend at 0x7fc7781c18b0>"
+                            "<matplotlib.legend.Legend at 0x7f7ad06196f0>"
                         ]
                     },
                     "execution_count": 15,
                     "metadata": {},
                     "output_type": "execute_result"
                 },
                 {
                     "data": {
-                        "image/png": "iVBORw0KGgoAAAANSUhEUgAAAYoAAAEGCAYAAAB7DNKzAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjMuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8vihELAAAACXBIWXMAAAsTAAALEwEAmpwYAAA18UlEQVR4nO3de3gUZZb48e8hRInIGi8MA0GG4Cpyae6gXEVUYHVUUBgYHRYU19EFrysOrrO7zG90RdnxijPoymhUBBUBb+tdMCKiggHCHTWABARFo6CASTi/P6o66YTuTnXS1ZfkfJ4nT7qrq6tOl9hv6rznfV9RVYwxxphIGiU7AGOMManNGgpjjDFRWUNhjDEmKmsojDHGRGUNhTHGmKgaJzsAL0466SRt27Ztrd678at9lJYfBqBRkx0cPtgagMyMRpz+y2bxCtEYY1LOypUrv1HV5nU9Tlo0FG3btmXFihW1em/u1FcJVwAswIrpF9QpLmOMSWUisi0ex6n3qadW2VkxbTfGGFNVvW8opgxrT1ZmRpVtWZkZTBnWPkkRGWNMekmL1FNdjOieA8CMNzaxs+QArbKzmDKsfcV2Y4wx0dX7hgKcxsIaBmMSp7S0lB07dnDw4MFkh9IgNGnShNatW5OZmenL8RtEQ2GMSawdO3bQrFkz2rZti4gkO5x6TVXZu3cvO3bsIDc315dz1Ps+CmNM4h08eJATTzzRGokEEBFOPPFEX+/erKEwxvjCGonE8ftaW0NhjDEmKmsojDH1UkZGBt26daNz586MHj2an376qc7HXLJkCcuWLYtDdOnFGgpjTNItKiim//R3yZ36Kv2nv8uiguI6HzMrK4tVq1axdu1ajjrqKGbNmuXpfWVlZRFfs4bCGGOSYFFBMbctKKS45AAKFJcc4LYFhXFpLIIGDhzIZ599xssvv8wZZ5xB9+7dOffcc9m9ezcA06ZNY9y4cfTv359x48bx9ddfc+mll9K7d2969+7NBx98wNatW5k1axb33Xcf3bp14/3332fr1q0MGTKELl26cM4557B9+/a4xZxKrKEwtRLICyQ7BFNPzHhjEwdKy6tsO1Bazow3NsXl+GVlZbz22msEAgEGDBjA8uXLKSgoYOzYsdxzzz0V+61fv563336buXPncsMNN3DTTTfxySef8MILL3DVVVfRtm1brrnmGm666SZWrVrFwIEDue666xg/fjxr1qzh8ssv5/rrr49LzKnGxlGYWikcX5jsEEw9sbPkQEzbvTpw4ADdunUDnDuKiRMnsmnTJsaMGcOuXbv4+eefq4w7uOiii8jKcuaAe/vtt1m/fn3Faz/88AP79+8/4hwffvghCxYsAGDcuHHceuutdYo5VVlDYYxJqlbZWRSHaRTqOnFnsI8i1HXXXcfNN9/MRRddxJIlS5g2bVrFa02bNq14fPjwYZYvX06TJk3qFEN9YaknY0xSJXLizu+//56cHGc6n7y8vIj7DR06lIceeqjiebDBadasGfv27avY3q9fP+bNmwfAnDlzGDhwYNxjTgXWUDRw1tdgkm1E9xzuuiRATnYWAuRkZ3HXJQFf5mebNm0ao0ePpmfPnpx00kkR93vwwQdZsWIFXbp0oWPHjhUVUxdeeCELFy6s6Mx+6KGHePzxx+nSpQtPPfUUDzzwQNxjTgWiGm5Zn9TSq1cvre3CRcaYxNuwYQMdOnRIdhgNSrhrLiIrVbVXXY9tdxTGGGOisobCGGNMVNZQGGOMicoaCmOMMVFZQ2GMMSYqayiMMcZE5WtDISLZIjJfRDaKyAYR6SsiJ4jIWyKyxf19vJ8xGGMaptBpxi+88EJKSkqSHVJETzzxBJMnT052GBH5fUfxAPC6qp4OdAU2AFOBd1T1VOAd97kxpqFaej8U5VfdVpTvbK+D0GnGTzjhBB5++OE6Ha8h862hEJHjgEHAbABV/VlVS4CLgeDY+TxghF8xGGPSQE4PeH5CZWNRlO88z+kRt1P07duX4mJn2vLPP/+c4cOH07NnTwYOHMjGjRsBmDBhAtdeey1nnnkm7dq1Y8mSJVx55ZV06NCBCRMmVBxr7ty5BAIBOnfuzB/+8AcAZs2axZQpUyr2Cb1DePrpp+nTpw/dunXj97//PeXlzky5jz/+OKeddhp9+vThgw8+iNtn9YWq+vIDdAM+Bp4ACoDHgKZAScg+Evq82vuvBlYAK9q0aaPGmPSxfv362N7wxXuqd+eqvnOH8/uL9+ocQ9OmTVVVtaysTEeNGqWvvfaaqqoOGTJEN2/erKqqy5cv17PPPltVVcePH69jxozRw4cP66JFi7RZs2a6Zs0aLS8v1x49emhBQYEWFxfrySefrHv27NHS0lI9++yzdeHChbpnzx495ZRTKs49fPhwff/993X9+vX661//Wn/++WdVVb322ms1Ly9Pd+7cWXGcQ4cOab9+/XTSpEl1+rzhrjmwQuPwfe7n7LGNgR7Adar6kYg8QLU0k6qqiISdQ0RVHwUeBWcKDx/jNMYkW+4g6DUR8u+BQbc6z+soOM14cXExHTp04LzzzmP//v0sW7aM0aNHV+x36NChiscXXnghIkIgEKBFixYEAs5caJ06dWLr1q1s27aNwYMH07x5cwAuv/xy8vPzGTFiBO3atWP58uWceuqpbNy4kf79+/Pwww+zcuVKevfuXRHTL37xCz766KMqxxkzZgybN2+u82f2i58NxQ5gh6p+5D6fj9NQ7BaRlqq6S0RaAnt8jMEYkw6K8mHFbKeRWDEbcgfWubEI9lH89NNPDBs2jIcffpgJEyaQnZ19xPTjQUcffTQAjRo1qngcfF5WVkZmZmbE840dO5bnnnuO008/nZEjRyIiqCrjx4/nrrvuqrLvokWL6vTZEs23PgpV/Qr4UkSCcwWfA6wHXgLGu9vGAy/6FYMxJg0E+yRGPwFDbnd+h/ZZ1NExxxzDgw8+yF/+8heOOeYYcnNzef755wEn9b569WrPx+rTpw/vvfce33zzDeXl5cydO5ezzjoLgJEjR/Liiy8yd+5cxo4dC8A555zD/Pnz2bPH+Xv422+/Zdu2bZxxxhm899577N27l9LS0op4UpXfVU/XAXNEZA1On8V/A9OB80RkC3Cu+9wY01AVf+o0DsE7iNxBzvPiT+N2iu7du9OlSxfmzp3LnDlzmD17Nl27dqVTp068+KL3v1VbtmzJ9OnTOfvss+natSs9e/bk4osvBuD444+nQ4cObNu2jT59+gDQsWNH7rjjDoYOHUqXLl0477zz2LVrFy1btmTatGn07duX/v37p/xMuzbNuDEm7mya8cSzacaNMcYkjTUUxhhjorKGwhhjTFTWUBhjjInKGgpjjDFRWUNhjDEmKmsojDH11ldffcXYsWM55ZRT6NmzJ+eff37cpsqYNWsWTz755BHbt27dSufOneNyjuomTJjA/PnzfTl2NH5O4WGMMUmjqowcOZLx48czb948AFavXs3u3bs57bTT6nz8a665ps7HACgrK6Nx49T+KrY7CmNMvbR48WIyMzOrfKF37dqVAQMGMGXKFDp37kwgEODZZ58FYMmSJQwePJhRo0Zx+umnc/nllwdnsmbq1Kl07NiRLl26cMsttwAwbdo0/ud//geAlStX0rVrV7p27Vpl3Yvy8nKmTJlC79696dKlC4888kjFuQYOHMhFF11Ex44dI+6nqkyePJn27dtz7rnnVkwFkmip3YwZYxqUQF6AwvGFcTnW2rVr6dmz5xHbFyxYwKpVq1i9ejXffPMNvXv3ZtAgZ/qQgoIC1q1bR6tWrejfvz8ffPABHTp0YOHChWzcuBERCbtS3hVXXMHMmTMZNGhQlXUpZs+ezXHHHccnn3zCoUOH6N+/P0OHDgXg008/Ze3ateTm5vLoo4+G3a+goIBNmzaxfv16du/eTceOHbnyyivjcn1iYXcUxpiUEa9GIpqlS5fy29/+loyMDFq0aMFZZ53FJ598AjiT/rVu3ZpGjRrRrVs3tm7dynHHHUeTJk2YOHEiCxYs4JhjjqlyvJKSEkpKSioam3HjxlW89uabb/Lkk0/SrVs3zjjjDPbu3cuWLVsqzpWbmxt1v/z8/IpYW7VqxZAhQ3y/PuFYQ2GMqZc6derEypUrY3pP6NTiGRkZFf0HH3/8MaNGjeKVV15h+PDhno+nqjz00EOsWrWKVatWUVRUVHFH0bRpU0/7pQJrKIwJx6d1nE3iDBkyhEOHDvHoo49WbFuzZg3Z2dk8++yzlJeX8/XXX5Ofn18x22s4+/fv5/vvv+f888/nvvvuO2Ja8uzsbLKzs1m6dCkAc+bMqXht2LBh/O1vf6O0tBSAzZs38+OPPx5xjkj7DRo0qCLWXbt2sXjx4tpfkDqwPgpjwgmu4xyc/jp0zQSTFkSEhQsXcuONN3L33XfTpEkT2rZty/3338/+/fvp2rUrIsI999zDL3/5y4q1s6vbt28fF198MQcPHkRVuffee4/Y5/HHH+fKK69ERKrcCVx11VVs3bqVHj16oKo0b9487KJFkfYbOXIk7777Lh07dqRNmzb07ds3btcnFjbNuDGRuI1DoEVTCnf/WHXNBBOVTTOeeDbNuDHJ4K7jXFi03VnP2RoJ00BZQ2FMJNXXcY7T0pzGpBtrKIwJx+d1nBuCdEhr1xd+X2trKIwJJwHrONdnTZo0Ye/evdZYJICqsnfvXpo0aeLbOawz2xgTd6WlpezYsYODBw8mO5QGoUmTJrRu3ZrMzMwq2+PVmW3lscaYuMvMzKwYdWzSn6WejDHGRGUNhTHGmKisoTDGGBOVNRQpJpAXSHYIxhhTha+d2SKyFdgHlANlqtpLRE4AngXaAluB36jqd37GkU4SMc2yMcbEIhF3FGerareQEq2pwDuqeirwjvu84bJZSo0xKS4ZqaeLgTz3cR4wIgkxpI7gLKXBxiI4IjinRzKjMsaYCn6Po1DgTRFR4BFVfRRooaq73Ne/Alr4HENqC474tVlKjTEpyu87igGq2gP4J2CSiFT59lNnWHjYoeEicrWIrBCRFV9//bXPYSaZzVJqjElhvjYUqlrs/t4DLAT6ALtFpCWA+3tPhPc+qqq9VLVX8+bN/Qwz+WyWUmNMCvOtoRCRpiLSLPgYGAqsBV4Cxru7jQde9CuGtGCzlBpjUpyffRQtgIUiEjzPM6r6uoh8AjwnIhOBbcBvfIwh9UWbpdRSUMaYFGCzxxpjTD1lS6EaY4xJCGsoTMLZNCXGpBdbjyIJFhUUM+ONTewsOUCr7CymDGvPiO45yQ4rYWyaEmPSizUUCbaooJjbFhRyoLQcgOKSA9y2wPnibEiNhTEmfVjqKcFmvLGpopFo1sGZ5upAaTkz3tiUzLCMMSYiaygSbGfJgYrH+zZMD7vdGGNSiTUUCdYqOyum7cYYk2zWUCTYlGHtycrMqLItKzODKcPaJykiY4yJzjqzEyzYYd2Qq56MMenFGookGNE9J2LD0NBLZ40xqccaihRipbPGmFTkqY9CRPq7M8AiIr8TkXtF5Ff+htbwRCqd/Y81w5MZljGmgfPamf034CcR6Qr8G/A58KRvUTVQkUpn94c8NsaYRPPaUJS5q9FdDMxU1YeBZv6F1TBZ6awxJhV5bSj2ichtwO+AV0WkEZDpX1gNk5fS2VSZUC9V4jDG+M9rQzEGOARMVNWvgNbADN+iaqBGdM/hrksC5GRnIUBOdhZ3XRKo0pGdKhPqpUocxhj/1bhwkYhkAG+r6tmJCelItnCRMcbELmELF6lqOXBYRI6r68mMMcakH6/jKPYDhSLyFvBjcKOqXu9LVMYYY1KG14ZigftjEsBGZxtjUomnhkJV80QkC2ijqrZwgo9sdLYxJtV4HZl9IbAKeN193k1EXvIxrgYrUQsbWXmrMcYrr+Wx04A+QAmAqq4C2vkSUQOXqIWNrLzVGOOV14aiVFW/r7btcLyDMTY62xiTerw2FOtE5DIgQ0ROFZGHgGU+xtVg2cJGxphU47WhuA7ohDM6+xnge+AGv4JqyLyMzjbGmESqcWQ2gIiMVtXna9oW4b0ZwAqgWFV/LSK5wDzgRGAlME5Vf452jIY6MtvKZI0xdZGwkdmu2zxuC+cGYEPI87uB+1T1H4HvgIkej9OgBMtki0sOoFSWyS4qKE52aMaYBiZqQyEi/+T2R+SIyIMhP08AZTUdXERaAxcAj7nPBRgCzHd3yQNG1D78+itRZbLRWAmtd3atTH1W04C7nThpo4tw0kRB+4CbPBz/fuBWKteuOBEoUdVgI7MDCJtLEZGrgasB2rRp4+FU9UuiymSjsRJa7+xamfosakOhqquB1SLyjLuv55HZIvJrYI+qrhSRwbEGpqqPAo+C00cR6/vTXavsLIrDNApWJmuMSTSvfRTDiX1kdn/gIhHZitN5PQR4AMgWkWAD1RqwpHsYViZrjEkVdRmZnRvtDap6m6q2VtW2wFjgXVW9HFgMjHJ3Gw+8GGvQDYGVyRpjUoXX2WNLVfV7py+6Qm3TQX8A5onIHUABMLuWx6n3RnTPsYbBGJN0XhuKKiOzgeuJYWS2qi4BlriPv8C5OzHGGJMGajMyey7wA3CjTzEZY4xJIV7Xo/gJuN39McYY04B4aihEpBfw70Db0Peoahd/wjLGGJMqvKae5gBPAJcCF4b8GHOEeIxStpHOxqQOr53ZX6uqrWhnPInHKGUb6WxM6vDaUPyXiDwGvIPToQ2Aqi7wJSpjjDEpw2tDcQVwOpBJ5cp2ClhDYYwx9ZzXhqK3qtrcESZhAnkBSz8ZkyK8dmYvE5GOvkZiTAhrJIxJHV7vKM4EVolIEU4fhQBq5bHGGFP/eW0ohvsahTHGmJTldWT2NgAR+QXQxNeIjDHGpBSvI7MvAv4CtAL2AL/CWQe7k3+hmWgWFRQz441N7Cw5QKvsLKYMa28zzRpjfOG1M/vPOP0Um1U1FzgHWO5bVCaqRQXF3LagkOKSAyhQXHKA2xYUsqjA1oAyxsSf14aiVFX3Ao1EpJGqLgZ6+RiXiWLGG5s4UFoOQLMOUwE4UFrOjDc8rVJr6simFzENjdfO7BIRORbIB+aIyB7gR//CMtHsDFlLe9+G6WG3x8LSWLGx0l3T0Hi9o7gY+Am4CWfd7M+xSQGTplV2Vkzbo7E0ljGmJjU2FCKSAbyiqodVtUxV81T1QTcVZZJgyrD2ZGVmVNmWlZnBlGGxD56vKY3lNc2SrHSMpYGM8V+NqSdVLReRwyJynKp+n4igTHTBtFA80kU1pbG8plmSlY6xNJAx/vPaR7EfKBSRtwjpm1DV632JytRoRPecuPQjtMrOojhM38Ytx74ORc0gd1DlxqJ8KP4UBtxY5/MaY9KH1z6KBcB/4HRmrwz5MWkuUhqra5+z4fkJTuMAzu/nJ0BOj4THaIxJLq8js/P8DsQkR6Q01oDuOXDqSfD8BAItmlK4+0cY/QSB/EkU5h6Z7knGbK9ezmmz0BpTd57uKETkVBGZLyLrReSL4I/fwZnEGNE9hynD2tMqO4udJQeY8cYmp+opdxD0mkhh0XboNRFyB0X80k3Gl7GXc6ZMI7H0/sq7s6CifGd7PN9jjA+8pp4eB/4GlAFnA08CT/sVlEmsSCWyS99cACtmw6Bbnd/Vv7SMdzk9Yk/l1eY9xvjAa2d2lqq+IyLiThA4TURWAv/pY2wmQaqXyO7bMJ1u5WvotOwhGD/HubPIHeh8SY1+omoHt/Emd5Bz7aql8qJey9q8xxgfeL2jOCQijYAtIjJZREYCx0Z7g4g0EZGPRWS1iKwTkT+523NF5CMR+UxEnhWRo+r4GUwdhSuR7SJf8K8/X1f5pRT80ir+NPYTWArFESaV58t7jIkzrw3FDcAxwPVAT2AcML6G9xwChqhqV6AbMFxEzgTuBu5T1X8EvgMm1iJuE0fhRnQ/Un4h2/+h2nReuYNqVxprKRRHUX7sqbzavMeYOPPUUKjqJ6q6H/gBuF5VL1HVqLPHqmO/+zTT/VFgCDDf3Z4HjKhN4CZ+4jnSO6zQFEpeoCKFFcifFPOh0nYkdrBxHP0EDLm94npE/eKvzXuM8YHXqqdeIlIIrMEZeLdaRHp6eF+GiKzCWcPiLZw5okpUtczdZQcQdtSYiFwtIitEZMXXX3/tJUxTSyO653DXJQFysrMQICc7i7suCcR3YsAYKqiiSZkqplgVf1q1f8FLKq827zHGB6KqNe8ksgaYpKrvu88HAH/1uma2iGQDC3EG7T3hpp0QkZOB11S1c7T39+rVS1esWOHlVCZVBf867jXRSaFYp6wxvhORlapa5yUhvPZRlAcbCQBVXYpTKuuJqpYAi4G+QLaIBKutWgM2TWl9ZykUY9Ka14biPRF5REQGi8hZIvJXYImI9BCRsD2SItLcvZNARLKA83CWT10MjHJ3Gw+8WKdPYFJfHVMofvRLpG1fhzFJ4DX1tDjKy6qqQ8K8pwtOZ3UGToP0nKr+PxFpB8wDTgAKgN+p6qFo57fUU3qr88JIS+93KqTqMkFhPI5hTJqJV+rJ64C7d1X1z+6Jm6jqwZreoKprgO5htn8B9IkpSpO2gqO+gwP6gqO+Ae+NRbC8NnhXEprK8ioexzCmgYqaehKRP4hIX+DSkM3L/A3J1CdxWd87THltoEXT2MprI5ToxtKhHi1dFe61WNNblg4zqSpq6klELgbOAq4CVgMbgaHAUFWN4f/0urHUU/rKnfoq4f6FCVA0/YLYDvbunZB/jzP4bMjttQsoHscwJk0kKvVUAvw7MNj96YDTUEwVkfaq2q+uAZj6LdLCSNnHZNJ/+rve+y2qj1DOHRhbee3S+6FR46rHaHIcHC6zPgpjalBT1dMw4FXgFOBe4AzgR1W9whoJ40W4Ud+ZGcL+g2VHzFa7qCBCpXQ8ymsbNYY3/wgDbnaOMeBm53kjr910xjRcURsKVf13VT0H2Ao8hVPB1FxElorIywmIz6S5cKO+mx7VmNLDTkLKU79FLcprj8j3Hy6DoXfA0nud15be6zw/XFZlXz/7FawPwqQrr+Wx96jqre7jAlXtLiInqeo3vkeI9VHUN+H6LX6f8TJrtB1z//vWyo3Vy1ejlbiCt/JX66MwDUhCR2YHGwnXBHdbQhoJU/+Em612jbbjr0c9FH2G2Wiz0HqZodZmYjWmVryOzK6gqqv9CMQ0HOH6LVZldGFdvwcilq8G8gIRy2SdhZVqmKHWQz9HXdNIdUktxVp6a0wieUo9JZulnuqfiKO1vaSGou0T6TUbmW0aoESPzDYmrkZ0zzmyHLZ6aujHPdD50qpf7stmwoczw5fJRiuhDdcYBO9E0p01gsZnMaeejPFFuNTQ2gUw7/LK9NCymU5J69m3H5k+asgz1NoKgsZn1lCY1BCuBHbsHOh0SWW/w+I7nZLWfpMr93HLZAP5kzyV0KZKX4DXklxPMcVhehJjorE+CpP6rKQ1umDqqej9yuuUOzC5qSdLh6WERC9cZExyWElrzXJ6OCm6j2Y51+mjWc7zZKaeLB1Wr1hntkldof0OuYOcv5ITkFYJTffUdo3uQF4gKet7B76cR0qsKh6aDmvRlMLdP1o6LI1Z6smkLktfeJOKqacgSxsmlaWeTP034MYj/wLNHeTPl9/To5yqqlDLZjrbU13weoSm6EK3J0to2vDDmUde36J8p5EzKc9ST8YAtBvslN6CU1UVLMUdekdSw/IkSSm6mGJqclzV62srDKYVayiMgcqS2zf/SGDLIxQWfVm1FDeVRZtdN1kNRfWYgtdx8Z3O9bU+i7RifRQm6SJO55EMfx8O2z+ENn3hytdr3j9Z/Sjp2n9jfRYJZX0Upl5YVFDMbQsKvS9i5KdlM2H7cqeR2L78yJx6OMkqA03H8lMrdU5b1lCYpJrxxiYOlJYDHhcx8kton8SVrzu/3/xjzY1FLUdF13kUeA3nDeQF6jzDbVxHqjfkKVbqAUs9maQKt4hR0NbpFyQukKdHOR3aoX0Sy2bCF0vgd/Nrfn+yUirpkspJ11RZmrPUk6kXwi1iBCCQ2PTT7+Yf2XHdb7K3RiJZKZV0SuUkstTZxJ01FCappgxrj4Q8D6afFBKffooiYhomxpRK3NI5Yc4byJ8Uc2PhJR5bOMlY6skkXdupr4bdLkBRItNPtWFVTyaFpXzqSUROFpHFIrJeRNaJyA3u9hNE5C0R2eL+Pt6vGEx6yImQfoqUlkoIryO1gymVpfdX/jUfTKn4OfLYUjkmgfxMPZUB/6aqHYEzgUki0hGYCryjqqcC77jPTQMWbg3trMwMpgxrn6SIqBypHWwsglVR7QaH3z8dy1WN8ci3hkJVd6nqp+7jfcAGIAe4GMhzd8sDRvgVg0kPI7rncNclAXKysxCcO4y7Lgkkb9AdOB3ZbolsIC9QWTobaaR2iiweFOxPqN6vkM79DMmIPZ2vlx8S0kchIm2BfKAzsF1Vs93tAnwXfF7tPVcDVwO0adOm57Zt23yP0zRgkXL+L06Cku3eR2rnXQRF71UtV7W+A5MkKd9HESQixwIvADeq6g+hr6nTSoVtqVT1UVXtpaq9mjdv7neYpqELlzp6ZkxlI+FlpHZRPuwsgMwsZ/Gg0LW8LQVl0pivDYWIZOI0EnNUdYG7ebeItHRfbwns8TMGYzypnjp6ZgyU/gRD7/Q2UjvYIIydQ6C184dNIH+Ss9Jcik1+FymtEuuobUvPNBy+pZ7ctFIe8K2q3hiyfQawV1Wni8hU4ARVvTXasaw81iRMcKTz8bnQ+yrvI7Wrp66Cx8k9C8a/lIjIjTlCOqSe+gPjgCEissr9OR+YDpwnIluAc93nxvhmUUEx/ae/S+7UV+k//d2qI75Dy1qDI527jIH9u6Fll6oHijZSO7RcNXTE9O61yRkxHfq5gmyhIFNLflY9LVVVUdUuqtrN/fk/Vd2rqueo6qmqeq6qfutXDMbUODttsG9i2Uzn94Cb4bO34ezbazdpXapMfmfluiaObAoPU6/VODttsG9i8Z0EWjSFpfc6z/tNrlz8hxjy99EWEYoTT30MKVKua+oHm8LD1GuRZqetmB4k2LdQ9H7lLKy5A9OnnDXaVB4Ae9bDmmcry3WtVLdBSYc+CmOSLtI0IBXbc3o4lUkfzXK+TD+a5TxPlxRNtBRTo8aw5jmnz2XF7Mr0Wrp8NpMyrKEw9Vos04MEvpwX8TgpWwoaKcUEThpt6B3w2dtOWu3NPzp9MDGmn6J99mRdl5T971FPWUNh6rUapwcp/hTGzoEzrqGwaDuccY3zvFqfQuH4wsQH71XuIOg10Ym/10TnebCvpN/kyte6/AYOl8V8+GifPVnXJaX/e9RD1lCYem9E9xw+mDqE+8Z0A+CmZ1dVlskGc/WhCwAVvnBkeibRpaWxlLeGW8AoWK4b+tpnb1vaydSKNRSmQYhUJrv0zQVHlrOuW+D0UySztNRreWu0ctxUKdU1ac8aCtMgRCqTXf3x4iPLWcfOgc6XJK20NJAX8F7eGq0ctw6lujX1ASS7jyCe50/2Z0kHVh5rGoQay2TDcafh2HjatUzcPpSdJQdolZ3FlGHtY5sCvbar0S29P3HlrbZiXr1k5bHGxKDGMtnq3Nz+xtOu5RebnqbNDyvCj+z2orajpBNZ3mojuU0U1lCYBiGmVfRCcvsTtw9lUun1zMx8MPzIbi8ipJEC+ZMiv6coP2J5a9T31VY9GcltaSR/WENhGoSYVtELye3vLDnAh4c7Mbn0ei7b3L9yl5ID4ScZjCR3EOjhyhLW4k8pHPQwvHIzPORmBkKrmqKUt8alNDRcVVXhC/APOVXLbNNsIkErm/VH42QHYEyijOie461vISQn3yo7i2K3sfiQTlV2C01FBY8fUVE+/PyT8/iDB+Cc/4Q5o6HsoPOlHFqhFBpD9dLX7r/z8lFrFkw1Be8aivKh8DlnDY5gqqvJcZVzX5kGze4ojIkiXMoqyHMqKtgI/G6+0yiUHyKw5RGnkWjchMDet8KmegJ5ASfN5Ed5a/VU07zLnT6RoXdWpLoCWx6p1UjuSOKdFgo9Xm2P7VeqKtWrxmJlVU/G1GBRQTEz3tjETncMRjhRq6eqVxTd2xF+KIaj/8EZCR6cjDC4xnak90H8K5FCF1gadItzruC2LmPgFx2t6imNWdWTMQkSHNldNP0CcmKtnoKqixq9cjP6QzFfcRJ68AcO5d/HxtOurRxRHdp3EDq6OthPkDsofl/c1RdYqr7N60juZC2SZIszJYw1FMbEIKbqqepeuRldMZtnys/jpp9/zyEyOUpLWbnhM5Z2+x8nrdSocWLKVMON2p53eeUa37GkupJVWmslvQljDYUxMYipeqq6onwWNhrG7aVX0EW+oHe7ljxVfg5nyFr+8Gm288V8uKxWZaqx5LwDeYHwo7Y7XeKMSPcwkruuiyTFmqMPu3/uIKdsOOS8gRZN066kN1bhroXffR7WR2FMAnkeIe51VLiXfgy/+zqStfjT06Og3WA4+H3leZscB18siby2eTT1cHS69VEYk4Y8jRCPZVS4l/SL3ymaZC3+1G6wMwjxw5nOeT+c6TxvN7h2x7NUVkTWUBiTQDX2ccQ6KtxL2ifMPoEWTes0wjviut1fziPQKjuux4y4X8sukJkFpQecRadKDzjPW3ap1flTbXR6KpXQWkNhTAJ5WkiphlHhO0sOVD1ouIWLqqu2T+H4wjqNYq7y3mqLPxWePDbs4k8xHdPLfsWfwmXPQpsznc/V5kzneYznrcLLtUyQVBplbiOzjUmwqCPEPYwKPyJ9VZTPoeX/yzMZo7novb8x7cNjOef8UVXP8fINsHZB5Qjv3IHOlB0CXPhAlWPFnJMfcOORI8hzB/qT1w/tRxhwozNR4vblkN3G+b1rjbfzRuqPWPsCbHi56ueo553jXlhDYUyKmjKsPbctKKxYRwPClOIW5XNo7j9z9YHJvFfagTcbncZMZnDzglLgt05jUZTvNBLgfvENdPoQDpc55bidL60crxE6jYhXoe/LHeQc36+0TejUI7vWOH0SmVlw8cOVz8GZI8vrcYKffd7lzmtj5/j/OdKMpZ6MSVGeSnGLP+UWvYn3SjsAsLb9U0wuvZ7TD39W2ZcRTA2NnePk34N9E4HfwNg5BPInVZ0uJMyXYjBfHnbajGqlthXHKf40/nn20H6ELY84jcRlzzrb+00mkHuyU/UURiAvUBlPuP6ITpdUNhKh+9SQykqlvgS/+FYeKyJ/B34N7FHVzu62E4BngbbAVuA3qvpdTcey8lhjIotpUabg9ByDbmXR8ROY8cYm7vnxj/TPWMfG067l9MumO/sFU1BQmaIJpmugMj2VrPLRkM9xxNQniThO9dTV06Oc9Fd2m8prsWxmzaW6PpfkpkN57BPA8GrbpgLvqOqpwDvuc2NMHXhelCmkH+HQ8v9l4YK5tPlhBYFGRfykR9FqU56zhnhoWWhoyWiwDDZY+pqs8tHq/SG1nSSxLsepXkqb3cY5Rsl25/kyj6W6aVKS61tDoar5wLfVNl8M5LmP84ARfp3fmIbC07Qi1absuEVv4qFGf2FW5r30b3cSE0unoCjX7vqvymk8cgdVppFCU1a46aVajISunqYJl8qKmsoJ+RyBL+dFnGakxnRQuClM3ONUSVFFUj11tX6RUyW14u/O8zf/6Cw61W9y9GOlWEluJL6OzBaRtsArIamnElXNdh8L8F3weZj3Xg1cDdCmTZue27Zt8y1OY9Jd6Ay3XkZw5059lTsaP4YA/152FQA3NX6eGxovdGaSHf9S1ROEpmggPmmf2ohXqiZex6meuvr7cNj+IbTpC1e+XvvjxEm8Uk9Jayjc59+p6vE1Hcf6KIyJr/7T36U4ZDxG30brmJn5IC81Hs4VR79b9a/a4F/fvSby87K/cqjsMI+XDWNc43dY1+8BBgy9JCmfIelCrgsrZkPHEbDi7854ju3LK+4ojhDaSC2936k8e+9uaNXdmcV3wM1ORVoD6aMIZ7eItARwf+9J8PmNMVRNVwUbiZsP38jxv/5T1XROSIpmaVkHDpYe5rAqHx7uyL/+fB0dP7je6ddoaKqnrjqOcBqLXlc6dxJD73DST8tmHvne0H6JRo2d/Q6XOeuBDLjZed4otUYuJLqheAkY7z4eD7yY4PMbY6haettVvmDaUVMYeYk77iK0LDSk9HX1x4v5felNXFN6M2vbP8Xa9k8xqfR6Vn+8OOq5Qvse6rLyW21eq03pqqf3VJ99t8QdyZ3dxjnGlkecxuKLJUceL3TW22CJb6PGTr/P0nud9x0ui8tniRc/y2PnAoOBk4DdwH8Bi4DngDbANpzy2Ood3kew1JMxyRdTGW41NfahNEShKwlm/8qXmXfjlXry7f5GVX8b4aVz/DqnMcY/wSlFwm2PZlFBcZUR5sFZcIGG21gES3O7jIE1zzl3FcGZdz+a5Qz8SyE2MtsY40ltV/eb8camikYi4iy41cRlYaNaHsvr+TyV0YYT2r/R/XdVZ8ANHr8OM/uGatK2Sc94HMcWLjLGeFabFFJdUlb1UvWqp5weUPA0rHm24aWejDH1T9SZbyOobcoqFqEN2C3Hvk7XPmdXLdv1Y0W/2o7BCN0nOA3KZ2/HPvNuAlfks9STMcZXtU1ZeRXsAykuOYACS386uWrZrh8r+sVr2o0oI8QTGkcNLPVkjPGdn1VPoYMHm3WYyr4N0+nbaB1/PeohBuVmU7j7R2fKj/xJRywGFMgL1GqBoNC+ieDxazXtRoS7gnCxhuU2DoEWTcPGkRYjs+PFGgpjTCSR+kBubvw81zdeGP+pRp4eReHR3VmxsYgryp/n8YzR9Do9l8ChgugzxfolyvQf6Toy2xhj4ipcX0ffRusY1/idus8wG0bh0d3ptPYeRpe9yANlIxld9iKd1t5D4dHd43YOz+I1k24NrKEwxqS16n0gfRut4+HMB1nX74HY8/4ePLr5WH7iKI7hZx47dSXH8DM/cRSPbj42LscP8jSKvbb9GzGyqidjTFoL9nUE+0AGHPMl6/s8WFn1FDolSRym7875aQP/olO4sfF8Cos28ZG25/6yUXQt21C3A7sprWs+7+v25TxA4fN3RkxpFZ4yEQaF9G/E+XOGsobCGJP2qpbthhmbkTsobl+eLzf7DcP3zae3bOajw+3pLZvpKFt5udlv6rQSm5PSmsHwssuYzQUM3zefTmufobDzFMLeW4QrgY3j5wxlDYUxxsRg1ikf0mntM9xZdhmzyy9gYsar3N74GUackgMMqfVxr/m8L8PLLuP2xs/w3Gnvc/sXX3Jn2WW8/nlfPohf+LViDYUxxsQgcKiAws5TeP3zvkjJAV5vNooRp+Q4KaI62FlygNlcwNCMFRUprdnlFyBhBismWlqUx4rI1zizzcbbScA3PhzXL+kWL6RfzOkWL1jMieB7vJnN2waaZ/x4VEv5lh85mqYcYpeewNflTX8u/Xpr7IM9nJibqmrzusaWFg2FX0RkRTxqjBMl3eKF9Is53eIFizkR0i1eiG/MVh5rjDEmKmsojDHGRNXQG4pHkx1AjNItXki/mNMtXrCYEyHd4oU4xtyg+yiMMcbUrKHfURhjjKmBNRTGGGOiqtcNhYjcICJrRWSdiNzobpsmIsUissr9OT9k/9tE5DMR2SQiw1Ik3mdDYt0qIqvc7W1F5EDIa7MSFOPfRWSPiKwN2XaCiLwlIlvc38e720VEHnSv6RoR6RHynvHu/ltEZHwKxXy5G2uhiCwTka4h79nqbl8lIr7Nex9jvINF5PuQfwf/GfKe4e6/5c9EpC6zS8Q75ikh8a4VkXIROcF9LSHXOErMo93//w6LSK9q+4f9fkjUdY4lXhE5T0RWutdypYgMCXltiRtv8L/BL2o8uarWyx+gM7AWOAZnBPrbwD8C04BbwuzfEVgNHA3kAp8DGcmOt9o+fwH+033cFlibhOs6COgRem7gHmCq+3gqcLf7+HzgNZzlkc8EPnK3nwB84f4+3n18fIrE3C8YC/BPwZjd51uBk1LsGg8GXglzjAz333A74Cj333bHVIi52vsuBN5N9DWOEnMHoD2wBOgVsj3s90Mir3OM8XYHWrmPOwPFIa9V2dfLT32+o+iA8z/5T6paBrwHXBJl/4uBeap6SFWLgM+APgmIMyhqvCIiwG+AuQmM6Qiqmg98W23zxUCe+zgPGBGy/Ul1LAeyRaQlMAx4S1W/VdXvgLeA4akQs6ouc2MCWA609iuuSGK8xpH0AT5T1S9U9WdgnnsMX9Qh5t+SpH/T4WJW1Q2quinM7pG+HxJ2nWOJV1ULVHWn+3QdkCUiR9f23PW5oVgLDBSRE0XkGJy/bk92X5vsphf+HrwdBnKAL0Pev8PdlijR4gUYCOxW1S0h23JFpEBE3hORgQmMtboWqrrLffwV0MJ9HOmaJvtaQ+SYQ03EuSMKUuBN91b+ar8DrCZavH1FZLWIvCYindxtKX+N3X/nw4EXQjYn8xpHk8r/lmtyKfCpqh4K2fa4m3b6D/eP0Kjq7aSAqrpBRO4G3gR+BFYB5cDfgD/j/IP8M04658okhVkhSrxB1f/y2gW0UdW9ItITWCQinVT1h0TFHI6qqoikVc11uJhF5GychmJAyOYBqlrs5nTfEpGN7l95CVUt3k+BX6nqfnH62xYBpyY6pppE+HdxIfCBqob+lZwS17i+cP9wuBsYGrL5cvcaN8NppMcBT0Y7Tn2+o0BVZ6tqT1UdBHwHbFbV3aparqqHgf+lMr1UTNW/4Fu725IaL4CINMZJQz0bsu8hVd3rPl6Jkyc9LZHxhtjtppRwf+9xt0e6pkm/1kSOGRHpAjwGXBy8xgCqWuz+3gMsJLGpybDxquoPqrrfffx/QKaInESKX2PXWKqlnZJ8jaNJ5X/LYYlIa5xr+M+q+nlwe8g13gc8g4drXK8bimBvvoi0wfmifSb4D9c1EiflA/ASMFZEjhaRXJy/yj5OdrzuS+cCG1V1R8i+zUUkw33czo33i0TGG+IlIFi5NB54MWT7P4vjTOB7NxXxBjBURI53U39D3W1Jj9m99guAcaq6ObiziDR1/wJDRJrixLyWxIkU7y+DqQMR6YPz//Re4BPgVBHJFZGjcL6UX0pgvBFjdmM9Djir2rZkX+NoIn0/pMJ1PoKIZAOv4hQTfBCyvbH7hwQikgn8Gi/X2I/e+VT5Ad4H1uNUIpzjbnsKKATW4PwHbRmy/+04f5lvAv4pFeJ1tz8BXFNt30txOqlW4aQfLkxQjHNx0l6lOPnYicCJwDvAFpxqrRPcfQV42L2mhVStyrgSp0PwM+CKFIr5MZy7uVXuzwp3ezv3v8tq97rfniLxTnbjWY3T+d4v5Djn49yVfu5nvLHG7O4/AadzOPQYCbvGUWIe6T4+BOwG3gjZP+z3Q6KucyzxAn+kMoUd/PkF0BRYifP9tw54AA/VnTaFhzHGmKjqderJGGNM3VlDYYwxJiprKIwxxkRlDYUxxpiorKEwxhgTlTUUJmWIiIrIX0Ke3yIi03w4zxMiMioOxxksIq+4jy8Kzhwa6/FFZL/7u5WIzHcfTxCRmXWNMcy5fDmuqd+soTCp5BBwSXBAUDpR1ZdUdXodj7FTVevcgBkTb9ZQmFRShrPO703VX3BHor8gIp+4P/1Dtr8lzpz8j4nItlgaGhE5x51YsdCdJPJod/v5IrLRnZzuweCdQ5TjhP1LXUT+7N5hZIizDsMn4kxI+acw+7aVkLUGgFYi8ro46zncE7Lfb91417rzg9W0/QoR2SwiHwP9vV4bY4KsoTCp5mHgcneKh1APAPepam+cUemPudv/C2c9g07AfKCN1xOJSBOcUe9jVDWAM0nmte72R3BG3/YEmtfmg4jIDPe9VwDn4Ez70AfoBvQUkUE1HKIbMAYIAGNE5GQRaYUzydsQ9/XeIjIiyvaWwJ9wGogBOOsqGBOTejt7rElPqvqDiDwJXA8cCHnpXKCjVM6I/A8icizOl99I972vi8h3eNceKNLKOZ3ygEk4C7t8oc66A+BMnRDrlNf/gbO+yNUAIjIUZ+6iAvf1Y3Eajmgzo76jqt+7718P/ApnWowlqvq1u30OzoI2GmE71bY/S/ImjzRpyhoKk4rux5m/6vGQbY2AM1X1YOiOUvNU+snyCc5dwwnqTKMtwF2q+kgMxwhdP6Ac+//VJImlnkzKcb9Yn8OZ9CzoTeC64BMR6eY+/ABn5b/gX+3H490moK2I/KP7fBzOyoKbgHYi0tbdPia2TwDA68B04FV3RtQ3gCvduyBEJEe8rFV8pI+Bs0TkJHFmD/6tG3Ok7R+52090ZwsdXYtzmgbOGgqTqv4ChHZKXw/0cjuC1wPXuNv/hDNl+VqcL8GvgH0AIvJ/bu4+LPfu5ArgeREpBA4Ds1T1APCvwOsistI93vexfgBVfR5nzZOXcGYGfgb40D3XfKBZLY65C2f96cU4s6yuVNUXa9g+DfgQp1HdEOs5jbHZY01ac6uUylW1TET6An9T1W5xOO6x6qwaF5wqfYuq3lfX4xqTjiznadJdG+A5EWkE/Az8S5yO+y8iMh44CqcDOpa+BWPqFbujMMYYE5X1URhjjInKGgpjjDFRWUNhjDEmKmsojDHGRGUNhTHGmKj+Py7ttL3M2NXQAAAAAElFTkSuQmCC\n",
+                        "image/png": "iVBORw0KGgoAAAANSUhEUgAAAX4AAAEGCAYAAABiq/5QAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/YYfK9AAAACXBIWXMAAAsTAAALEwEAmpwYAABPEUlEQVR4nO29eXwUVbr//z6dhFUkIIoQyJC4IEuHVUYkhGUccGYEAUVQdGBgrqMXBhm/onj1N5c7o1fUEQVxBrhuqCggAuMyKm4YI+DImrCIKJElIiiC7JDl/P44Vd3VnV6T7qSTPO/Xq19dderUqVPdydNVn3oWpbVGEARBqDu4qnsCgiAIQtUihl8QBKGOIYZfEAShjiGGXxAEoY4hhl8QBKGOkVzdE4iEFi1a6Hbt2gXc9sV3xyguLQPA1WAfZafbAJCS5OKyC5uEH/zMcThcyNYUF52Ky6BZBtQ/J1ZTFwRBqDbWr1//g9b6fP/2GmH427Vrx7p16wJuy5j2FsEcUu8f1ZVh3dLCH+DDByH3EcgaBSPme9sLc6FoA2RPiXrOgiAI1Y1Saneg9hov9bRObRh0273LClixsSj0AIW5sO4ZY/Tzl8DqOd72V8dBWvfYTVYQBCEBqPGGf+rg9jRMSfJpa9JhGgCnikt59N0dwXe2jfvI582V/qAHYOX9uBe44dVxuFs2hoycuMzbvcAdl3EFQRDCUeMN/7BuaTw0wteIHts+w7P87ZFTwXcu2mCMvm3cr5wEWTdQULgHek6gYGxBHGZsiOfYgiAIoagRGn84hnVL49F3d1AUwMiHkoLKafeFufDV+5Bzt5F/MvrG7YpfEGozxcXF7Nu3j9OnT1f3VOoEDRo0oE2bNqSkpETUv1YYfjCSz73LCjhVXOppa5iSxNTB7SMbwCn7ZOQYo+9cFwQhYvbt20eTJk1o164dSqnqnk6tRmvNoUOH2LdvHxkZGRHtU+OlHhtb8klLbYgC0lIb8tAId2RePVBe9snIMetFG+I0Y0GovZw+fZrzzjtPjH4VoJTivPPOi+ruqtZc8YMx/hEben8CuWxm5MjVviBUEDH6VUe0n3WtueIXBEEQIkMMvyAItZKkpCS6du1K586dGTlyJCdPnqz0mKtWrWL16tUxmF31IoY/BO4F7oj97cUvXxAqzoqNRfSZ8SEZ096iz4wPwwdeRkDDhg3ZtGkTW7ZsoV69esydOzei/UpKSoJuqy2Gv1Zp/LEmGl978csXhIqxYmORj0de0ZFT3LvM/D9V+JmdH3379iU/P5833niDBx54gLNnz3LeeeexcOFCWrZsyfTp0/n666/ZtWsX6enpzJ49m9tuu409e/YA8MQTT5CWlsbcuXNJSkripZde4sknn6Rt27aMHz+eH374gfPPP5/nnnuO9PT0mMw5nojhFwShWnn03R0+btjgjbqPheEvKSnh7bff5uqrryY7O5u1a9eilOLpp5/mkUce4bHHHgNg27Zt5OXl0bBhQ2666Sb+9Kc/kZ2dzZ49exg8eDDbt2/ntttu45xzzuGuu+4CYMiQIYwdO5axY8fy7LPPMnnyZFasWFHpOccbMfzVhHuB2+cuwX9dEOoKwaLrQ0bdR8CpU6fo2rUrYK74J0yYwI4dOxg1ahT79+/n7NmzPn7vQ4cOpWFDE/D5/vvvs23bNs+2o0ePcvz48XLHWLNmDcuWLQPglltu4e67767UnKsKMfzVhL+RF6Mv1FVapzaMPuo+AmyN38kf//hH7rzzToYOHcqqVauYPn26Z1vjxo09y2VlZaxdu5YGDRpUag6JijzcFQShWgmUaDGqqPso+Omnn0hLM/LRggULgvYbNGgQTz75pGfd/gFp0qQJx44d87RfeeWVLFq0CICFCxfSt2/fmM85HojhjzG2d494+QhCZFQ66j4Kpk+fzsiRI+nRowctWrQI2m/27NmsW7eOrKwsOnbs6PEIGjJkCMuXL6dr16588sknPPnkkzz33HNkZWXx4osvMmvWrJjPOR4orYOVMUkcevbsqYMVYhEEIfHYvn07HTp0qO5p1CkCfeZKqfVa657+feWKXxAEoY4hhj8OiMwjCEIiEzfDr5Rqr5Ta5HgdVUpNUUo1V0q9p5Taab03i9ccqgvx0BEEIZGJm+HXWu/QWnfVWncFegAngeXANOADrfUlwAfWuiAIglBFVJXU8wvga631buBawPajWgAMq6I5JATBZCCRhwRBqCqqyvCPBl6xlltqrfdby98BLQPtoJS6VSm1Tim17vvvv6+KOVYJwWQgkYcEQagq4m74lVL1gKHAq/7btPElDehPqrWer7XuqbXuef7558d5loIg1DacaZmHDBnCkSNHqntKQXn++eeZNGlSlR2vKq74fwVs0FofsNYPKKVaAVjvB6tgDjGnpgZq1bT5CnWAvCdMzWsnhbmmvRI40zI3b96cp556qlLj1SaqwvDfiFfmAXgdGGstjwX+WQVziDm2NFMwtiBuf7jxQCQlIeFI6w6vjvP+DxXmmvW07jE7RO/evSkqMjn+v/76a66++mp69OhB3759+eKLLwAYN24ct99+O1dccQWZmZmsWrWK8ePH06FDB8aNG+cZ65VXXsHtdtO5c2fuueceAObOncvUqVM9fZxX8C+99BK9evWia9eu/OEPf6C01GQife6557j00kvp1asXn376aczONSK01nF7AY2BQ0BTR9t5GG+encD7QPNw4/To0UMnNLs+1vrhDPMeaF0Q6hjbtm2Lbgf7f+aDB2L2v9O4cWOttdYlJSX6+uuv12+//bbWWuuBAwfqL7/8Umut9dq1a/WAAQO01lqPHTtWjxo1SpeVlekVK1boJk2a6Pz8fF1aWqq7d++uN27cqIuKinTbtm31wYMHdXFxsR4wYIBevny5PnjwoL7ooos8x7766qv1J598ordt26avueYaffbsWa211rfffrtesGCB/vbbbz3jnDlzRl955ZV64sSJlTrfQJ85sE4HsKlxzc6ptT5hGXpn2yGMl0/tISMHRj4Pr47D3bIxBQdOmPUICrVLOmZBwPyv9JwAuY9Azt0R/e+Ew07LXFRURIcOHfjlL3/J8ePHWb16NSNHjvT0O3PmjGd5yJAhKKVwu920bNkSt9tIo506deKbb75h9+7d9O/fH/u545gxY8jNzWXYsGFkZmaydu1aLrnkEr744gv69OnDU089xfr167n88ss9c7rgggv47LPPfMYZNWoUX375ZaXPOVIkLXOssP5wC6L8wxWjLwgYeWfdM+Z/Z90zkNG30sbf1vhPnjzJ4MGDeeqppxg3bhypqanl0jXb1K9fHwCXy+VZttdLSkpISUkJerzRo0ezZMkSLrvsMoYPH45SCq01Y8eO5aGHHvLpW93FWiRlQ6zw/8P11/wFQQiMremPfB4G3ue5e47V/1CjRo2YPXs2jz32GI0aNSIjI4NXXzVOhlprNm/eHPFYvXr14uOPP+aHH36gtLSUV155hX79+gEwfPhw/vnPf/LKK68wevRoAH7xi1+wdOlSDh40Piw//vgju3fv5uc//zkff/wxhw4dori42DOfqkIMfyyI8x9uXUc8kWo5RRt8pVFbOi3aELNDdOvWjaysLF555RUWLlzIM888Q5cuXejUqRP//Gfk/iWtWrVixowZDBgwgC5dutCjRw+uvfZaAJo1a0aHDh3YvXs3vXr1AqBjx4488MADDBo0iKysLH75y1+yf/9+WrVqxfTp0+nduzd9+vSp8kymkpa5suQ9AYcLofN13j/cwlx4bzq0csMQR37uwlzzx5w9pRomKghVh6RlrnokLXNVktYdtr/hXbev/juPMO1xdFETBEGoCPJwtxJ4PHICePS4cydSUEFPn9qOeDIJQvUiV/yVwGO8bI+ewj3GJS0jx2xztl98la/RT9AAr6pAjL4gVC9i+GNBMI8euz1rFOQvgdVzvO0i+wiCUE2I4a8swTx6Vs/xto+YjzujLay833io2O0Ryj410aslVnOO97nXhM+2JsxRqFmI4a8sRRugwxDvuu2KtmWZabeMe8HYAsi6wUcOipSaKI3Eas7xPvea8NnWhDkKNQsx/JUle4px5fT32z/yjWm3KcyFr96XAC9BqEK+++47Ro8ezUUXXUSPHj349a9/HbPUCHPnzuWFF14o1/7NN9/QuXPnmBzDn3HjxrF06dJKjyOGPxY4c/X4STnuBW4ozMWdO9F4++xdFDTAK9Jbern1l89ACI/WmuHDh9O/f3++/vpr1q9fz0MPPcSBAwfC7xwBt912G7/97W8rPU5JSUkMZhMdYvhjRQDPHrBu0z+dTcElf/D19sm+Ez6d7TNEpLf0cusvn4EQno8++oiUlBRuu+02T1uXLl3Izs5m6tSpdO7cGbfbzeLFiwFYtWoV/fv35/rrr+eyyy5jzJgxdkZhpk2bRseOHcnKyuKuu+4CYPr06fztb38DYP369XTp0oUuXbr45P0vLS1l6tSpXH755WRlZTFv3jzPsfr27cvQoUPp2LFj0H5aayZNmkT79u256qqrPKkfKov48ceKUEmm+kw2V/itskxbYS7kzTRX/oIgeIhljMeWLVvo0aNHufZly5axadMmNm/ezA8//MDll19OTo75X924cSNbt26ldevW9OnTh08//ZQOHTqwfPlyvvjiC5RSASt5/e53v2POnDnk5OT45OV/5plnaNq0KZ9//jlnzpyhT58+DBo0CIANGzawZcsWMjIymD9/fsB+GzduZMeOHWzbto0DBw7QsWNHxo8fX+nPRq74oySQxOAj7wy8D3fLxr5Sjp8UZMs+lQnmqm1Sh3uBu9adkxA9VXEnl5eXx4033khSUhItW7akX79+fP7554BJwtamTRtcLhddu3blm2++oWnTpjRo0IAJEyawbNkyGjVq5DPekSNHOHLkiOfH45ZbbvFsW7lyJS+88AJdu3bl5z//OYcOHWLnzp2eY2VkZITsl5ub65lr69atGThwYEw+AzH8/oSpphWo4lbBRROMdGMllfJE8zqTTDmkoIK2oysdwVvbpI6CsQW17pyE6qVTp06sX78+qn2cqZiTkpIoKSkhOTmZf//731x//fW8+eabXH311RGPp7XmySefZNOmTWzatInCwkLPFX/jxo0j6hcPxPD7E0kZOP8+ad2NdOPsk5Hjm4xN0jYLQpUycOBAzpw5w/z58z1t+fn5pKamsnjxYkpLS/n+++/Jzc31ZNMMxPHjx/npp5/49a9/zeOPP14ujXNqaiqpqank5eUBsHDhQs+2wYMH849//IPi4mIAvvzyS06cOFHuGMH65eTkeOa6f/9+Pvroo4p/IA5E4/fHr5oWYHLu2B46FgV+fWjZmALrCt+dO9H0GVtgDPyW10zCNlveyejrkYbcuRPLXenWtlw2te18hJqBUorly5czZcoUHn74YRo0aEC7du144oknOH78OF26dEEpxSOPPMKFF17oqb3rz7Fjx7j22ms5ffo0WmtmzpxZrs9zzz3H+PHjUUr5XKn//ve/55tvvqF79+5orTn//PMDFmEJ1m/48OF8+OGHdOzYkfT0dHr37h2bz0bSMgfhwwe9ZeAG3hdZH2cUr/0Q99VxcNkQcF9XPlePpGgWaimSlrnqkbTMlSUSWcbRx713kVkP4M/vbtkYhs4qr+n7S0FVRCwfoEYzVri+ifRg155LIs1JEGJJXK/4lVKpwNNAZ0AD44EdwGKgHfANcIPW+nCocar0ij/QVfvLo2DAfXDlJG+fRWOg0whj1P2v7As/cRSN7itX9kKdQ674q55EuuKfBbyjtb4M6AJsB6YBH2itLwE+sNYTh0Bl4AbcBx896L3y3/KaeXdf5+0z8nlQmB+Ez+Yao//ZXLMuWTiFOkhNkJFrC9F+1nEz/EqppkAO8AyA1vqs1voIcC2wwOq2ABgWrzlUiOwp5WWZKyfBTYu9Es72N2D0Qs9DXMA8/P3xQ8+qe+8i73LuRB/ZIJ4SgsgTQjyI9u+qQYMGHDp0SIx/FaC15tChQzRo0CDifeIm9SilugLzgW2Yq/31wB1AkdY61eqjgMP2ut/+twK3AqSnp/fYvXt3XOYZFeEe+OY9Ya7ubaknaxR0u9kr9cgDXaGOUFxczL59+zh9+nR1T6VO0KBBA9q0aUNKSopPezCpJ57unMlAd+CPWuvPlFKz8JN1tNZaKRXwl0drPR/zw0HPnj2r/7IhVEoGG9u4O4uvXJjlbbefHQhCLSclJcUTlSokHvHU+PcB+7TWn1nrSzE/BAeUUq0ArPfYZB2KJ8GKrQSK8HUUX2HQA7h3zosoTUOwW+m6LN3U5XMXhHgSN8Ovtf4O2KuUam81/QIj+7wOjLXaxgL/jNccYob9wLdog6/bpr1u1871fzBcVkKByvRN0xCk1m6wAKe6HPhUl89dEOJJvCN3/wgsVErVA3YBv8P82CxRSk0AdgM3xHkOlcepyfuXTXTKN/7avSsZdn1sZJ91z0CDppKVUxCEakcid6PFknPcLRtTcOBEcPnGln2y74S8maZ/4V4Y9IA3HkAQBCGOSORurAhScKUctuxz5SRo2dn0z7oByqxqO0EkH0EQhHgjhj9aIs2yaccDFObCtxshpSHseNty9wyQ8VMQBKGKEMMfDZF69/j3H70QbloCWJk7F40JKhFVlSdLbfKYqUl5gAQhERCNPxrsAK1Is2z697cDwDL6wdjXvf1euh4y+/tq/6vnwK5VcPPSmJ+GIAh1A9H4Y0GgdA6hsmw6+zslogNbfO8SMvvDyvuNsQfzvvJ+0y4IghBjxPBXBYW5Jl9Py8aBJaIrJxlvn5X3G1li5f24M9oG9f4R6SI6JM2yIPgiUk9VEKlE9OzVsGcNpPeG8e9U9SwFQahlVEeuHsEmkBSUkeP7Q7B6DuxZa4z+nrVmXfz9BUGIAyL1xAB/CSFqScHW9Ac9YK70LdnHo/nHaF7x2kcQhJqFSD0Otiz5C199kc/i073Yc25Ppg5uz7DUr+G96dDKDUNmeTtHm2I5lNzzTZ549QiCEHPEqycMKzYW8WhBIwaU5jEv5XHSj65j+bJXOLvwRvh+O2xZ5n0YW5EArLTuvg90nWPcvLS8rHPlJDH6giDEBTH8Fo++u4OPiztwW/Gd9MlswZb2L7Lh4gWcKSkz1bdGLyxfRD1YuoZAZOSYfRxjRBLEFWhZ5Bgh0ZC/yZqFGH6Lb4+cAmBNWSd+v7OHSaVcuIdnSwbTZ3EJK45cBBdfZXLutOxMQc5TvgOEy72T94TZx5nnx2r3x5OO2N7H2V6YS8FFEypxpoIQeySFds1CDL9F69SGAPR2bWVc0juc0cloDb9P+hfpR9exfdlD6PwlJsXytxtN2oVopJ+07tEXYg8lDwmCIFQQMfwWUwe3p1/KduamzEShGFd8Dw+UjOGKzJZsaf8iL1/8MU8mjTWVtUYvNDstGhNWtgmEe+8i3K1Ty7f73y7bBV+ilIeqm0jmIjmJBKH6EK8eB06vnjVlnQB4LOXvXJeUR0FZO4ac/V++mfEb07kwF3L/BoUfBy++7sS/EHvO3aZub9EGsz1UgFe4Iu+CIAgBEK+eCOh8w58Z9uel7DnXfE69XVvp79rMrJLhtFaH6O3ayoqNRd4dDmwJn57Zxnb7dKZ0tttDSTqRpoEWBEGIEDH8AZg6uD29XVuZkzKbScWTefqS9UwqnsyclNl88K+l0adnhtD7+Ek6nsLsEHCfYF4/kSLyhxf5LIS6iEg9QXjovtvI15keyQfMHUCW2sW9v7osuvTMEFm+Hn9JJ9o00IIgCA6CST1i+IPQZ8aHFFkunk4U8PiorgzrlhbbA9p3BD0nGEkniofFgiAIgaiUxq+U6qOUamwt36yUmqmU+lmsJ5lITB3cHuVYb9JhGgAaE+wVCPcCd8WkgzDSkT1urGSJSucWqsHUpXMVhGBEdMWvlMoHugBZwPPA08ANWut+Yfb7BjgGlAIlWuueSqnmwGKgHfCNNc7hUONUV1rmdtPeCtiugELbuydSOSbvCThcCJ2v8y3OUvAaHC2CPpNDjyGyjyAIUVJZr54SbX4hrgXmaK2fAppEuO8ArXVXx8GnAR9orS8BPrDWE5I0K6jLn9bO9kiDrNK6m3w/duBXYa5Z3rqsvNGH8pW9JJhLEIQYEanhP6aUuhe4GXhLKeUCUip4zGuBBdbyAmBYBceJO1MHt6dhSpJPW8OUJKYObu9tsDxy3LkTPR45dh4fn9w6GTkweiHu1qmmT+5Es611ajmjH1CKCRPMFa2EESjvT3XLINV9fEGoK0Qq9VwI3AR8rrX+RCmVDvTXWr8QZr9C4DBGGp+ntZ6vlDqitU61tivgsL3ut++twK0A6enpPXbv3h3VicWKFRuLePTdHXx75BStUxuaVM2BHuxGGmRl94PoA7LynoCD2yB/sXdfkXsEQQhChStwKaWSgFe01gPsNq31HiCk0bfI1loXKaUuAN5TSn3h3Ki11kqpgL88Wuv5wHwwGn8Ex4oLw7qlhffg8Q+yyugb2COnMNfk6ElpaH4KP5sbvG8gXMlg5wta9ww0aAp5M70+/4IgCBEQVurRWpcCZUqpptEOrrUust4PAsuBXsABpVQrAOv9YLTjJhSRBnPZmj7ATUtgzBKz7Ez2FgT3AreV/XMmDHoA97E1uFs2xr1zHmTf6SMr+exTg0mkfD/hSJR5CEKkRCr1/BPoBrwHnLDbtdaTQ+zTGHBprY9Zy+8BfwF+ARzSWs9QSk0Dmmut7w51/IQutm572xRt8Hrd2PKL3Z49xfTb/jp0GuEtulKYaypt6TJTdCWU5w54t9lyUdYouKCjyDyCIASkssXWl1mvaGgJLDcyPsnAy1rrd5RSnwNLlFITgN3ADVGOm1g4ja5/9kx73e5ne+a0yvL2KVrn7WNvt8dw3k04XUCdslK3m+N3boIg1EoijtxVSjUE0rXWgaOX4kgiXPE7H/Ke02Eaf816p7z2bxlqd8vGFBw4ETj61tEHMIVWLKnGLrRie/wUHDhhxrKLXFjbfPbx7yMIgmBR2cjdIcAm4B1rvatS6vWYzjCBWbGxiHuXFVB05BQaOLZ9BvcuK/DN1AnGyDsrbAV6aOvoU9B2tKePx3Bn5FDQdrRnDB+DXrTBY/Q9+4x8XipyCYIQFZH68U/HPJg9AqC13gRkxmVGCcij7+7gVHEp4E3dkHzx1HKpG9wL3OFTKIdLsxxqe/YUz92AB79Ar2APGqNJ+SAPK8Mjn5FQk4n04e5arfUVSqmNWutuVlu+1jor7jOk+qWejGlvEexTesJO2OavxwfT50P1iWQMQRCECKlsyoatSqmbgCSl1CVKqSeB1TGdYQLTOkjqBsAr+RRt8DXQdqSt7ZED4ftEMoYgCEIlidTw/xHoBJwBXgZ+Au6I16QSjUCpG2zJ51RxqZF8sqeEz7fj18eTisHuE2QM99fPlJtToFQLTjmnsgVaAu1fmbHDHVekE6G2kch/05FKPSO11q+Ga4sX1S31gHnAO2XxpoDbFFB4zc7YZM/09+XPe8JE7JaVeMeRNA2CIERAZaWeeyNsq7UM65YWOltnrLJn+o/jSoaV95v3yowrCIJgEdLwK6V+Zen5aUqp2Y7X80BJlcwwgQiZrTNM9syI8R/HStNA3szKjUvlC7DEQ+KpTJ9YpamIl4RVURJlHkLtJaTUo5TqAnTFpFr4s2PTMeCjcAVUYkUiSD02KzYWUfTWDPJOtmXPuT292Tpt+eXsiciydIbDP9tnpNk/BUEQLCqUskFrvRnYrJR62epbLZG7icSwbmmQOpKJnitvhytn9p2RZekMh78vf4OmsRlXEASByDX+q6nDkbvlCCTrZN9psmWGy9IZDmdKh4H3mfeV95sfFb9xQ3nexIOaIkHIPAUhNJF69awHBgKrHAFcBVrrKvnLTSSpxwen/FKvcXmvntfvMC4/Q2Z528J55IhXjyAIMaKy2TmLtdY/WZk2baqtOEpC4C/HBHrg6r7OXJ3bBdadkbjB8DfmgYx7Ro5IPYIgVBiJ3K0IYYqveLxEcif61OMN5pETiVdJVckCIj/EDvkshUQlUqmnEXAfMAgjXrwL/FVrfTq+0zMknNQTqGDK63fAgQK4arq3/Y074Oh+KDkNhR+bu4OMvpWTaUIVaxHpRxAEB8Gknojz8VcnCWf4A+EsrTh6oXl/eRQUn4SURtB7kqmxa2+vqFQjidwEQYiQyubj76mUWqaU2qCUyrdfsZ9mDSYjx2Pw3bkTzatNC9wZ6eBKxr13Ee7WqZ7u4YKPgsoEFQgUCyc5hMvRU9uoC+coCKGIVOrZAUwFCoAyu11rvTt+U/NSI674bRYMNbIOQEY/yLkLNr4E+YtjI/XYSECXIAhhqGyunu+11q9rrQu11rvtV4znWPMpzIV9n5tlVz34diNsXQH5S0xh9HVWls3KGv1wxVwEQRBCEKnh/2+l1NNKqRuVUiPsV1xnVtOwNX5XMgx6EFIa4G6divvQe9BzPIyY7yPROF/BCLgtjEdRyH2joDrkkMrkDoq1R1R1y0HVnUdJqN1EKvW8BFwGbMUr9Wit9fgI9k0C1gFFWutrlFIZwCLgPGA9cIvW+myoMWqE1PPS9aBccOUko7fbUkzD5tDnjtgFX4lXjyAIEVLZAK7LtdbtK3jsO4DtwLnW+sPA41rrRUqpucAE4B8VHDtx6DPZXHmDMcSfzYXkhibi1plCubLBVxLQJQhCJYlU6lmtlOoY7eBKqTbAb4CnrXWFSf2w1OqyABgW7biJhOcW2/a2WTTGWxB9zBLj6eMnxQTz4Inmdj0SqSjiuVcxieJFVBPkkZowR6HmEanUsx24CCjElF9UGKknZLF1pdRS4CGgCXAXMA5Yq7W+2NreFnhba905wL63ArcCpKen99i9O4GeJQeTWz6dDccPwHf5Xm+bwlwoeA2aZ4gUIwhClVJZqefqChzwGuCg1nq9Uqp/tPtrrecD88Fo/NHuH1fsKln+QVQdh8FX73s9eBo0NYVUJLhKEIQEIiKpx+G+eQqTnM1+haIPMFQp9Q3mYe5AYBaQqpSyf3DaAEUVmHf1Eiwt86H3TLWsr973TaccgdGvzupWoaSmWMgyVb1fohy7siTCHITaSaRSz1DgMaA1cBD4GbBda90pooOYK/67LK+eV4HXHA9387XWfw+1f6J59azYWMSj7+5g1PEXmJy8nC8uvZ3Lyr6CzP7Gq8cO4srsD64UuHlp5TxvJFWzIAgVoLIBXH8FrgC+1FpnAL8A1lZwLvcAdyqlvsK4dD5TwXGqhRUbi7h3WQHpR9cxJul9ZpUM54IdL1FQv5uRdVbPMYFbrnqwyzL+lS2QLgXYBUGIIZEa/mKt9SHApZRyaa0/Asr9igRDa71Ka32NtbxLa91La32x1nqk1vpMBeZdbTz67g66luYzJ2U2/TOb8XjJSCYWT6bN1rlG4195v8nJk9IAUhqaqlyLxgRNxxzIw6fcLb4lLXnSO+fNxJ3R1lOAvVz65wBE0x5Nbp/qoDpkMUGoTUQq9byPcbt8CGiBkXsu11pfGdfZWSSS1JMx7S1uTXqDfJ3JmjKv0tXbtZVXOv4bGjWH/MU8lzSSY2dKmJy8nIMtruCCSe9GdoBQAVpff+hN7+wswJ7RD8bW3UqYgiAEprJSz7XASeBPmLq7XwNDYje9mkPr1IbMKx3iY/QB9pzbE/pM5swXK/l72XVcV/IWY5PeYVbJcJK/30reymWRHcBf1rFlHFeykZBSGprgsNVzzHtKQ9Mu+XoEQYiQsIbfSrnwpta6TGtdorVeoLWebUk/dY6pg9vTMCXJp61hShIPdz8Cr47jLv0nPim5DI0mO/N81pZ1ZGLxZDqtviMy4xzEY4i8mSYY7KYlUFZiJKSyErMeIEgMIpd3qkLuifaY0R6/ssFswcapipw5VSk1iawlQORSzwfACK31T/GfUnkSSeoBr1fPt0dO0Tq1IVMHt2fYiVchrTsZ8455pCCALLWLeaVDjBT063pmgB8LTT1eW84pzIUtr0EzR5BXqELutteQU+KpSGF3QRBqNZUN4DoOFCil3gNO2I1a68kxml+NYli3NIZ1S/NrnQJA69QPmXfEq4KtwUhCe87tCdkDjTH+5DHYusxbqcu/cleoQu6FuXBgi29K5oycihV2FwShThKpxr8M+P+AXExGTfsl+BFMCpo62MpxF6hSV+tUbzlGv7TL7paNvTKOtc3dsnH5lMwBJCJ3y8YVjhiOpyRQEWkp0anp8xe81IXvUmruxoGAUpD/HYIt5YBvFa1AXj1v3GHipJtneLfZMk5ad185p7oqc0m6aEFIOCpVbF0pdQnGlbMj0MBu19oSsuNMTTP8YbGLtpQWG13elRK6AHukBdbt9p4TyktE8UaKwAtCwlFZd87nMDnzS4ABwAvAS7GbXh3CNvpg0jbftMQsLxoT3OsnjIzjXuD2MbTuvYt8ZCB/L5VoPGAivu31DzILYfRr2610IlTLSsTPNBHnJBgiveJfr7XuoZQq0Fq7nW1xnyG17Io/74nQXj0QXDI5eyK4jJMoUks4qSlR5ikIdYDKXvGfUUq5gJ1KqUlKqeHAOTGdYV0hewoMneVr+DJyjBtm9pTQAVyhCqxnTyl/dZ2RU7XGNJIi8MHOT/IMCUKVEanhvwNoBEwGegC3AGPjNam6QkR5eWxZx87r7/D0CVe5qyJBWBUJhPKXmpweR5GcnzwHCI1IJvGnrn3GUXn1KKXOxVTeOha/KZWnVkk94bClkMJPvJLJiYPGq2foLG8fZ1pm5zp4r55t+aQqpJRoJJy8J+DgNshf7FupTOQeQYgplQrgUkr1xDzgbWKt/wSM11qLL3+sSevuffibc7fJxwPe4C67jzM4y07TPOgBaJXlGxBWVYFc0RSBdyVD/pLAlcoEQYg7kUo9zwL/qbVup7VuB0zE/BAIccS9d1HgDX5ePu6d84zRz5tpUjRbV/7u3IneXD9FGypU1D0W+ByvMNcY+QpWKgs5dpz2qWsygFD7idTwl2qtP7FXtNZ5GNdOIdYUbTBX6j+/jYLCPfDz28x60Qbffhk50HMCBYV7KGg72lT+stZBQ/tfmeWLrzKGNq07BWMLADzvVYXP8Yo2mB8t53yzbvDKVJUZO077VPXnJQjxJlLD/7FSap5Sqr9Sqp9S6u/AKqVUd6WUuGPEAM9VpS2ZOL1jnO02lgeNOyPd3BmsnuPdBwX5S3BnpJv3lo3N1b/jWMGyZUaSRTOSbUGxvY+cHkBfvR/Wq6eiD7AjIZox5OpfqA1E6sf/UYjNWms9MHZTKk+dergbKAL25VEw4D5zlWw/yP34Yeg8wriBvnmnMaKDHjQa/0vXgy41V9FZo4xhzb7Tt0ZvdSJRvoJQJVQ2O+eHWuu/WgM10FqfjunsBC+2FGIbwIwcY/Q/sox6Wndj2F1JJhNnYS5sfsWkaSgrMft3uxnWPQsXdjFGv+Mws/9Ni6vzzLwEOseRz5t2MfyCEHdCSj1KqXuUUr2B6xzNq+M7pbqN++tnyhu/KycZo/3qOCPZJNfH3aaF9+HtTYvhmplm37TusG2FeXh6dJ+ReQ69BwPu85F7ws4jDhKKj5xVBcFm8ZZlghVsiacsJQixIKTUo5S6FugH/B7YDHwBDAIGaa13hBxYqQaYNM71MXcWS7XW/62UygAWAedhUjvforU+G2qs2iD1RJSxMxzOdAgQODWC05/e7p81Ck7+CH0mS6oEQahDVDRlwxHgv4CvgP6AXd5pmlIq3JX/GWCg1roL0BW4Wil1BfAw8LjW+mLgMDAhwnOosazYWMS9ywooOnIKDRQdOcW9ywpYsbEo8kGcD0M/m2tegVIjBHt4mtlfUiUIggCEN/yDgbeAi4CZwM+BE1rr32mtrwy1ozYct1ZTrJcGBgJLrfYFwLCKTb3m8Oi7OzhVXApAkw7TADhVXMqj75qbJqdHjdPjxrNcmGtkmpHPQ0Zf78AZfQNn4QyUqTNvpnnA66zla+ns/sd0vgdarqgHUG2UOqI9r9r4GQg1j0i9ejZjrsy7Aw8CO4DDWushYfZLwsg5FwNPAY8Ca62rfZRSbYG3tdadA+x7K3ArQHp6eo/du3dHcVqJRca0twj0KSugcMZvgu9oyzZ2wZWMHG9t3c7XBU/JECp9QqgMn4Ig1Coqm53zXa31Oq31fGCf1job+F24nbTWpVrrrkAboBdwWaQT1lrP11r31Fr3PP/88yPdLSFpndowqnYPdmoGZ9WtL97w1tW1Db3/g9FgD0/TuofPnikIQq0nIsOvtb7bsTrOavsh0oNorY8AHwG9gVSllO1G2gaIQuiumYStwxsMv0yWXrknJ2LPkUDyT7l6vSH2j3RbJISThhJRBknEOdUmEunzTaS5xJu41dxVSp0PFGutjyilGgIrMQ92xwKvaa0XKaXmAvla67+HGqvOefU4pRpnJsuMfjD29Yp540gBFEGoc1Sq5m4FD5iFeXibhLmzWKK1/otSKhPjztkc2AjcrLU+E2qs2mD4o8J5db4/H1beB0n1Ibk+9LvHm8lSgp0EQQhBZTX+qNFa52utu2mts7TWnbXWf7Had2mte2mtL9Zajwxn9OskdiTrojG4d84zOXeS6+NunQor7/ept2sTae6dSJEMloJQe4nbFX8sqXNX/LYsk/s3KPzYBGCBkXuyRkFKQ1OfVyQaQRBCUNlcPUJV4izGkjXKGHx7ecfbZtlZmEUQBCEK4ib1CLHBfWyNz7K7dap3PUjgV9CxIuznP77//hXtF6x/VSKSVPUTq+9AvsuKI1JPNWJ7+gw5toSiRh34wyU/0bnhIRPf3OIS2LnSSD3NM+HsSTj+nfHBz+jrDeqyvXICee3YwV5DZnnbxJNHEOoMVf5wVwiNM3/PZp3J9LOP8kbBQc5uXgoFS0wa5X2fQ1I9+HEXnDpstH27Bq8zuMu57szFs3UZbFkm+XkEQfBBDH814czfs6X9i0wqnsytrhX0aNscik+atMttWoAr2evV08ZEMLtzJ5qXVVnLDu5yt2zsrcObOxF361QjDfnl5/HsE0FenmBEIisF65tot+iReEBVV71iQYgHIvVUE4Hy9/wp+VXuSF7OURpzLicAONy0A82GPWL8+dc/D03bwK6PvMFcb9xhpKGhs4zcs2UZfLfZbL9ooKnWVbAE9m/2lYlE6hGEWo9IPQmGf56e3q6t3Jz0Pq+VZnOOPoHWcFa7aHpkO7s+fskEbZ13sTH6mQPgwBZTZ3fLMiPpFOYaI//dZjPgvs/hyB4T/LV/s/EI+myu8RYSqUcQ6jRi+KsJZ/6e3q6tzEmZzd9LhnKVaz2nqE9WZjrFpNAlM51r1Roj6xRvNbLPd/lmfec8I+WMXugJ9iKlEaQ0MlLRofdMMfaMdI9HkLt1arnC6/7Lobx3Ar0i2TfQOP7HjxehpKZIjl/ZilpVFUQXj/2ryztLJLX4IlJPNeLv1dP65HZ+pg7wRllvACYmrSA7aSsHy5pygesn9rQZyo0//I5Rx19gcvJy9rQZSvplPYxss2Co8QDKuRv2fmaWAZq0ghaXmvWMfuauoTAXrpkJn86WqlyCUIuRAK4EZFi3NCtR20AA+sz4kKIjpwBzF9DBtYfXSrMZnvQpe9oM5Zy9H3F1SRPGJL/PrJLh3LL3ffLSh5NdmGukH7s6V4mVBUO54Nh+OHHQrO9ebQx7z/HmQa9VmMWT98eZI0gQhFqLSD0JhC3/OKWfAa7NbO00lSb7VvFmaS/uS36Z/pnNeLxkJP0ym3H7/v/2pGt2711kpJz0ltBzAu52bYzM87M0670V7oy2pvj6yOfhykk+nkG8Os6zHoxg0lC4PsHWwx2jovtEuz0aopG1gh0/WrlJCIx8dhVDpJ4EY8XGIoremkHeybZkN9pLl14DyB40ghv/6xH+I+lNPi3rTDJlzCs1xc/+N/lpel90Hhm/e9p49fxYaIK/dq2C4wfgu3xwpUBZMTRqASd/MAFhQ2Z5JZ0XrjX9w1XlktTOglCjqPK0zLGkLhn+YDhlIH8apiTx0Ai3b37/1XNg5f3QKst49aAADU1aw7FvTZrnm5fC1hWmGldmf/iuIHS6Z6cU5C8NSYpoQUg4xJ2zhhOoileTDtNo0mFaucLt7gVu4+Fz6dWwf7Pl2dMWVBLuFlZAWOkZI+mse8Zs17t8A8L8ZAz3Arep/OUIEgsnDUUi2YTzmIlGEonGWyhenjax9vSJV5H6WJ5/dcst1X38mohc8dcgVmwsYsriTUG3Tz3nHSMNNdoDhwthfwHoEnPF37C5uco/vh/qnQONzoMjuyGpAdz8Kmx5zaR6diUb2efmpcEn8uGDtb9gu8haQi1ArvhrAcO6pZEWokB73sm2dPx0Mnkn001B9u+3e4O3zhwzRr/5RXD2uDH6AKWn4cURJhDMlWwCxfpMDj6Jwty6UbA9UO4jyXMk1BLE8NcwAkk+YGSfLe1fZGLxZI+nj7tNCxPMdWwNlJUYSadpsTeoy3pRVmy8gXbOC5rLx/OycwTtXeQp2B5UGvLb17nuT7S5f6INGAu0b7DtgLcKml+eI7vQfbTyQjgJKlJPplhJSZWRR2Ip94hMUz2I1FMDsQO/Aj3s/UPSG1zq2st1SXlwzoVwwWVGumnVBQY9YAK90F4PH4BzWhoPoEDSjX/hd/uK15Y8bPkDaqc0UhdkLaHWIlJPLWJYtzQ+nTYwoOxTgovhLhPwxanDxui7ko2b5wd/BTs13MkfTLsrxRj9zAGBpRun5GEbcKfkkZFj2mujNFJXZC2hzhE3w6+UaquU+kgptU0ptVUpdYfV3lwp9Z5Saqf13ixec6jtTB3cHuVYb9JhGv+Z/DoPltzEb1I2mUAuMDJP61TcKd9Bi8u8Ms/PWhuZJyMdt/7a47FDYW55accv/XM57x9LGimXJjpAUfhobu+DefdURCKIylOoMNcTGMfA+3wD3YLsF6mcEyoPUiTzryoqImeJdFMziJvUo5RqBbTSWm9QSjUB1gPDgHHAj1rrGUqpaUAzrfU9ocYSqSc47aa95Vn+Q9Ib5OtM1pR14qWUB8lO2gpZozi77W3qlRzlu7KmnE5qTP0LLqFVY2XuBs65EK78o3m426i58ecvK/Fe3dtyzdkTRvLIGgUj5nsnUJhrcv6cmwbu66DwE2+/mlwUXrx6hFpAlUs9Wuv9WusN1vIxYDuQBlwLLLC6LcD8GAgVxCn3zCsdwpqyTvR2baVT0l7IuZuSLf8kpfgoxdrFBeoncos7cO53a9C7VhnjXHwSPn4YfjndePPkzfTKM7Zc40o2UkfWKMhfYoLDnNsz+5vU0C9bqZ/tfvlLaq7Ukz2lfFCaLWsJQg2nSjR+pVQ7oBvwGdBSa73f2vQd0LIq5lBb8ffy6e3aylMps9l65Sxo0BRX2WlOUp8ZJTfSJTOdRy/ZyRWZF3KK+j6pmoFyco0doEXeTCN1HFtjAsFW3u8bwLVzHvS7x6SCbp1qvIhSGpp1hzwCwb18QnnpVDQQLJqcP/GQKWIZpJWIgVM1lcp6TNUG4u7Vo5Q6B/gYeFBrvUwpdURrnerYflhrXU7nV0rdCtwKkJ6e3mP37t1xnWdNxvby+fbIKe6yg7gGjYCXruev2y9gm25HltpFI3XaVPgqa8h7uofx/LGrcr03HVq5TQ4f25MlaxSc/LF86uZlt0L+Yl9Pl7wn4OA20w7ecT+d7ZWPwNwBbHnNWzXMlk+cheMFQYgJ1ZKWWSmVArwGLNRaL7OaDyilWmmt91vPAQ4G2ldrPR+YD0bjj+c8azre9M4Av/FuuHkp79g5flwwJ3k2s0qG8/ukfzFc5bGirC+/Wvt/1G/QFA7tNK/zLvGVdQY9UF7n/up9r6dLRl+zPa07fPIYuOpB2VlYM8dsy+xvcgYNesDkDVo0xvwIuJJNMrm8mb7poQVBiDvxfLirMBr+j1rrKY72R4FDjoe7zbXWd4caSx7uVpwVG4tYvuwVZrqeYFKxicjd0v5F1u46QClJ9MlsAcDLjUbz0RcH+WPJ82Rlpnv2LzhwArLvNHIOULD3AO62vupcQUoH2L3GrIxe6JO7p+DbI7hbp1Jw4ISRjYCCPQe8HkfOcXKeKpf3p2BsAWBuw+1lJ5G028vB2uzjOJdjQaDxAs3XKTFEcuxA5xNJf6Fy1MTPscqzcyqlsoFPgAKgzGr+L4zOvwRIB3YDN2itfww1lhj+yrFlyV94cFMD1pR18nj+gLfC1542Q1my5xyKSzV9XAXkJG0hr8zN5Q32UT9rBGx+BQbcBx/8BVxJcNNib3bORWPMXcKFbuPVY98dvDDM1Ae+sAvcluuVh5QLtP3n4MLzp9FzAmxbIZk+BSGGVIdXT57WWmmts7TWXa3Xv7TWh7TWv9BaX6K1viqc0RcqT+cb/syec813b3v+AHRw7eG5pJE02beK9SUZ5OtMJl58lNdKs7lSbaFnWhNY96x5SLtzHu70lj4PbN25E83D3Prfw9BZnqt19wI3bv21kYu+yzfrx9aY9BDJDUyfjHTcGW28y4feCxgf4P+yiWTZM5cgD479t/kTbtxQ68GIJt1EuLiASOca7VhVQUXPrSLbo6Gi32tNQ1I21BFWbCzi3mUFnCou9VT4urNsCsNH3MjiVxcyL+VxNJrbiu9kTVkn3qj3X7hd37C77Hx+5vqeLy69nct6/xoKXjOZP+0avjl3+V6hr54DHz3ovSuwi7xk9oe+/8/cIZw5jvcm0KoTkFQfutxoHviC14/efvBr32HUhAfBEgMgJAiSsqGOM6xbGg+NcJOW2pAuahfT601l+IgbGdYtjT3n9uSN0it4q7S3Jw7gZ+ogxVqRrr4nt7QzrXcsoPjFkVCwBL7daB7ufrvRGHJnmoaPHjSykG2o9/7bGP29/zbePP2csXqW0T+nFZSeMfWBbewUEK5k8756ju96IscH1Mb0FUKtQgx/HcLO8TPtwbk8ed8dHk+gqYPb84D6A/9V8nvP3cCskuGcoiFZmelMvPgofTJbkFx22uOrz8D7vP7/i8Z4pR9bFrL9/Nu0MEVe2rTA/eOHZltGG09xGHdGukkXfemvcJds96SL8MQU7JxnHgqvvN8TUxAuS2Yg2aMisop/W8T+336ZPT2pHxx3ANHISJH0r+i5hdsnXkQzl8ruW1vlmsogUo8AeGMBhhxbwmadSZbaRb7O5ArXNu5IXg5AQVk7zsm4nJsP3MS3R07ROrUhD3c/Qvb+5430c2EWDH7Qm8nTlWwielu6jYTzxh3w5XvQ/mpzFdw0zchAzTLhvIvA5YLjP8CtH3onZj8UTu8Ne9bUrCyZktlTqGZE6hFC4rwb2HNuT08x93FJ73BS1+Okrkc710Gm77qMoiOn0EDRkVP83ye7OFOUbz3ILTBpGwpzjazx8cNwcLsx/oW5JjhsxFzjvZORA7s+torE/GTkoN1rTCyBLZGsnmNiCTIHwJ61pm9NyZIpmT2FBEYMv1COqYPb0y9lO3NTZqJQTCieyu1l96DRPOl6jN6urTTpMI3erq1suHiB8f4ZMR8GPeD1+rE9fuw0Dv5pILatMP2PrfFN+9A61Vv8ZOX90HO8yRya0dbT1z+DKASXS6JNBRELDxqfIvRWZk8fzb8Cxww1h2jGiUdqilDHcr77t1dmzHhQlyQhkXqEgGxZ8he++iKfxad7sefcnkwd3J7Fry7kGtca9uiWzCsdwrMpD/NpWWeeKf0NT4zqyrCtd0DRejhleejm3A0NmprMn3bt35y7oV5jr9eLMz3EBR2N18uCoUY6stvsh6IFr0HzDPHqEYQIqfIArlgihj8x6GOnf7CwHwRPKp7MpqQsPmj9D1ofWOXdwZUCZcXWewlk3WDSPdgPOu0r454TjBxip2xYNAZKiyEpBUYvNG2O0oeCIESGaPxCpfHPBLqmrBP9M5sxJ2U2yRdPZXCjXcZLByso62etPO+2rBOoWIt77yIjhywa45GIGLPEKxE5ir9A8ECsYMFeTiKRSMJ51QRrDxZkVpUeMoHmVNnxqoq6JLU4qY7zlit+ISpWbCxiyuJNPm1/Sn6VO5KXs6W0HZ3HPwkf/a/xwLHYw4Uc7TiGzkdWQeuu8NM++HEX9Bhnrvp1Gdy8FF6/w7j2D7GCuGwZKKMfjH29is5QEGoPcsUvxIRh3dJ8ir/0dm3l5qT3mVUynLSkH2HrCvSeNZRoF1qD1tBGf8fmgnxKv9tiJJ1dq4zR/+hB2Pmu8egB4/JpG32nV8yBLeIVIwgxRAy/EDW25OPU+Oeq0Rxu9ytY9wzFJHGC+rxY+guyMtNRwIyLd9D1ZyYjpzu9pQnMatPCSEFWwJePTGNp+rYMFKqgi7/nTiT5dwJ5+wSTiYJJJ8Ekp8oQabBVNPJUOOkr1pJUPHPnxOs4dQ2ReoQKsWJjEUVvzSDvZFuP18+wrXfAqcNs3HOYR0pHs6asExOS3uL3Sf+ileuw2dEOxAK+5QL+39n/8O7fLc1bw7dpGnS+zjcY7Iedxqsne4p4yQhCBIhXj1BlOL1/eru2MjdlJimUkqTKqE8JGijRSSRRyinq8/viu9iUlMX/9T1J9qa7vN49zuIsi8aYd/HyEYSIEcMvVBl2JtCupfmeILCnyq7j7pQlJJWd4TQpPFp8A3cmL+WKzJas3XWAKzL9iruMLTBBWgGKukDgoi32fk4JIFTRk2CEKtYSaCxnURT/8UMVibHfo90eimBzdY4bzb7OfSoyn1jif/xI5lPROYf7bmoKYviFKsWWgpqd3seahv35wyU/ebx6Xl5byG7dknydyYSkt7hI7SfDdYBZJcN5omQkrVMbeqUfO5grcwC0udwb7HXqiNcbSBCEgFRLzV2h7jKsWxp0exKAmzytfwbgqS2+gWB2NtCbk95nbVlH1hzpxL3LCmjx/Wdkf7vRBIDt+gh2r7ZqAVsF3Qc9WHUnJAi1CPHqEaqcQF5Bj5eMZFLxZLa0f5Herq10Lc2n0+o7jKZ/1XTA8gayKnkF8gayCRXQFWxbKG+acN4+kXjPxJJoPX8q6hkT7nwSKTisqoLlAh0z0caKBJF6hGrB6RVkl4IE8zA4S+0CIF9n8sr/3m28eg5u81zpf1bWnpfqjzHy0Q1/9g7qrNp1uNB4BYG3aped6ycaTyDJuyPUYCSAS0gohnVLY+L9T/LK/97tExC2pqwT80qHMK90iKdOMGndKdn6OlpDsU7icrWDC07uYGRBL1ZsLPIO6qzatWWZSRG9aIxZXzTGpIeOtgqWVNMSaiFi+IVqxz8HEEDDlCSmDm5vDO3Lo3CVnuKBkjH8tngaXTLTuS95IckXT+XRd3d4pRg7p8/Oecb7p/ikyfdjrTvTQweTacrJRo48QfYxnPmGnPs6x/MfM9C6f39/IpVvAh0j3D6B9g137Ei2xbJ/pJ9TJOOFkgMrO36g4wVarsw4sSZuUo9S6lngGuCg1rqz1dYcWAy0A74BbtBaHw43lkg9tR+7Aphd2cvj1ZP3BGx7nb/uvoxnSn8DGDloQtJbuNBMKL6Hwhm/8R3MyvHzQ/MetPhxPQDPJY2k2TX/4w0Si1aqCVVNK5HloESemxB3qkPqeR642q9tGvCB1voS4ANrXRA8FcAKZ/yGT6cN9NQDJnsK3Poh7zS53tN3TVknfl98N+OL76G1QyYCPDl+9rQZSvND6zlr5Qy6oeR1li97hbyVy6KXasJV00pkOSiR5yZUG3F9uKuUage86bji3wH011rvV0q1AlZprduHG0eu+AU7KOxUcamnrWFKEg+NcHt/JGyjln0nx1Y+iEuXUoKL7MzzPfusLvyBJmMXBwz+chIoGAtM4Jinipj/tgMnPO3OALNQgV/OtmCBQZFuCzau/9wCzSnYeIHmHmlwWaC+oQLMnNsDzTNcAFdVBldV1bEqe5xqCeAKYPiPaK1TrWUFHLbXA+x7K3ArQHp6eo/du3fHbZ5CzSCoHGTj8Op5+Z2PeaOsNwBZaheXuvZyXVIen5Z2os9fV5cbc8ixJVxW/xAtrriR7EEjzMbCXHhvOrRye7OG2u2BpBKnHGRXGbM9iuzCM/Z6VUstzhTXOXcFl35EGqpVJJxXjza/OEF/dbTW87XWPbXWPc8///xg3YQ6RFA5yCZ7ijFY2VN46pw/sqasE2vKOpGvM+nv2syskuF0TNrrkT3su4iiI6fYrDMZWJpH1qf/aeSgwlzjCXRop9ct1MY6hg/+cpAr2eth9Oo4UzjeuV6VUotzbt9uNOcVTPoRaahOUNWG/4Al8WC9H6zi4wt1hGCpo7deOctj2B59d4dHOtrS/kX6ZLYAFLfv/2+vFDR6YdDKXz5tlvzjqSaWN9PrYeT37u8VVBmCefB4sAy3PTdPkrtFY3zmbV/h215LnoL3jmR4obyh/D+PUJ404c4jlPdNsH0r6i0V6+8g3Hihzr8qg7iqWup5FDiktZ6hlJoGNNda3x1uHNH4hYoQMHW0w6sn481Lyt1y2tXEgHIePP5S07zMPDo3PGTuW93XeeWc5bdBk9bQ4Ro4e8JILA1S4fQRX6mlKqSfYNJN7t9MDiT7HJ3Bb2ndofATX2no09nQZ7JIQDWMKtf4lVKvAP2BFsAB4L+BFcASIB3YjXHn/DHcWGL4hXgQqHj8vJTHSVElJq7AZRV7z8gJ+HC5X8p2/q/+49RLcvlcSVN6FkpOmyLy21ZA07awfxOoJEiub+SefvdA3kzIvtO8V2WK6WBF7q0H43z8MJSVmPJpSvnO156nPYakxk5oJDunIPjhNOa20QdNfp+/k31JC58aAH0Wl3h+JJp0MF7Ix7bPYEiTr3jS9TdvumhH6uhAFOz7AXebFiHnFStvkWBeNQUHTvjIN551MBKQY/7Bzsc5RqDjBTuvQJ44zm32crAxo0mTHeqYkXzG4TyQohmrovtE40UVCDH8ghCAsF49W16DZhkBZSEwteELB20ysgj4Sif5i+HgNr4inV+ensHjjZ6j3zn7aHZ0OzS+AE4cNNlGL+hYdZ4+4bx27DTYdqW0Zhlw0UA4ssdIPbYE1CwDhs5OHKlHvJECIoZfECqBvyxkY1/xU1ZstP4kSx7an49eeT/rdHt6sIMHS0xy6vuSX+ZI0440P7oVWnWB/fnQc7yRhKpbNrHlm4uvgvwlkHUDbH8Dik8aWajgVSg5A6VnIKm+ka0sKaza8ZeeRIoCEtCdUxBqEoHyCfVL2c5j2rrSv2kJjFlilheOhJX38WTSWEae+TMPltzEkks/4c7kpXTJbEvq0W0mrXSDw7gz2uI+9J7R1m3PmhBeMcGIJOdMKA8gjwdP9p3w1fsw6AHzPuA+SGmE+9B7JtdReksz9/SW5SSgSPIF+Z9fsP6hzi/g2Bk5IXMqRXu8QMeNtG80ROthFNaLK8JtcsUvCBES1KvHLgoPXq+elp3JKBjrkYeeTnmU8zjKO2W9PMFkXNDRpJu25Z7sKWE9kXxki0jkjUglEH+vHn+vo8W3GK+kc9PgaJGRtDL6VuxY8SRUTiV/EmG+cUau+AWhkvgHkHW+4c8motdpODJy4M5tMGaJTx6h3xdPZXjxX8nXmQxMyjfG/uB28/7V+5DW3fOwOe9kW+akzCb96DqzHiy/UCTBVpEGZDmC3zznY6/vz4fTP5kfp6NFpgzmume8+0V7rHgRLqeSP9U932pErvgFIU74u4D2dm3lqZTZFHW+HXfhM15XTuv9j8V38MaxiwHjObRq12H6ZzYjt/AIzcYu9HrhOL07HAFagTxt/Ps4ichLZPUcWHm/9zlEx2Gw7tngzyUimU8AwuUICrtvgBxK9vGdOZMikVMqkjMp3lT085GHu4JQDTjlobvOeYcuvQaQ3WhPQDllxtMvM7d0iGdfO5hsdslwJj/wfPCDRCJvWH2+uPR2JuwZFDzfEfhKIC9dD5n9TeoKDQydZX4Mdq0yXj7hchaFk1tiRUVkG3sf21MpkHxVwxHDLwgJjtNzyE418VLpVfw2+QPPFX85AgVjBbni/6LNDVyw4yUmFk/2lLssl+HUOWZFPGQimU+iYOdjAvj5bfDZXLOcKJ5KMUA0fkFIcCLJL+SD0yAPvM+TY8enn6PPhD2DmFg8mTkpsz1BaKeKS3n03R2+42bk+OYTitboh5pPguLeuyiol1LUY1XSUydQW7gxo52rXPELQgIRT6+ejGlvofEWtJ9nyUoKylcxg+glm5rmJVPDpJ6wackDIFKPINRxggWhpaU25NNpA30ba5JkUxlqyHlGVIgoACL1CEIdJ2RReyc1WLKJihp0ns4U4iFlugipEVf8SqnvMdk8q5oWwA/VcNx4UJvOBWrX+VTZubgants86ZzmaSopuZ4uLTlbevzHorJTR30y5LZuolqeOKtP/nSGY3Zb0/o0aVxPNfr2mD4QwWFqxHcTxXlW+/nUu/DiHsG2nf3uq/Uhdv2Z1rpcJasaYfirC6XUukC3STWR2nQuULvOpzadC8j51ARE6hEEQahjiOEXBEGoY4jhD8386p5ADKlN5wK163xq07mAnE/CIxq/IAhCHUOu+AVBEOoYYvgFQRDqGHXa8Cul7lBKbVFKbVVKTbHapiulipRSm6zXrx3971VKfaWU2qGUGlxtE/fO51ml1EGl1BZHW3Ol1HtKqZ3WezOrXSmlZlvzz1dKdXfsM9bqv1MpNbYGnEt/pdRPju/oz459rra+n6+UUtOq41yseQQ6n5HW31qZUqqnX/+Af1uJcD7RnItSqp1S6pTju5nr2NZDKVVgnctspZSq6nOx5hHofB5VSn1h/W8sV0qlOrYl7HdTYbTWdfIFdAa2AI2AZOB94GJgOnBXgP4dgc1AfSAD+BpIquZzyAG6A1scbY8A06zlacDD1vKvgbcxqVmuAD6z2psDu6z3ZtZyswQ/l/7AmwHGSLK+l0ygnvV9dUyg76YD0B5YBfQM97eVKOcT5bm0c/bzG+ff1t+esv4Wf5VA380gINlaftjxt5bQ301FX3X5ir8Dxvid1FqXAB8DI0L0vxZYpLU+o7UuBL4CelXBPIOitc4FfvRrvhZYYC0vAIY52l/QhrVAqlKqFTAYeE9r/aPW+jDwHnB13CfvR5TnEoxewFda611a67PAImuMKifQ+Witt2utA8XYB/vbSojzifJcAmL9rZ2rtV6rjUV9gfDfZ1wIcj4rLTsAsBZoYy0n9HdTUeqy4d8C9FVKnaeUaoS5Im5rbZtk3fI9a8sLQBqw17H/Pqst0Wiptd5vLX8HtLSWg80/kc8r2LkA9FZKbVZKva2U6mS1JfK5hKImfjehyFBKbVRKfayU6mu1pWHmb5PI5zIec0cCte+7Aeqw4ddab8fc0q0E3gE2AaXAP4CLgK7AfuCx6plh5bGurGqFv67fuWzA5CDpAjwJrKiueQnl2A+ka627AXcCLyulzq3mOUWMUuo+oARYWN1ziSd11vADaK2f0Vr30FrnAIeBL7XWB7TWpVrrMuD/8Mo5RXjvCMDcChZV7Ywj4oB1W23fXh+02oPNP5HPK+C5aK2Paq2PW8v/AlKUUi1I7HMJRU38bgJiSSKHrOX1GB38Usy82zi6Jty5KKXGAdcAY6wLDahF342TOm34lVIXWO/pGH3/ZdvQWAzHSEIArwOjlVL1lVIZwCWYh1WJxuuA7ZkzFvino/23lnfPFcBPlozyLjBIKdXMkrUGWW2JQMBzUUpdaHuEKKV6Yf6ODwGfA5copTKUUvWA0dYYiU6wv60adz5KqfOVUknWcibmXHZZf2tHlVJXWN/db/H+bVY7SqmrgbuBoVrrk45Ntea78aG6ny5X5wv4BNiGeSL/C6vtRaAAyMd8ka0c/e/DXMHsoJo8Evzm/wrm1roYozFOAM4DPgB2YjyVmlt9FfCUNf8CfD0xxmMeWn0F/K4GnMskYKv1va0FrnSM82vgS+s870uw72a4tXwGOAC8G+5vKxHOJ5pzAa6zvptNGEluiGOcnpgLqa+BOViZAxLkfL7CaPabrNfcmvDdVPQlKRsEQRDqGHVa6hEEQaiLiOEXBEGoY4jhFwRBqGOI4RcEQahjiOEXBEGoY4jhFxIGpZRWSj3mWL9LKTU9Dsd5Xil1fQzG6a+UetNaHmpnaIx2fKXUceu9tVJqqbU8Tik1p7JzDHCsuIwr1CzE8AuJxBlghBWFW6PQWr+utZ5RyTG+1VpX+gdJEMIhhl9IJEow9U3/5L/Bigh9TSn1ufXq42h/z8oN/7RSanc0PxxKqV9YCcUKrKR89a32X1v52ddbuePfDDNOwCtppdRfrTuAJKXUVGvu+Uqp/wnQt50zRzzQWin1jjL1CB5x9LvRmu8WpdTDEbT/Tin1pVLq30CfSD8bofYihl9INJ4Cxiilmvq1zwIe11pfjokOfdpq/2/gQ611J2ApkB7pgZRSDYDngVFaazemLsPtVvs8TJRmD+D8ipyIUupRa9/fAb/AhPv3wiQA7KGUygkzRFdgFOAGRiml2iqlWmOSCw60tl+ulBoWor0V8D8Yg5+NyS8v1HGSq3sCguBEa31UKfUCMBk45dh0FdBReYs2nauUOgdjzIZb+76jlDocxeHaA4Va6y+t9QXARExxkV3a5F8HE+J/a5Sn8v9h6j3cCqCUGoTJg7TR2n4O5ocgN8QYH2itf7L23wb8DJPGYpXW+nurfSGmsIgO0o5f+2JM0jShDiOGX0hEnsDkeXnO0eYCrtBan3Z2VNVTvS8SPsdc1TfXWv+IyZX0kNZ6XhRjnHEslyL/r0KMEKlHSDgsQ7kEkzzLZiXwR3tFKdXVWvwUuMFqG4QpHxkpO4B2SqmLrfVbMJXYdgCZSql2Vvuo6M4AMDUeZgBvKaWaYDKejrfuUlBKpSkrO2yU/Bvop5RqYWXBvNGac7D2z6z285RSKcDIChxTqGWI4RcSlccA50PayUBP68HoNuA2q/1/MGmlt2CM2nfAMQCl1L8s7Tsg1t3D74BXlVIFQBkmK+Mp4D+Bd5RS663xfor2BLTWr2JqOryOyQT7MrDGOtZSoEkFxtyPqT/8ESY76Xqt9T/DtE8H1mB+JLdHe0yh9iHZOYUajeWFU6q1LlFK9Qb+obXuGoNxz9FaH7dyxz8F7NRaP17ZcQUhERDNUKjppANLlFIu4CzwHzEa9z+UUmOBepgHstFo84KQ0MgVvyAIQh1DNH5BEIQ6hhh+QRCEOoYYfkEQhDqGGH5BEIQ6hhh+QRCEOsb/Dxb94nwokEINAAAAAElFTkSuQmCC\n",
                         "text/plain": [
                             "<Figure size 432x288 with 1 Axes>"
                         ]
                     },
                     "metadata": {
                         "needs_background": "light"
                     },
@@ -971,27 +1225,27 @@
             "metadata": {},
             "outputs": [],
             "source": []
         }
     ],
     "metadata": {
         "kernelspec": {
-            "display_name": "Python 3",
+            "display_name": "Python 3 (ipykernel)",
             "language": "python",
             "name": "python3"
         },
         "language_info": {
             "codemirror_mode": {
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.8.5"
+            "version": "3.10.0"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 4
 }
```

### Comparing `biogeme-3.2.8/examples/assisted/airline.py` & `biogeme-3.2.9/examples/assisted/airline.py`

 * *Files 24% similar despite different names*

```diff
@@ -7,27 +7,30 @@
 """
 
 # Too constraining
 # pylint: disable=invalid-name, undefined-variable
 
 import pandas as pd
 import biogeme.database as db
-import biogeme.models as models
 import biogeme.messaging as msg
-import biogeme.vns as vns
-import biogeme.assisted as assisted
+from biogeme import models, vns, assisted
 from biogeme.expressions import (
     Beta,
     log,
-    DefineVariable,
     Elem,
     Numeric,
     Variable,
 )
+from biogeme.assisted import (
+    DiscreteSegmentationTuple,
+    TermTuple,
+    SegmentedParameterTuple,
+)
 
+## Step 1: data preparation. Identical to any Biogeme script.
 logger = msg.bioMessage()
 logger.setDebug()
 
 # Read the data
 df = pd.read_csv('airline.dat', sep='\t')
 
 # Update some data
@@ -42,88 +45,110 @@
 
 # Definition of new variables
 
 chosenAlternative = (
     (BestAlternative_1 * 1) + (BestAlternative_2 * 2) + (BestAlternative_3 * 3)
 )
 
-DepartureTimeSensitive = DefineVariable(
-    'DepartureTimeSensitive', q11_DepartureOrArrivalIsImportant == 1, database
-)
-ArrivalTimeSensitive = DefineVariable(
-    'ArrivalTimeSensitive', q11_DepartureOrArrivalIsImportant == 2, database
+DepartureTimeSensitive = database.DefineVariable(
+    'DepartureTimeSensitive', q11_DepartureOrArrivalIsImportant == 1
 )
-Missing = DefineVariable(
-    'Missing',
-    (q11_DepartureOrArrivalIsImportant != 1)
-    * (q11_DepartureOrArrivalIsImportant != 2),
-    database,
+ArrivalTimeSensitive = database.DefineVariable(
+    'ArrivalTimeSensitive', q11_DepartureOrArrivalIsImportant == 2
 )
 
-DesiredDepartureTime = DefineVariable(
-    'DesiredDepartureTime', q12_IdealDepTime, database
+DesiredDepartureTime = database.DefineVariable(
+    'DesiredDepartureTime', q12_IdealDepTime
 )
-DesiredArrivalTime = DefineVariable(
-    'DesiredArrivalTime', q13_IdealArrTime, database
+DesiredArrivalTime = database.DefineVariable(
+    'DesiredArrivalTime', q13_IdealArrTime
 )
-ScheduledDelay_1 = DefineVariable(
+ScheduledDelay_1 = database.DefineVariable(
     'ScheduledDelay_1',
     (DepartureTimeSensitive * (DepartureTimeMins_1 - DesiredDepartureTime))
     + (ArrivalTimeSensitive * (ArrivalTimeMins_1 - DesiredArrivalTime)),
-    database,
 )
 
-ScheduledDelay_2 = DefineVariable(
+ScheduledDelay_2 = database.DefineVariable(
     'ScheduledDelay_2',
     (DepartureTimeSensitive * (DepartureTimeMins_2 - DesiredDepartureTime))
     + (ArrivalTimeSensitive * (ArrivalTimeMins_2 - DesiredArrivalTime)),
-    database,
 )
 
-ScheduledDelay_3 = DefineVariable(
+ScheduledDelay_3 = database.DefineVariable(
     'ScheduledDelay_3',
     (DepartureTimeSensitive * (DepartureTimeMins_3 - DesiredDepartureTime))
     + (ArrivalTimeSensitive * (ArrivalTimeMins_3 - DesiredArrivalTime)),
-    database,
 )
 
-Opt1_SchedDelayEarly = DefineVariable(
-    'Opt1_SchedDelayEarly',
-    (-(ScheduledDelay_1) * (ScheduledDelay_1 < 0)) / 60,
-    database,
+Opt1_SchedDelayEarly = database.DefineVariable(
+    'Opt1_SchedDelayEarly', (-(ScheduledDelay_1) * (ScheduledDelay_1 < 0)) / 60
 )
-Opt2_SchedDelayEarly = DefineVariable(
-    'Opt2_SchedDelayEarly',
-    (-(ScheduledDelay_2) * (ScheduledDelay_2 < 0)) / 60,
-    database,
+Opt2_SchedDelayEarly = database.DefineVariable(
+    'Opt2_SchedDelayEarly', (-(ScheduledDelay_2) * (ScheduledDelay_2 < 0)) / 60
 )
-Opt3_SchedDelayEarly = DefineVariable(
-    'Opt3_SchedDelayEarly',
-    (-(ScheduledDelay_3) * (ScheduledDelay_3 < 0)) / 60,
-    database,
+Opt3_SchedDelayEarly = database.DefineVariable(
+    'Opt3_SchedDelayEarly', (-(ScheduledDelay_3) * (ScheduledDelay_3 < 0)) / 60
 )
 
-Opt1_SchedDelayLate = DefineVariable(
-    'Opt1_SchedDelayLate',
-    (ScheduledDelay_1 * (ScheduledDelay_1 > 0)) / 60,
-    database,
+Opt1_SchedDelayLate = database.DefineVariable(
+    'Opt1_SchedDelayLate', (ScheduledDelay_1 * (ScheduledDelay_1 > 0)) / 60
 )
-Opt2_SchedDelayLate = DefineVariable(
-    'Opt2_SchedDelayLate',
-    (ScheduledDelay_2 * (ScheduledDelay_2 > 0)) / 60,
-    database,
+Opt2_SchedDelayLate = database.DefineVariable(
+    'Opt2_SchedDelayLate', (ScheduledDelay_2 * (ScheduledDelay_2 > 0)) / 60
 )
-Opt3_SchedDelayLate = DefineVariable(
-    'Opt3_SchedDelayLate',
-    (ScheduledDelay_3 * (ScheduledDelay_3 > 0)) / 60,
-    database,
+Opt3_SchedDelayLate = database.DefineVariable(
+    'Opt3_SchedDelayLate', (ScheduledDelay_3 * (ScheduledDelay_3 > 0)) / 60
 )
 
+## Step 2: identify and name the relevant attributes of the alternatives
+# Define the attributes of the alternatives
+
+attributes = {
+    'Fare direct': Fare_1,
+    'Fare same': Fare_2,
+    'Fare multiple': Fare_3,
+    'Legroom direct': Legroom_1,
+    'Legroom same': Legroom_2,
+    'Legroom multiple': Legroom_3,
+    'Time direct': TripTimeHours_1,
+    'Time same': TripTimeHours_2,
+    'Time multiple': TripTimeHours_3,
+    'Early direct': Opt1_SchedDelayEarly,
+    'Early same': Opt2_SchedDelayEarly,
+    'Early multiple': Opt3_SchedDelayEarly,
+    'Late direct': Opt1_SchedDelayLate,
+    'Late same': Opt2_SchedDelayLate,
+    'Late multiple': Opt3_SchedDelayLate,
+}
+
+## Step 3: define the group of attributes
+
+# Group the attributes. All attributes in the same group will be
+# associated with the same transformation, and the same
+# segmentation. Attributes in the same group can be generic or
+# alternative specific, except if mentioned otherwise
+
+groupsOfAttributes = {
+    'Fare': ['Fare direct', 'Fare same', 'Fare multiple'],
+    'Legroom': ['Legroom direct', 'Legroom same', 'Legroom multiple'],
+    'Time': ['Time direct', 'Time same', 'Time multiple'],
+    'Early': ['Early direct', 'Early same', 'Early multiple'],
+    'Late': ['Late direct', 'Late same', 'Late multiple'],
+}
+
+## Step 4: force some groups of attributes to be alternative specific.
+# In this example, no variable must be alternative specific
+genericForbiden = None
+
+## Step 5: force some groups of attributes to be active.
+# In this example, all the variables must be in the model
+forceActive = list(groupsOfAttributes.keys())
 
-# Definition of potential nonlinear transforms of variables
+## Step 6: define potential transformations of the attributes
 def incomeInteraction(x):
     """Defines an interaction with income"""
     return 'inc. interaction', x / Variable('Cont_Income')
 
 
 def incomeInteraction2(x):
     """Defines another interaction with income"""
@@ -133,30 +158,30 @@
 def logincomeInteraction(x):
     """Defines an interaction with between the log and income"""
     return 'inc. interaction', log(x) / Variable('Cont_Income')
 
 
 def sqrtincomeInteraction(x):
     """Defines an interaction with between the sqrt and income"""
-    return 'inc. interaction', x ** 0.5 / Variable('Cont_Income')
+    return 'inc. interaction', x**0.5 / Variable('Cont_Income')
 
 
 def mylog(x):
     """Log of the variable"""
     return 'log', Elem({0: log(x), 1: Numeric(0)}, x == 0)
 
 
 def sqrt(x):
     """Sqrt of the variable"""
-    return 'sqrt', x ** 0.5
+    return 'sqrt', x**0.5
 
 
 def square(x):
     """Square of the variable"""
-    return 'square', x ** 2
+    return 'square', x**2
 
 
 def piecewise(x, thresholds, name):
     """Piecewise linear specification"""
     piecewiseVariables = models.piecewiseVariables(x, thresholds)
     formula = piecewiseVariables[0]
     for k in range(1, len(thresholds) - 1):
@@ -195,164 +220,235 @@
 
 
 def boxcox_fare(x):
     """Box-Cox transform of the variable fare"""
     return boxcox(x, 'fare')
 
 
-# Define all possible segmentations
+## Step 7: Associate each group of attributes with possible
+## transformations. Define a dictionary where the keys are the names
+## of the groups of attributes, and the values are lists of functions
+## defined in the previous step.
+nonlinearSpecs = {
+    'Time': [
+        mylog,
+        sqrt,
+        square,
+        boxcox_time,
+        piecewise_time_1,
+        piecewise_time_2,
+    ],
+    'Fare': [
+        incomeInteraction,
+        incomeInteraction2,
+        logincomeInteraction,
+        sqrtincomeInteraction,
+        mylog,
+        sqrt,
+        square,
+        boxcox_fare,
+    ],
+    'Legroom': [mylog, sqrt, square],
+    'Early': [mylog, sqrt, square],
+    'Late': [mylog, sqrt, square],
+}
+
+
+## Step 7: define the potential segmentations
 all_segmentations = {
-    'TripPurpose': (
-        q02_TripPurpose,
-        {
+    'TripPurpose': DiscreteSegmentationTuple(
+        variable=q02_TripPurpose,
+        mapping={
             1: 'business',
             2: 'leisure',
             3: 'attending conf.',
             4: 'business & leisure',
             0: 'unknown',
         },
     ),
-    'Gender': (q17_Gender, {1: 'male', 2: 'female', -1: 'unknown'}),
-    'Education': (
-        q20_Education,
-        {
+    'Gender': DiscreteSegmentationTuple(
+        variable=q17_Gender,
+        mapping={1: 'male', 2: 'female', -1: 'unknown'},
+    ),
+    'Education': DiscreteSegmentationTuple(
+        variable=q20_Education,
+        mapping={
             1: 'less than high school',
             2: 'high school',
             3: 'some college',
             4: 'associate occ.',
             5: 'associate acad.',
             6: 'bachelor',
             7: 'master',
             8: 'professional',
             9: 'doctorate',
             -1: 'unkonown',
         },
     ),
-    'Importance': (
-        q11_DepartureOrArrivalIsImportant,
-        {1: 'departure', 2: 'arrival', 3: 'not important'},
-    ),
-    'Who pays': (
-        q03_WhoPays,
-        {1: 'traveler', 2: 'employer', 3: 'third party', 0: 'unknown'},
+    'Importance': DiscreteSegmentationTuple(
+        variable=q11_DepartureOrArrivalIsImportant,
+        mapping={1: 'departure', 2: 'arrival', 3: 'not important'},
+    ),
+    'Who pays': DiscreteSegmentationTuple(
+        variable=q03_WhoPays,
+        mapping={1: 'traveler', 2: 'employer', 3: 'third party', 0: 'unknown'},
     ),
 }
 
 # Define segmentations
 segmentations = {
-    'Seg. cte': all_segmentations,
-    'Seg. fare': all_segmentations,
-    'Seg. time': all_segmentations,
-    'Seg. delay': all_segmentations,
-    'Seg. legroom': all_segmentations,
-}
-
-# Define the attributes of the alternatives
-variables = {
-    'Fare direct': Fare_1,
-    'Fare same': Fare_2,
-    'Fare multiple': Fare_3,
-    'Legroom direct': Legroom_1,
-    'Legroom same': Legroom_2,
-    'Legroom multiple': Legroom_3,
-    'Time direct': TripTimeHours_1,
-    'Time same': TripTimeHours_2,
-    'Time multiple': TripTimeHours_3,
-    'Early direct': Opt1_SchedDelayEarly,
-    'Early same': Opt2_SchedDelayEarly,
-    'Early multiple': Opt3_SchedDelayEarly,
-    'Late direct': Opt1_SchedDelayLate,
-    'Late same': Opt2_SchedDelayLate,
-    'Late multiple': Opt3_SchedDelayLate,
-}
-
-
-# Group the attributes. All attributes in the same group will be
-# assoaited with the same nonlinear transform, and the same
-# segmentation. Attributes in the same group can be generic or
-# alternative specific, except if mentioned otherwise
-groupsOfVariables = {
-    'Fare': ['Fare direct', 'Fare same', 'Fare multiple'],
-    'Legroom': ['Legroom direct', 'Legroom same', 'Legroom multiple'],
-    'Time': ['Time direct', 'Time same', 'Time multiple'],
-    'Early': ['Early direct', 'Early same', 'Early multiple'],
-    'Late': ['Late direct', 'Late same', 'Late multiple'],
+    'Seg. cte': SegmentedParameterTuple(
+        dict=all_segmentations,
+        combinatorial=False
+    ),
+    'Seg. fare': SegmentedParameterTuple(
+        dict=all_segmentations,
+        combinatorial=False
+    ),
+    'Seg. time': SegmentedParameterTuple(
+        dict=all_segmentations,
+        combinatorial=False
+    ),
+    'Seg. delay': SegmentedParameterTuple(
+        dict=all_segmentations,
+        combinatorial=False
+    ),
+    'Seg. legroom': SegmentedParameterTuple(
+        dict=all_segmentations,
+        combinatorial=False
+    ),
 }
 
-# In this example, no variable must be alternative specific
-genericForbiden = None
-
-# In this example, all the variables must be in the model
-forceActive = list(groupsOfVariables.keys())
-
-# Associate a list of potential nonlinearities with each group of variable
-nonlinearSpecs = {
-    'Time': [
-        mylog,
-        sqrt,
-        square,
-        boxcox_time,
-        piecewise_time_1,
-        piecewise_time_2,
-    ],
-    'Fare': [
-        incomeInteraction,
-        incomeInteraction2,
-        logincomeInteraction,
-        sqrtincomeInteraction,
-        mylog,
-        sqrt,
-        square,
-        boxcox_fare,
-    ],
-    'Legroom': [mylog, sqrt, square],
-    'Early': [mylog, sqrt, square],
-    'Late': [mylog, sqrt, square],
-}
 
-# Specification of the utility function. For each term, it is possible
-# to define bounds on the coefficient, and to include a function that
-# verifies its validity a posteriori.
+## Step 8: Specification of the utility function. For each term, it is possible
+## to define bounds on the coefficient, and to include a function that
+## verifies its validity a posteriori.
 
 utility_direct = [
-    ('Fare direct', 'Seg. fare', (None, 0), None),
-    ('Legroom direct', 'Seg. legroom', (0, None), None),
-    ('Early direct', 'Seg. delay', (None, 0), None),
-    ('Late direct', 'Seg. delay', (None, 0), None),
-    ('Time direct', 'Seg. time', (None, 0), None),
+    TermTuple(
+        attribute='Fare direct',
+        segmentation='Seg. fare',
+        bounds=(None, 0),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Legroom direct',
+        segmentation='Seg. legroom',
+        bounds=(0, None),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Early direct',
+        segmentation='Seg. delay',
+        bounds=(None, 0),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Late direct',
+        segmentation='Seg. delay',
+        bounds=(None, 0),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Time direct',
+        segmentation='Seg. time',
+        bounds=(None, 0),
+        validity=None,
+    ),
 ]
 
 utility_same = [
-    (None, 'Seg. cte', (None, None), None),
-    ('Fare same', 'Seg. fare', (None, 0), None),
-    ('Legroom same', 'Seg. legroom', (0, None), None),
-    ('Early same', 'Seg. delay', (None, 0), None),
-    ('Late same', 'Seg. delay', (None, 0), None),
-    ('Time same', 'Seg. time', (None, 0), None),
+    TermTuple(
+        attribute=None,
+        segmentation='Seg. cte',
+        bounds=(None, None),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Fare same',
+        segmentation='Seg. fare',
+        bounds=(None, 0),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Legroom same',
+        segmentation='Seg. legroom',
+        bounds=(0, None),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Early same',
+        segmentation='Seg. delay',
+        bounds=(None, 0),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Late same',
+        segmentation='Seg. delay',
+        bounds=(None, 0),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Time same',
+        segmentation='Seg. time',
+        bounds=(None, 0),
+        validity=None,
+    ),
 ]
 
 utility_multiple = [
-    (None, 'Seg. cte', (None, None), None),
-    ('Fare multiple', 'Seg. fare', (None, 0), None),
-    ('Legroom multiple', 'Seg. legroom', (0, None), None),
-    ('Early multiple', 'Seg. delay', (None, 0), None),
-    ('Late multiple', 'Seg. delay', (None, 0), None),
-    ('Time multiple', 'Seg. time', (None, 0), None),
+    TermTuple(
+        attribute=None,
+        segmentation='Seg. cte',
+        bounds=(None, None),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Fare multiple',
+        segmentation='Seg. fare',
+        bounds=(None, 0),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Legroom multiple',
+        segmentation='Seg. legroom',
+        bounds=(0, None),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Early multiple',
+        segmentation='Seg. delay',
+        bounds=(None, 0),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Late multiple',
+        segmentation='Seg. delay',
+        bounds=(None, 0),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Time multiple',
+        segmentation='Seg. time',
+        bounds=(None, 0),
+        validity=None,
+    ),
 ]
 
 utilities = {
     1: ('Non stop', utility_direct),
     2: ('Same airline', utility_same),
     3: ('Multiple airlines', utility_multiple),
 }
 
+## Step 9: availabilities
 availabilities = {1: 1, 2: 1, 3: 1}
 
 
-# We define potential candidates for the choice model.
+# Step 10: We define potential candidates for the choice model.
 def logit(V, av, choice):
     """logit model"""
     return models.loglogit(V, av, choice)
 
 
 def nested1(V, av, choice):
     """Nested logit model: no stop / one stop"""
@@ -400,70 +496,54 @@
     'Logit': logit,
     'Nested one stop': nested1,
     'Nested same': nested2,
     'CNL alpha fixed': cnl1,
     'CNL alpha est.': cnl2,
 }
 
-# Definition of the specification problem, gathering all information defined above.
+## Step 11:  Definition of the specification problem, gathering all information
+# defined above.
 theProblem = assisted.specificationProblem(
     'Airline',
     database,
-    variables,
-    groupsOfVariables,
+    attributes,
+    groupsOfAttributes,
     genericForbiden,
     forceActive,
     nonlinearSpecs,
     segmentations,
     utilities,
     availabilities,
     chosenAlternative,
     myModels,
 )
 
 theProblem.maximumNumberOfParameters = 300
 
 # We propose several specifications to initialize the algorithm.
 # For each group of attributes, we decide if it is nonlinear, and generic.
-nl1 = {
-    'Time': (None, False),
-    'Fare': (None, False),
-    'Legroom': (None, False),
-    'Early': (None, False),
-    'Late': (None, False),
-}
-
-nl2 = {
+nl = {
     'Time': (5, False),
     'Fare': (0, False),
     'Legroom': (None, False),
     'Early': (None, False),
     'Late': (None, False),
 }
 
-nl3 = {
-    'Time': (5, False),
-    'Fare': (1, False),
-    'Legroom': (None, False),
-    'Early': (None, False),
-    'Late': (None, False),
-}
 
 # For each segmentation, we decided which dimensions are active.
-sg1 = {'Seg. cte': [], 'Seg. legroom': ['TripPurpose', 'Gender']}
-
-sg2 = {'Seg. cte': ['TripPurpose'], 'Seg. legroom': ['Gender']}
+sg = {'Seg. cte': ['TripPurpose'], 'Seg. legroom': ['Gender']}
 
 
 initSolutions = [
-    theProblem.generateSolution(nl2, sg2, 'Logit'),
-    theProblem.generateSolution(nl2, sg2, 'Nested one stop'),
-    theProblem.generateSolution(nl2, sg2, 'Nested same'),
-    theProblem.generateSolution(nl2, sg2, 'CNL alpha fixed'),
-    theProblem.generateSolution(nl2, sg2, 'CNL alpha est.'),
+    theProblem.generateSolution(nl, sg, 'Logit'),
+    theProblem.generateSolution(nl, sg, 'Nested one stop'),
+    theProblem.generateSolution(nl, sg, 'Nested same'),
+    theProblem.generateSolution(nl, sg, 'CNL alpha fixed'),
+    theProblem.generateSolution(nl, sg, 'CNL alpha est.'),
 ]
 
 # Optimization algorithm
 vns.vns(
     theProblem,
     initSolutions,
     archiveInputFile='airlinePareto.pickle',
```

### Comparing `biogeme-3.2.8/examples/assisted/optima.py` & `biogeme-3.2.9/examples/assisted/optima.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,20 +14,26 @@
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme import vns
 from biogeme import assisted
 from biogeme.expressions import (
     Beta,
     log,
-    DefineVariable,
     Elem,
     Numeric,
     Variable,
 )
+from biogeme.assisted import (
+    DiscreteSegmentationTuple,
+    TermTuple,
+    SegmentedParameterTuple,
+)
+
 
+## Step 1: data preparation. Identical to any Biogeme script.
 logger = msg.bioMessage()
 logger.setDebug()
 
 # Read the data
 df = pd.read_csv('optima.dat', sep='\t')
 
 df.loc[df['OccupStat'] > 2, 'OccupStat'] = 3
@@ -50,196 +56,276 @@
     (Choice == -1) + (CostCarCHF < 0) + (CarAvail == 3) * (Choice == 1)
 ) > 0
 database.remove(exclude)
 
 # Definition of new variables
 
 
-otherSubscription = DefineVariable(
+otherSubscription = database.DefineVariable(
     'otherSubscription',
     ((HalfFareST == 1) + (LineRelST == 1) + (AreaRelST == 1) + (OtherST) == 1)
-    > 0,
-    database,
-)
+    > 0)
 
-subscription = DefineVariable(
+subscription = database.DefineVariable(
     'subscription',
-    (GenAbST == 1) * 1 + (GenAbST != 1) * otherSubscription * 2,
-    database,
-)
+    (GenAbST == 1) * 1 + (GenAbST != 1) * otherSubscription * 2)
 
 TimePT_scaled = TimePT / 200
 TimeCar_scaled = TimeCar / 200
 MarginalCostPT_scaled = MarginalCostPT / 10
 CostCarCHF_scaled = CostCarCHF / 10
 distance_km_scaled = distance_km / 5
 
-# Definition of potential nonlinear transforms of variables
+## Step 2: attributes
+
+# Define the attributes of the alternatives
+attributes = {
+    'PT travel time': TimePT_scaled,
+    'PT travel cost': MarginalCostPT_scaled,
+    'Car travel time': TimeCar_scaled,
+    'Car travel cost': CostCarCHF_scaled,
+    'Distance': distance_km_scaled,
+    'Transfers': NbTransf,
+    'PT Waiting time': WaitingTimePT,
+}
+
+## Step 3:Group the attributes. All attributes in the same group will be
+# associated with the same  transform, and the same
+# segmentation. Attributes in the same group can be generic or
+# alternative specific, except if mentioned otherwise
+groupsOfAttributes = {
+    'Travel time': ['PT travel time', 'Car travel time'],
+    'Travel cost': ['PT travel cost', 'Car travel cost'],
+}
+
+## Step 4
+# In this example, no group of attributes must be alternative specific
+genericForbiden = None
+
+## Step 5
+# In this example, all the attributes must be in the model
+forceActive = ['Travel time', 'Distance']
+
+
+## Step 6: Definition of potential transforms of attributes
 def mylog(x):
-    """Log of the variable"""
+    """Log of the attribute"""
     return 'log', Elem({0: log(x), 1: Numeric(0)}, x == 0)
 
 
 def sqrt(x):
-    """Sqrt of the variable"""
+    """Sqrt of the attribute"""
     return 'sqrt', x ** 0.5
 
 
 def square(x):
-    """Square of the variable"""
+    """Square of the attribute"""
     return 'square', x ** 2
 
 
 def boxcox(x, name):
-    """Box-Cox transform of the variable"""
+    """Box-Cox transform of the attribute"""
     ell = Beta(f'lambda_{name}', 1, 0.0001, 3.0, 0)
     return f'Box-Cox_{name}', models.boxcox(x, ell)
 
 
 def boxcox_time(x):
-    """Box-Cox transform of the variable time"""
+    """Box-Cox transform of the attribute time"""
     return boxcox(x, 'time')
 
 
 def boxcox_cost(x):
-    """Box-Cox transform of the variable cost"""
+    """Box-Cox transform of the attribute cost"""
     return boxcox(x, 'cost')
 
 
 def distanceInteraction(x):
-    """Nonlinea rinteraction with distance"""
-    return 'dist. interaction', x * log(1 + Variable('distance_km') / 1000)
+    """Nonlinear interaction with distance"""
+    return ('dist. interaction', x * log(1 + Variable('distance_km') / 1000))
+
+
+# Associate a list of potential transformations with each group of attributes
+transformations = {
+    'Travel time': [distanceInteraction, mylog, sqrt, square, boxcox_time],
+    'PT Waiting time': [mylog, sqrt, square, boxcox_time],
+    'Travel cost': [mylog, sqrt, square, boxcox_cost],
+}
 
+## Step 7
 
 # Define all possible segmentations
-all_segmentations = {
-    'TripPurpose': (TripPurpose, {1: 'work', 2: 'others'}),
-    'Urban': (UrbRur, {1: 'rural', 2: 'urban'}),
-    'Language': (LangCode, {1: 'French', 2: 'German'}),
-    'Income': (
-        Income,
-        {
-            1: '<2500',
-            2: '2051_4000',
-            3: '4001_6000',
-            4: '6001_8000',
-            5: '8001_10000',
-            6: '>10000',
-            -1: 'unknown',
-        },
+all_discrete_segmentations = {
+    'TripPurpose': DiscreteSegmentationTuple(
+        variable=TripPurpose, mapping={1: 'work', 2: 'others'}
+    ),
+    'Urban': DiscreteSegmentationTuple(
+        variable=UrbRur, mapping={1: 'rural', 2: 'urban'}
+    ),
+    'Language': DiscreteSegmentationTuple(
+        variable=LangCode, mapping={1: 'French', 2: 'German'}
+    ),
+    'Gender': DiscreteSegmentationTuple(
+        variable=Gender, mapping={1: 'male', 2: 'female', -1: 'unkown'}
+    ),
+    'Occupation': DiscreteSegmentationTuple(
+        variable=OccupStat,
+        mapping={1: 'full_time', 2: 'partial_time', 3: 'others'},
+    ),
+    'Subscription': DiscreteSegmentationTuple(
+        variable=subscription, mapping={0: 'none', 1: 'GA', 2: 'other'}
+    ),
+    'CarAvail': DiscreteSegmentationTuple(
+        variable=CarAvail, mapping={1: 'yes', 3: 'no'}
     ),
-    'Gender': (Gender, {1: 'male', 2: 'female', -1: 'unkown'}),
-    'Occupation': (
-        OccupStat,
-        {1: 'full_time', 2: 'partial_time', 3: 'others'},
-    ),
-    'Subscription': (subscription, {0: 'none', 1: 'GA', 2: 'other'}),
-    'CarAvail': (CarAvail, {1: 'yes', 3: 'no'}),
-    'Education': (
-        Education,
-        {3: 'vocational', 4: 'high_school', 6: 'higher_edu', 7: 'university'},
+    'Education': DiscreteSegmentationTuple(
+        variable=Education,
+        mapping={
+            3: 'vocational',
+            4: 'high_school',
+            6: 'higher_edu',
+            7: 'university',
+        },
     ),
 }
 
+# Continuous segmentations
 
 # Define segmentations
 segmentations = {
-    'Seg. cte': all_segmentations,
-    'Seg. cost': all_segmentations,
-    'Seg. wait': all_segmentations,
-    'Seg. time': all_segmentations,
-    'Seg. transfers': all_segmentations,
-    'Seg. dist': all_segmentations,
+    'Seg. cte': SegmentedParameterTuple(
+        dict=all_discrete_segmentations, combinatorial=False
+    ),
+    'Seg. cost': SegmentedParameterTuple(
+        dict=all_discrete_segmentations, combinatorial=False
+    ),
+    'Seg. wait': SegmentedParameterTuple(
+        dict=all_discrete_segmentations, combinatorial=False
+    ),
+    'Seg. time': SegmentedParameterTuple(
+        dict=all_discrete_segmentations, combinatorial=False
+    ),
+    'Seg. transfers': SegmentedParameterTuple(
+        dict=all_discrete_segmentations, combinatorial=False
+    ),
+    'Seg. dist': SegmentedParameterTuple(
+        dict=all_discrete_segmentations, combinatorial=False
+    ),
 }
 
-# Define the attributes of the alternatives
-variables = {
-    'PT travel time': TimePT_scaled,
-    'PT travel cost': MarginalCostPT_scaled,
-    'Car travel time': TimeCar_scaled,
-    'Car travel cost': CostCarCHF_scaled,
-    'Distance': distance_km_scaled,
-    'Transfers': NbTransf,
-    'PT Waiting time': WaitingTimePT,
-}
 
-# Group the attributes. All attributes in the same group will be
-# assoaited with the same nonlinear transform, and the same
-# segmentation. Attributes in the same group can be generic or
-# alternative specific, except if mentioned otherwise
-groupsOfVariables = {
-    'Travel time': ['PT travel time', 'Car travel time'],
-    'Travel cost': ['PT travel cost', 'Car travel cost'],
-}
+## Step 8: utility function
 
-# In this example, no variable must be alternative specific
-genericForbiden = None
-
-# In this example, all the variables must be in the model
-forceActive = ['Travel time', 'Distance']
+# First, we define a function that checks if a parameter is negative.
+def negativeParameter(val):
+    """Function verifying the negativity of the coefficient.
 
-# Associate a list of potential nonlinearities with each group of variable
-nonlinearSpecs = {
-    'Travel time': [distanceInteraction, mylog, sqrt, square, boxcox_time],
-    'PT Waiting time': [mylog, sqrt, square, boxcox_time],
-    'Travel cost': [mylog, sqrt, square, boxcox_cost],
-}
+    :param val: value to verify
+    :type val: float
 
-def negativeParameter(val):
-    """ Function verifying the negativity of the parameters"""
+    :return: True if the value is negative, False otherwise.
+    :rtype: bool
+    """
     return val < 0
 
 
 # Specification of the utility function. For each term, it is possible
 # to define bounds on the coefficient, and to include a function that
 # verifies its validity a posteriori.
 
 utility_pt = [
-    (None, 'Seg. cte', (None, None), None),
-    ('PT travel time', 'Seg. time', (None, 0), negativeParameter),
-    ('PT travel cost', 'Seg. cost', (None, 0), negativeParameter),
-    ('Transfers', 'Seg. transfers', (None, 0), negativeParameter),
-    ('PT Waiting time', 'Seg. wait', (None, 0), negativeParameter),
+    TermTuple(
+        attribute=None,
+        segmentation='Seg. cte',
+        bounds=(None, None),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='PT travel time',
+        segmentation='Seg. time',
+        bounds=(None, 0),
+        validity=negativeParameter,
+    ),
+    TermTuple(
+        attribute='PT travel cost',
+        segmentation='Seg. cost',
+        bounds=(None, 0),
+        validity=negativeParameter,
+    ),
+    TermTuple(
+        attribute='Transfers',
+        segmentation='Seg. transfers',
+        bounds=(None, 0),
+        validity=negativeParameter,
+    ),
+    TermTuple(
+        attribute='PT Waiting time',
+        segmentation='Seg. wait',
+        bounds=(None, 0),
+        validity=negativeParameter,
+    ),
 ]
 
 
 utility_car = [
-    (None, 'Seg. cte', (None, None), None),
-    ('Car travel time', 'Seg. time', (None, 0), negativeParameter),
-    ('Car travel cost', 'Seg. cost', (None, 0), negativeParameter),
+    TermTuple(
+        attribute=None,
+        segmentation='Seg. cte',
+        bounds=(None, None),
+        validity=None,
+    ),
+    TermTuple(
+        attribute='Car travel time',
+        segmentation='Seg. time',
+        bounds=(None, 0),
+        validity=negativeParameter,
+    ),
+    TermTuple(
+        attribute='Car travel cost',
+        segmentation='Seg. cost',
+        bounds=(None, 0),
+        validity=negativeParameter,
+    ),
 ]
 
-utility_sm = [('Distance', 'Seg. dist', (None, 0), negativeParameter)]
+utility_sm = [
+    TermTuple(
+        attribute='Distance',
+        segmentation='Seg. dist',
+        bounds=(None, 0),
+        validity=negativeParameter,
+    )
+]
 
 
 utilities = {
     0: ('pt', utility_pt),
     1: ('car', utility_car),
     2: ('sm', utility_sm),
 }
 
+## Step 9
 availabilities = {0: 1, 1: CarAvail != 3, 2: 1}
 
-
+## Step 10
 # We define potential candidates for the choice model.
 def logit(V, av, choice):
     """logit model"""
     return models.loglogit(V, av, choice)
 
 
 def nested1(V, av, choice):
-    """Nested logit model: first specification """
+    """Nested logit model: first specification"""
     same = Beta('mu_same', 1, 1, None, 0), [0, 1]
     multiple = 1.0, [2]
     nests = same, multiple
     return models.lognested(V, av, nests, choice)
 
 
 def nested2(V, av, choice):
-    """Nested logit model: second specification """
+    """Nested logit model: second specification"""
     onestop = Beta('mu_onestop', 1, 1, None, 0), [1, 2]
     nostop = 1.0, [0]
     nests = nostop, onestop
     return models.lognested(V, av, nests, choice)
 
 
 def cnl1(V, av, choice):
@@ -264,41 +350,44 @@
     nest_same = mu_same, alpha_same
     nest_onestop = mu_onestop, alpha_onestop
     nests = nest_onestop, nest_same
     return models.logcnl_avail(V, av, nests, choice)
 
 
 # We provide names to these candidates
-myModels = {'Logit': logit,
-            'Nested 1': nested1,
-            'Nested 2': nested2,
-            'Cross nested 1': cnl1,
-            'Cross nested 2': cnl2}
+myModels = {
+    'Logit': logit,
+    'Nested 1': nested1,
+    'Nested 2': nested2,
+    'Cross nested 1': cnl1,
+    'Cross nested 2': cnl2,
+}
 
+## Step 11
 # Definition of the specification problem, gathering all information
 # defined above.
 theProblem = assisted.specificationProblem(
     'Optima',
     database,
-    variables,
-    groupsOfVariables,
+    attributes,
+    groupsOfAttributes,
     genericForbiden,
     forceActive,
-    nonlinearSpecs,
+    transformations,
     segmentations,
     utilities,
     availabilities,
     Choice,
     myModels,
 )
 
 theProblem.maximumNumberOfParameters = 100
 
 # We propose several specifications to initialize the algorithm.
-# For each group of attributes, we decide if it is nonlinear, and generic.
+# For each group of attributes, we decide if it is transformed, and generic.
 nl1 = {'Travel time': (None, False), 'Distance': (None, False)}
 
 # For each segmentation, we decided which dimensions are active.
 sg1 = {
     'Seg. cte': ['Subscription'],
     'Seg. time': [],
     'Seg. cost': [],
```

### Comparing `biogeme-3.2.8/examples/assisted/swissmetro.dat` & `biogeme-3.2.9/examples/assisted/swissmetro.dat`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/assisted/swissmetro.py` & `biogeme-3.2.9/examples/assisted/debug.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,21 +14,22 @@
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme import vns
 from biogeme import assisted
 from biogeme.expressions import (
     Beta,
     log,
-    DefineVariable,
     Elem,
     Numeric,
 )
 
+
+## Step 1: data preparation. Identical to any Biogeme script.
 logger = msg.bioMessage()
-logger.setDebug()
+logger.setDetailed()
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 
 # Update some data
 df['TRAIN_TT_SCALED'] = df['TRAIN_TT'] / 100
 df['TRAIN_TT_SQUARE'] = df['TRAIN_TT_SCALED'] * df['TRAIN_TT_SCALED'] / 100
@@ -42,34 +43,74 @@
 globals().update(database.variables)
 
 exclude = (CHOICE == 0) > 0
 database.remove(exclude)
 
 # Definition of new variables
 
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_COST = DefineVariable('TRAIN_COST', TRAIN_CO * (GA == 0) / 100, database)
-SM_COST = DefineVariable('SM_COST', SM_CO * (GA == 0) / 100, database)
-CAR_COST = DefineVariable('CAR_COST', CAR_CO / 100, database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_COST = database.DefineVariable('TRAIN_COST', TRAIN_CO * (GA == 0) / 100)
+SM_COST = database.DefineVariable('SM_COST', SM_CO * (GA == 0) / 100)
+CAR_COST = database.DefineVariable('CAR_COST', CAR_CO / 100)
+
+
+## Step 2: identify and name the relevant attributes of the alternatives
+attributes = {
+    'Train travel time': TRAIN_TT_SCALED,
+    'Swissmetro travel time': SM_TT_SCALED,
+    'Car travel time': CAR_TT_SCALED,
+    'Train travel cost': TRAIN_COST,
+    'Swissmetro travel cost': SM_COST,
+    'Car travel cost': CAR_COST,
+    'Train headway': TRAIN_HE,
+    'Swissmetro headway': SM_HE,
+}
+
+## Step 3: define the group of attributes
 
+# Group the attributes. All attributes in the same group will be
+# associated with the same nonlinear transform, and the same
+# segmentation. Attributes in the same group can be generic or
+# alternative specific, except if mentioned otherwise
+groupsOfAttributes = {
+    'Travel time': [
+        'Train travel time',
+        'Swissmetro travel time',
+        'Car travel time',
+    ],
+    'Travel cost': [
+        'Train travel cost',
+        'Swissmetro travel cost',
+        'Car travel cost',
+    ],
+    'Headway': ['Train headway', 'Swissmetro headway'],
+}
 
-# Definition of potential nonlinear transforms of variables
+
+# In this example, all the attributes could be generic
+genericForbiden = None
+
+# In this example, we impose time and cost to be in the model
+forceActive = ['Travel time', 'Travel cost']
+
+# Associate a list of potential nonlinearities with each group of attributes
+# Definition of potential nonlinear transforms of attributes
 def mylog(x):
-    """Log of the variable, or 0 if the variable is zero"""
+    """Log of the attribute, or 0 if it is zero"""
     return 'log', Elem({0: log(x), 1: Numeric(0)}, x == 0)
 
 
 def sqrt(x):
-    """Sqrt of the variable"""
+    """Sqrt of the attribute"""
     return 'sqrt', x ** 0.5
 
 
 def square(x):
-    """Square of the variable"""
+    """Square of the attribute"""
     return 'square', x ** 2
 
 
 def piecewise(x, thresholds, name):
     """Piecewise linear specification"""
     piecewiseVariables = models.piecewiseVariables(x, thresholds)
     formula = piecewiseVariables[0]
@@ -104,34 +145,59 @@
 
 def piecewise_cost_2(x):
     """Piecewise linear for cost :math:`0, 0.25, +\\infty`"""
     return piecewise(x, [0, 0.25, None], 'cost')
 
 
 def boxcox(x, name):
-    """Box-Cox transform of the variable"""
+    """Box-Cox transform of the attribute"""
     ell = Beta(f'lambda_{name}', 1, 0.0001, 3.0, 0)
     return f'Box-Cox_{name}', models.boxcox(x, ell)
 
 
 def boxcox_time(x):
-    """Box-Cox transform of the variable time"""
+    """Box-Cox transform of the attribute time"""
     return boxcox(x, 'time')
 
 
 def boxcox_cost(x):
-    """Box-Cox transform of the variable cost"""
+    """Box-Cox transform of the attribute cost"""
     return boxcox(x, 'cost')
 
 
 def boxcox_headway(x):
-    """Box-Cox transform of the variable headway"""
+    """Box-Cox transform of the attribute headway"""
     return boxcox(x, 'headway')
 
 
+
+
+
+nonlinearSpecs = {
+    'Travel time': [
+        mylog,
+        sqrt,
+        square,
+        piecewise_time_1,
+        piecewise_time_2,
+        boxcox_time,
+    ],
+    'Travel cost': [
+        mylog,
+        sqrt,
+        square,
+        piecewise_cost_1,
+        piecewise_cost_2,
+        boxcox_cost,
+    ],
+    'Headway': [mylog, sqrt, square, boxcox_headway],
+}
+
+
+
 # Define all possible segmentations
 segmentations_cte = {
     'GA': (GA, {1: 'GA', 0: 'noGA'}),
     'gender': (MALE, {0: 'female', 1: 'male'}),
     'class': (FIRST, {0: 'secondClass', 1: 'firstClass'}),
     'luggage': (LUGGAGE, {0: 'noLugg', 1: 'oneLugg', 3: 'severalLugg'}),
     'income': (
@@ -170,72 +236,14 @@
     'Seg. cte': segmentations_cte,
     'Seg. cost': segmentations_cost,
     'Seg. time': segmentations_time,
     'Seg. headway': segmentations_headway,
 }
 
 
-# Define the attributes of the alternatives
-variables = {
-    'Train travel time': TRAIN_TT_SCALED,
-    'Swissmetro travel time': SM_TT_SCALED,
-    'Car travel time': CAR_TT_SCALED,
-    'Train travel cost': TRAIN_COST,
-    'Swissmetro travel cost': SM_COST,
-    'Car travel cost': CAR_COST,
-    'Train headway': TRAIN_HE,
-    'Swissmetro headway': SM_HE,
-}
-
-
-# Group the attributes. All attributes in the same group will be
-# assoaited with the same nonlinear transform, and the same
-# segmentation. Attributes in the same group can be generic or
-# alternative specific, except if mentioned otherwise
-groupsOfVariables = {
-    'Travel time': [
-        'Train travel time',
-        'Swissmetro travel time',
-        'Car travel time',
-    ],
-    'Travel cost': [
-        'Train travel cost',
-        'Swissmetro travel cost',
-        'Car travel cost',
-    ],
-    'Headway': ['Train headway', 'Swissmetro headway'],
-}
-
-
-# In this example, all the variables could be generic
-genericForbiden = None
-
-# In this example, we impose time and cost ot be in the model
-forceActive = ['Travel time', 'Travel cost']
-
-# Associate a list of potential nonlinearities with each group of variable
-nonlinearSpecs = {
-    'Travel time': [
-        mylog,
-        sqrt,
-        square,
-        piecewise_time_1,
-        piecewise_time_2,
-        boxcox_time,
-    ],
-    'Travel cost': [
-        mylog,
-        sqrt,
-        square,
-        piecewise_cost_1,
-        piecewise_cost_2,
-        boxcox_cost,
-    ],
-    'Headway': [mylog, sqrt, square, boxcox_headway],
-}
 
 # Specification of the utility function. For each term, it is possible
 # to define bounds on the coefficient, and to include a function that
 # verifies its validity a posteriori.
 
 utility_train = [
     (None, 'Seg. cte', (None, None), None),
@@ -323,16 +331,16 @@
 }
 
 # Definition of the specification problem, gathering all information
 # defined above.
 theProblem = assisted.specificationProblem(
     'Swissmetro',
     database,
-    variables,
-    groupsOfVariables,
+    attributes,
+    groupsOfAttributes,
     genericForbiden,
     forceActive,
     nonlinearSpecs,
     segmentations,
     utilities,
     availabilities,
     CHOICE,
@@ -364,10 +372,10 @@
 ]
 
 
 # Optimization algorithm
 vns.vns(
     theProblem,
     initSolutions,
-    archiveInputFile='airlinePareto.pickle',
-    pickleOutputFile='airlinePareto.pickle',
+    archiveInputFile='swissmetroPareto.pickle',
+    pickleOutputFile='swissmetroPareto.pickle',
 )
```

### Comparing `biogeme-3.2.8/examples/checkhtml.py` & `biogeme-3.2.9/examples/checkhtml.py`

 * *Files 1% similar despite different names*

```diff
@@ -53,15 +53,15 @@
     './swissmetro/11cnl_simul.html',
     './swissmetro/19individualLevelParameters.html',
     './swissmetro/09nested_allAlgos.html',
     './swissmetro/05normalMixture_allAlgos.html',
     './latent/00factorAnalysis.html',
 ]
 
-version = '3.2.7'
+version = '3.2.8'
 
 def checkFile(theFile):
     if theFile.is_file() and theFile.name.endswith('py'):
         current_file = os.path.split(theFile.path)
         dir = current_file[0]
         if dir not in ignoreDirectory:
             root = theFile.name.split(".")[0]
```

### Comparing `biogeme-3.2.8/examples/generateNotebooks.py` & `biogeme-3.2.9/examples/generateNotebooks.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/latent/00factorAnalysis.py` & `biogeme-3.2.9/examples/latent/00factorAnalysis.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/latent/01oneLatentRegression.py` & `biogeme-3.2.9/examples/latent/01oneLatentRegression.py`

 * *Files 19% similar despite different names*

```diff
@@ -10,48 +10,46 @@
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.loglikelihood as ll
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable, Elem, bioMultSum
+from biogeme.expressions import Beta, Elem, bioMultSum
 
 # Read the data
 df = pd.read_csv('optima.dat', sep='\t')
 database = db.Database('optima', df)
 
 # The following statement allows you to use the names of the variable
 # as Python variable.
 globals().update(database.variables)
 
 # Exclude observations such that the chosen alternative is -1
 database.remove(Choice == -1.0)
 
 # Piecewise linear definition of income
-ScaledIncome = DefineVariable(
-    'ScaledIncome', CalculatedIncome / 1000, database
-)
+ScaledIncome = database.DefineVariable(
+    'ScaledIncome', CalculatedIncome / 1000)
 
 thresholds = [None, 4, 6, 8, 10, None]
 formulaIncome = models.piecewiseFormula(
     ScaledIncome, thresholds, [0.0, 0.0, 0.0, 0.0, 0.0]
 )
 
 # Definition of other variables
-age_65_more = DefineVariable('age_65_more', age >= 65, database)
-moreThanOneCar = DefineVariable('moreThanOneCar', NbCar > 1, database)
-moreThanOneBike = DefineVariable('moreThanOneBike', NbBicy > 1, database)
-individualHouse = DefineVariable('individualHouse', HouseType == 1, database)
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-haveGA = DefineVariable('haveGA', GenAbST == 1, database)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+age_65_more = database.DefineVariable('age_65_more', age >= 65)
+moreThanOneCar = database.DefineVariable('moreThanOneCar', NbCar > 1)
+moreThanOneBike = database.DefineVariable('moreThanOneBike', NbBicy > 1)
+individualHouse = database.DefineVariable('individualHouse', HouseType == 1)
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0)
+haveGA = database.DefineVariable('haveGA', GenAbST == 1)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
 # Parameters to be estimated
 coef_intercept = Beta('coef_intercept', 0.0, None, None, 0)
 coef_age_65_more = Beta('coef_age_65_more', 0.0, None, None, 0)
 coef_haveGA = Beta('coef_haveGA', 0.0, None, None, 0)
 coef_moreThanOneCar = Beta('coef_moreThanOneCar', 0.0, None, None, 0)
 coef_moreThanOneBike = Beta('coef_moreThanOneBike', 0.0, None, None, 0)
@@ -97,21 +95,21 @@
 MODEL_Envir02 = INTER_Envir02 + B_Envir02_F1 * CARLOVERS
 MODEL_Envir03 = INTER_Envir03 + B_Envir03_F1 * CARLOVERS
 MODEL_Mobil11 = INTER_Mobil11 + B_Mobil11_F1 * CARLOVERS
 MODEL_Mobil14 = INTER_Mobil14 + B_Mobil14_F1 * CARLOVERS
 MODEL_Mobil16 = INTER_Mobil16 + B_Mobil16_F1 * CARLOVERS
 MODEL_Mobil17 = INTER_Mobil17 + B_Mobil17_F1 * CARLOVERS
 
-SIGMA_STAR_Envir01 = Beta('SIGMA_STAR_Envir01', 1, 0, None, 0)
-SIGMA_STAR_Envir02 = Beta('SIGMA_STAR_Envir02', 1, 0, None, 0)
-SIGMA_STAR_Envir03 = Beta('SIGMA_STAR_Envir03', 1, 0, None, 0)
-SIGMA_STAR_Mobil11 = Beta('SIGMA_STAR_Mobil11', 1, 0, None, 0)
-SIGMA_STAR_Mobil14 = Beta('SIGMA_STAR_Mobil14', 1, 0, None, 0)
-SIGMA_STAR_Mobil16 = Beta('SIGMA_STAR_Mobil16', 1, 0, None, 0)
-SIGMA_STAR_Mobil17 = Beta('SIGMA_STAR_Mobil17', 1, 0, None, 0)
+SIGMA_STAR_Envir01 = Beta('SIGMA_STAR_Envir01', 1, None, None, 0)
+SIGMA_STAR_Envir02 = Beta('SIGMA_STAR_Envir02', 1, None, None, 0)
+SIGMA_STAR_Envir03 = Beta('SIGMA_STAR_Envir03', 1, None, None, 0)
+SIGMA_STAR_Mobil11 = Beta('SIGMA_STAR_Mobil11', 1, None, None, 0)
+SIGMA_STAR_Mobil14 = Beta('SIGMA_STAR_Mobil14', 1, None, None, 0)
+SIGMA_STAR_Mobil16 = Beta('SIGMA_STAR_Mobil16', 1, None, None, 0)
+SIGMA_STAR_Mobil17 = Beta('SIGMA_STAR_Mobil17', 1, None, None, 0)
 
 # We build a dict with each contribution to the loglikelihood if
 # (var > 0) and (var < 6). If not, 0 is returned.
 F = {}
 F['Envir01'] = Elem(
     {
         0: 0,
```

### Comparing `biogeme-3.2.8/examples/latent/02oneLatentOrdered.py` & `biogeme-3.2.9/examples/latent/02oneLatentOrdered.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,48 +9,46 @@
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable, log, Elem, bioNormalCdf
+from biogeme.expressions import Beta, log, Elem, bioNormalCdf
 
 # Read the data
 df = pd.read_csv('optima.dat', sep='\t')
 database = db.Database('optima', df)
 
 # The following statement allows you to use the names of the variable
 # as Python variable.
 globals().update(database.variables)
 
 # Exclude observations such that the chosen alternative is -1
 database.remove(Choice == -1.0)
 
 # Piecewise linear definition of income
-ScaledIncome = DefineVariable(
-    'ScaledIncome', CalculatedIncome / 1000, database
-)
+ScaledIncome = database.DefineVariable(
+    'ScaledIncome', CalculatedIncome / 1000)
 
 thresholds = [None, 4, 6, 8, 10, None]
 formulaIncome = models.piecewiseFormula(
-    ScaledIncome, thresholds, [0.0, 0.0, 0.0, 0.0, 0.0]
+    ScaledIncome, thresholds
 )
 
 # Definition of other variables
-age_65_more = DefineVariable('age_65_more', age >= 65, database)
-moreThanOneCar = DefineVariable('moreThanOneCar', NbCar > 1, database)
-moreThanOneBike = DefineVariable('moreThanOneBike', NbBicy > 1, database)
-individualHouse = DefineVariable('individualHouse', HouseType == 1, database)
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-haveGA = DefineVariable('haveGA', GenAbST == 1, database)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+age_65_more = database.DefineVariable('age_65_more', age >= 65)
+moreThanOneCar = database.DefineVariable('moreThanOneCar', NbCar > 1)
+moreThanOneBike = database.DefineVariable('moreThanOneBike', NbBicy > 1)
+individualHouse = database.DefineVariable('individualHouse', HouseType == 1)
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0)
+haveGA = database.DefineVariable('haveGA', GenAbST == 1)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
 # Parameters to be estimated
 coef_intercept = Beta('coef_intercept', 0.0, None, None, 0)
 coef_age_65_more = Beta('coef_age_65_more', 0.0, None, None, 0)
 coef_haveGA = Beta('coef_haveGA', 0.0, None, None, 0)
 coef_moreThanOneCar = Beta('coef_moreThanOneCar', 0.0, None, None, 0)
 coef_moreThanOneBike = Beta('coef_moreThanOneBike', 0.0, None, None, 0)
```

### Comparing `biogeme-3.2.8/examples/latent/03choiceOnly.py` & `biogeme-3.2.9/examples/latent/03choiceOnly_mc.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,30 +1,28 @@
-"""File 03choiceOnly.py
+"""File 03choiceOnly_mc.py
 
 Choice model with the latent variable.
-Mixture of logit.
+Mixture of logit, using Monte-Carlo integration
 No measurement equation for the indicators.
 
 :author: Michel Bierlaire, EPFL
-:date: Thu Sep  6 15:14:39 2018
+:date: Sat May 30 18:16:04 2020
 
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-from biogeme import models
-import biogeme.distributions as dist
+from  biogeme import models
 import biogeme.optimization as opt
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
-    RandomVariable,
-    Integrate,
+    bioDraws,
+    MonteCarlo,
     exp,
     log,
 )
 
 # Read the data
 df = pd.read_csv('optima.dat', sep='\t')
 database = db.Database('optima', df)
@@ -36,66 +34,60 @@
 
 # Exclude observations such that the chosen alternative is -1
 database.remove(Choice == -1.0)
 
 ### Variables
 
 # Piecewise linear definition of income
-ScaledIncome = DefineVariable(
-    'ScaledIncome', CalculatedIncome / 1000, database
-)
+ScaledIncome = database.DefineVariable(
+    'ScaledIncome', CalculatedIncome / 1000)
 
 thresholds = [None, 4, 6, 8, 10, None]
 formulaIncome = models.piecewiseFormula(
     ScaledIncome, thresholds, [0.0, 0.0, 0.0, 0.0, 0.0]
 )
 
 # Definition of other variables
-age_65_more = DefineVariable('age_65_more', age >= 65, database)
-moreThanOneCar = DefineVariable('moreThanOneCar', NbCar > 1, database)
-moreThanOneBike = DefineVariable('moreThanOneBike', NbBicy > 1, database)
-individualHouse = DefineVariable('individualHouse', HouseType == 1, database)
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-haveGA = DefineVariable('haveGA', GenAbST == 1, database)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+age_65_more = database.DefineVariable('age_65_more', age >= 65)
+moreThanOneCar = database.DefineVariable('moreThanOneCar', NbCar > 1)
+moreThanOneBike = database.DefineVariable('moreThanOneBike', NbBicy > 1)
+individualHouse = database.DefineVariable('individualHouse', HouseType == 1)
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0)
+haveGA = database.DefineVariable('haveGA', GenAbST == 1)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
 # Parameters to be estimated
 coef_intercept = Beta('coef_intercept', 0.0, None, None, 1)
 coef_age_65_more = Beta('coef_age_65_more', 0.0, None, None, 0)
 coef_haveGA = Beta('coef_haveGA', 0.0, None, None, 0)
 coef_moreThanOneCar = Beta('coef_moreThanOneCar', 0.0, None, None, 0)
 coef_moreThanOneBike = Beta('coef_moreThanOneBike', 0.0, None, None, 0)
 coef_individualHouse = Beta('coef_individualHouse', 0.0, None, None, 0)
 coef_male = Beta('coef_male', 0.0, None, None, 0)
 coef_haveChildren = Beta('coef_haveChildren', 0.0, None, None, 0)
 coef_highEducation = Beta('coef_highEducation', 0.0, None, None, 0)
 
 ### Latent variable: structural equation
 
-# Define a random parameter, normally distributed, designed to be used
-# for numerical integration
-omega = RandomVariable('omega')
-density = dist.normalpdf(omega)
 sigma_s = Beta('sigma_s', 1, None, None, 0)
 
 CARLOVERS = (
     coef_intercept
     + coef_age_65_more * age_65_more
     + formulaIncome
     + coef_moreThanOneCar * moreThanOneCar
     + coef_moreThanOneBike * moreThanOneBike
     + coef_individualHouse * individualHouse
     + coef_male * male
     + coef_haveChildren * haveChildren
     + coef_haveGA * haveGA
     + coef_highEducation * highEducation
-    + sigma_s * omega
+    + sigma_s * bioDraws('EC', 'NORMAL_MLHS')
 )
 
 # Choice model
 
 ASC_CAR = Beta('ASC_CAR', 0.0, None, None, 0)
 ASC_PT = Beta('ASC_PT', 0.0, None, None, 1)
 ASC_SM = Beta('ASC_SM', 0.0, None, None, 0)
@@ -104,27 +96,24 @@
 BETA_DIST = Beta('BETA_DIST', 0.0, None, None, 0)
 BETA_TIME_CAR_REF = Beta('BETA_TIME_CAR_REF', 0.0, None, 0, 0)
 BETA_TIME_CAR_CL = Beta('BETA_TIME_CAR_CL', 0.0, None, None, 0)
 BETA_TIME_PT_REF = Beta('BETA_TIME_PT_REF', 0.0, None, 0, 0)
 BETA_TIME_PT_CL = Beta('BETA_TIME_PT_CL', -1.0, None, None, 0)
 BETA_WAITING_TIME = Beta('BETA_WAITING_TIME', 0.0, None, None, 0)
 
-TimePT_scaled = DefineVariable('TimePT_scaled', TimePT / 200, database)
-TimeCar_scaled = DefineVariable('TimeCar_scaled', TimeCar / 200, database)
-MarginalCostPT_scaled = DefineVariable(
-    'MarginalCostPT_scaled', MarginalCostPT / 10, database
-)
-CostCarCHF_scaled = DefineVariable(
-    'CostCarCHF_scaled', CostCarCHF / 10, database
-)
-distance_km_scaled = DefineVariable(
-    'distance_km_scaled', distance_km / 5, database
-)
-PurpHWH = DefineVariable('PurpHWH', TripPurpose == 1, database)
-PurpOther = DefineVariable('PurpOther', TripPurpose != 1, database)
+TimePT_scaled = database.DefineVariable('TimePT_scaled', TimePT / 200)
+TimeCar_scaled = database.DefineVariable('TimeCar_scaled', TimeCar / 200)
+MarginalCostPT_scaled = database.DefineVariable(
+    'MarginalCostPT_scaled', MarginalCostPT / 10)
+CostCarCHF_scaled = database.DefineVariable(
+    'CostCarCHF_scaled', CostCarCHF / 10)
+distance_km_scaled = database.DefineVariable(
+    'distance_km_scaled', distance_km / 5)
+PurpHWH = database.DefineVariable('PurpHWH', TripPurpose == 1)
+PurpOther = database.DefineVariable('PurpOther', TripPurpose != 1)
 
 ### Definition of utility functions:
 
 BETA_TIME_PT = BETA_TIME_PT_REF * exp(BETA_TIME_PT_CL * CARLOVERS)
 
 V0 = (
     ASC_PT
@@ -147,26 +136,26 @@
 
 # Associate utility functions with the numbering of alternatives
 V = {0: V0, 1: V1, 2: V2}
 
 # Conditional to omega, we have a logit model (called the kernel)
 condprob = models.logit(V, None, Choice)
 # We integrate over omega using numerical integration
-loglike = log(Integrate(condprob * density, 'omega'))
+loglike = log(MonteCarlo(condprob))
 
 # Define level of verbosity
 logger = msg.bioMessage()
 # logger.setSilent()
 # logger.setWarning()
 logger.setGeneral()
 # logger.setDetailed()
 
 # Create the Biogeme object
-biogeme = bio.BIOGEME(database, loglike)
-biogeme.modelName = '03choiceOnly'
+biogeme = bio.BIOGEME(database, loglike, numberOfDraws=20000)
+biogeme.modelName = '03choiceOnly_mc'
 
 # Estimate the parameters
 results = biogeme.estimate(algorithm=opt.bioNewton)
 
 print(f'Estimated betas: {len(results.data.betaValues)}')
 print(f'Final log likelihood: {results.data.logLike:.3f}')
 print(f'Output file: {results.data.htmlFileName}')
```

### Comparing `biogeme-3.2.8/examples/latent/03choiceOnly_mc.py` & `biogeme-3.2.9/examples/latent/03choiceOnly.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-"""File 03choiceOnly_mc.py
+"""File 03choiceOnly.py
 
 Choice model with the latent variable.
-Mixture of logit, using Monte-Carlo integration
+Mixture of logit.
 No measurement equation for the indicators.
 
 :author: Michel Bierlaire, EPFL
-:date: Sat May 30 18:16:04 2020
+:date: Thu Sep  6 15:14:39 2018
 
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-from  biogeme import models
+from biogeme import models
+import biogeme.distributions as dist
 import biogeme.optimization as opt
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
-    bioDraws,
-    MonteCarlo,
+    RandomVariable,
+    Integrate,
     exp,
     log,
 )
 
 # Read the data
 df = pd.read_csv('optima.dat', sep='\t')
 database = db.Database('optima', df)
@@ -35,62 +35,65 @@
 
 # Exclude observations such that the chosen alternative is -1
 database.remove(Choice == -1.0)
 
 ### Variables
 
 # Piecewise linear definition of income
-ScaledIncome = DefineVariable(
-    'ScaledIncome', CalculatedIncome / 1000, database
-)
+ScaledIncome = database.DefineVariable(
+    'ScaledIncome', CalculatedIncome / 1000)
 
 thresholds = [None, 4, 6, 8, 10, None]
 formulaIncome = models.piecewiseFormula(
     ScaledIncome, thresholds, [0.0, 0.0, 0.0, 0.0, 0.0]
 )
 
 # Definition of other variables
-age_65_more = DefineVariable('age_65_more', age >= 65, database)
-moreThanOneCar = DefineVariable('moreThanOneCar', NbCar > 1, database)
-moreThanOneBike = DefineVariable('moreThanOneBike', NbBicy > 1, database)
-individualHouse = DefineVariable('individualHouse', HouseType == 1, database)
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-haveGA = DefineVariable('haveGA', GenAbST == 1, database)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+age_65_more = database.DefineVariable('age_65_more', age >= 65)
+moreThanOneCar = database.DefineVariable('moreThanOneCar', NbCar > 1)
+moreThanOneBike = database.DefineVariable('moreThanOneBike', NbBicy > 1)
+individualHouse = database.DefineVariable('individualHouse', HouseType == 1)
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0)
+haveGA = database.DefineVariable('haveGA', GenAbST == 1)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
 # Parameters to be estimated
 coef_intercept = Beta('coef_intercept', 0.0, None, None, 1)
 coef_age_65_more = Beta('coef_age_65_more', 0.0, None, None, 0)
 coef_haveGA = Beta('coef_haveGA', 0.0, None, None, 0)
 coef_moreThanOneCar = Beta('coef_moreThanOneCar', 0.0, None, None, 0)
 coef_moreThanOneBike = Beta('coef_moreThanOneBike', 0.0, None, None, 0)
 coef_individualHouse = Beta('coef_individualHouse', 0.0, None, None, 0)
 coef_male = Beta('coef_male', 0.0, None, None, 0)
 coef_haveChildren = Beta('coef_haveChildren', 0.0, None, None, 0)
 coef_highEducation = Beta('coef_highEducation', 0.0, None, None, 0)
 
 ### Latent variable: structural equation
 
+# Define a random parameter, normally distributed)
+# designed to be used
+# for numerical integration
+omega = RandomVariable('omega')
+density = dist.normalpdf(omega)
 sigma_s = Beta('sigma_s', 1, None, None, 0)
 
 CARLOVERS = (
     coef_intercept
     + coef_age_65_more * age_65_more
     + formulaIncome
     + coef_moreThanOneCar * moreThanOneCar
     + coef_moreThanOneBike * moreThanOneBike
     + coef_individualHouse * individualHouse
     + coef_male * male
     + coef_haveChildren * haveChildren
     + coef_haveGA * haveGA
     + coef_highEducation * highEducation
-    + sigma_s * bioDraws('EC', 'NORMAL_MLHS')
+    + sigma_s * omega
 )
 
 # Choice model
 
 ASC_CAR = Beta('ASC_CAR', 0.0, None, None, 0)
 ASC_PT = Beta('ASC_PT', 0.0, None, None, 1)
 ASC_SM = Beta('ASC_SM', 0.0, None, None, 0)
@@ -99,27 +102,24 @@
 BETA_DIST = Beta('BETA_DIST', 0.0, None, None, 0)
 BETA_TIME_CAR_REF = Beta('BETA_TIME_CAR_REF', 0.0, None, 0, 0)
 BETA_TIME_CAR_CL = Beta('BETA_TIME_CAR_CL', 0.0, None, None, 0)
 BETA_TIME_PT_REF = Beta('BETA_TIME_PT_REF', 0.0, None, 0, 0)
 BETA_TIME_PT_CL = Beta('BETA_TIME_PT_CL', -1.0, None, None, 0)
 BETA_WAITING_TIME = Beta('BETA_WAITING_TIME', 0.0, None, None, 0)
 
-TimePT_scaled = DefineVariable('TimePT_scaled', TimePT / 200, database)
-TimeCar_scaled = DefineVariable('TimeCar_scaled', TimeCar / 200, database)
-MarginalCostPT_scaled = DefineVariable(
-    'MarginalCostPT_scaled', MarginalCostPT / 10, database
-)
-CostCarCHF_scaled = DefineVariable(
-    'CostCarCHF_scaled', CostCarCHF / 10, database
-)
-distance_km_scaled = DefineVariable(
-    'distance_km_scaled', distance_km / 5, database
-)
-PurpHWH = DefineVariable('PurpHWH', TripPurpose == 1, database)
-PurpOther = DefineVariable('PurpOther', TripPurpose != 1, database)
+TimePT_scaled = database.DefineVariable('TimePT_scaled', TimePT / 200)
+TimeCar_scaled = database.DefineVariable('TimeCar_scaled', TimeCar / 200)
+MarginalCostPT_scaled = database.DefineVariable(
+    'MarginalCostPT_scaled', MarginalCostPT / 10)
+CostCarCHF_scaled = database.DefineVariable(
+    'CostCarCHF_scaled', CostCarCHF / 10)
+distance_km_scaled = database.DefineVariable(
+    'distance_km_scaled', distance_km / 5)
+PurpHWH = database.DefineVariable('PurpHWH', TripPurpose == 1)
+PurpOther = database.DefineVariable('PurpOther', TripPurpose != 1)
 
 ### Definition of utility functions:
 
 BETA_TIME_PT = BETA_TIME_PT_REF * exp(BETA_TIME_PT_CL * CARLOVERS)
 
 V0 = (
     ASC_PT
@@ -142,26 +142,26 @@
 
 # Associate utility functions with the numbering of alternatives
 V = {0: V0, 1: V1, 2: V2}
 
 # Conditional to omega, we have a logit model (called the kernel)
 condprob = models.logit(V, None, Choice)
 # We integrate over omega using numerical integration
-loglike = log(MonteCarlo(condprob))
+loglike = log(Integrate(condprob * density, 'omega'))
 
 # Define level of verbosity
 logger = msg.bioMessage()
 # logger.setSilent()
 # logger.setWarning()
 logger.setGeneral()
 # logger.setDetailed()
 
 # Create the Biogeme object
-biogeme = bio.BIOGEME(database, loglike, numberOfDraws=10000)
-biogeme.modelName = '03choiceOnly_mc'
+biogeme = bio.BIOGEME(database, loglike)
+biogeme.modelName = '03choiceOnly'
 
 # Estimate the parameters
 results = biogeme.estimate(algorithm=opt.bioNewton)
 
 print(f'Estimated betas: {len(results.data.betaValues)}')
 print(f'Final log likelihood: {results.data.logLike:.3f}')
 print(f'Output file: {results.data.htmlFileName}')
```

### Comparing `biogeme-3.2.8/examples/latent/04latentChoiceSeq.py` & `biogeme-3.2.9/examples/latent/04latentChoiceSeq.py`

 * *Files 6% similar despite different names*

```diff
@@ -16,15 +16,14 @@
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.distributions as dist
 import biogeme.results as res
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
     RandomVariable,
     exp,
     log,
     Integrate,
 )
 
 # Read the data
@@ -48,39 +47,37 @@
     )
     sys.exit()
 structBetas = structResults.getBetaValues()
 
 ### Variables
 
 # Piecewise linear definition of income
-ScaledIncome = DefineVariable(
-    'ScaledIncome', CalculatedIncome / 1000, database
-)
+ScaledIncome = database.DefineVariable(
+    'ScaledIncome', CalculatedIncome / 1000)
 thresholds = [None, 4, 6, 8, 10, None]
 piecewiseVariables = models.piecewiseVariables(ScaledIncome, thresholds)
 formulaIncome = (
-    structBetas['beta_ScaledIncome_lessthan_4'] * piecewiseVariables[0]
+    structBetas['beta_ScaledIncome_minus_inf_4'] * piecewiseVariables[0]
     + structBetas['beta_ScaledIncome_4_6'] * piecewiseVariables[1]
     + structBetas['beta_ScaledIncome_6_8'] * piecewiseVariables[2]
     + structBetas['beta_ScaledIncome_8_10'] * piecewiseVariables[3]
-    + structBetas['beta_ScaledIncome_10_more'] * piecewiseVariables[4]
+    + structBetas['beta_ScaledIncome_10_inf'] * piecewiseVariables[4]
 )
 
 
 # Definition of other variables
-age_65_more = DefineVariable('age_65_more', age >= 65, database)
-moreThanOneCar = DefineVariable('moreThanOneCar', NbCar > 1, database)
-moreThanOneBike = DefineVariable('moreThanOneBike', NbBicy > 1, database)
-individualHouse = DefineVariable('individualHouse', HouseType == 1, database)
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-haveGA = DefineVariable('haveGA', GenAbST == 1, database)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+age_65_more = database.DefineVariable('age_65_more', age >= 65)
+moreThanOneCar = database.DefineVariable('moreThanOneCar', NbCar > 1)
+moreThanOneBike = database.DefineVariable('moreThanOneBike', NbBicy > 1)
+individualHouse = database.DefineVariable('individualHouse', HouseType == 1)
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0)
+haveGA = database.DefineVariable('haveGA', GenAbST == 1)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
 ### Coefficients
 
 coef_intercept = structBetas['coef_intercept']
 coef_age_65_more = structBetas['coef_age_65_more']
 coef_haveGA = structBetas['coef_haveGA']
 coef_moreThanOneCar = structBetas['coef_moreThanOneCar']
@@ -126,27 +123,27 @@
 # The coefficient of the latent variable should be initialized to
 # something different from zero. If not, the algorithm may be trapped
 # in a local optimum, and never change the value.
 BETA_TIME_PT_CL = Beta('BETA_TIME_PT_CL', -0.01, None, None, 0)
 BETA_TIME_CAR_CL = Beta('BETA_TIME_CAR_CL', -0.01, None, None, 0)
 
 
-TimePT_scaled = DefineVariable('TimePT_scaled', TimePT / 200, database)
-TimeCar_scaled = DefineVariable('TimeCar_scaled', TimeCar / 200, database)
-MarginalCostPT_scaled = DefineVariable(
-    'MarginalCostPT_scaled', MarginalCostPT / 10, database
+TimePT_scaled = database.DefineVariable('TimePT_scaled', TimePT / 200)
+TimeCar_scaled = database.DefineVariable('TimeCar_scaled', TimeCar / 200)
+MarginalCostPT_scaled = database.DefineVariable(
+    'MarginalCostPT_scaled', MarginalCostPT / 10
 )
-CostCarCHF_scaled = DefineVariable(
-    'CostCarCHF_scaled', CostCarCHF / 10, database
+CostCarCHF_scaled = database.DefineVariable(
+    'CostCarCHF_scaled', CostCarCHF / 10
 )
-distance_km_scaled = DefineVariable(
-    'distance_km_scaled', distance_km / 5, database
+distance_km_scaled = database.DefineVariable(
+    'distance_km_scaled', distance_km / 5
 )
-PurpHWH = DefineVariable('PurpHWH', TripPurpose == 1, database)
-PurpOther = DefineVariable('PurpOther', TripPurpose != 1, database)
+PurpHWH = database.DefineVariable('PurpHWH', TripPurpose == 1)
+PurpOther = database.DefineVariable('PurpOther', TripPurpose != 1)
 
 ### Definition of utility functions:
 
 BETA_TIME_PT = BETA_TIME_PT_REF * exp(BETA_TIME_PT_CL * CARLOVERS)
 
 V0 = (
     ASC_PT
```

### Comparing `biogeme-3.2.8/examples/latent/04latentChoiceSeq_mc.py` & `biogeme-3.2.9/examples/latent/04latentChoiceSeq_mc.py`

 * *Files 10% similar despite different names*

```diff
@@ -15,15 +15,14 @@
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.results as res
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
     bioDraws,
     MonteCarlo,
     exp,
     log,
 )
 
 # Read the data
@@ -47,39 +46,37 @@
     )
     sys.exit()
 structBetas = structResults.getBetaValues()
 
 ### Variables
 
 # Piecewise linear definition of income
-ScaledIncome = DefineVariable(
-    'ScaledIncome', CalculatedIncome / 1000, database
-)
+ScaledIncome = database.DefineVariable(
+    'ScaledIncome', CalculatedIncome / 1000)
 thresholds = [None, 4, 6, 8, 10, None]
 piecewiseVariables = models.piecewiseVariables(ScaledIncome, thresholds)
 formulaIncome = (
-    structBetas['beta_ScaledIncome_lessthan_4'] * piecewiseVariables[0]
+    structBetas['beta_ScaledIncome_minus_inf_4'] * piecewiseVariables[0]
     + structBetas['beta_ScaledIncome_4_6'] * piecewiseVariables[1]
     + structBetas['beta_ScaledIncome_6_8'] * piecewiseVariables[2]
     + structBetas['beta_ScaledIncome_8_10'] * piecewiseVariables[3]
-    + structBetas['beta_ScaledIncome_10_more'] * piecewiseVariables[4]
+    + structBetas['beta_ScaledIncome_10_inf'] * piecewiseVariables[4]
 )
 
 
 # Definition of other variables
-age_65_more = DefineVariable('age_65_more', age >= 65, database)
-moreThanOneCar = DefineVariable('moreThanOneCar', NbCar > 1, database)
-moreThanOneBike = DefineVariable('moreThanOneBike', NbBicy > 1, database)
-individualHouse = DefineVariable('individualHouse', HouseType == 1, database)
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-haveGA = DefineVariable('haveGA', GenAbST == 1, database)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+age_65_more = database.DefineVariable('age_65_more', age >= 65)
+moreThanOneCar = database.DefineVariable('moreThanOneCar', NbCar > 1)
+moreThanOneBike = database.DefineVariable('moreThanOneBike', NbBicy > 1)
+individualHouse = database.DefineVariable('individualHouse', HouseType == 1)
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0)
+haveGA = database.DefineVariable('haveGA', GenAbST == 1)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
 ### Coefficients
 
 coef_intercept = structBetas['coef_intercept']
 coef_age_65_more = structBetas['coef_age_65_more']
 coef_haveGA = structBetas['coef_haveGA']
 coef_moreThanOneCar = structBetas['coef_moreThanOneCar']
@@ -123,27 +120,27 @@
 # The coefficient of the latent variable should be initialized to
 # something different from zero. If not, the algorithm may be trapped
 # in a local optimum, and never change the value.
 BETA_TIME_PT_CL = Beta('BETA_TIME_PT_CL', -0.01, None, None, 0)
 BETA_TIME_CAR_CL = Beta('BETA_TIME_CAR_CL', -0.01, None, None, 0)
 
 
-TimePT_scaled = DefineVariable('TimePT_scaled', TimePT / 200, database)
-TimeCar_scaled = DefineVariable('TimeCar_scaled', TimeCar / 200, database)
-MarginalCostPT_scaled = DefineVariable(
-    'MarginalCostPT_scaled', MarginalCostPT / 10, database
+TimePT_scaled = database.DefineVariable('TimePT_scaled', TimePT / 200)
+TimeCar_scaled = database.DefineVariable('TimeCar_scaled', TimeCar / 200)
+MarginalCostPT_scaled = database.DefineVariable(
+    'MarginalCostPT_scaled', MarginalCostPT / 10
 )
-CostCarCHF_scaled = DefineVariable(
-    'CostCarCHF_scaled', CostCarCHF / 10, database
+CostCarCHF_scaled = database.DefineVariable(
+    'CostCarCHF_scaled', CostCarCHF / 10
 )
-distance_km_scaled = DefineVariable(
-    'distance_km_scaled', distance_km / 5, database
+distance_km_scaled = database.DefineVariable(
+    'distance_km_scaled', distance_km / 5
 )
-PurpHWH = DefineVariable('PurpHWH', TripPurpose == 1, database)
-PurpOther = DefineVariable('PurpOther', TripPurpose != 1, database)
+PurpHWH = database.DefineVariable('PurpHWH', TripPurpose == 1)
+PurpOther = database.DefineVariable('PurpOther', TripPurpose != 1)
 
 ### Definition of utility functions:
 
 BETA_TIME_PT = BETA_TIME_PT_REF * exp(BETA_TIME_PT_CL * CARLOVERS)
 
 V0 = (
     ASC_PT
@@ -176,15 +173,15 @@
 logger = msg.bioMessage()
 # logger.setSilent()
 # logger.setWarning()
 logger.setGeneral()
 # logger.setDetailed()
 
 # Create the Biogeme object
-biogeme = bio.BIOGEME(database, loglike, numberOfDraws=10000)
+biogeme = bio.BIOGEME(database, loglike, numberOfDraws=20000)
 biogeme.modelName = '04latentChoiceSeq_mc'
 
 # Estimate the parameters
 results = biogeme.estimate()
 
 print(f'Estimated betas: {len(results.data.betaValues)}')
 print(f'Final log likelihood: {results.data.logLike:.3f}')
```

### Comparing `biogeme-3.2.8/examples/latent/05latentChoiceFull.py` & `biogeme-3.2.9/examples/latent/05latentChoiceFull.py`

 * *Files 5% similar despite different names*

```diff
@@ -15,15 +15,14 @@
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.distributions as dist
 import biogeme.results as res
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
     log,
     RandomVariable,
     Integrate,
     Elem,
     bioNormalCdf,
     exp,
 )
@@ -49,41 +48,39 @@
     )
     sys.exit()
 structBetas = structResults.getBetaValues()
 
 ### Variables
 
 # Piecewise linear definition of income
-ScaledIncome = DefineVariable(
-    'ScaledIncome', CalculatedIncome / 1000, database
-)
+ScaledIncome = database.DefineVariable(
+    'ScaledIncome', CalculatedIncome / 1000)
 thresholds = [None, 4, 6, 8, 10, None]
 formulaIncome = models.piecewiseFormula(
     ScaledIncome,
     thresholds,
     [
-        structBetas['beta_ScaledIncome_lessthan_4'],
+        structBetas['beta_ScaledIncome_minus_inf_4'],
         structBetas['beta_ScaledIncome_4_6'],
         structBetas['beta_ScaledIncome_6_8'],
         structBetas['beta_ScaledIncome_8_10'],
-        structBetas['beta_ScaledIncome_10_more'],
+        structBetas['beta_ScaledIncome_10_inf'],
     ],
 )
 
 # Definition of other variables
-age_65_more = DefineVariable('age_65_more', age >= 65, database)
-moreThanOneCar = DefineVariable('moreThanOneCar', NbCar > 1, database)
-moreThanOneBike = DefineVariable('moreThanOneBike', NbBicy > 1, database)
-individualHouse = DefineVariable('individualHouse', HouseType == 1, database)
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-haveGA = DefineVariable('haveGA', GenAbST == 1, database)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+age_65_more = database.DefineVariable('age_65_more', age >= 65)
+moreThanOneCar = database.DefineVariable('moreThanOneCar', NbCar > 1)
+moreThanOneBike = database.DefineVariable('moreThanOneBike', NbBicy > 1)
+individualHouse = database.DefineVariable('individualHouse', HouseType == 1)
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0)
+haveGA = database.DefineVariable('haveGA', GenAbST == 1)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
 
 ### Coefficients
 
 coef_intercept = Beta(
     'coef_intercept', structBetas['coef_intercept'], None, None, 0
 )
@@ -329,27 +326,27 @@
 BETA_TIME_PT_CL = Beta(
     'BETA_TIME_PT_CL', choiceBetas['BETA_TIME_PT_CL'], None, None, 0
 )
 BETA_WAITING_TIME = Beta(
     'BETA_WAITING_TIME', choiceBetas['BETA_WAITING_TIME'], None, None, 0
 )
 
-TimePT_scaled = DefineVariable('TimePT_scaled', TimePT / 200, database)
-TimeCar_scaled = DefineVariable('TimeCar_scaled', TimeCar / 200, database)
-MarginalCostPT_scaled = DefineVariable(
-    'MarginalCostPT_scaled', MarginalCostPT / 10, database
+TimePT_scaled = database.DefineVariable('TimePT_scaled', TimePT / 200)
+TimeCar_scaled = database.DefineVariable('TimeCar_scaled', TimeCar / 200)
+MarginalCostPT_scaled = database.DefineVariable(
+    'MarginalCostPT_scaled', MarginalCostPT / 10
 )
-CostCarCHF_scaled = DefineVariable(
-    'CostCarCHF_scaled', CostCarCHF / 10, database
+CostCarCHF_scaled = database.DefineVariable(
+    'CostCarCHF_scaled', CostCarCHF / 10
 )
-distance_km_scaled = DefineVariable(
-    'distance_km_scaled', distance_km / 5, database
+distance_km_scaled = database.DefineVariable(
+    'distance_km_scaled', distance_km / 5
 )
-PurpHWH = DefineVariable('PurpHWH', TripPurpose == 1, database)
-PurpOther = DefineVariable('PurpOther', TripPurpose != 1, database)
+PurpHWH = database.DefineVariable('PurpHWH', TripPurpose == 1)
+PurpOther = database.DefineVariable('PurpOther', TripPurpose != 1)
 
 ### Definition of utility functions:
 
 BETA_TIME_PT = BETA_TIME_PT_REF * exp(BETA_TIME_PT_CL * CARLOVERS)
 
 V0 = (
     ASC_PT
```

### Comparing `biogeme-3.2.8/examples/latent/05latentChoiceFull_mc.py` & `biogeme-3.2.9/examples/latent/05latentChoiceFull_mc.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,14 @@
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.optimization as opt
 import biogeme.results as res
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
     log,
     bioDraws,
     MonteCarlo,
     Elem,
     bioNormalCdf,
     exp,
 )
@@ -49,41 +48,39 @@
     )
     sys.exit()
 structBetas = structResults.getBetaValues()
 
 ### Variables
 
 # Piecewise linear definition of income
-ScaledIncome = DefineVariable(
-    'ScaledIncome', CalculatedIncome / 1000, database
-)
+ScaledIncome = database.DefineVariable(
+    'ScaledIncome', CalculatedIncome / 1000)
 thresholds = [None, 4, 6, 8, 10, None]
 formulaIncome = models.piecewiseFormula(
     ScaledIncome,
     thresholds,
     [
-        structBetas['beta_ScaledIncome_lessthan_4'],
+        structBetas['beta_ScaledIncome_minus_inf_4'],
         structBetas['beta_ScaledIncome_4_6'],
         structBetas['beta_ScaledIncome_6_8'],
         structBetas['beta_ScaledIncome_8_10'],
-        structBetas['beta_ScaledIncome_10_more'],
+        structBetas['beta_ScaledIncome_10_inf'],
     ],
 )
 
 # Definition of other variables
-age_65_more = DefineVariable('age_65_more', age >= 65, database)
-moreThanOneCar = DefineVariable('moreThanOneCar', NbCar > 1, database)
-moreThanOneBike = DefineVariable('moreThanOneBike', NbBicy > 1, database)
-individualHouse = DefineVariable('individualHouse', HouseType == 1, database)
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-haveGA = DefineVariable('haveGA', GenAbST == 1, database)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+age_65_more = database.DefineVariable('age_65_more', age >= 65)
+moreThanOneCar = database.DefineVariable('moreThanOneCar', NbCar > 1)
+moreThanOneBike = database.DefineVariable('moreThanOneBike', NbBicy > 1)
+individualHouse = database.DefineVariable('individualHouse', HouseType == 1)
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0)
+haveGA = database.DefineVariable('haveGA', GenAbST == 1)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
 
 ### Coefficients
 
 coef_intercept = Beta(
     'coef_intercept', structBetas['coef_intercept'], None, None, 0
 )
@@ -327,27 +324,27 @@
 BETA_TIME_PT_CL = Beta(
     'BETA_TIME_PT_CL', choiceBetas['BETA_TIME_PT_CL'], None, None, 0
 )
 BETA_WAITING_TIME = Beta(
     'BETA_WAITING_TIME', choiceBetas['BETA_WAITING_TIME'], None, None, 0
 )
 
-TimePT_scaled = DefineVariable('TimePT_scaled', TimePT / 200, database)
-TimeCar_scaled = DefineVariable('TimeCar_scaled', TimeCar / 200, database)
-MarginalCostPT_scaled = DefineVariable(
-    'MarginalCostPT_scaled', MarginalCostPT / 10, database
+TimePT_scaled = database.DefineVariable('TimePT_scaled', TimePT / 200)
+TimeCar_scaled = database.DefineVariable('TimeCar_scaled', TimeCar / 200)
+MarginalCostPT_scaled = database.DefineVariable(
+    'MarginalCostPT_scaled', MarginalCostPT / 10
 )
-CostCarCHF_scaled = DefineVariable(
-    'CostCarCHF_scaled', CostCarCHF / 10, database
+CostCarCHF_scaled = database.DefineVariable(
+    'CostCarCHF_scaled', CostCarCHF / 10
 )
-distance_km_scaled = DefineVariable(
-    'distance_km_scaled', distance_km / 5, database
+distance_km_scaled = database.DefineVariable(
+    'distance_km_scaled', distance_km / 5
 )
-PurpHWH = DefineVariable('PurpHWH', TripPurpose == 1, database)
-PurpOther = DefineVariable('PurpOther', TripPurpose != 1, database)
+PurpHWH = database.DefineVariable('PurpHWH', TripPurpose == 1)
+PurpOther = database.DefineVariable('PurpOther', TripPurpose != 1)
 
 ### Definition of utility functions:
 
 BETA_TIME_PT = BETA_TIME_PT_REF * exp(BETA_TIME_PT_CL * CARLOVERS)
 
 V0 = (
     ASC_PT
@@ -395,15 +392,15 @@
 logger = msg.bioMessage()
 # logger.setSilent()
 # logger.setWarning()
 logger.setGeneral()
 # logger.setDetailed()
 
 # Create the Biogeme object
-biogeme = bio.BIOGEME(database, loglike, numberOfDraws=10000)
+biogeme = bio.BIOGEME(database, loglike, numberOfDraws=20000)
 biogeme.modelName = '05latentChoiceFull_mc'
 
 # Estimate the parameters
 results = biogeme.estimate(algorithm=opt.bioBfgs)
 
 print(f'Estimated betas: {len(results.data.betaValues)}')
 print(f'Final log likelihood: {results.data.logLike:.3f}')
```

### Comparing `biogeme-3.2.8/examples/latent/06serialCorrelation.py` & `biogeme-3.2.9/examples/latent/06serialCorrelation.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,17 +13,17 @@
 import sys
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.results as res
 import biogeme.messaging as msg
+import biogeme.optimization as opt
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
     bioDraws,
     MonteCarlo,
     Elem,
     bioNormalCdf,
     exp,
     log,
 )
@@ -52,41 +52,39 @@
     sys.exit()
 
 betas = results.getBetaValues()
 
 ### Variables
 
 # Piecewise linear definition of income
-ScaledIncome = DefineVariable(
-    'ScaledIncome', CalculatedIncome / 1000, database
-)
+ScaledIncome = database.DefineVariable(
+    'ScaledIncome', CalculatedIncome / 1000)
 thresholds = [None, 4, 6, 8, 10, None]
 formulaIncome = models.piecewiseFormula(
     ScaledIncome,
     thresholds,
     [
-        betas['beta_ScaledIncome_lessthan_4'],
+        betas['beta_ScaledIncome_minus_inf_4'],
         betas['beta_ScaledIncome_4_6'],
         betas['beta_ScaledIncome_6_8'],
         betas['beta_ScaledIncome_8_10'],
-        betas['beta_ScaledIncome_10_more'],
+        betas['beta_ScaledIncome_10_inf'],
     ],
 )
 
 # Definition of other variables
-age_65_more = DefineVariable('age_65_more', age >= 65, database)
-moreThanOneCar = DefineVariable('moreThanOneCar', NbCar > 1, database)
-moreThanOneBike = DefineVariable('moreThanOneBike', NbBicy > 1, database)
-individualHouse = DefineVariable('individualHouse', HouseType == 1, database)
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-haveGA = DefineVariable('haveGA', GenAbST == 1, database)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+age_65_more = database.DefineVariable('age_65_more', age >= 65)
+moreThanOneCar = database.DefineVariable('moreThanOneCar', NbCar > 1)
+moreThanOneBike = database.DefineVariable('moreThanOneBike', NbBicy > 1)
+individualHouse = database.DefineVariable('individualHouse', HouseType == 1)
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0)
+haveGA = database.DefineVariable('haveGA', GenAbST == 1)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
 
 ### Coefficients
 
 coef_intercept = Beta('coef_intercept', betas['coef_intercept'], None, None, 0)
 coef_age_65_more = Beta(
     'coef_age_65_more', betas['coef_age_65_more'], None, None, 0
@@ -332,27 +330,27 @@
     'BETA_TIME_PT_REF', betas['BETA_TIME_PT_REF'], None, 0, 0
 )
 BETA_TIME_PT_CL = Beta('BETA_TIME_PT_CL', betas['BETA_TIME_PT_CL'], -10, 10, 0)
 BETA_WAITING_TIME = Beta(
     'BETA_WAITING_TIME', betas['BETA_WAITING_TIME'], None, None, 0
 )
 
-TimePT_scaled = DefineVariable('TimePT_scaled', TimePT / 200, database)
-TimeCar_scaled = DefineVariable('TimeCar_scaled', TimeCar / 200, database)
-MarginalCostPT_scaled = DefineVariable(
-    'MarginalCostPT_scaled', MarginalCostPT / 10, database
+TimePT_scaled = database.DefineVariable('TimePT_scaled', TimePT / 200)
+TimeCar_scaled = database.DefineVariable('TimeCar_scaled', TimeCar / 200)
+MarginalCostPT_scaled = database.DefineVariable(
+    'MarginalCostPT_scaled', MarginalCostPT / 10
 )
-CostCarCHF_scaled = DefineVariable(
-    'CostCarCHF_scaled', CostCarCHF / 10, database
+CostCarCHF_scaled = database.DefineVariable(
+    'CostCarCHF_scaled', CostCarCHF / 10
 )
-distance_km_scaled = DefineVariable(
-    'distance_km_scaled', distance_km / 5, database
+distance_km_scaled = database.DefineVariable(
+    'distance_km_scaled', distance_km / 5
 )
-PurpHWH = DefineVariable('PurpHWH', TripPurpose == 1, database)
-PurpOther = DefineVariable('PurpOther', TripPurpose != 1, database)
+PurpHWH = database.DefineVariable('PurpHWH', TripPurpose == 1)
+PurpOther = database.DefineVariable('PurpOther', TripPurpose != 1)
 
 ### DEFINITION OF UTILITY FUNCTIONS:
 
 BETA_TIME_PT = BETA_TIME_PT_REF * exp(BETA_TIME_PT_CL * CARLOVERS)
 
 V0 = (
     ASC_PT
@@ -406,13 +404,13 @@
 # logger.setDetailed()
 
 # Create the Biogeme object
 biogeme = bio.BIOGEME(database, loglike, numberOfDraws=20000)
 biogeme.modelName = '06serialCorrelation'
 
 # Estimate the parameters
-results = biogeme.estimate()
+results = biogeme.estimate(algorithm=opt.bioBfgs)
 print(f'Estimated betas: {len(results.data.betaValues)}')
 print(f'Final log likelihood: {results.data.logLike:.3f}')
 print(f'Output file: {results.data.htmlFileName}')
 results.writeLaTeX()
 print(f'LaTeX file: {results.data.latexFileName}')
```

### Comparing `biogeme-3.2.8/examples/latent/07problem.py` & `biogeme-3.2.9/examples/latent/07problem.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,50 +14,49 @@
 :date: Wed Sep 11 15:40:43 2019
 
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
+import biogeme.optimization as opt
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable, log, Elem, bioNormalCdf
+from biogeme.expressions import Beta, log, Elem, bioNormalCdf
 
 # Read the data
 df = pd.read_csv('optima.dat', sep='\t')
 database = db.Database('optima', df)
 
 # The following statement allows you to use the names of the variable
 # as Python variable.
 globals().update(database.variables)
 
 # Exclude observations such that the chosen alternative is -1
 database.remove(Choice == -1.0)
 
 # Piecewise linear definition of income
-ScaledIncome = DefineVariable(
-    'ScaledIncome', CalculatedIncome / 1000, database
-)
+ScaledIncome = database.DefineVariable(
+    'ScaledIncome', CalculatedIncome / 1000)
 
 thresholds = [None, 4, 6, 8, 10, None]
 formulaIncome = models.piecewiseFormula(
     ScaledIncome, thresholds, [0.0, 0.0, 0.0, 0.0, 0.0]
 )
 
 # Definition of other variables
-age_65_more = DefineVariable('age_65_more', age >= 65, database)
-moreThanOneCar = DefineVariable('moreThanOneCar', NbCar > 1, database)
-moreThanOneBike = DefineVariable('moreThanOneBike', NbBicy > 1, database)
-individualHouse = DefineVariable('individualHouse', HouseType == 1, database)
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-haveGA = DefineVariable('haveGA', GenAbST == 1, database)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+age_65_more = database.DefineVariable('age_65_more', age >= 65)
+moreThanOneCar = database.DefineVariable('moreThanOneCar', NbCar > 1)
+moreThanOneBike = database.DefineVariable('moreThanOneBike', NbBicy > 1)
+individualHouse = database.DefineVariable('individualHouse', HouseType == 1)
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0)
+haveGA = database.DefineVariable('haveGA', GenAbST == 1)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
 # Parameters to be estimated
 coef_intercept = Beta('coef_intercept', 0.0, None, None, 0)
 coef_age_65_more = Beta('coef_age_65_more', 0.0, None, None, 0)
 coef_haveGA = Beta('coef_haveGA', 0.0, None, None, 0)
 coef_moreThanOneCar = Beta('coef_moreThanOneCar', 0.0, None, None, 0)
 coef_moreThanOneBike = Beta('coef_moreThanOneBike', 0.0, None, None, 0)
```

### Comparing `biogeme-3.2.8/examples/latent/07problem_simul.py` & `biogeme-3.2.9/examples/latent/07problem_simul.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,48 +9,46 @@
 
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
-from biogeme.expressions import Beta, DefineVariable, Elem, bioNormalCdf
+from biogeme.expressions import Beta, Elem, bioNormalCdf
 
 # Read the data
 df = pd.read_csv('optima.dat', sep='\t')
 database = db.Database('optima', df)
 
 # The following statement allows you to use the names of the variable
 # as Python variable.
 globals().update(database.variables)
 
 # Exclude observations such that the chosen alternative is -1
 database.remove(Choice == -1.0)
 
 # Piecewise linear definition of income
-ScaledIncome = DefineVariable(
-    'ScaledIncome', CalculatedIncome / 1000, database
-)
+ScaledIncome = database.DefineVariable(
+    'ScaledIncome', CalculatedIncome / 1000)
 
 thresholds = [None, 4, 6, 8, 10, None]
 formulaIncome = models.piecewiseFormula(
     ScaledIncome, thresholds, [0.0, 0.0, 0.0, 0.0, 0.0]
 )
 
 # Definition of other variables
-age_65_more = DefineVariable('age_65_more', age >= 65, database)
-moreThanOneCar = DefineVariable('moreThanOneCar', NbCar > 1, database)
-moreThanOneBike = DefineVariable('moreThanOneBike', NbBicy > 1, database)
-individualHouse = DefineVariable('individualHouse', HouseType == 1, database)
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-haveGA = DefineVariable('haveGA', GenAbST == 1, database)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+age_65_more = database.DefineVariable('age_65_more', age >= 65)
+moreThanOneCar = database.DefineVariable('moreThanOneCar', NbCar > 1)
+moreThanOneBike = database.DefineVariable('moreThanOneBike', NbBicy > 1)
+individualHouse = database.DefineVariable('individualHouse', HouseType == 1)
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0)
+haveGA = database.DefineVariable('haveGA', GenAbST == 1)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
 # Parameters to be estimated
 coef_intercept = Beta('coef_intercept', 0.0, None, None, 0)
 coef_age_65_more = Beta('coef_age_65_more', 0.0, None, None, 0)
 coef_haveGA = Beta('coef_haveGA', 0.0, None, None, 0)
 coef_moreThanOneCar = Beta('coef_moreThanOneCar', 0.0, None, None, 0)
 coef_moreThanOneBike = Beta('coef_moreThanOneBike', 0.0, None, None, 0)
```

### Comparing `biogeme-3.2.8/examples/latentbis/m01_latent_variable.py` & `biogeme-3.2.9/examples/latentbis/m01_latent_variable.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 """
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
+    Variable,
     log,
     Elem,
     bioNormalCdf,
     Variable,
     bioMultSum,
 )
 
@@ -35,28 +35,28 @@
 SocioProfCat = Variable('SocioProfCat')
 age = Variable('age')
 
 # Exclude observations such that the chosen alternative is -1
 database.remove(Choice == -1.0)
 
 # Definition of other variables
-male = DefineVariable('male', Gender == 1, database)
+male = database.DefineVariable('male', Gender == 1)
 
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0
 )
 
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
-childCenter = DefineVariable(
-    'childCenter', ((ResidChild == 1) + (ResidChild == 2)) > 0, database
+childCenter = database.DefineVariable(
+    'childCenter', ((ResidChild == 1) + (ResidChild == 2)) > 0
 )
 
-childSuburb = DefineVariable(
-    'childSuburb', ((ResidChild == 3) + (ResidChild == 4)) > 0, database
+childSuburb = database.DefineVariable(
+    'childSuburb', ((ResidChild == 3) + (ResidChild == 4)) > 0
 )
 
 # Parameters for the structural equation
 coef_intercept = Beta('coef_intercept', 0.0, None, None, 0)
 coef_age_30_less = Beta('coef_age_30_less', 0.0, None, None, 0)
 coef_male = Beta('coef_male', 0.0, None, None, 0)
 coef_haveChildren = Beta('coef_haveChildren', 0.0, None, None, 0)
```

### Comparing `biogeme-3.2.8/examples/latentbis/m02_sequential_estimation.py` & `biogeme-3.2.9/examples/latentbis/m02_sequential_estimation.py`

 * *Files 6% similar despite different names*

```diff
@@ -17,15 +17,14 @@
 import biogeme.distributions as dist
 import biogeme.results as res
 import biogeme.messaging as msg
 import biogeme.optimization as opt
 from biogeme import models
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
     Variable,
     RandomVariable,
     exp,
     log,
     Integrate,
 )
 
@@ -65,28 +64,28 @@
     )
     sys.exit()
 structBetas = structResults.getBetaValues()
 
 ### Variables
 
 # Definition of other variables
-male = DefineVariable('male', Gender == 1, database)
+male = database.DefineVariable('male', Gender == 1)
 
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0
 )
 
-highEducation = DefineVariable('highEducation', Education >= 6, database)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
 
-childCenter = DefineVariable(
-    'childCenter', ((ResidChild == 1) + (ResidChild == 2)) > 0, database
+childCenter = database.DefineVariable(
+    'childCenter', ((ResidChild == 1) + (ResidChild == 2)) > 0
 )
 
-childSuburb = DefineVariable(
-    'childSuburb', ((ResidChild == 3) + (ResidChild == 4)) > 0, database
+childSuburb = database.DefineVariable(
+    'childSuburb', ((ResidChild == 3) + (ResidChild == 4)) > 0
 )
 
 
 ### Coefficients
 
 coef_intercept = structBetas['coef_intercept']
 coef_age_30_less = structBetas['coef_age_30_less']
@@ -137,27 +136,27 @@
 # The coefficient of the latent variable should be initialized to
 # something different from zero. If not, the algorithm may be trapped
 # in a local optimum, and never change the value.
 BETA_TIME_PT_AL = Beta('BETA_TIME_PT_AL', 1, None, None, 0)
 BETA_TIME_CAR_AL = Beta('BETA_TIME_CAR_AL', -1, None, None, 0)
 
 
-TimePT_scaled = DefineVariable('TimePT_scaled', TimePT / 200, database)
-TimeCar_scaled = DefineVariable('TimeCar_scaled', TimeCar / 200, database)
-MarginalCostPT_scaled = DefineVariable(
-    'MarginalCostPT_scaled', MarginalCostPT / 10, database
+TimePT_scaled = database.DefineVariable('TimePT_scaled', TimePT / 200)
+TimeCar_scaled = database.DefineVariable('TimeCar_scaled', TimeCar / 200)
+MarginalCostPT_scaled = database.DefineVariable(
+    'MarginalCostPT_scaled', MarginalCostPT / 10
 )
-CostCarCHF_scaled = DefineVariable(
-    'CostCarCHF_scaled', CostCarCHF / 10, database
+CostCarCHF_scaled = database.DefineVariable(
+    'CostCarCHF_scaled', CostCarCHF / 10
 )
-distance_km_scaled = DefineVariable(
-    'distance_km_scaled', distance_km / 5, database
+distance_km_scaled = database.DefineVariable(
+    'distance_km_scaled', distance_km / 5
 )
-PurpHWH = DefineVariable('PurpHWH', TripPurpose == 1, database)
-PurpOther = DefineVariable('PurpOther', TripPurpose != 1, database)
+PurpHWH = database.DefineVariable('PurpHWH', TripPurpose == 1)
+PurpOther = database.DefineVariable('PurpOther', TripPurpose != 1)
 
 ### Definition of utility functions:
 
 BETA_TIME_PT = BETA_TIME_PT_REF * exp(BETA_TIME_PT_AL * ACTIVELIFE)
 
 V0 = (
     ASC_PT
```

### Comparing `biogeme-3.2.8/examples/latentbis/m03_simultaneous_estimation.py` & `biogeme-3.2.9/examples/latentbis/m03_simultaneous_estimation.py`

 * *Files 7% similar despite different names*

```diff
@@ -16,15 +16,14 @@
 import biogeme.distributions as dist
 import biogeme.results as res
 import biogeme.optimization as opt
 import biogeme.messaging as msg
 from biogeme import models
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
     Variable,
     log,
     RandomVariable,
     Integrate,
     Elem,
     bioNormalCdf,
     exp,
@@ -69,24 +68,24 @@
 structBetas = structResults.getBetaValues()
 
 
 ### Variables
 
 
 # Definition of other variables
-male = DefineVariable('male', Gender == 1, database)
-haveChildren = DefineVariable(
-    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0, database
-)
-highEducation = DefineVariable('highEducation', Education >= 6, database)
-childCenter = DefineVariable(
-    'childCenter', ((ResidChild == 1) + (ResidChild == 2)) > 0, database
+male = database.DefineVariable('male', Gender == 1)
+haveChildren = database.DefineVariable(
+    'haveChildren', ((FamilSitu == 3) + (FamilSitu == 4)) > 0
+)
+highEducation = database.DefineVariable('highEducation', Education >= 6)
+childCenter = database.DefineVariable(
+    'childCenter', ((ResidChild == 1) + (ResidChild == 2)) > 0
 )
-childSuburb = DefineVariable(
-    'childSuburb', ((ResidChild == 3) + (ResidChild == 4)) > 0, database
+childSuburb = database.DefineVariable(
+    'childSuburb', ((ResidChild == 3) + (ResidChild == 4)) > 0
 )
 
 ### Coefficients
 
 coef_intercept = Beta(
     'coef_intercept', structBetas['coef_intercept'], None, None, 0
 )
@@ -243,27 +242,27 @@
 BETA_TIME_PT_AL = Beta(
     'BETA_TIME_PT_AL', choiceBetas['BETA_TIME_PT_AL'], None, None, 0
 )
 BETA_WAITING_TIME = Beta(
     'BETA_WAITING_TIME', choiceBetas['BETA_WAITING_TIME'], None, None, 0
 )
 
-TimePT_scaled = DefineVariable('TimePT_scaled', TimePT / 200, database)
-TimeCar_scaled = DefineVariable('TimeCar_scaled', TimeCar / 200, database)
-MarginalCostPT_scaled = DefineVariable(
-    'MarginalCostPT_scaled', MarginalCostPT / 10, database
+TimePT_scaled = database.DefineVariable('TimePT_scaled', TimePT / 200)
+TimeCar_scaled = database.DefineVariable('TimeCar_scaled', TimeCar / 200)
+MarginalCostPT_scaled = database.DefineVariable(
+    'MarginalCostPT_scaled', MarginalCostPT / 10
 )
-CostCarCHF_scaled = DefineVariable(
-    'CostCarCHF_scaled', CostCarCHF / 10, database
+CostCarCHF_scaled = database.DefineVariable(
+    'CostCarCHF_scaled', CostCarCHF / 10
 )
-distance_km_scaled = DefineVariable(
-    'distance_km_scaled', distance_km / 5, database
+distance_km_scaled = database.DefineVariable(
+    'distance_km_scaled', distance_km / 5
 )
-PurpHWH = DefineVariable('PurpHWH', TripPurpose == 1, database)
-PurpOther = DefineVariable('PurpOther', TripPurpose != 1, database)
+PurpHWH = database.DefineVariable('PurpHWH', TripPurpose == 1)
+PurpOther = database.DefineVariable('PurpOther', TripPurpose != 1)
 
 ### Definition of utility functions:
 
 BETA_TIME_PT = BETA_TIME_PT_REF * exp(BETA_TIME_PT_AL * ACTIVELIFE)
 
 V0 = (
     ASC_PT
```

### Comparing `biogeme-3.2.8/examples/montecarlo/01simpleIntegral.py` & `biogeme-3.2.9/examples/montecarlo/01simpleIntegral.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/02simpleIntegral.py` & `biogeme-3.2.9/examples/montecarlo/02simpleIntegral.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/03antithetic.py` & `biogeme-3.2.9/examples/montecarlo/03antithetic.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/03antitheticExplicit.py` & `biogeme-3.2.9/examples/montecarlo/03antitheticExplicit.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/04normalMixtureNumerical.py` & `biogeme-3.2.9/examples/montecarlo/04normalMixtureNumerical.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/05normalMixtureMonteCarlo.py` & `biogeme-3.2.9/examples/montecarlo/05normalMixtureMonteCarlo.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/06estimationIntegral.py` & `biogeme-3.2.9/examples/montecarlo/06estimationIntegral.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo.py` & `biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_500.py` & `biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_500.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_anti.py` & `biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_anti.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_anti_500.py` & `biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_anti_500.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_halton.py` & `biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_halton.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_halton_500.py` & `biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_halton_500.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_mlhs.py` & `biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_mlhs_500.py` & `biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs_500.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_mlhs_anti.py` & `biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs_anti.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/07estimationMonteCarlo_mlhs_anti_500.py` & `biogeme-3.2.9/examples/montecarlo/07estimationMonteCarlo_mlhs_anti_500.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/montecarlo/swissmetro.dat` & `biogeme-3.2.9/examples/montecarlo/swissmetro.dat`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/FirstModelWithPandasBiogeme-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/FirstModelWithPandasBiogeme-checkpoint.ipynb`

 * *Files 0% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9999723086349924%*

 * *Differences: {"'cells'": '{3: {\'outputs\': {0: {\'data\': {\'text/plain\': ["\'3.2.8\'"]}}}}, 33: '*

 * *            "{'outputs': {0: {'text': {insert: [(2, 'Output file "*

 * *            "(HTML):\\t\\t\\t01logit.html\\n')], delete: [2]}}}}}"}*

```diff
@@ -32,15 +32,15 @@
             "cell_type": "code",
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'3.2.7'"
+                            "'3.2.8'"
                         ]
                     },
                     "execution_count": 2,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -1106,15 +1106,15 @@
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "\n",
                         "Results for model 01logit\n",
-                        "Output file (HTML):\t\t\t01logit~00.html\n",
+                        "Output file (HTML):\t\t\t01logit.html\n",
                         "Nbr of parameters:\t\t4\n",
                         "Sample size:\t\t\t6768\n",
                         "Excluded data:\t\t\t3960\n",
                         "Init log likelihood:\t\t-6964.663\n",
                         "Final log likelihood:\t\t-5331.252\n",
                         "Likelihood ratio test (init):\t\t3266.822\n",
                         "Rho square (init):\t\t\t0.235\n",
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/My first model-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/My first model-checkpoint.ipynb`

 * *Files 0% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9999723086349924%*

 * *Differences: {"'cells'": '{3: {\'outputs\': {0: {\'data\': {\'text/plain\': ["\'3.2.8\'"]}}}}, 33: '*

 * *            "{'outputs': {0: {'text': {insert: [(2, 'Output file "*

 * *            "(HTML):\\t\\t\\t01logit~00.html\\n')], delete: [2]}}}}}"}*

```diff
@@ -32,15 +32,15 @@
             "cell_type": "code",
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'3.2.7'"
+                            "'3.2.8'"
                         ]
                     },
                     "execution_count": 2,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -1108,15 +1108,15 @@
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "\n",
                         "Results for model 01logit\n",
-                        "Output file (HTML):\t\t\t01logit~01.html\n",
+                        "Output file (HTML):\t\t\t01logit~00.html\n",
                         "Nbr of parameters:\t\t4\n",
                         "Sample size:\t\t\t6768\n",
                         "Excluded data:\t\t\t3960\n",
                         "Init log likelihood:\t\t-5331.252\n",
                         "Final log likelihood:\t\t-5331.252\n",
                         "Likelihood ratio test (init):\t\t-0\n",
                         "Rho square (init):\t\t\t0\n",
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.algorithms-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.algorithms-checkpoint.ipynb`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9999627976190476%*

 * *Differences: {"'cells'": "{4: {'outputs': {0: {'text': ['2021-10-26 15:15:24.503452\\n']}}}, 5: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9a [2021-10-26]\\n')], delete: [0]}}}}}"}*

```diff
@@ -33,15 +33,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 11:08:54.689460\n"
+                        "2021-10-26 15:15:24.503452\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -51,15 +51,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9a [2021-10-26]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.biogeme-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.biogeme-checkpoint.ipynb`

 * *Files 10% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9827652146250427%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2022-08-09 11:12:23.423610\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9b [2022-08-09]\\n')], delete: [0]}}}}, 13: "*

 * *            "{'outputs': {0: {'text': ['[11:12:24] < Detailed >  It is suggested to scale the "*

 * *            "following variables.\\n', '[11:12:24] < Detailed >  Multiply Variable2 by\\t0.01 "*

 * *            "because the largest (abs) value is\\t50\\n', '[11:12:24] < Detailed >  To remove this "*

 * *            'feature, s […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:40:30.882517\n"
+                        "2022-08-09 11:12:23.423610\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9b [2022-08-09]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -154,20 +154,19 @@
             "execution_count": 7,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < General >   Remove 6 unused variables from the database as only 2 are used.\n",
-                        "[10:40:31] < Detailed >  It is suggested to scale the following variables.\n",
-                        "[10:40:31] < Detailed >  Multiply Variable2 by\t0.01 because the largest (abs) value is\t50\n",
-                        "[10:40:31] < Detailed >  To remove this feature, set the parameter suggestScales to False when creating the BIOGEME object.\n",
-                        "simpleExample: database [test]{'loglike': ((((-(beta1(-1.0) ** `2`)) * Variable1) - (exp((beta2(2.0) * beta1(-1.0))) * Variable2)) - (beta2(2.0) ** `4`)), 'beta1': beta1(-1.0), 'simul': ((beta1(-1.0) / Variable1) + (beta2(2.0) / Variable2))}\n",
-                        "simpleExample: database [test]{'loglike': ((((-(beta1(-1.0) ** `2`)) * Variable1) - (exp((beta2(2.0) * beta1(-1.0))) * Variable2)) - (beta2(2.0) ** `4`)), 'beta1': beta1(-1.0), 'simul': ((beta1(-1.0) / Variable1) + (beta2(2.0) / Variable2))}\n"
+                        "[11:12:24] < Detailed >  It is suggested to scale the following variables.\n",
+                        "[11:12:24] < Detailed >  Multiply Variable2 by\t0.01 because the largest (abs) value is\t50\n",
+                        "[11:12:24] < Detailed >  To remove this feature, set the parameter suggestScales to False when creating the BIOGEME object.\n",
+                        "simpleExample: database [test]{'loglike': ((((-(beta1(init=-1.0)[elid:0 id:0] ** `2.0`)) * Variable1 [elid:4 id:2]) - (exp((beta2(init=2.0)[elid:1 id:1] * beta1(init=-1.0)[elid:0 id:0])) * Variable2 [elid:5 id:3])) - (beta2(init=2.0)[elid:1 id:1] ** `4.0`)), 'beta1': beta1(init=-1.0)[elid:0 id:0], 'simul': ((beta1(init=-1.0)[elid:0 id:0] / Variable1 [elid:4 id:2]) + (beta2(init=2.0)[elid:1 id:1] / Variable2 [elid:5 id:3]))}\n",
+                        "simpleExample: database [test]{'loglike': ((((-(beta1(init=-1.0)[elid:0 id:0] ** `2.0`)) * Variable1 [elid:4 id:2]) - (exp((beta2(init=2.0)[elid:1 id:1] * beta1(init=-1.0)[elid:0 id:0])) * Variable2 [elid:5 id:3])) - (beta2(init=2.0)[elid:1 id:1] ** `4.0`)), 'beta1': beta1(init=-1.0)[elid:0 id:0], 'simul': ((beta1(init=-1.0)[elid:0 id:0] / Variable1 [elid:4 id:2]) + (beta2(init=2.0)[elid:1 id:1] / Variable2 [elid:5 id:3]))}\n"
                     ]
                 }
             ],
             "source": [
                 "myBiogeme = bio.BIOGEME(myData, dictOfExpressions)\n",
                 "myBiogeme.modelName = 'simpleExample'\n",
                 "print(myBiogeme)"
@@ -214,15 +213,15 @@
             "execution_count": 9,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -115.3003\n"
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -115.3003\n"
                     ]
                 },
                 {
                     "data": {
                         "text/plain": [
                             "-115.30029248549191"
                         ]
@@ -253,29 +252,29 @@
                     "output_type": "stream",
                     "text": [
                         "[0.0, 3.0]\n"
                     ]
                 }
             ],
             "source": [
-                "x = myBiogeme.betaInitValues\n",
+                "x = myBiogeme.id_manager.free_betas_values\n",
                 "xplus = [v + 1 for v in x]\n",
                 "print(xplus)"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 11,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):       -555\n"
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):       -555\n"
                     ]
                 },
                 {
                     "data": {
                         "text/plain": [
                             "-111.0"
                         ]
@@ -301,16 +300,16 @@
             "execution_count": 12,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < Detailed >  Use 50.0% of the data.\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 2):       -555\n"
+                        "[11:12:24] < Detailed >  Use 50.0% of the data.\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 2):       -555\n"
                     ]
                 },
                 {
                     "data": {
                         "text/plain": [
                             "-277.5"
                         ]
@@ -358,43 +357,43 @@
                             "      <th>Av1</th>\n",
                             "      <th>Av2</th>\n",
                             "      <th>Av3</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
-                            "      <th>2</th>\n",
-                            "      <td>1</td>\n",
+                            "      <th>0</th>\n",
                             "      <td>1</td>\n",
-                            "      <td>3</td>\n",
-                            "      <td>30</td>\n",
-                            "      <td>3</td>\n",
+                            "      <td>0</td>\n",
                             "      <td>1</td>\n",
+                            "      <td>10</td>\n",
                             "      <td>1</td>\n",
+                            "      <td>0</td>\n",
                             "      <td>1</td>\n",
+                            "      <td>0</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
-                            "      <th>4</th>\n",
-                            "      <td>2</td>\n",
+                            "      <th>1</th>\n",
                             "      <td>1</td>\n",
-                            "      <td>5</td>\n",
-                            "      <td>50</td>\n",
+                            "      <td>0</td>\n",
+                            "      <td>2</td>\n",
+                            "      <td>20</td>\n",
                             "      <td>2</td>\n",
                             "      <td>1</td>\n",
                             "      <td>1</td>\n",
                             "      <td>1</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
                             "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3\n",
-                            "2       1        1          3         30       3    1    1    1\n",
-                            "4       2        1          5         50       2    1    1    1"
+                            "0       1        0          1         10       1    0    1    0\n",
+                            "1       1        0          2         20       2    1    1    1"
                         ]
                     },
                     "execution_count": 13,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -407,16 +406,16 @@
             "execution_count": 14,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < Detailed >  Use 60.0% of the data.\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 3):       -555\n"
+                        "[11:12:24] < Detailed >  Use 60.0% of the data.\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 3):       -555\n"
                     ]
                 },
                 {
                     "data": {
                         "text/plain": [
                             "-185.0"
                         ]
@@ -464,23 +463,23 @@
                             "      <th>Av1</th>\n",
                             "      <th>Av2</th>\n",
                             "      <th>Av3</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
-                            "      <th>0</th>\n",
+                            "      <th>4</th>\n",
+                            "      <td>2</td>\n",
                             "      <td>1</td>\n",
-                            "      <td>0</td>\n",
+                            "      <td>5</td>\n",
+                            "      <td>50</td>\n",
+                            "      <td>2</td>\n",
                             "      <td>1</td>\n",
-                            "      <td>10</td>\n",
                             "      <td>1</td>\n",
-                            "      <td>0</td>\n",
                             "      <td>1</td>\n",
-                            "      <td>0</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>3</th>\n",
                             "      <td>2</td>\n",
                             "      <td>0</td>\n",
                             "      <td>4</td>\n",
                             "      <td>40</td>\n",
@@ -502,15 +501,15 @@
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
                             "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3\n",
-                            "0       1        0          1         10       1    0    1    0\n",
+                            "4       2        1          5         50       2    1    1    1\n",
                             "3       2        0          4         40       1    1    1    1\n",
                             "2       1        1          3         30       3    1    1    1"
                         ]
                     },
                     "execution_count": 15,
                     "metadata": {},
                     "output_type": "execute_result"
@@ -532,16 +531,16 @@
             "execution_count": 16,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < Detailed >  Use 60.0% of the data.\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 3):       -555\n"
+                        "[11:12:24] < Detailed >  Use 60.0% of the data.\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 3):       -555\n"
                     ]
                 },
                 {
                     "data": {
                         "text/plain": [
                             "-185.0"
                         ]
@@ -590,31 +589,20 @@
                             "      <th>Av1</th>\n",
                             "      <th>Av2</th>\n",
                             "      <th>Av3</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
-                            "      <th>4</th>\n",
-                            "      <td>2</td>\n",
+                            "      <th>1</th>\n",
                             "      <td>1</td>\n",
-                            "      <td>5</td>\n",
-                            "      <td>50</td>\n",
+                            "      <td>0</td>\n",
                             "      <td>2</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>3</th>\n",
+                            "      <td>20</td>\n",
                             "      <td>2</td>\n",
-                            "      <td>0</td>\n",
-                            "      <td>4</td>\n",
-                            "      <td>40</td>\n",
-                            "      <td>1</td>\n",
                             "      <td>1</td>\n",
                             "      <td>1</td>\n",
                             "      <td>1</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>2</th>\n",
                             "      <td>1</td>\n",
@@ -622,23 +610,34 @@
                             "      <td>3</td>\n",
                             "      <td>30</td>\n",
                             "      <td>3</td>\n",
                             "      <td>1</td>\n",
                             "      <td>1</td>\n",
                             "      <td>1</td>\n",
                             "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>4</th>\n",
+                            "      <td>2</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>5</td>\n",
+                            "      <td>50</td>\n",
+                            "      <td>2</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
                             "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3\n",
-                            "4       2        1          5         50       2    1    1    1\n",
-                            "3       2        0          4         40       1    1    1    1\n",
-                            "2       1        1          3         30       3    1    1    1"
+                            "1       1        0          2         20       2    1    1    1\n",
+                            "2       1        1          3         30       3    1    1    1\n",
+                            "4       2        1          5         50       2    1    1    1"
                         ]
                     },
                     "execution_count": 17,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -658,15 +657,15 @@
             "execution_count": 18,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
                         "f = -111.0\n",
                         "g = [ -90. -108.]\n",
                         "h = [[-270.  -30.]\n",
                         " [ -30. -108.]]\n",
                         "bhhh = [[ 9900.  9720.]\n",
                         " [ 9720. 11664.]]\n"
                     ]
@@ -696,15 +695,15 @@
             "execution_count": 19,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
                         "f = -555.0\n",
                         "g = [-450. -540.]\n",
                         "h = [[-1350.  -150.]\n",
                         " [ -150.  -540.]]\n",
                         "bhhh = [[49500. 48600.]\n",
                         " [48600. 58320.]]\n"
                     ]
@@ -734,16 +733,16 @@
             "execution_count": 20,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < Detailed >  Use 50.0% of the data.\n",
-                        "[10:40:31] < General >   Log likelihood (N = 2):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
+                        "[11:12:24] < Detailed >  Use 50.0% of the data.\n",
+                        "[11:12:24] < General >   Log likelihood (N = 2):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
                         "f = -277.5\n",
                         "g = [-225. -270.]\n",
                         "h = [[-675.  -75.]\n",
                         " [ -75. -270.]]\n",
                         "bhhh = [[24750. 24300.]\n",
                         " [24300. 29160.]]\n"
                     ]
@@ -774,17 +773,17 @@
             "execution_count": 21,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02  \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02  \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -555.0002 Gradient norm:      7e+02  \n"
+                        "[11:12:24] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02  \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02  \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -555.0002 Gradient norm:      7e+02  \n"
                     ]
                 },
                 {
                     "data": {
                         "text/plain": [
                             "array([[-1380.00020229,  -150.        ],\n",
                             "       [ -150.0000451 ,  -540.00005396]])"
@@ -811,29 +810,29 @@
             "execution_count": 22,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < Detailed >  x\t\tGradient\tFinDiff\t\tDifference\n",
-                        "[10:40:31] < Detailed >  beta1          \t-1.060058E+01\t-1.060058E+01\t-5.427932E-06\n",
-                        "[10:40:31] < Detailed >  beta2          \t-1.396997E+02\t-1.396997E+02\t+2.608000E-05\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < Detailed >  Row\t\tCol\t\tHessian\tFinDiff\t\tDifference\n",
-                        "[10:40:31] < Detailed >  beta1          \tbeta1          \t-1.112012E+02\t-1.112012E+02\t-8.045522E-06\n",
-                        "[10:40:31] < Detailed >  beta1          \tbeta2          \t+2.030029E+01\t+2.030029E+01\t+7.365980E-09\n",
-                        "[10:40:31] < Detailed >  beta2          \tbeta1          \t+2.030029E+01\t+2.030029E+01\t-1.613879E-07\n",
-                        "[10:40:31] < Detailed >  beta2          \tbeta2          \t-2.603003E+02\t-2.603003E+02\t+2.229281E-05\n"
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < Detailed >  x\t\tGradient\tFinDiff\t\tDifference\n",
+                        "[11:12:24] < Detailed >  beta1          \t-1.060058E+01\t-1.060058E+01\t-5.427932E-06\n",
+                        "[11:12:24] < Detailed >  beta2          \t-1.396997E+02\t-1.396997E+02\t+2.608000E-05\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < Detailed >  Row\t\tCol\t\tHessian\tFinDiff\t\tDifference\n",
+                        "[11:12:24] < Detailed >  beta1          \tbeta1          \t-1.112012E+02\t-1.112012E+02\t-8.045522E-06\n",
+                        "[11:12:24] < Detailed >  beta1          \tbeta2          \t+2.030029E+01\t+2.030029E+01\t+7.365980E-09\n",
+                        "[11:12:24] < Detailed >  beta2          \tbeta1          \t+2.030029E+01\t+2.030029E+01\t-1.613879E-07\n",
+                        "[11:12:24] < Detailed >  beta2          \tbeta2          \t-2.603003E+02\t-2.603003E+02\t+2.229281E-05\n"
                     ]
                 }
             ],
             "source": [
                 "f, g, h, gdiff, hdiff = myBiogeme.checkDerivatives(verbose=True)"
             ]
         },
@@ -895,49 +894,49 @@
             "execution_count": 24,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < General >   *** Initial values of the parameters are obtained from the file __simpleExample.iter\n",
-                        "[10:40:31] < Detailed >  Parameter values restored from __simpleExample.iter\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -115.3003\n",
-                        "[10:40:31] < Detailed >  ** Optimization: Newton with trust region for simple bounds\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -69.98205\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -69.98205 Gradient norm:      3e+01 Hessian norm:       2e+02 \n",
-                        "[10:40:31] < Detailed >  1 f=  13.99641 projected rel. grad.=  0.28 rel. change=  0.38 delta=     2 rho=   1.1 ++\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -67.07892\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -67.07892 Gradient norm:          2 Hessian norm:       2e+02 \n",
-                        "[10:40:31] < Detailed >  2 f=  13.41578 projected rel. grad.= 0.021 rel. change=  0.15 delta=     4 rho=     1 ++\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -67.06549\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      0.007 Hessian norm:       2e+02 \n",
-                        "[10:40:31] < Detailed >  3 f=   13.4131 projected rel. grad.=8.1e-05 rel. change= 0.011 delta=     8 rho=     1 ++\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -67.06549\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      1e-07 Hessian norm:       2e+02 \n",
-                        "[10:40:31] < Detailed >  4 f=   13.4131 projected rel. grad.=1.2e-09 rel. change=4.4e-05 delta=    16 rho=     1 ++\n",
-                        "[10:40:31] < Detailed >  Proportion of Hessian calculation: 100.0%\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      1e-07 Hessian norm:       2e+02 BHHH norm:       7e+01\n",
-                        "[10:40:31] < General >   Re-estimate the model 10 times for bootstrapping\n"
+                        "[11:12:24] < General >   *** Initial values of the parameters are obtained from the file __simpleExample.iter\n",
+                        "[11:12:24] < Detailed >  Parameter values restored from __simpleExample.iter\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -115.3003\n",
+                        "[11:12:24] < Detailed >  ** Optimization: Newton with trust region for simple bounds\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -69.98205\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -69.98205 Gradient norm:      3e+01 Hessian norm:       2e+02 \n",
+                        "[11:12:24] < Detailed >  1 f=  13.99641 projected rel. grad.=  0.28 rel. change=  0.38 delta=     2 rho=   1.1 ++\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -67.07892\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -67.07892 Gradient norm:          2 Hessian norm:       2e+02 \n",
+                        "[11:12:24] < Detailed >  2 f=  13.41578 projected rel. grad.= 0.021 rel. change=  0.15 delta=     4 rho=     1 ++\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -67.06549\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      0.007 Hessian norm:       2e+02 \n",
+                        "[11:12:24] < Detailed >  3 f=   13.4131 projected rel. grad.=8.1e-05 rel. change= 0.011 delta=     8 rho=     1 ++\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -67.06549\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      1e-07 Hessian norm:       2e+02 \n",
+                        "[11:12:24] < Detailed >  4 f=   13.4131 projected rel. grad.=1.2e-09 rel. change=4.4e-05 delta=    16 rho=     1 ++\n",
+                        "[11:12:24] < Detailed >  Proportion of Hessian calculation: 100.0%\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      1e-07 Hessian norm:       2e+02 BHHH norm:       7e+01\n",
+                        "[11:12:24] < General >   Re-estimate the model 10 times for bootstrapping\n"
                     ]
                 },
                 {
                     "name": "stderr",
                     "output_type": "stream",
                     "text": [
-                        "100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00<00:00, 361.05it/s]"
+                        "100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00<00:00, 331.01it/s]"
                     ]
                 },
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:32] < General >   Results saved in file simpleExample~08.html\n",
-                        "[10:40:32] < General >   Results saved in file simpleExample~11.pickle\n"
+                        "[11:12:24] < General >   Results saved in file simpleExample~03.html\n",
+                        "[11:12:24] < General >   Results saved in file simpleExample~03.pickle\n"
                     ]
                 },
                 {
                     "name": "stderr",
                     "output_type": "stream",
                     "text": [
                         "\n"
@@ -971,68 +970,42 @@
                             "    }\n",
                             "</style>\n",
                             "<table border=\"1\" class=\"dataframe\">\n",
                             "  <thead>\n",
                             "    <tr style=\"text-align: right;\">\n",
                             "      <th></th>\n",
                             "      <th>Value</th>\n",
-                            "      <th>Std err</th>\n",
-                            "      <th>t-test</th>\n",
-                            "      <th>p-value</th>\n",
                             "      <th>Rob. Std err</th>\n",
                             "      <th>Rob. t-test</th>\n",
                             "      <th>Rob. p-value</th>\n",
-                            "      <th>Bootstrap[10] Std err</th>\n",
-                            "      <th>Bootstrap t-test</th>\n",
-                            "      <th>Bootstrap p-value</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>beta1</th>\n",
                             "      <td>-1.273264</td>\n",
-                            "      <td>0.115144</td>\n",
-                            "      <td>-11.057997</td>\n",
-                            "      <td>0.0</td>\n",
                             "      <td>0.013724</td>\n",
                             "      <td>-92.776664</td>\n",
                             "      <td>0.0</td>\n",
-                            "      <td>0.017135</td>\n",
-                            "      <td>-74.307129</td>\n",
-                            "      <td>0.0</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>beta2</th>\n",
                             "      <td>1.248769</td>\n",
-                            "      <td>0.084830</td>\n",
-                            "      <td>14.720836</td>\n",
-                            "      <td>0.0</td>\n",
                             "      <td>0.059086</td>\n",
                             "      <td>21.134794</td>\n",
                             "      <td>0.0</td>\n",
-                            "      <td>0.075144</td>\n",
-                            "      <td>16.618264</td>\n",
-                            "      <td>0.0</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "          Value   Std err     t-test  p-value  Rob. Std err  Rob. t-test  \\\n",
-                            "beta1 -1.273264  0.115144 -11.057997      0.0      0.013724   -92.776664   \n",
-                            "beta2  1.248769  0.084830  14.720836      0.0      0.059086    21.134794   \n",
-                            "\n",
-                            "       Rob. p-value  Bootstrap[10] Std err  Bootstrap t-test  \\\n",
-                            "beta1           0.0               0.017135        -74.307129   \n",
-                            "beta2           0.0               0.075144         16.618264   \n",
-                            "\n",
-                            "       Bootstrap p-value  \n",
-                            "beta1                0.0  \n",
-                            "beta2                0.0  "
+                            "          Value  Rob. Std err  Rob. t-test  Rob. p-value\n",
+                            "beta1 -1.273264      0.013724   -92.776664           0.0\n",
+                            "beta2  1.248769      0.059086    21.134794           0.0"
                         ]
                     },
                     "execution_count": 25,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -1040,42 +1013,123 @@
                 "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "The values of the intermediate results saved can be retrieved as follows. "
+                "If the model has already been estimated, it is possible to recycle the estimation results. In that case, the other arguments are ignored, and the results are whatever is in the file."
             ]
         },
         {
-            "cell_type": "markdown",
+            "cell_type": "code",
+            "execution_count": 26,
             "metadata": {},
+            "outputs": [
+                {
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "[11:12:25] < Warning >   Several pickle files are available for this model: ['simpleExample.pickle', 'simpleExample~00.pickle', 'simpleExample~01.pickle', 'simpleExample~02.pickle', 'simpleExample~03.pickle']. The file simpleExample~03.pickle is used to load the results.\n",
+                        "[11:12:25] < General >   Estimation results read from simpleExample~03.pickle\n"
+                    ]
+                }
+            ],
             "source": [
-                "Formula before"
+                "recycled_results = myBiogeme.estimate(recycle=True, bootstrap=10)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 26,
+            "execution_count": 27,
+            "metadata": {},
+            "outputs": [
+                {
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "Results for model simpleExample\n",
+                        "Nbr of parameters:\t\t2\n",
+                        "Sample size:\t\t\t5\n",
+                        "Excluded data:\t\t\t0\n",
+                        "Final log likelihood:\t\t-67.06549\n",
+                        "Akaike Information Criterion:\t138.131\n",
+                        "Bayesian Information Criterion:\t137.3499\n",
+                        "\n"
+                    ]
+                }
+            ],
+            "source": [
+                "print(recycled_results.shortSummary())"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 28,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>-1.273264</td>\n",
+                            "      <td>0.013724</td>\n",
+                            "      <td>-92.776664</td>\n",
+                            "      <td>0.0</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>1.248769</td>\n",
+                            "      <td>0.059086</td>\n",
+                            "      <td>21.134794</td>\n",
+                            "      <td>0.0</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
                         "text/plain": [
-                            "((((-(beta1(-1.0) ** `2`)) * Variable1) - (exp((beta2(2.0000002) * beta1(-1.0))) * Variable2)) - (beta2(2.0000002) ** `4`))"
+                            "          Value  Rob. Std err  Rob. t-test  Rob. p-value\n",
+                            "beta1 -1.273264      0.013724   -92.776664           0.0\n",
+                            "beta2  1.248769      0.059086    21.134794           0.0"
                         ]
                     },
-                    "execution_count": 26,
+                    "execution_count": 28,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myBiogeme.loglike"
+                "recycled_results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## simulate"
@@ -1086,15 +1140,15 @@
             "metadata": {},
             "source": [
                 "Simulate with the default values for the parameters"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 27,
+            "execution_count": 29,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -1118,56 +1172,56 @@
                             "      <th>beta1</th>\n",
                             "      <th>simul</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>0</th>\n",
-                            "      <td>-25.413417</td>\n",
+                            "      <td>-23.060064</td>\n",
                             "      <td>-1.0</td>\n",
-                            "      <td>-0.20</td>\n",
+                            "      <td>-0.266667</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>1</th>\n",
-                            "      <td>-20.706712</td>\n",
+                            "      <td>-27.766769</td>\n",
                             "      <td>-1.0</td>\n",
-                            "      <td>-0.40</td>\n",
+                            "      <td>-0.160000</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>2</th>\n",
-                            "      <td>-27.766769</td>\n",
+                            "      <td>-20.706712</td>\n",
                             "      <td>-1.0</td>\n",
-                            "      <td>-0.16</td>\n",
+                            "      <td>-0.400000</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>3</th>\n",
-                            "      <td>-27.766769</td>\n",
+                            "      <td>-25.413417</td>\n",
                             "      <td>-1.0</td>\n",
-                            "      <td>-0.16</td>\n",
+                            "      <td>-0.200000</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>4</th>\n",
-                            "      <td>-27.766769</td>\n",
+                            "      <td>-23.060064</td>\n",
                             "      <td>-1.0</td>\n",
-                            "      <td>-0.16</td>\n",
+                            "      <td>-0.266667</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "     loglike  beta1  simul\n",
-                            "0 -25.413417   -1.0  -0.20\n",
-                            "1 -20.706712   -1.0  -0.40\n",
-                            "2 -27.766769   -1.0  -0.16\n",
-                            "3 -27.766769   -1.0  -0.16\n",
-                            "4 -27.766769   -1.0  -0.16"
+                            "     loglike  beta1     simul\n",
+                            "0 -23.060064   -1.0 -0.266667\n",
+                            "1 -27.766769   -1.0 -0.160000\n",
+                            "2 -20.706712   -1.0 -0.400000\n",
+                            "3 -25.413417   -1.0 -0.200000\n",
+                            "4 -23.060064   -1.0 -0.266667"
                         ]
                     },
-                    "execution_count": 27,
+                    "execution_count": 29,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "simulationWithDefaultBetas = myBiogeme.simulate()\n",
                 "simulationWithDefaultBetas"
@@ -1178,15 +1232,15 @@
             "metadata": {},
             "source": [
                 "Simulate with the estimated values for the parameters"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 28,
+            "execution_count": 30,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "{'beta1': -1.2732639872136933, 'beta2': 1.2487688099301195}\n"
@@ -1217,56 +1271,56 @@
                             "      <th>beta1</th>\n",
                             "      <th>simul</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>0</th>\n",
-                            "      <td>-17.073530</td>\n",
+                            "      <td>-13.413098</td>\n",
                             "      <td>-1.273264</td>\n",
-                            "      <td>-0.287097</td>\n",
+                            "      <td>-0.382796</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>1</th>\n",
-                            "      <td>-9.752666</td>\n",
+                            "      <td>-20.733962</td>\n",
                             "      <td>-1.273264</td>\n",
-                            "      <td>-0.574194</td>\n",
+                            "      <td>-0.229677</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>2</th>\n",
-                            "      <td>-20.733962</td>\n",
+                            "      <td>-9.752666</td>\n",
                             "      <td>-1.273264</td>\n",
-                            "      <td>-0.229677</td>\n",
+                            "      <td>-0.574194</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>3</th>\n",
-                            "      <td>-20.733962</td>\n",
+                            "      <td>-17.073530</td>\n",
                             "      <td>-1.273264</td>\n",
-                            "      <td>-0.229677</td>\n",
+                            "      <td>-0.287097</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>4</th>\n",
-                            "      <td>-20.733962</td>\n",
+                            "      <td>-13.413098</td>\n",
                             "      <td>-1.273264</td>\n",
-                            "      <td>-0.229677</td>\n",
+                            "      <td>-0.382796</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
                             "     loglike     beta1     simul\n",
-                            "0 -17.073530 -1.273264 -0.287097\n",
-                            "1  -9.752666 -1.273264 -0.574194\n",
-                            "2 -20.733962 -1.273264 -0.229677\n",
-                            "3 -20.733962 -1.273264 -0.229677\n",
-                            "4 -20.733962 -1.273264 -0.229677"
+                            "0 -13.413098 -1.273264 -0.382796\n",
+                            "1 -20.733962 -1.273264 -0.229677\n",
+                            "2  -9.752666 -1.273264 -0.574194\n",
+                            "3 -17.073530 -1.273264 -0.287097\n",
+                            "4 -13.413098 -1.273264 -0.382796"
                         ]
                     },
-                    "execution_count": 28,
+                    "execution_count": 30,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "print(results.getBetaValues())\n",
                 "simulationWithEstimatedBetas =\\\n",
@@ -1279,15 +1333,15 @@
             "metadata": {},
             "source": [
                 "## confidenceIntervals"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 29,
+            "execution_count": 31,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -1311,70 +1365,70 @@
                             "      <th>beta1</th>\n",
                             "      <th>simul</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>0</th>\n",
-                            "      <td>-17.689026</td>\n",
-                            "      <td>-1.302323</td>\n",
-                            "      <td>-0.297597</td>\n",
+                            "      <td>-13.563315</td>\n",
+                            "      <td>-1.291034</td>\n",
+                            "      <td>-0.391319</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>1</th>\n",
-                            "      <td>-10.034047</td>\n",
-                            "      <td>-1.302323</td>\n",
-                            "      <td>-0.595193</td>\n",
+                            "      <td>-21.261787</td>\n",
+                            "      <td>-1.291034</td>\n",
+                            "      <td>-0.234791</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>2</th>\n",
-                            "      <td>-21.715671</td>\n",
-                            "      <td>-1.302323</td>\n",
-                            "      <td>-0.238077</td>\n",
+                            "      <td>-10.034047</td>\n",
+                            "      <td>-1.291034</td>\n",
+                            "      <td>-0.586978</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>3</th>\n",
-                            "      <td>-21.715671</td>\n",
-                            "      <td>-1.302323</td>\n",
-                            "      <td>-0.238077</td>\n",
+                            "      <td>-17.387198</td>\n",
+                            "      <td>-1.291034</td>\n",
+                            "      <td>-0.293489</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>4</th>\n",
-                            "      <td>-21.715671</td>\n",
-                            "      <td>-1.302323</td>\n",
-                            "      <td>-0.238077</td>\n",
+                            "      <td>-13.563315</td>\n",
+                            "      <td>-1.291034</td>\n",
+                            "      <td>-0.391319</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
                             "     loglike     beta1     simul\n",
-                            "0 -17.689026 -1.302323 -0.297597\n",
-                            "1 -10.034047 -1.302323 -0.595193\n",
-                            "2 -21.715671 -1.302323 -0.238077\n",
-                            "3 -21.715671 -1.302323 -0.238077\n",
-                            "4 -21.715671 -1.302323 -0.238077"
+                            "0 -13.563315 -1.291034 -0.391319\n",
+                            "1 -21.261787 -1.291034 -0.234791\n",
+                            "2 -10.034047 -1.291034 -0.586978\n",
+                            "3 -17.387198 -1.291034 -0.293489\n",
+                            "4 -13.563315 -1.291034 -0.391319"
                         ]
                     },
-                    "execution_count": 29,
+                    "execution_count": 31,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "drawsFromBetas =\\\n",
-                "    results.getBetasForSensitivityAnalysis(myBiogeme.freeBetaNames)\n",
+                "    results.getBetasForSensitivityAnalysis(myBiogeme.id_manager.free_betas.names)\n",
                 "left, right = myBiogeme.confidenceIntervals(drawsFromBetas)\n",
                 "left"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 30,
+            "execution_count": 32,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -1398,56 +1452,56 @@
                             "      <th>beta1</th>\n",
                             "      <th>simul</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>0</th>\n",
-                            "      <td>-16.974003</td>\n",
+                            "      <td>-13.413098</td>\n",
                             "      <td>-1.255223</td>\n",
-                            "      <td>-0.280663</td>\n",
+                            "      <td>-0.374218</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>1</th>\n",
-                            "      <td>-9.619739</td>\n",
+                            "      <td>-20.443982</td>\n",
                             "      <td>-1.255223</td>\n",
-                            "      <td>-0.561327</td>\n",
+                            "      <td>-0.224531</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>2</th>\n",
-                            "      <td>-20.443982</td>\n",
+                            "      <td>-9.638020</td>\n",
                             "      <td>-1.255223</td>\n",
-                            "      <td>-0.224531</td>\n",
+                            "      <td>-0.561327</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>3</th>\n",
-                            "      <td>-20.443982</td>\n",
+                            "      <td>-16.974003</td>\n",
                             "      <td>-1.255223</td>\n",
-                            "      <td>-0.224531</td>\n",
+                            "      <td>-0.280663</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>4</th>\n",
-                            "      <td>-20.443982</td>\n",
+                            "      <td>-13.413098</td>\n",
                             "      <td>-1.255223</td>\n",
-                            "      <td>-0.224531</td>\n",
+                            "      <td>-0.374218</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
                             "     loglike     beta1     simul\n",
-                            "0 -16.974003 -1.255223 -0.280663\n",
-                            "1  -9.619739 -1.255223 -0.561327\n",
-                            "2 -20.443982 -1.255223 -0.224531\n",
-                            "3 -20.443982 -1.255223 -0.224531\n",
-                            "4 -20.443982 -1.255223 -0.224531"
+                            "0 -13.413098 -1.255223 -0.374218\n",
+                            "1 -20.443982 -1.255223 -0.224531\n",
+                            "2  -9.638020 -1.255223 -0.561327\n",
+                            "3 -16.974003 -1.255223 -0.280663\n",
+                            "4 -13.413098 -1.255223 -0.374218"
                         ]
                     },
-                    "execution_count": 30,
+                    "execution_count": 32,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "right"
             ]
@@ -1465,98 +1519,129 @@
             "source": [
                 "The validation consists in organizing the data into several slices of about the same size, randomly defined. \n",
                 "Each slide is considered as a validation dataset. The model is then re-estimated using all the data except the slice, and the estimated model is applied on the validation set (i.e. the slice). The value of the log likelihood for each observation in the validation set is reported in a dataframe. As this is done for each slice, the output is a list of dataframes, each corresponding to one of these exercises.   "
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 35,
+            "execution_count": 33,
             "metadata": {},
             "outputs": [],
             "source": [
                 "logger.setSilent()\n",
                 "validationData = myData.split(slices=5)\n",
                 "validation_results = myBiogeme.validate(results, validationData)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 36,
+            "execution_count": 34,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "[   Loglikelihood\n",
-                            " 2     -13.547382,\n",
+                            " 3     -17.145326,\n",
                             "    Loglikelihood\n",
-                            " 1     -10.126055,\n",
+                            " 0       -6.34111,\n",
                             "    Loglikelihood\n",
-                            " 3     -16.968709,\n",
+                            " 2     -13.413098,\n",
                             "    Loglikelihood\n",
-                            " 0      -6.704727,\n",
+                            " 4     -21.037421,\n",
                             "    Loglikelihood\n",
-                            " 4     -20.390037]"
+                            " 1      -9.817721]"
                         ]
                     },
-                    "execution_count": 36,
+                    "execution_count": 34,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "validation_results"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 38,
+            "execution_count": 35,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "Log likelihood for 1 validation data: -13.547381997593472\n",
-                        "Log likelihood for 1 validation data: -10.12605473847826\n",
-                        "Log likelihood for 1 validation data: -16.968709256708685\n",
-                        "Log likelihood for 1 validation data: -6.704727479363046\n",
-                        "Log likelihood for 1 validation data: -20.390036515823898\n"
+                        "Log likelihood for 1 validation data: -17.14532644602357\n",
+                        "Log likelihood for 1 validation data: -6.34111029142699\n",
+                        "Log likelihood for 1 validation data: -13.413098095892842\n",
+                        "Log likelihood for 1 validation data: -21.037421362921453\n",
+                        "Log likelihood for 1 validation data: -9.817721165500888\n"
                     ]
                 }
             ],
             "source": [
                 "for slide in validation_results:\n",
                 "    print(f'Log likelihood for {slide.shape[0]} '\n",
                 "          f'validation data: {slide[\"Loglikelihood\"].sum()}')\n"
             ]
         },
         {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "## files_of_type"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 36,
+            "metadata": {},
+            "outputs": [
+                {
+                    "data": {
+                        "text/plain": [
+                            "['simpleExample.pickle',\n",
+                            " 'simpleExample~02.pickle',\n",
+                            " 'simpleExample~00.pickle',\n",
+                            " 'simpleExample~03.pickle',\n",
+                            " 'simpleExample~01.pickle']"
+                        ]
+                    },
+                    "execution_count": 36,
+                    "metadata": {},
+                    "output_type": "execute_result"
+                }
+            ],
+            "source": [
+                "myBiogeme.files_of_type('pickle')"
+            ]
+        },
+        {
             "cell_type": "code",
             "execution_count": null,
             "metadata": {},
             "outputs": [],
             "source": []
         }
     ],
     "metadata": {
         "kernelspec": {
-            "display_name": "Python 3",
+            "display_name": "Python 3 (ipykernel)",
             "language": "python",
             "name": "python3"
         },
         "language_info": {
             "codemirror_mode": {
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.9.5"
+            "version": "3.10.4"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 2
 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.database-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.database-checkpoint.ipynb`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9836751500814002%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2022-08-09 11:23:26.647742\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9b [2022-08-09]\\n')], delete: [0]}}}}, 13: "*

 * *            "{'outputs': {0: {'text': ['[11. 22. 33. 44. 55.]\\n']}}}, 16: {'outputs': {0: "*

 * *            "{'text': ['[False  True  True  True  True]\\n']}}}, 19: {'outputs': {0: {'data': "*

 * *            "{'text/plain': ['{1.0: (2, 4.0), 2.0: (2, 5.0), 3.0: (1, 4.0)}']}}}}, 22: "*

 * *            "{'execution_count': 10, ' […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:55:23.580890\n"
+                        "2022-08-09 11:23:26.647742\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9b [2022-08-09]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -165,20 +165,15 @@
             "execution_count": 7,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "0    11\n",
-                        "1    22\n",
-                        "2    33\n",
-                        "3    44\n",
-                        "4    55\n",
-                        "dtype: int64\n"
+                        "[11. 22. 33. 44. 55.]\n"
                     ]
                 }
             ],
             "source": [
                 "Variable1 = Variable('Variable1')\n",
                 "Variable2 = Variable('Variable2')\n",
                 "expr = Variable1 + Variable2\n",
@@ -216,20 +211,15 @@
             "execution_count": 8,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "0    False\n",
-                        "1     True\n",
-                        "2     True\n",
-                        "3     True\n",
-                        "4     True\n",
-                        "dtype: bool\n"
+                        "[False  True  True  True  True]\n"
                     ]
                 }
             ],
             "source": [
                 "Av1 = Variable('Av1')\n",
                 "Av2 = Variable('Av2')\n",
                 "Av3 = Variable('Av3')\n",
@@ -267,15 +257,15 @@
             "cell_type": "code",
             "execution_count": 9,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "{1: (2, 4), 2: (2, 5), 3: (1, 4)}"
+                            "{1.0: (2, 4.0), 2.0: (2, 5.0), 3.0: (1, 4.0)}"
                         ]
                     },
                     "execution_count": 9,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -283,55 +273,14 @@
                 "myData.choiceAvailabilityStatistics(avail, Choice)"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "## sumFromDatabase"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Calculates the value of an expression for each entry in the database, and retturns the sum.\n",
-                "\n",
-                "        Args:\n",
-                "            expression: object of type biogeme.expressions \n",
-                "            \n",
-                "        Returns:\n",
-                "            Sum of the expressions over the database.\n"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 10,
-            "metadata": {},
-            "outputs": [
-                {
-                    "name": "stdout",
-                    "output_type": "stream",
-                    "text": [
-                        "50.0\n"
-                    ]
-                }
-            ],
-            "source": [
-                "Variable1 = Variable('Variable1')\n",
-                "Variable2 = Variable('Variable2')\n",
-                "expression = Variable2 / Variable1\n",
-                "result = myData.sumFromDatabase(expression)\n",
-                "print(result)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
                 "## Suggest scaling"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
@@ -345,37 +294,37 @@
                 "        A Pandas dataframe where each row contains the name of\n",
                 "        the variable, the suggested scale s and the laergest value in the column. \n",
                 "        Ideally, the column should be multiplied by s. \n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 11,
+            "execution_count": 10,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "Index(['Person', 'Exclude', 'Variable1', 'Variable2', 'Choice', 'Av1', 'Av2',\n",
                             "       'Av3'],\n",
                             "      dtype='object')"
                         ]
                     },
-                    "execution_count": 11,
+                    "execution_count": 10,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data.columns"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 12,
+            "execution_count": 11,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -412,26 +361,26 @@
                             "</div>"
                         ],
                         "text/plain": [
                             "      Column  Scale  Largest\n",
                             "3  Variable2   0.01       50"
                         ]
                     },
-                    "execution_count": 12,
+                    "execution_count": 11,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.suggestScaling()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 13,
+            "execution_count": 12,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -468,15 +417,15 @@
                             "</div>"
                         ],
                         "text/plain": [
                             "      Column  Scale  Largest\n",
                             "1  Variable2   0.01       50"
                         ]
                     },
-                    "execution_count": 13,
+                    "execution_count": 12,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.suggestScaling(columns=['Variable1', 'Variable2'])"
             ]
@@ -499,15 +448,15 @@
                 "\n",
                 "              scale: value of the scale. All values of the \n",
                 "              column will be multiplied by that scale.\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 14,
+            "execution_count": 13,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -602,35 +551,35 @@
                             "0       1        0          1         10       1    0    1    0\n",
                             "1       1        0          2         20       2    1    1    1\n",
                             "2       1        1          3         30       3    1    1    1\n",
                             "3       2        0          4         40       1    1    1    1\n",
                             "4       2        1          5         50       2    1    1    1"
                         ]
                     },
-                    "execution_count": 14,
+                    "execution_count": 13,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 15,
+            "execution_count": 14,
             "metadata": {},
             "outputs": [],
             "source": [
                 "myData.scaleColumn('Variable2', 0.01)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 16,
+            "execution_count": 15,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -725,15 +674,15 @@
                             "0       1        0          1        0.1       1    0    1    0\n",
                             "1       1        0          2        0.2       2    1    1    1\n",
                             "2       1        1          3        0.3       3    1    1    1\n",
                             "3       2        0          4        0.4       1    1    1    1\n",
                             "4       2        1          5        0.5       2    1    1    1"
                         ]
                     },
-                    "execution_count": 16,
+                    "execution_count": 15,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data"
             ]
@@ -761,15 +710,15 @@
                 "\n",
                 "        Raises:\n",
                 "              ValueError: if the column name already exists."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 17,
+            "execution_count": 16,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "[0.1, 0.4, 0.8999999999999999, 1.6, 2.5]\n"
@@ -783,15 +732,15 @@
                 "expression = Variable2 * Variable1\n",
                 "result = myData.addColumn(expression, 'NewVariable')\n",
                 "print(myData.data['NewVariable'].tolist())"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 18,
+            "execution_count": 17,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -892,15 +841,15 @@
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "1       1        0          2        0.2       2    1    1    1          0.4\n",
                             "2       1        1          3        0.3       3    1    1    1          0.9\n",
                             "3       2        0          4        0.4       1    1    1    1          1.6\n",
                             "4       2        1          5        0.5       2    1    1    1          2.5"
                         ]
                     },
-                    "execution_count": 18,
+                    "execution_count": 17,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data"
             ]
@@ -917,15 +866,15 @@
             "metadata": {},
             "source": [
                 "Shuffle the data, and split the data into slices. For each slide, an estimation and a validation sets are generated. The validation set is the slice itself. The estimation set is the rest of the data. "
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 19,
+            "execution_count": 18,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "==========\n",
@@ -1001,24 +950,24 @@
             "metadata": {},
             "source": [
                 "Here, count the number of entries for individual 1."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 20,
+            "execution_count": 19,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "3"
                         ]
                     },
-                    "execution_count": 20,
+                    "execution_count": 19,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.count('Person',1)"
             ]
@@ -1041,15 +990,15 @@
                 "           describing the expression to evaluate\n",
                 "        Returns:\n",
                 "           Nothing."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 21,
+            "execution_count": 20,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -1124,15 +1073,15 @@
                         "text/plain": [
                             "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  NewVariable\n",
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "1       1        0          2        0.2       2    1    1    1          0.4\n",
                             "3       2        0          4        0.4       1    1    1    1          1.6"
                         ]
                     },
-                    "execution_count": 21,
+                    "execution_count": 20,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "Exclude = Variable('Exclude')\n",
                 "myData.remove(Exclude)\n",
@@ -1153,35 +1102,35 @@
                 "Dumps the database in a CSV formatted file.\n",
                 "\n",
                 "        Returns:  name of the file"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 22,
+            "execution_count": 21,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'test_dumped~05.dat'"
+                            "'test_dumped~00.dat'"
                         ]
                     },
-                    "execution_count": 22,
+                    "execution_count": 21,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.dumpOnFile()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 23,
+            "execution_count": 22,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "__rowId\tPerson\tExclude\tVariable1\tVariable2\tChoice\tAv1\tAv2\tAv3\tNewVariable\n",
@@ -1234,15 +1183,15 @@
             "metadata": {},
             "source": [
                 "List native types and their description"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 24,
+            "execution_count": 23,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "['UNIFORM: Uniform U[0, 1]',\n",
                             " 'UNIFORM_ANTI: Antithetic uniform U[0, 1]',\n",
@@ -1263,26 +1212,26 @@
                             " 'NORMAL_HALTON2: Normal draws from Halton base 2 sequence',\n",
                             " 'NORMAL_HALTON3: Normal draws from Halton base 3 sequence',\n",
                             " 'NORMAL_HALTON5: Normal draws from Halton base 5 sequence',\n",
                             " 'NORMAL_MLHS: Normal draws from Modified Latin Hypercube Sampling',\n",
                             " 'NORMAL_MLHS_ANTI: Antithetic normal draws from Modified Latin Hypercube Sampling']"
                         ]
                     },
-                    "execution_count": 24,
+                    "execution_count": 23,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.descriptionOfNativeDraws()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 25,
+            "execution_count": 24,
             "metadata": {},
             "outputs": [],
             "source": [
                 "randomDraws1 = bioDraws('randomDraws1', 'NORMAL_MLHS_ANTI')\n",
                 "randomDraws2 = bioDraws('randomDraws2', 'UNIFORM_MLHS_ANTI')\n",
                 "randomDraws3 = bioDraws('randomDraws3', 'UNIFORMSYM_MLHS_ANTI')"
             ]
@@ -1292,15 +1241,15 @@
             "metadata": {},
             "source": [
                 "We build an expression that involves the three random variables"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 26,
+            "execution_count": 25,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "{'randomDraws1': 'NORMAL_MLHS_ANTI', 'randomDraws2': 'UNIFORM_MLHS_ANTI', 'randomDraws3': 'UNIFORMSYM_MLHS_ANTI'}\n"
@@ -1311,15 +1260,15 @@
                 "x = randomDraws1 + randomDraws2 + randomDraws3\n",
                 "types = x.dictOfDraws()\n",
                 "print(types)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 27,
+            "execution_count": 26,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "array([[[-0.5605896 ,  0.17260212, -0.35933972],\n",
                             "        [-0.13811324,  0.53162299,  0.85919231],\n",
@@ -1351,15 +1300,15 @@
                             "        [-0.79534986,  0.40343658, -0.03577992],\n",
                             "        [-0.94867479,  0.64723909,  0.77071189],\n",
                             "        [ 1.04456302,  0.11702105, -0.44668319],\n",
                             "        [-0.15248012,  0.56738015, -0.51955543],\n",
                             "        [ 0.35858978,  0.66669537,  0.98648324]]])"
                         ]
                     },
-                    "execution_count": 27,
+                    "execution_count": 26,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "theDrawsTable = myData.generateDraws(types,                         \n",
                 "                                     ['randomDraws1',\n",
@@ -1402,15 +1351,15 @@
             "metadata": {},
             "source": [
                 "We first define functions returning draws, given the number of observations, and the number of draws"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 28,
+            "execution_count": 27,
             "metadata": {},
             "outputs": [],
             "source": [
                 "def logNormalDraws(sampleSize, numberOfDraws):\n",
                 "    return np.exp(np.random.randn(sampleSize, numberOfDraws))\n",
                 "\n",
                 "def exponentialDraws(sampleSize, numberOfDraws):\n",
@@ -1422,15 +1371,15 @@
             "metadata": {},
             "source": [
                 "We associate these functions with a name"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 29,
+            "execution_count": 28,
             "metadata": {},
             "outputs": [],
             "source": [
                 "dict = {'LOGNORMAL': (logNormalDraws, \n",
                 "                      'Draws from lognormal distribution'), \n",
                 "        'EXP': (exponentialDraws,\n",
                 "                'Draws from exponential distributions')}\n",
@@ -1442,15 +1391,15 @@
             "metadata": {},
             "source": [
                 "We can now generate draws from these distributions"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 30,
+            "execution_count": 29,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "[[[2.15336577 0.35541854]\n",
@@ -1517,15 +1466,15 @@
                 "\n",
                 "        Returns:\n",
                 "            pandas dataframe with the sample.\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 31,
+            "execution_count": 30,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -1600,26 +1549,26 @@
                         "text/plain": [
                             "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  NewVariable\n",
                             "3       2        0          4        0.4       1    1    1    1          1.6\n",
                             "3       2        0          4        0.4       1    1    1    1          1.6\n",
                             "1       1        0          2        0.2       2    1    1    1          0.4"
                         ]
                     },
-                    "execution_count": 31,
+                    "execution_count": 30,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.sampleWithReplacement()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 32,
+            "execution_count": 31,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -1733,15 +1682,15 @@
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "1       1        0          2        0.2       2    1    1    1          0.4"
                         ]
                     },
-                    "execution_count": 32,
+                    "execution_count": 31,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.sampleWithReplacement(6)"
             ]
@@ -1762,15 +1711,15 @@
                 "        Args:\n",
                 "           columnName: name of the columns that identifies\n",
                 "           individuals.\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 33,
+            "execution_count": 32,
             "metadata": {},
             "outputs": [],
             "source": [
                 "myPanelData = db.Database('test', df)"
             ]
         },
         {
@@ -1778,35 +1727,35 @@
             "metadata": {},
             "source": [
                 "Data is not considered panel yet"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 34,
+            "execution_count": 33,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "False"
                         ]
                     },
-                    "execution_count": 34,
+                    "execution_count": 33,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myPanelData.isPanel()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 35,
+            "execution_count": 34,
             "metadata": {},
             "outputs": [],
             "source": [
                 "myPanelData.panel('Person')"
             ]
         },
         {
@@ -1814,15 +1763,15 @@
             "metadata": {},
             "source": [
                 "Now it is panel"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 36,
+            "execution_count": 35,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "True\n"
@@ -1831,31 +1780,26 @@
             ],
             "source": [
                 "print(myPanelData.isPanel())"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 37,
+            "execution_count": 36,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "biogeme database test:\n",
-                        "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  NewVariable  \\\n",
-                        "0       1        0          1        0.1       1    0    1    0          0.1   \n",
-                        "1       1        0          2        0.2       2    1    1    1          0.4   \n",
-                        "2       2        0          4        0.4       1    1    1    1          1.6   \n",
-                        "\n",
-                        "   _biogroups  \n",
-                        "0           1  \n",
-                        "1           1  \n",
-                        "2           2  \n",
+                        "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  NewVariable\n",
+                        "0       1        0          1        0.1       1    0    1    0          0.1\n",
+                        "1       1        0          2        0.2       2    1    1    1          0.4\n",
+                        "2       2        0          4        0.4       1    1    1    1          1.6\n",
                         "Panel data\n",
                         "   0  1\n",
                         "1  0  1\n",
                         "2  2  2\n"
                     ]
                 }
             ],
@@ -1868,15 +1812,15 @@
             "metadata": {},
             "source": [
                 "When draws are generated for panel data, a set of draws is generated per person, not per observation."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 38,
+            "execution_count": 37,
             "metadata": {},
             "outputs": [],
             "source": [
                 "randomDraws1 = bioDraws('randomDraws1', 'NORMAL')\n",
                 "randomDraws2 = bioDraws('randomDraws2', 'UNIFORM_HALTON3')"
             ]
         },
@@ -1885,15 +1829,15 @@
             "metadata": {},
             "source": [
                 "We build an expression that involves the two random variables"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 39,
+            "execution_count": 38,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "[[[-1.57792232  0.7037037 ]\n",
@@ -1947,44 +1891,44 @@
                 "            Number of observations.\n",
                 "\n",
                 "        See:  getSampleSize()\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 40,
+            "execution_count": 39,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "3"
                         ]
                     },
-                    "execution_count": 40,
+                    "execution_count": 39,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.getNumberOfObservations()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 41,
+            "execution_count": 40,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "3"
                         ]
                     },
-                    "execution_count": 41,
+                    "execution_count": 40,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myPanelData.getNumberOfObservations()"
             ]
@@ -2008,44 +1952,44 @@
                 "           Sample size.\n",
                 "\n",
                 "        See: getNumberOfObservations()\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 42,
+            "execution_count": 41,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "3"
                         ]
                     },
-                    "execution_count": 42,
+                    "execution_count": 41,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.getSampleSize()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 43,
+            "execution_count": 42,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "2"
                         ]
                     },
-                    "execution_count": 43,
+                    "execution_count": 42,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myPanelData.getSampleSize()"
             ]
@@ -2069,15 +2013,15 @@
                 "\n",
                 "        Returns:\n",
                 "            pandas dataframe with the sample.\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 44,
+            "execution_count": 43,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -2166,15 +2110,15 @@
                             "1  0  1\n",
                             "1  0  1\n",
                             "1  0  1\n",
                             "2  2  2\n",
                             "1  0  1"
                         ]
                     },
-                    "execution_count": 44,
+                    "execution_count": 43,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myPanelData.sampleIndividualMapWithReplacement(10)"
             ]
@@ -2191,15 +2135,15 @@
             "metadata": {},
             "source": [
                 "It is possible as well to sample without replacement. This is typically useful for stochastic algorithms that use only part of the database. "
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 45,
+            "execution_count": 44,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -2300,15 +2244,15 @@
                             "0       1        0          1         10       1    0    1    0       1\n",
                             "1       1        0          2         20       2    1    1    1       5\n",
                             "2       1        1          3         30       3    1    1    1       1\n",
                             "3       2        0          4         40       1    1    1    1       1\n",
                             "4       2        1          5         50       2    1    1    1       5"
                         ]
                     },
-                    "execution_count": 45,
+                    "execution_count": 44,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "df = pd.DataFrame({'Person': [1, 1, 1, 2, 2],\n",
                 "                   'Exclude': [0, 0, 1, 0, 1],\n",
@@ -2321,38 +2265,38 @@
                 "                   'Weight': [1, 5, 1, 1, 5]})\n",
                 "myData = db.Database('test', df)\n",
                 "myData.data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 46,
+            "execution_count": 45,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "1    2\n",
                             "2    2\n",
                             "3    1\n",
                             "Name: Choice, dtype: int64"
                         ]
                     },
-                    "execution_count": 46,
+                    "execution_count": 45,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data.Choice.value_counts()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 47,
+            "execution_count": 46,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -2440,39 +2384,39 @@
                             "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  Weight\n",
                             "3       2        0          4         40       1    1    1    1       1\n",
                             "4       2        1          5         50       2    1    1    1       5\n",
                             "2       1        1          3         30       3    1    1    1       1\n",
                             "1       1        0          2         20       2    1    1    1       5"
                         ]
                     },
-                    "execution_count": 47,
+                    "execution_count": 46,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.sampleWithoutReplacement(0.7)\n",
                 "myData.data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 48,
+            "execution_count": 47,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "2    2\n",
                             "1    1\n",
                             "3    1\n",
                             "Name: Choice, dtype: int64"
                         ]
                     },
-                    "execution_count": 48,
+                    "execution_count": 47,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data.Choice.value_counts()"
             ]
@@ -2482,15 +2426,15 @@
             "metadata": {},
             "source": [
                 "The sampling does not have to be uniform. Here, we oversample data corresponding to Choice = 2"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 49,
+            "execution_count": 48,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -2578,63 +2522,63 @@
                             "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  Weight\n",
                             "1       1        0          2         20       2    1    1    1       5\n",
                             "4       2        1          5         50       2    1    1    1       5\n",
                             "2       1        1          3         30       3    1    1    1       1\n",
                             "0       1        0          1         10       1    0    1    0       1"
                         ]
                     },
-                    "execution_count": 49,
+                    "execution_count": 48,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.sampleWithoutReplacement(0.7, 'Weight')\n",
                 "myData.data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 50,
+            "execution_count": 49,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "2    2\n",
                             "3    1\n",
                             "1    1\n",
                             "Name: Choice, dtype: int64"
                         ]
                     },
-                    "execution_count": 50,
+                    "execution_count": 49,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data.Choice.value_counts()"
             ]
         }
     ],
     "metadata": {
         "kernelspec": {
-            "display_name": "Python 3",
+            "display_name": "Python 3 (ipykernel)",
             "language": "python",
             "name": "python3"
         },
         "language_info": {
             "codemirror_mode": {
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.9.5"
+            "version": "3.10.4"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 2
 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.distributions-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/biogeme.distributions.ipynb`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.999934668989547%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2021-10-26 16:01:45.374556\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9a [2021-10-26]\\n')], delete: [0]}}}}}"}*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:55:52.658179\n"
+                        "2021-10-26 16:01:45.374556\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9a [2021-10-26]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.draws-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/biogeme.draws.ipynb`

 * *Files 0% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9999503968253969%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2021-10-26 16:02:01.433519\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9a [2021-10-26]\\n')], delete: [0]}}}}}"}*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:56:10.201916\n"
+                        "2021-10-26 16:02:01.433519\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9a [2021-10-26]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.expressions-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/biogeme.biogeme.ipynb`

 * *Files 21% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9087347155659139%*

 * *Differences: {"'cells'": "{0: {'source': ['# Module biogeme.biogeme ']}, 3: {'outputs': {0: {'text': "*

 * *            "['2022-08-09 11:12:23.423610\\n']}}}, 4: {'outputs': {0: {'text': {insert: [(0, "*

 * *            "'biogeme 3.2.9b [2022-08-09]\\n')], delete: [0]}}}}, 5: {'source': {insert: [(0, "*

 * *            "'import biogeme.biogeme as bio\\n'), (1, 'import biogeme.database as db\\n'), (2, "*

 * *            "'import pandas as pd\\n'), (4, 'from biogeme.expressions import Beta, Variable, "*

 * *            "exp')], delete: [1]}}, 7:  […]*

```diff
@@ -1,14 +1,14 @@
 {
     "cells": [
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "# Module biogeme.expressions "
+                "# Module biogeme.biogeme "
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## Examples of use of each function"
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:56:32.756833\n"
+                        "2022-08-09 11:12:23.423610\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9b [2022-08-09]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -64,2200 +64,1584 @@
         },
         {
             "cell_type": "code",
             "execution_count": 3,
             "metadata": {},
             "outputs": [],
             "source": [
-                "import numpy as np\n",
-                "import pandas as pd"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 4,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "import biogeme.expressions as ex\n",
+                "import biogeme.biogeme as bio\n",
                 "import biogeme.database as db\n",
-                "import biogeme.models as models"
+                "import pandas as pd\n",
+                "import numpy as np\n",
+                "from biogeme.expressions import Beta, Variable, exp"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "We first create a small database"
+                "Define the verbosity of Biogeme"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 5,
+            "execution_count": 4,
             "metadata": {},
             "outputs": [],
             "source": [
-                "df = pd.DataFrame({'Person': [1, 1, 1, 2, 2],\n",
-                "                   'Exclude': [0, 0, 1, 0, 1],\n",
-                "                   'Variable1': [10, 20, 30, 40, 50],\n",
-                "                   'Variable2': [100, 200, 300, 400, 500],\n",
-                "                   'Choice': [1, 2, 3, 1, 2],\n",
-                "                   'Av1': [0, 1, 1, 1, 1],\n",
-                "                   'Av2': [1, 1, 1, 1, 1],\n",
-                "                   'Av3': [0, 1, 1, 1, 1]})\n",
-                "myData = db.Database('test', df)"
+                "import biogeme.messaging as msg\n",
+                "logger = msg.bioMessage()\n",
+                "logger.setDetailed()"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "The following type of expression is a literal called Variable that corresponds to an entry in the database."
+                "##  Definition of a database"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 6,
+            "execution_count": 5,
             "metadata": {},
             "outputs": [],
             "source": [
-                "Person = ex.Variable('Person')\n",
-                "Variable1 = ex.Variable('Variable1')\n",
-                "Variable2 = ex.Variable('Variable2')\n",
-                "Choice = ex.Variable('Choice')\n",
-                "Av1 = ex.Variable('Av1')\n",
-                "Av2 = ex.Variable('Av2')\n",
-                "Av3 = ex.Variable('Av3')"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "It is possible to add a new column to thre database, that creates a new variable that can be used in expressions."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 7,
-            "metadata": {},
-            "outputs": [
-                {
-                    "name": "stdout",
-                    "output_type": "stream",
-                    "text": [
-                        "biogeme database test:\n",
-                        "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  newvar\n",
-                        "0       1        0         10        100       1    0    1    0     110\n",
-                        "1       1        0         20        200       2    1    1    1     220\n",
-                        "2       1        1         30        300       3    1    1    1     330\n",
-                        "3       2        0         40        400       1    1    1    1     440\n",
-                        "4       2        1         50        500       2    1    1    1     550\n"
-                    ]
-                }
-            ],
-            "source": [
-                "newvar = ex.DefineVariable('newvar',\n",
-                "                           Variable1 + Variable2,\n",
-                "                           myData)\n",
-                "print(myData)"
+                "df = pd.DataFrame({'Person':[1,1,1,2,2],\n",
+                "                   'Exclude':[0,0,1,0,1],\n",
+                "                   'Variable1':[1,2,3,4,5],\n",
+                "                   'Variable2':[10,20,30,40,50],\n",
+                "                   'Choice':[1,2,3,1,2],\n",
+                "                   'Av1':[0,1,1,1,1],\n",
+                "                   'Av2':[1,1,1,1,1],\n",
+                "                   'Av3':[0,1,1,1,1]})\n",
+                "myData = db.Database('test', df)"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "The following type of expression is another literal, corresponding to an unknown parameter. "
+                "## Definition of various expressions"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 8,
+            "execution_count": 6,
             "metadata": {},
             "outputs": [],
             "source": [
-                "beta1 = ex.Beta('beta1', 0, None, None, 0)\n",
-                "beta2 = ex.Beta('beta2', 0, None, None, 0)\n",
-                "beta3 = ex.Beta('beta3', 1, None, None, 1)\n",
-                "beta4 = ex.Beta('beta4', 0, None, None, 1)"
+                "Variable1=Variable('Variable1')\n",
+                "Variable2=Variable('Variable2')\n",
+                "beta1 = Beta('beta1', -1.0, -3, 3, 0)\n",
+                "beta2 = Beta('beta2', 2.0, -3, 10, 0)\n",
+                "likelihood = -beta1**2 * Variable1 - exp(beta2 * beta1) \\\n",
+                "    * Variable2 - beta2**4\n",
+                "simul = beta1 / Variable1 + beta2 / Variable2\n",
+                "dictOfExpressions = {'loglike': likelihood, \n",
+                "                     'beta1': beta1,\n",
+                "                     'simul': simul}"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Arithmetic operators are overloaded to allow standard manipulations of expressions. The first expression is $$e_1 = 2  \\beta_1 - \\frac{\\exp(-\\beta_2)}{\\beta_3 (\\beta_2 \\geq \\beta_1)},$$\n",
-                "where $(\\beta_2 \\geq \\beta_1)$ equals 1 if $\\beta_2 \\geq \\beta_1$ and 0 otherwise."
+                "## Creation of the BIOGEME object"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 9,
+            "execution_count": 7,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "((`2` * beta1(0)) - (exp((-beta2(0))) / (beta3(1) * (beta2(0) >= beta1(0)))))\n"
+                        "[11:12:24] < Detailed >  It is suggested to scale the following variables.\n",
+                        "[11:12:24] < Detailed >  Multiply Variable2 by\t0.01 because the largest (abs) value is\t50\n",
+                        "[11:12:24] < Detailed >  To remove this feature, set the parameter suggestScales to False when creating the BIOGEME object.\n",
+                        "simpleExample: database [test]{'loglike': ((((-(beta1(init=-1.0)[elid:0 id:0] ** `2.0`)) * Variable1 [elid:4 id:2]) - (exp((beta2(init=2.0)[elid:1 id:1] * beta1(init=-1.0)[elid:0 id:0])) * Variable2 [elid:5 id:3])) - (beta2(init=2.0)[elid:1 id:1] ** `4.0`)), 'beta1': beta1(init=-1.0)[elid:0 id:0], 'simul': ((beta1(init=-1.0)[elid:0 id:0] / Variable1 [elid:4 id:2]) + (beta2(init=2.0)[elid:1 id:1] / Variable2 [elid:5 id:3]))}\n",
+                        "simpleExample: database [test]{'loglike': ((((-(beta1(init=-1.0)[elid:0 id:0] ** `2.0`)) * Variable1 [elid:4 id:2]) - (exp((beta2(init=2.0)[elid:1 id:1] * beta1(init=-1.0)[elid:0 id:0])) * Variable2 [elid:5 id:3])) - (beta2(init=2.0)[elid:1 id:1] ** `4.0`)), 'beta1': beta1(init=-1.0)[elid:0 id:0], 'simul': ((beta1(init=-1.0)[elid:0 id:0] / Variable1 [elid:4 id:2]) + (beta2(init=2.0)[elid:1 id:1] / Variable2 [elid:5 id:3]))}\n"
                     ]
                 }
             ],
             "source": [
-                "expr1 = 2 * beta1 - ex.exp(-beta2) / (beta3 * (beta2 >= beta1))\n",
-                "print(expr1)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "The evaluation of expressions can be done in two ways. For simple expressions, the fonction getValue(), implemented in Python, returns the value of the expression.  "
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 10,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "-1.0"
-                        ]
-                    },
-                    "execution_count": 10,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr1.getValue()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "It is possible to modify the values of the parameters"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 11,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "1.954888238921129"
-                        ]
-                    },
-                    "execution_count": 11,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "newvalues = {'beta1': 1, 'beta2': 2, 'beta3': 3, 'beta4': 2}\n",
-                "expr1.changeInitValues(newvalues)\n",
-                "expr1.getValue()"
+                "myBiogeme = bio.BIOGEME(myData, dictOfExpressions)\n",
+                "myBiogeme.modelName = 'simpleExample'\n",
+                "print(myBiogeme)"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "The function getValue_c() is implemented in C++, and works for any expression. It requires a database as input, and evaluates the expression for each entry in the database.\n",
-                "In the following example, as no variable of the database is involved in the expression, the output of the expression is the same for each entry."
+                "Note that, by default, Biogeme removes the unused variables from the database to optimize space."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 12,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "array([1.95488824, 1.95488824, 1.95488824, 1.95488824, 1.95488824])"
-                        ]
-                    },
-                    "execution_count": 12,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr1.getValue_c(myData)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "The following function scans the expression and extracts a dict with all free parameters."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 13,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "{'beta1', 'beta2'}"
-                        ]
-                    },
-                    "execution_count": 13,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr1.setOfBetas()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Options can be set to extract free parameters, fixed parameters, or both. "
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 14,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "{'beta3'}"
-                        ]
-                    },
-                    "execution_count": 14,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr1.setOfBetas(free=False, fixed=True)"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 15,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "{'beta1', 'beta2', 'beta3'}"
-                        ]
-                    },
-                    "execution_count": 15,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr1.setOfBetas(free=True, fixed=True)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "It is possible also to extract an elementary expression from its name."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 16,
+            "execution_count": 8,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "beta2(2)"
+                            "Index(['Person', 'Exclude', 'Variable1', 'Variable2', 'Choice', 'Av1', 'Av2',\n",
+                            "       'Av3'],\n",
+                            "      dtype='object')"
                         ]
                     },
-                    "execution_count": 16,
+                    "execution_count": 8,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "expr1.getElementaryExpression('beta2')"
+                "myBiogeme.database.data.columns"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Let's consider an expression involving two variables $V_1$ and $V_2$: $$e_2 =2 \\beta_1  V_1 - \\frac{\\exp(-\\beta_2 V_2) }{ \\beta_3  (\\beta_2 \\geq \\beta_1)}.$$ Note that, in our example, the second term is numerically negligible with respect to the first one."
+                "## calculateInitLikelihood"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 17,
+            "execution_count": 9,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "(((`2` * beta1(1)) * Variable1) - (exp(((-beta2(2)) * Variable2)) / (beta3(3) * (beta2(2) >= beta1(1)))))\n"
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -115.3003\n"
                     ]
-                }
-            ],
-            "source": [
-                "expr2 = 2 * beta1 * Variable1 - ex.exp(-beta2*Variable2) / (beta3 * (beta2 >= beta1))\n",
-                "print(expr2)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "It is not a simple expression anymore, and only the function getValue_c can be invoked."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 18,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "array([ 20.,  40.,  60.,  80., 100.])"
-                        ]
-                    },
-                    "execution_count": 18,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr2.getValue_c(myData)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "The following function extracts the names of the parameters apprearing in the expression"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 19,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "{'beta1', 'beta2', 'beta3'}"
-                        ]
-                    },
-                    "execution_count": 19,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr2.setOfBetas(free=True,fixed=True)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "The list of parameters can also be obtained in the form of a dictionary."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 20,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "{'beta1': beta1(1), 'beta2': beta2(2), 'beta3': beta3(3)}"
-                        ]
-                    },
-                    "execution_count": 20,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr2.dictOfBetas(free=True,fixed=True)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "The list of variables can also be obtained in the form of a dictionary"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 21,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "{'Variable1': Variable1, 'Variable2': Variable2}"
-                        ]
-                    },
-                    "execution_count": 21,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr2.dictOfVariables()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "or a set..."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 22,
-            "metadata": {},
-            "outputs": [
+                },
                 {
                     "data": {
                         "text/plain": [
-                            "{'Variable1', 'Variable2'}"
+                            "-115.30029248549191"
                         ]
                     },
-                    "execution_count": 22,
+                    "execution_count": 9,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "expr2.setOfVariables()"
+                "myBiogeme.calculateInitLikelihood()"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Expressions are defined recursively, using a tree representation. The following function describes the type of the upper most node of the tree."
+                "## calculateLikelihood"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 23,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "'Minus'"
-                        ]
-                    },
-                    "execution_count": 23,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr2.getClassName()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "The signature is a formal representation of the expression, assigning identifiers to each node of the tree, and representing them starting from the leaves. It is easy to parse, and is passed to the C++ implementation. "
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 24,
+            "execution_count": 10,
             "metadata": {},
             "outputs": [
                 {
-                    "data": {
-                        "text/plain": [
-                            "[b'<Numeric>{140650395832816},2',\n",
-                            " b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<Times>{140650395832768}(2),140650395832816,140650395694512',\n",
-                            " b'<Variable>{140649582359792}\"Variable1\",5,2',\n",
-                            " b'<Times>{140650395832960}(2),140650395832768,140649582359792',\n",
-                            " b'<Beta>{140650395694416}\"beta2\"[0],1,1',\n",
-                            " b'<UnaryMinus>{140650395834352}(1),140650395694416',\n",
-                            " b'<Variable>{140649582360272}\"Variable2\",6,3',\n",
-                            " b'<Times>{140650395834976}(2),140650395834352,140649582360272',\n",
-                            " b'<exp>{140650395835024}(1),140650395834976',\n",
-                            " b'<Beta>{140650395694560}\"beta3\"[1],2,0',\n",
-                            " b'<Beta>{140650395694416}\"beta2\"[0],1,1',\n",
-                            " b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<GreaterOrEqual>{140650395835072}(2),140650395694416,140650395694512',\n",
-                            " b'<Times>{140650395835120}(2),140650395694560,140650395835072',\n",
-                            " b'<Divide>{140650395835168}(2),140650395835024,140650395835120',\n",
-                            " b'<Minus>{140650395834256}(2),140650395832960,140650395835168']"
-                        ]
-                    },
-                    "execution_count": 24,
-                    "metadata": {},
-                    "output_type": "execute_result"
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "[0.0, 3.0]\n"
+                    ]
                 }
             ],
             "source": [
-                "expr2.getSignature()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "The elementary expressions are\n",
-                "- free parameters,\n",
-                "- fixed parameters,\n",
-                "- random variables (for numerical integration),\n",
-                "- draws (for Monte-Carlo integration), and\n",
-                "- variables from the database.\n",
-                "\n",
-                "The following function extracts all elementary expressions from a list of formulas, give them a unique numbering, and return them organized by group, as defined above (with the exception of the variables, that are directly available in the database)."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 25,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "collectionOfFormulas = [expr1, expr2]\n",
-                "(elementaryExpressionIndex,\n",
-                "    allFreeBetas,freeBetaNames,\n",
-                "    allFixedBetas,\n",
-                "    fixedBetaNames,\n",
-                "    allRandomVariables,\n",
-                "    randomVariableNames,\n",
-                "    allDraws,\n",
-                "    drawNames) =\\\n",
-                "ex.defineNumberingOfElementaryExpressions(collectionOfFormulas,\n",
-                "                                         list(myData.data.columns))"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Unique numbering for all elementary expressions"
+                "x = myBiogeme.id_manager.free_betas_values\n",
+                "xplus = [v + 1 for v in x]\n",
+                "print(xplus)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 26,
+            "execution_count": 11,
             "metadata": {},
             "outputs": [
                 {
-                    "data": {
-                        "text/plain": [
-                            "{'beta1': 0,\n",
-                            " 'beta2': 1,\n",
-                            " 'beta3': 2,\n",
-                            " 'Person': 3,\n",
-                            " 'Exclude': 4,\n",
-                            " 'Variable1': 5,\n",
-                            " 'Variable2': 6,\n",
-                            " 'Choice': 7,\n",
-                            " 'Av1': 8,\n",
-                            " 'Av2': 9,\n",
-                            " 'Av3': 10,\n",
-                            " 'newvar': 11}"
-                        ]
-                    },
-                    "execution_count": 26,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "elementaryExpressionIndex"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 27,
-            "metadata": {},
-            "outputs": [
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):       -555\n"
+                    ]
+                },
                 {
                     "data": {
                         "text/plain": [
-                            "{'beta1': beta1(1), 'beta2': beta2(2)}"
+                            "-111.0"
                         ]
                     },
-                    "execution_count": 27,
+                    "execution_count": 11,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "allFreeBetas"
+                "myBiogeme.calculateLikelihood(xplus, scaled=True)"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Each elementary expression has two ids. One unique across all elementary expressions, and one unique within each specific group"
+                "It is possible to calculate the likelihood based only on a sample of the data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 28,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "[(0, 0), (1, 1)]"
-                        ]
-                    },
-                    "execution_count": 28,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "[(i.uniqueId, i.betaId) for k, i in allFreeBetas.items()]"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 29,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "['beta1', 'beta2']"
-                        ]
-                    },
-                    "execution_count": 29,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "freeBetaNames"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 30,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "{'beta3': beta3(3)}"
-                        ]
-                    },
-                    "execution_count": 30,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "allFixedBetas"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 31,
+            "execution_count": 12,
             "metadata": {},
             "outputs": [
                 {
-                    "data": {
-                        "text/plain": [
-                            "[(2, 0)]"
-                        ]
-                    },
-                    "execution_count": 31,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "[(i.uniqueId, i.betaId) for k, i in allFixedBetas.items()]"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 32,
-            "metadata": {},
-            "outputs": [
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "[11:12:24] < Detailed >  Use 50.0% of the data.\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 2):       -555\n"
+                    ]
+                },
                 {
                     "data": {
                         "text/plain": [
-                            "['beta3']"
+                            "-277.5"
                         ]
                     },
-                    "execution_count": 32,
+                    "execution_count": 12,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "fixedBetaNames"
+                "myBiogeme.calculateLikelihood(xplus, scaled=True, batch=0.5)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 33,
+            "execution_count": 13,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
-                        "text/plain": [
-                            "{}"
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Person</th>\n",
+                            "      <th>Exclude</th>\n",
+                            "      <th>Variable1</th>\n",
+                            "      <th>Variable2</th>\n",
+                            "      <th>Choice</th>\n",
+                            "      <th>Av1</th>\n",
+                            "      <th>Av2</th>\n",
+                            "      <th>Av3</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>0</th>\n",
+                            "      <td>1</td>\n",
+                            "      <td>0</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>10</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>0</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>0</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>1</th>\n",
+                            "      <td>1</td>\n",
+                            "      <td>0</td>\n",
+                            "      <td>2</td>\n",
+                            "      <td>20</td>\n",
+                            "      <td>2</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3\n",
+                            "0       1        0          1         10       1    0    1    0\n",
+                            "1       1        0          2         20       2    1    1    1"
                         ]
                     },
-                    "execution_count": 33,
+                    "execution_count": 13,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "allRandomVariables"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Monte Carlo integration is based on draws. "
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 34,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "myDraws = ex.bioDraws('myDraws', 'UNIFORM')\n",
-                "expr3 = ex.MonteCarlo(myDraws * myDraws)"
+                "myBiogeme.database.data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 35,
+            "execution_count": 14,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "MonteCarlo((bioDraws(\"myDraws\", \"UNIFORM\") * bioDraws(\"myDraws\", \"UNIFORM\")))\n"
+                        "[11:12:24] < Detailed >  Use 60.0% of the data.\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 3):       -555\n"
                     ]
-                }
-            ],
-            "source": [
-                "print(expr3)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Note that draws are not random variables, used for numerical integration."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 36,
-            "metadata": {},
-            "outputs": [
+                },
                 {
                     "data": {
                         "text/plain": [
-                            "{}"
+                            "-185.0"
                         ]
                     },
-                    "execution_count": 36,
+                    "execution_count": 14,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "expr3.dictOfRandomVariables()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "The following function reports the draws involved in an expression."
+                "myBiogeme.calculateLikelihood(xplus, scaled=True, batch=0.6)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 37,
+            "execution_count": 15,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
-                        "text/plain": [
-                            "{'myDraws': 'UNIFORM'}"
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Person</th>\n",
+                            "      <th>Exclude</th>\n",
+                            "      <th>Variable1</th>\n",
+                            "      <th>Variable2</th>\n",
+                            "      <th>Choice</th>\n",
+                            "      <th>Av1</th>\n",
+                            "      <th>Av2</th>\n",
+                            "      <th>Av3</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>4</th>\n",
+                            "      <td>2</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>5</td>\n",
+                            "      <td>50</td>\n",
+                            "      <td>2</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>3</th>\n",
+                            "      <td>2</td>\n",
+                            "      <td>0</td>\n",
+                            "      <td>4</td>\n",
+                            "      <td>40</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>2</th>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>3</td>\n",
+                            "      <td>30</td>\n",
+                            "      <td>3</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3\n",
+                            "4       2        1          5         50       2    1    1    1\n",
+                            "3       2        0          4         40       1    1    1    1\n",
+                            "2       1        1          3         30       3    1    1    1"
                         ]
                     },
-                    "execution_count": 37,
+                    "execution_count": 15,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "expr3.dictOfDraws()"
+                "myBiogeme.database.data"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "The expression is a Monte-Carlo integration."
+                "By default, each observation has the same probability to be selected in the sample. It is possible to define the selection probability to be proportional to the values of a column of the database, using the parameter 'weights'. "
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 38,
+            "execution_count": 16,
             "metadata": {},
             "outputs": [
                 {
-                    "data": {
-                        "text/plain": [
-                            "'MonteCarlo'"
-                        ]
-                    },
-                    "execution_count": 38,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr3.getClassName()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Here is its value. It is an approximation of $\\int_0^1 x^2 dx=\\frac{1}{3}$."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 39,
-            "metadata": {},
-            "outputs": [
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "[11:12:24] < Detailed >  Use 60.0% of the data.\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 3):       -555\n"
+                    ]
+                },
                 {
                     "data": {
                         "text/plain": [
-                            "array([0.33405527, 0.33176643, 0.33263835, 0.3342899 , 0.33372886])"
+                            "-185.0"
                         ]
                     },
-                    "execution_count": 39,
+                    "execution_count": 16,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "expr3.getValue_c(myData, numberOfDraws=100000)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Here is its signature."
+                "myBiogeme.columnForBatchSamplingWeights = 'Variable2'\n",
+                "myBiogeme.calculateLikelihood(xplus, scaled=True, batch=0.6)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 40,
+            "execution_count": 17,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
-                        "text/plain": [
-                            "[b'<bioDraws>{140650395869136}\"myDraws\",0,0',\n",
-                            " b'<bioDraws>{140650395869136}\"myDraws\",0,0',\n",
-                            " b'<Times>{140650395867792}(2),140650395869136,140650395869136',\n",
-                            " b'<MonteCarlo>{140650395865968}(1),140650395867792']"
-                        ]
-                    },
-                    "execution_count": 40,
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Person</th>\n",
+                            "      <th>Exclude</th>\n",
+                            "      <th>Variable1</th>\n",
+                            "      <th>Variable2</th>\n",
+                            "      <th>Choice</th>\n",
+                            "      <th>Av1</th>\n",
+                            "      <th>Av2</th>\n",
+                            "      <th>Av3</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>1</th>\n",
+                            "      <td>1</td>\n",
+                            "      <td>0</td>\n",
+                            "      <td>2</td>\n",
+                            "      <td>20</td>\n",
+                            "      <td>2</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>2</th>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>3</td>\n",
+                            "      <td>30</td>\n",
+                            "      <td>3</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>4</th>\n",
+                            "      <td>2</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>5</td>\n",
+                            "      <td>50</td>\n",
+                            "      <td>2</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "      <td>1</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3\n",
+                            "1       1        0          2         20       2    1    1    1\n",
+                            "2       1        1          3         30       3    1    1    1\n",
+                            "4       2        1          5         50       2    1    1    1"
+                        ]
+                    },
+                    "execution_count": 17,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "expr3.getSignature()"
+                "myBiogeme.database.data"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "The same integral can be calculated using numerical integration, declaring a random variable. "
+                "## calculateLikelihoodAndDerivatives"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 41,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "omega = ex.RandomVariable('omega')"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Numerical integration calculates integrals between $-\\infty$ and $+\\infty$. Here, the interval being $[0,1]$, a change of variables is required."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 42,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "a = 0\n",
-                "b = 1\n",
-                "x = a + (b - a) / ( 1 + ex.exp(-omega))\n",
-                "dx = (b - a) * ex.exp(-omega) * (1 + ex.exp(-omega))**(-2) \n",
-                "integrand = x * x\n",
-                "expr4 = ex.Integrate(integrand * dx /(b - a), 'omega')"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "In this case, omega is a random variable."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 43,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "{'omega': omega}"
-                        ]
-                    },
-                    "execution_count": 43,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr4.dictOfRandomVariables()"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 44,
+            "execution_count": 18,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "Integrate(((((`0` + (`1` / (`1` + exp((-omega))))) * (`0` + (`1` / (`1` + exp((-omega)))))) * ((`1` * exp((-omega))) * ((`1` + exp((-omega))) ** `-2`))) / `1`), \"omega\")\n"
+                        "[11:12:24] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
+                        "f = -111.0\n",
+                        "g = [ -90. -108.]\n",
+                        "h = [[-270.  -30.]\n",
+                        " [ -30. -108.]]\n",
+                        "bhhh = [[ 9900.  9720.]\n",
+                        " [ 9720. 11664.]]\n"
                     ]
                 }
             ],
             "source": [
-                "print(expr4)"
+                "f, g, h, bhhh = myBiogeme.\\\n",
+                "    calculateLikelihoodAndDerivatives(xplus,\n",
+                "                                      scaled=True,\n",
+                "                                      hessian=True,\n",
+                "                                      bhhh=True)\n",
+                "print(f'f = {f}')\n",
+                "print(f'g = {g}')\n",
+                "print(f'h = {h}')\n",
+                "print(f'bhhh = {bhhh}')"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Calculating its value requires the C++ implementation."
+                "Now the unscaled version"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 45,
+            "execution_count": 19,
             "metadata": {},
             "outputs": [
                 {
-                    "data": {
-                        "text/plain": [
-                            "array([0.33333231, 0.33333231, 0.33333231, 0.33333231, 0.33333231])"
-                        ]
-                    },
-                    "execution_count": 45,
-                    "metadata": {},
-                    "output_type": "execute_result"
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "[11:12:24] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
+                        "f = -555.0\n",
+                        "g = [-450. -540.]\n",
+                        "h = [[-1350.  -150.]\n",
+                        " [ -150.  -540.]]\n",
+                        "bhhh = [[49500. 48600.]\n",
+                        " [48600. 58320.]]\n"
+                    ]
                 }
             ],
             "source": [
-                "expr4.getValue_c(myData)"
+                "f, g, h, bhhh = myBiogeme.\\\n",
+                "    calculateLikelihoodAndDerivatives(xplus,\n",
+                "                                      scaled=False,\n",
+                "                                      hessian=True,\n",
+                "                                      bhhh=True)\n",
+                "print(f'f = {f}')\n",
+                "print(f'g = {g}')\n",
+                "print(f'h = {h}')\n",
+                "print(f'bhhh = {bhhh}')"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "We illustrate now the Elem function. It takes two arguments: a dictionary, and a formula for the key. For each entry in the database, the formula is evaluated, and its result identifies which formula in the dictionary should be evaluated.\n",
-                "Here is 'Person' is 1, the expression is $$e_1=2  \\beta_1 - \\frac{\\exp(-\\beta_2)}{\\beta_3 (\\beta_2 \\geq \\beta_1)},$$ and if 'Person' is 2, the expression is $$e_2=2 \\beta_1  V_1 - \\frac{\\exp(-\\beta_2 V_2) }{ \\beta_3  (\\beta_2 \\geq \\beta_1)}.$$ As it is a regular expression, it can be included in any formula. Here, we illustrate it by dividing the result by 10."
+                "Using only a sample of the data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 46,
+            "execution_count": 20,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "({{1:((`2` * beta1(1)) - (exp((-beta2(2))) / (beta3(3) * (beta2(2) >= beta1(1))))), 2:(((`2` * beta1(1)) * Variable1) - (exp(((-beta2(2)) * Variable2)) / (beta3(3) * (beta2(2) >= beta1(1)))))}[Person] / `10`)\n"
+                        "[11:12:24] < Detailed >  Use 50.0% of the data.\n",
+                        "[11:12:24] < General >   Log likelihood (N = 2):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
+                        "f = -277.5\n",
+                        "g = [-225. -270.]\n",
+                        "h = [[-675.  -75.]\n",
+                        " [ -75. -270.]]\n",
+                        "bhhh = [[24750. 24300.]\n",
+                        " [24300. 29160.]]\n"
                     ]
                 }
             ],
             "source": [
-                "elemExpr = ex.Elem({1: expr1, 2: expr2}, Person) \n",
-                "expr5 =  elemExpr / 10\n",
-                "print(expr5)"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 47,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "{'Variable1': Variable1, 'Variable2': Variable2, 'Person': Person}"
-                        ]
-                    },
-                    "execution_count": 47,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr5.dictOfVariables()"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 48,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "array([ 0.19548882,  0.19548882,  0.19548882,  8.        , 10.        ])"
-                        ]
-                    },
-                    "execution_count": 48,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr5.getValue_c(myData)"
+                "f, g, h, bhhh = myBiogeme.\\\n",
+                "    calculateLikelihoodAndDerivatives(xplus,\n",
+                "                                      scaled=True,\n",
+                "                                      batch=0.5,\n",
+                "                                      hessian=True,\n",
+                "                                      bhhh=True)\n",
+                "print(f'f = {f}')\n",
+                "print(f'g = {g}')\n",
+                "print(f'h = {h}')\n",
+                "print(f'bhhh = {bhhh}')"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "The next expression is simply the sum of multiples expressions. The argument is a list of expressions. "
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 49,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "expr6 = ex.bioMultSum([expr1, expr2, expr4])"
+                "## likelihoodFiniteDifferenceHessian"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 50,
+            "execution_count": 21,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "bioMultSum(((`2` * beta1(1)) - (exp((-beta2(2))) / (beta3(3) * (beta2(2) >= beta1(1))))), (((`2` * beta1(1)) * Variable1) - (exp(((-beta2(2)) * Variable2)) / (beta3(3) * (beta2(2) >= beta1(1))))), Integrate(((((`0` + (`1` / (`1` + exp((-omega))))) * (`0` + (`1` / (`1` + exp((-omega)))))) * ((`1` * exp((-omega))) * ((`1` + exp((-omega))) ** `-2`))) / `1`), \"omega\"))\n"
+                        "[11:12:24] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02  \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02  \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -555.0002 Gradient norm:      7e+02  \n"
                     ]
-                }
-            ],
-            "source": [
-                "print(expr6)"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 51,
-            "metadata": {},
-            "outputs": [
+                },
                 {
                     "data": {
                         "text/plain": [
-                            "array([ 22.28822055,  42.28822055,  62.28822055,  82.28822055,\n",
-                            "       102.28822055])"
+                            "array([[-1380.00020229,  -150.        ],\n",
+                            "       [ -150.0000451 ,  -540.00005396]])"
                         ]
                     },
-                    "execution_count": 51,
+                    "execution_count": 21,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "expr6.getValue_c(myData, 100000)"
+                "myBiogeme.likelihoodFiniteDifferenceHessian(xplus)"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "We now illustrate how to calculate a logit model, that is $$ \\frac{y_1 e^{V_1}}{y_0 e^{V_0}+y_1 e^{V_1}+y_2 e^{V_2}}$$ where $V_0=-\\beta_1$, $V_1=-\\beta_2$ and $V_2=-\\beta_1$, and $y_i = 1$, $i=1,2,3$."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 52,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "V = {0: -beta1, 1: -beta2, 2: -beta1}\n",
-                "av = {0: 1, 1: 1, 2: 1}\n",
-                "expr7 = ex.LogLogit(V, av, 1)"
+                "## checkDerivatives"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 53,
+            "execution_count": 22,
             "metadata": {},
             "outputs": [
                 {
-                    "data": {
-                        "text/plain": [
-                            "-1.861994804058251"
-                        ]
-                    },
-                    "execution_count": 53,
-                    "metadata": {},
-                    "output_type": "execute_result"
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < Detailed >  x\t\tGradient\tFinDiff\t\tDifference\n",
+                        "[11:12:24] < Detailed >  beta1          \t-1.060058E+01\t-1.060058E+01\t-5.427932E-06\n",
+                        "[11:12:24] < Detailed >  beta2          \t-1.396997E+02\t-1.396997E+02\t+2.608000E-05\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < Detailed >  Row\t\tCol\t\tHessian\tFinDiff\t\tDifference\n",
+                        "[11:12:24] < Detailed >  beta1          \tbeta1          \t-1.112012E+02\t-1.112012E+02\t-8.045522E-06\n",
+                        "[11:12:24] < Detailed >  beta1          \tbeta2          \t+2.030029E+01\t+2.030029E+01\t+7.365980E-09\n",
+                        "[11:12:24] < Detailed >  beta2          \tbeta1          \t+2.030029E+01\t+2.030029E+01\t-1.613879E-07\n",
+                        "[11:12:24] < Detailed >  beta2          \tbeta2          \t-2.603003E+02\t-2.603003E+02\t+2.229281E-05\n"
+                    ]
                 }
             ],
             "source": [
-                "expr7.getValue()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "It is actually better to use the C++ implementation, available in the module models"
+                "f, g, h, gdiff, hdiff = myBiogeme.checkDerivatives(verbose=True)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 54,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "expr8 = models.loglogit(V,av,1)"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 55,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "array([-1.8619948, -1.8619948, -1.8619948, -1.8619948, -1.8619948])"
-                        ]
-                    },
-                    "execution_count": 55,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr8.getValue_c(myData)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "As the result is a numpy array, it can be used for any calculation. Here, we show how to calculate the logsum"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 56,
+            "execution_count": 23,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[-1. -1. -1. -1. -1.]\n",
-                        "[-2. -2. -2. -2. -2.]\n",
-                        "[-1. -1. -1. -1. -1.]\n"
+                        "f = -115.30029248549191\n",
+                        "g = [ -10.60058497 -139.69970751]\n",
+                        "h = [[-111.20116994   20.30029249]\n",
+                        " [  20.30029249 -260.30029249]]\n",
+                        "gdiff = [-5.42793187e-06  2.60800035e-05]\n",
+                        "hdiff = [[-8.04552171e-06  7.36597983e-09]\n",
+                        " [-1.61387920e-07  2.22928137e-05]]\n"
                     ]
-                }
-            ],
-            "source": [
-                "for v in V.values():\n",
-                "    print(v.getValue_c(myData))"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 57,
-            "metadata": {},
-            "outputs": [
+                },
                 {
                     "data": {
                         "text/plain": [
-                            "array([ 0.60943791, -0.39056209,  0.60943791])"
+                            "array([[-8.04552171e-06,  7.36597983e-09],\n",
+                            "       [-1.61387920e-07,  2.22928137e-05]])"
                         ]
                     },
-                    "execution_count": 57,
+                    "execution_count": 23,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "logsum = np.log(np.sum([np.exp(v.getValue_c(myData)) \n",
-                "                        for v in V.values()], axis=1))\n",
-                "logsum"
+                "print(f'f = {f}')\n",
+                "print(f'g = {g}')\n",
+                "print(f'h = {h}')\n",
+                "print(f'gdiff = {gdiff}')\n",
+                "print(f'hdiff = {hdiff}')\n",
+                "hdiff"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "It is possible to calculate the derivative of a formula with respect to a literal: $$e_9=\\frac{\\partial e_8}{\\partial \\beta_2}.$$"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 58,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "expr9 = ex.Derive(expr8, 'beta2')"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 59,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "array([-0.8446376, -0.8446376, -0.8446376, -0.8446376, -0.8446376])"
-                        ]
-                    },
-                    "execution_count": 59,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr9.getValue_c(myData)"
+                "## estimate"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Biogeme also provides an approximation of the CDF of the normal distribution: $$e_{10}= \\frac{1}{{\\sigma \\sqrt {2\\pi } }}\\int_{-\\infty}^t e^{{{ - \\left( {x - \\mu } \\right)^2 } \\mathord{\\left/ {\\vphantom {{ - \\left( {x - \\mu } \\right)^2 } {2\\sigma ^2 }}} \\right. } {2\\sigma ^2 }}}dx$$"
+                "During estimation, it is possible to save intermediate results, in case the estimation must be interrupted. "
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 60,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "expr10 = ex.bioNormalCdf(Variable1 / 10 - 1)"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 61,
+            "execution_count": 24,
             "metadata": {},
             "outputs": [
                 {
-                    "data": {
-                        "text/plain": [
-                            "array([0.5       , 0.84134475, 0.97724987, 0.9986501 , 0.99996833])"
-                        ]
-                    },
-                    "execution_count": 61,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr10.getValue_c(myData)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Min and max operators are also available. To avoid any ambiguity with the Python operator, they are called bioMin and bioMax. "
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 62,
-            "metadata": {},
-            "outputs": [
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "[11:12:24] < General >   *** Initial values of the parameters are obtained from the file __simpleExample.iter\n",
+                        "[11:12:24] < Detailed >  Parameter values restored from __simpleExample.iter\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -115.3003\n",
+                        "[11:12:24] < Detailed >  ** Optimization: Newton with trust region for simple bounds\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -69.98205\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -69.98205 Gradient norm:      3e+01 Hessian norm:       2e+02 \n",
+                        "[11:12:24] < Detailed >  1 f=  13.99641 projected rel. grad.=  0.28 rel. change=  0.38 delta=     2 rho=   1.1 ++\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -67.07892\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -67.07892 Gradient norm:          2 Hessian norm:       2e+02 \n",
+                        "[11:12:24] < Detailed >  2 f=  13.41578 projected rel. grad.= 0.021 rel. change=  0.15 delta=     4 rho=     1 ++\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -67.06549\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      0.007 Hessian norm:       2e+02 \n",
+                        "[11:12:24] < Detailed >  3 f=   13.4131 projected rel. grad.=8.1e-05 rel. change= 0.011 delta=     8 rho=     1 ++\n",
+                        "[11:12:24] < Detailed >  Log likelihood (N = 5):  -67.06549\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      1e-07 Hessian norm:       2e+02 \n",
+                        "[11:12:24] < Detailed >  4 f=   13.4131 projected rel. grad.=1.2e-09 rel. change=4.4e-05 delta=    16 rho=     1 ++\n",
+                        "[11:12:24] < Detailed >  Proportion of Hessian calculation: 100.0%\n",
+                        "[11:12:24] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      1e-07 Hessian norm:       2e+02 BHHH norm:       7e+01\n",
+                        "[11:12:24] < General >   Re-estimate the model 10 times for bootstrapping\n"
+                    ]
+                },
                 {
-                    "data": {
-                        "text/plain": [
-                            "array([0.19548882, 0.19548882, 0.19548882, 0.9986501 , 0.99996833])"
-                        ]
-                    },
-                    "execution_count": 62,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr11 = ex.bioMin(expr5, expr10)\n",
-                "expr11.getValue_c(myData)"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 63,
-            "metadata": {},
-            "outputs": [
+                    "name": "stderr",
+                    "output_type": "stream",
+                    "text": [
+                        "100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00<00:00, 331.01it/s]"
+                    ]
+                },
                 {
-                    "data": {
-                        "text/plain": [
-                            "array([ 0.5       ,  0.84134475,  0.97724987,  8.        , 10.        ])"
-                        ]
-                    },
-                    "execution_count": 63,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr12 = ex.bioMax(expr5, expr10)\n",
-                "expr12.getValue_c(myData)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "For the sake of efficiency, it is possible to specify explicitly a linear function, where each term is the product of a parameter and a variable."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 64,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "terms = [(beta1, ex.Variable('Variable1')),\n",
-                "         (beta2, ex.Variable('Variable2')),\n",
-                "         (beta3, ex.Variable('newvar'))]"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 65,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "expr13 = ex.bioLinearUtility(terms)"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 66,
-            "metadata": {},
-            "outputs": [
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "[11:12:24] < General >   Results saved in file simpleExample~03.html\n",
+                        "[11:12:24] < General >   Results saved in file simpleExample~03.pickle\n"
+                    ]
+                },
                 {
-                    "data": {
-                        "text/plain": [
-                            "array([ 540., 1080., 1620., 2160., 2700.])"
-                        ]
-                    },
-                    "execution_count": 66,
-                    "metadata": {},
-                    "output_type": "execute_result"
+                    "name": "stderr",
+                    "output_type": "stream",
+                    "text": [
+                        "\n"
+                    ]
                 }
             ],
             "source": [
-                "expr13.getValue_c(myData)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "In terms of specification, it is equivalent to the expression below. But the calculation of the derivates is more efficient, as the linear structure of the specification is exploited."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 67,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "expr13bis = beta1 * Variable1 + beta2 * Variable2 + beta3 * newvar"
+                "results = myBiogeme.estimate(bootstrap=10)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 68,
+            "execution_count": 25,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
-                        "text/plain": [
-                            "array([ 540., 1080., 1620., 2160., 2700.])"
-                        ]
-                    },
-                    "execution_count": 68,
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>-1.273264</td>\n",
+                            "      <td>0.013724</td>\n",
+                            "      <td>-92.776664</td>\n",
+                            "      <td>0.0</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>1.248769</td>\n",
+                            "      <td>0.059086</td>\n",
+                            "      <td>21.134794</td>\n",
+                            "      <td>0.0</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "          Value  Rob. Std err  Rob. t-test  Rob. p-value\n",
+                            "beta1 -1.273264      0.013724   -92.776664           0.0\n",
+                            "beta2  1.248769      0.059086    21.134794           0.0"
+                        ]
+                    },
+                    "execution_count": 25,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "expr13bis.getValue_c(myData)"
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "A Pythonic way to write a linear utility function"
+                "If the model has already been estimated, it is possible to recycle the estimation results. In that case, the other arguments are ignored, and the results are whatever is in the file."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 69,
+            "execution_count": 26,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "((((((`0` + (beta_v1(0) * v1)) + (beta_v2(0) * v2)) + (beta_v3(0) * v3)) + (beta_cost(0) * cost)) + (beta_time(0) * time)) + (beta_headway(0) * headway))\n"
+                        "[11:12:25] < Warning >   Several pickle files are available for this model: ['simpleExample.pickle', 'simpleExample~00.pickle', 'simpleExample~01.pickle', 'simpleExample~02.pickle', 'simpleExample~03.pickle']. The file simpleExample~03.pickle is used to load the results.\n",
+                        "[11:12:25] < General >   Estimation results read from simpleExample~03.pickle\n"
                     ]
                 }
             ],
             "source": [
-                "variables = ['v1', 'v2', 'v3', 'cost', 'time', 'headway']\n",
-                "coefficients = {f'{v}': ex.Beta(f'beta_{v}', 0, None, None, 0) \n",
-                "                for v in variables}\n",
-                "terms = [coefficients[v] * ex.Variable(v) for v in variables]\n",
-                "util = sum(terms)\n",
-                "print(util)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "# Signatures"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "The Python library communicates the expressions to the C++ library using a syntax called a \"signature\". We describe and illustrate now the signature for each expression. Each expression is identified by an identifier provided by Python using the function 'id'. "
+                "recycled_results = myBiogeme.estimate(recycle=True, bootstrap=10)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 70,
+            "execution_count": 27,
             "metadata": {},
             "outputs": [
                 {
-                    "data": {
-                        "text/plain": [
-                            "140650395697104"
-                        ]
-                    },
-                    "execution_count": 70,
-                    "metadata": {},
-                    "output_type": "execute_result"
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "Results for model simpleExample\n",
+                        "Nbr of parameters:\t\t2\n",
+                        "Sample size:\t\t\t5\n",
+                        "Excluded data:\t\t\t0\n",
+                        "Final log likelihood:\t\t-67.06549\n",
+                        "Akaike Information Criterion:\t138.131\n",
+                        "Bayesian Information Criterion:\t137.3499\n",
+                        "\n"
+                    ]
                 }
             ],
             "source": [
-                "id(expr1)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## Numerical expression"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "&lt;Numeric&gt;{identifier},value"
+                "print(recycled_results.shortSummary())"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 71,
+            "execution_count": 28,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
-                        "text/plain": [
-                            "[b'<Numeric>{140649582696192},0']"
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>-1.273264</td>\n",
+                            "      <td>0.013724</td>\n",
+                            "      <td>-92.776664</td>\n",
+                            "      <td>0.0</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>1.248769</td>\n",
+                            "      <td>0.059086</td>\n",
+                            "      <td>21.134794</td>\n",
+                            "      <td>0.0</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "          Value  Rob. Std err  Rob. t-test  Rob. p-value\n",
+                            "beta1 -1.273264      0.013724   -92.776664           0.0\n",
+                            "beta2  1.248769      0.059086    21.134794           0.0"
                         ]
                     },
-                    "execution_count": 71,
+                    "execution_count": 28,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "ex.Numeric(0).getSignature()"
+                "recycled_results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "## Beta parameters"
+                "## simulate"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "&lt;Beta&gt;{identifier}\"name\"[status],uniqueId,betaId'\n",
-                "where \n",
-                "- status is 0 for free parameters, and non zero for fixed parameters,\n",
-                "- uniqueId is a unique index given by Biogeme to all elementary expressions,\n",
-                "- betaId is a unique index given by Biogeme to all free parameters, and to all fixed parameters."
+                "Simulate with the default values for the parameters"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 72,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "[b'<Beta>{140650395694512}\"beta1\"[0],0,0']"
-                        ]
-                    },
-                    "execution_count": 72,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "beta1.getSignature()"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 73,
+            "execution_count": 29,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
-                        "text/plain": [
-                            "[b'<Beta>{140650395694560}\"beta3\"[1],2,0']"
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>loglike</th>\n",
+                            "      <th>beta1</th>\n",
+                            "      <th>simul</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>0</th>\n",
+                            "      <td>-23.060064</td>\n",
+                            "      <td>-1.0</td>\n",
+                            "      <td>-0.266667</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>1</th>\n",
+                            "      <td>-27.766769</td>\n",
+                            "      <td>-1.0</td>\n",
+                            "      <td>-0.160000</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>2</th>\n",
+                            "      <td>-20.706712</td>\n",
+                            "      <td>-1.0</td>\n",
+                            "      <td>-0.400000</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>3</th>\n",
+                            "      <td>-25.413417</td>\n",
+                            "      <td>-1.0</td>\n",
+                            "      <td>-0.200000</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>4</th>\n",
+                            "      <td>-23.060064</td>\n",
+                            "      <td>-1.0</td>\n",
+                            "      <td>-0.266667</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "     loglike  beta1     simul\n",
+                            "0 -23.060064   -1.0 -0.266667\n",
+                            "1 -27.766769   -1.0 -0.160000\n",
+                            "2 -20.706712   -1.0 -0.400000\n",
+                            "3 -25.413417   -1.0 -0.200000\n",
+                            "4 -23.060064   -1.0 -0.266667"
                         ]
                     },
-                    "execution_count": 73,
+                    "execution_count": 29,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "beta3.getSignature()"
+                "simulationWithDefaultBetas = myBiogeme.simulate()\n",
+                "simulationWithDefaultBetas"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "## Variables"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "&lt;Variable&gt;{identifier}\"name\",uniqueId,variableId \n",
-                "where\n",
-                "- uniqueId is a unique index given by Biogeme to all elementary expressions,\n",
-                "- variableId is a unique index given by Biogeme to all variables.\n"
+                "Simulate with the estimated values for the parameters"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 74,
+            "execution_count": 30,
             "metadata": {},
             "outputs": [
                 {
-                    "data": {
-                        "text/plain": [
-                            "[b'<Variable>{140649582359792}\"Variable1\",5,2']"
-                        ]
-                    },
-                    "execution_count": 74,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "Variable1.getSignature()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## Random variables"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "&lt;RandomVariable&gt;{identifier}\"name\",uniqueId,randomVariableId\n",
-                "where\n",
-                "- uniqueId is a unique index given by Biogeme to all elementary expressions,\n",
-                "- randomVariableId is a unique index given by Biogeme to all random variables."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 75,
-            "metadata": {},
-            "outputs": [
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "{'beta1': -1.2732639872136933, 'beta2': 1.2487688099301195}\n"
+                    ]
+                },
                 {
                     "data": {
-                        "text/plain": [
-                            "[b'<RandomVariable>{140649582654416}\"omega\",3,0']"
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>loglike</th>\n",
+                            "      <th>beta1</th>\n",
+                            "      <th>simul</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>0</th>\n",
+                            "      <td>-13.413098</td>\n",
+                            "      <td>-1.273264</td>\n",
+                            "      <td>-0.382796</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>1</th>\n",
+                            "      <td>-20.733962</td>\n",
+                            "      <td>-1.273264</td>\n",
+                            "      <td>-0.229677</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>2</th>\n",
+                            "      <td>-9.752666</td>\n",
+                            "      <td>-1.273264</td>\n",
+                            "      <td>-0.574194</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>3</th>\n",
+                            "      <td>-17.073530</td>\n",
+                            "      <td>-1.273264</td>\n",
+                            "      <td>-0.287097</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>4</th>\n",
+                            "      <td>-13.413098</td>\n",
+                            "      <td>-1.273264</td>\n",
+                            "      <td>-0.382796</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "     loglike     beta1     simul\n",
+                            "0 -13.413098 -1.273264 -0.382796\n",
+                            "1 -20.733962 -1.273264 -0.229677\n",
+                            "2  -9.752666 -1.273264 -0.574194\n",
+                            "3 -17.073530 -1.273264 -0.287097\n",
+                            "4 -13.413098 -1.273264 -0.382796"
                         ]
                     },
-                    "execution_count": 75,
+                    "execution_count": 30,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "omega.getSignature()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## Draws"
+                "print(results.getBetaValues())\n",
+                "simulationWithEstimatedBetas =\\\n",
+                "    myBiogeme.simulate(results.getBetaValues())\n",
+                "simulationWithEstimatedBetas"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "&lt;bioDraws&gt;{identifier}\"name\",uniqueId,drawId\n",
-                "where\n",
-                "- uniqueId is a unique index given by Biogeme to all elementary expressions,\n",
-                "- drawId is a unique index given by Biogeme to all draws.\n"
+                "## confidenceIntervals"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 76,
+            "execution_count": 31,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
-                        "text/plain": [
-                            "[b'<bioDraws>{140650395869136}\"myDraws\",0,0']"
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>loglike</th>\n",
+                            "      <th>beta1</th>\n",
+                            "      <th>simul</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>0</th>\n",
+                            "      <td>-13.563315</td>\n",
+                            "      <td>-1.291034</td>\n",
+                            "      <td>-0.391319</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>1</th>\n",
+                            "      <td>-21.261787</td>\n",
+                            "      <td>-1.291034</td>\n",
+                            "      <td>-0.234791</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>2</th>\n",
+                            "      <td>-10.034047</td>\n",
+                            "      <td>-1.291034</td>\n",
+                            "      <td>-0.586978</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>3</th>\n",
+                            "      <td>-17.387198</td>\n",
+                            "      <td>-1.291034</td>\n",
+                            "      <td>-0.293489</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>4</th>\n",
+                            "      <td>-13.563315</td>\n",
+                            "      <td>-1.291034</td>\n",
+                            "      <td>-0.391319</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "     loglike     beta1     simul\n",
+                            "0 -13.563315 -1.291034 -0.391319\n",
+                            "1 -21.261787 -1.291034 -0.234791\n",
+                            "2 -10.034047 -1.291034 -0.586978\n",
+                            "3 -17.387198 -1.291034 -0.293489\n",
+                            "4 -13.563315 -1.291034 -0.391319"
                         ]
                     },
-                    "execution_count": 76,
+                    "execution_count": 31,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myDraws.getSignature()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## General expression"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "&lt;operator&gt;{identifier}(numberOfChildren),idFirstChild,idSecondChild,idThirdChild, etc...\n",
-                "where the number of identifiers given after the comma matches the reported number of children. \n",
-                "\n",
-                "Specific examples are reported below."
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "### Binary operator"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "&lt;operator&gt;{identifier}(2),idFirstChild,idSecondChild \n",
-                "where operator is one of: \n",
-                "    - 'Plus'\n",
-                "    - 'Minus'\n",
-                "    - 'Times'\n",
-                "    - 'Divide'\n",
-                "    - 'Power'\n",
-                "    - 'bioMin'\n",
-                "    - 'bioMax'\n",
-                "    - 'And'\n",
-                "    - 'Or'\n",
-                "    - 'Equal'\n",
-                "    - 'NotEqual'\n",
-                "    - 'LessOrEqual'\n",
-                "    - 'GreaterOrEqual'\n",
-                "    - 'Less'\n",
-                "    - 'Greater'\n"
+                "drawsFromBetas =\\\n",
+                "    results.getBetasForSensitivityAnalysis(myBiogeme.id_manager.free_betas.names)\n",
+                "left, right = myBiogeme.confidenceIntervals(drawsFromBetas)\n",
+                "left"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 77,
-            "metadata": {},
-            "outputs": [],
-            "source": [
-                "sum = beta1 + Variable1"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 78,
+            "execution_count": 32,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
-                        "text/plain": [
-                            "[b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<Variable>{140649582359792}\"Variable1\",5,2',\n",
-                            " b'<Plus>{140649582778592}(2),140650395694512,140649582359792']"
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>loglike</th>\n",
+                            "      <th>beta1</th>\n",
+                            "      <th>simul</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>0</th>\n",
+                            "      <td>-13.413098</td>\n",
+                            "      <td>-1.255223</td>\n",
+                            "      <td>-0.374218</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>1</th>\n",
+                            "      <td>-20.443982</td>\n",
+                            "      <td>-1.255223</td>\n",
+                            "      <td>-0.224531</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>2</th>\n",
+                            "      <td>-9.638020</td>\n",
+                            "      <td>-1.255223</td>\n",
+                            "      <td>-0.561327</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>3</th>\n",
+                            "      <td>-16.974003</td>\n",
+                            "      <td>-1.255223</td>\n",
+                            "      <td>-0.280663</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>4</th>\n",
+                            "      <td>-13.413098</td>\n",
+                            "      <td>-1.255223</td>\n",
+                            "      <td>-0.374218</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "     loglike     beta1     simul\n",
+                            "0 -13.413098 -1.255223 -0.374218\n",
+                            "1 -20.443982 -1.255223 -0.224531\n",
+                            "2  -9.638020 -1.255223 -0.561327\n",
+                            "3 -16.974003 -1.255223 -0.280663\n",
+                            "4 -13.413098 -1.255223 -0.374218"
                         ]
                     },
-                    "execution_count": 78,
+                    "execution_count": 32,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "sum.getSignature()"
+                "right"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "### Unary operator"
+                "## validate"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "&lt;operator&gt;{identifier}(1),idChild, \n",
-                "where operator is one of: \n",
-                "    - 'UnaryMinus'\n",
-                "    - 'MonteCarlo'\n",
-                "    - 'bioNormalCdf'\n",
-                "    - 'PanelLikelihoodTrajectory'\n",
-                "    - 'exp'\n",
-                "    - 'log'"
+                "The validation consists in organizing the data into several slices of about the same size, randomly defined. \n",
+                "Each slide is considered as a validation dataset. The model is then re-estimated using all the data except the slice, and the estimated model is applied on the validation set (i.e. the slice). The value of the log likelihood for each observation in the validation set is reported in a dataframe. As this is done for each slice, the output is a list of dataframes, each corresponding to one of these exercises.   "
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 79,
+            "execution_count": 33,
             "metadata": {},
             "outputs": [],
             "source": [
-                "m = -beta1"
+                "logger.setSilent()\n",
+                "validationData = myData.split(slices=5)\n",
+                "validation_results = myBiogeme.validate(results, validationData)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 80,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "[b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<UnaryMinus>{140649582777872}(1),140650395694512']"
-                        ]
-                    },
-                    "execution_count": 80,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "m.getSignature()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## LogLogit"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "&lt;LogLogit&gt;{identifier}(nbrOfAlternatives),chosenAlt,altNumber,utility,availability,altNumber,utility,availability, etc."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 81,
-            "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "[b'<Numeric>{140649582749488},1',\n",
-                            " b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<UnaryMinus>{140649582751360}(1),140650395694512',\n",
-                            " b'<Beta>{140650395694416}\"beta2\"[0],1,1',\n",
-                            " b'<UnaryMinus>{140649582751408}(1),140650395694416',\n",
-                            " b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<UnaryMinus>{140649582751456}(1),140650395694512',\n",
-                            " b'<Numeric>{140649582749728},1',\n",
-                            " b'<Numeric>{140649582749680},1',\n",
-                            " b'<Numeric>{140649582749632},1',\n",
-                            " b'<LogLogit>{140649582751504}(3),140649582749488,0,140649582751360,140649582749728,1,140649582751408,140649582749680,2,140649582751456,140649582749632']"
-                        ]
-                    },
-                    "execution_count": 81,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr7.getSignature()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## Derive"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "&lt;Derive&gt;{identifier},id of expression to derive,unique index of elementary expression"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 82,
+            "execution_count": 34,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "[b'<Numeric>{140649582750640},1',\n",
-                            " b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<UnaryMinus>{140649582751360}(1),140650395694512',\n",
-                            " b'<Beta>{140650395694416}\"beta2\"[0],1,1',\n",
-                            " b'<UnaryMinus>{140649582751408}(1),140650395694416',\n",
-                            " b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<UnaryMinus>{140649582751456}(1),140650395694512',\n",
-                            " b'<Numeric>{140649582749200},1',\n",
-                            " b'<Numeric>{140649582749584},1',\n",
-                            " b'<Numeric>{140649582749152},1',\n",
-                            " b'<_bioLogLogit>{140649582749872}(3),140649582750640,0,140649582751360,140649582749200,1,140649582751408,140649582749584,2,140649582751456,140649582749152',\n",
-                            " b'<Derive>{140649582780224},140649582749872,1']"
+                            "[   Loglikelihood\n",
+                            " 3     -17.145326,\n",
+                            "    Loglikelihood\n",
+                            " 0       -6.34111,\n",
+                            "    Loglikelihood\n",
+                            " 2     -13.413098,\n",
+                            "    Loglikelihood\n",
+                            " 4     -21.037421,\n",
+                            "    Loglikelihood\n",
+                            " 1      -9.817721]"
                         ]
                     },
-                    "execution_count": 82,
+                    "execution_count": 34,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "expr9.getSignature()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## Integrate"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "&lt;Integrate&gt;{identifier},id of expression to derive,index of random variable"
+                "validation_results"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 83,
+            "execution_count": 35,
             "metadata": {},
             "outputs": [
                 {
-                    "data": {
-                        "text/plain": [
-                            "[b'<Numeric>{140649582675424},0',\n",
-                            " b'<Numeric>{140649582676672},1',\n",
-                            " b'<Numeric>{140649582676864},1',\n",
-                            " b'<RandomVariable>{140649582654416}\"omega\",3,0',\n",
-                            " b'<UnaryMinus>{140649582676816}(1),140649582654416',\n",
-                            " b'<exp>{140649582677968}(1),140649582676816',\n",
-                            " b'<Plus>{140649582676768}(2),140649582676864,140649582677968',\n",
-                            " b'<Divide>{140649582676720}(2),140649582676672,140649582676768',\n",
-                            " b'<Plus>{140649582675472}(2),140649582675424,140649582676720',\n",
-                            " b'<Numeric>{140649582675424},0',\n",
-                            " b'<Numeric>{140649582676672},1',\n",
-                            " b'<Numeric>{140649582676864},1',\n",
-                            " b'<RandomVariable>{140649582654416}\"omega\",3,0',\n",
-                            " b'<UnaryMinus>{140649582676816}(1),140649582654416',\n",
-                            " b'<exp>{140649582677968}(1),140649582676816',\n",
-                            " b'<Plus>{140649582676768}(2),140649582676864,140649582677968',\n",
-                            " b'<Divide>{140649582676720}(2),140649582676672,140649582676768',\n",
-                            " b'<Plus>{140649582675472}(2),140649582675424,140649582676720',\n",
-                            " b'<Times>{140649582675376}(2),140649582675472,140649582675472',\n",
-                            " b'<Numeric>{140649582675232},1',\n",
-                            " b'<RandomVariable>{140649582654416}\"omega\",3,0',\n",
-                            " b'<UnaryMinus>{140649582676912}(1),140649582654416',\n",
-                            " b'<exp>{140649582677824}(1),140649582676912',\n",
-                            " b'<Times>{140649582675280}(2),140649582675232,140649582677824',\n",
-                            " b'<Numeric>{140649582657200},1',\n",
-                            " b'<RandomVariable>{140649582654416}\"omega\",3,0',\n",
-                            " b'<UnaryMinus>{140649582675184}(1),140649582654416',\n",
-                            " b'<exp>{140649582675136}(1),140649582675184',\n",
-                            " b'<Plus>{140649582677872}(2),140649582657200,140649582675136',\n",
-                            " b'<Numeric>{140649582657296},-2',\n",
-                            " b'<Power>{140649582657248}(2),140649582677872,140649582657296',\n",
-                            " b'<Times>{140649582657344}(2),140649582675280,140649582657248',\n",
-                            " b'<Times>{140649582656864}(2),140649582675376,140649582657344',\n",
-                            " b'<Numeric>{140649582656912},1',\n",
-                            " b'<Divide>{140649582657152}(2),140649582656864,140649582656912',\n",
-                            " b'<Integrate>{140649582657392},140649582657152,0']"
-                        ]
-                    },
-                    "execution_count": 83,
-                    "metadata": {},
-                    "output_type": "execute_result"
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "Log likelihood for 1 validation data: -17.14532644602357\n",
+                        "Log likelihood for 1 validation data: -6.34111029142699\n",
+                        "Log likelihood for 1 validation data: -13.413098095892842\n",
+                        "Log likelihood for 1 validation data: -21.037421362921453\n",
+                        "Log likelihood for 1 validation data: -9.817721165500888\n"
+                    ]
                 }
             ],
             "source": [
-                "expr4.getSignature()"
+                "for slide in validation_results:\n",
+                "    print(f'Log likelihood for {slide.shape[0]} '\n",
+                "          f'validation data: {slide[\"Loglikelihood\"].sum()}')\n"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "## Elem"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "&lt;Elem&gt;{identifier}(numberOfExpressions),keyId,value1,expression1,value2,expression2, etc...\n",
-                "\n",
-                "where\n",
-                "- keyId is the identifier of the expression calculating the key,\n",
-                "- the number of pairs valuex,expressionx must correspond to the value of numberOfExpressions"
+                "## files_of_type"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 84,
+            "execution_count": 36,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "[b'<Variable>{140649582360320}\"Person\",3,0',\n",
-                            " b'<Numeric>{140650395696336},2',\n",
-                            " b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<Times>{140650395696384}(2),140650395696336,140650395694512',\n",
-                            " b'<Beta>{140650395694416}\"beta2\"[0],1,1',\n",
-                            " b'<UnaryMinus>{140650395695472}(1),140650395694416',\n",
-                            " b'<exp>{140650395695424}(1),140650395695472',\n",
-                            " b'<Beta>{140650395694560}\"beta3\"[1],2,0',\n",
-                            " b'<Beta>{140650395694416}\"beta2\"[0],1,1',\n",
-                            " b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<GreaterOrEqual>{140650395694320}(2),140650395694416,140650395694512',\n",
-                            " b'<Times>{140650395694608}(2),140650395694560,140650395694320',\n",
-                            " b'<Divide>{140650395694704}(2),140650395695424,140650395694608',\n",
-                            " b'<Minus>{140650395697104}(2),140650395696384,140650395694704',\n",
-                            " b'<Numeric>{140650395832816},2',\n",
-                            " b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<Times>{140650395832768}(2),140650395832816,140650395694512',\n",
-                            " b'<Variable>{140649582359792}\"Variable1\",5,2',\n",
-                            " b'<Times>{140650395832960}(2),140650395832768,140649582359792',\n",
-                            " b'<Beta>{140650395694416}\"beta2\"[0],1,1',\n",
-                            " b'<UnaryMinus>{140650395834352}(1),140650395694416',\n",
-                            " b'<Variable>{140649582360272}\"Variable2\",6,3',\n",
-                            " b'<Times>{140650395834976}(2),140650395834352,140649582360272',\n",
-                            " b'<exp>{140650395835024}(1),140650395834976',\n",
-                            " b'<Beta>{140650395694560}\"beta3\"[1],2,0',\n",
-                            " b'<Beta>{140650395694416}\"beta2\"[0],1,1',\n",
-                            " b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<GreaterOrEqual>{140650395835072}(2),140650395694416,140650395694512',\n",
-                            " b'<Times>{140650395835120}(2),140650395694560,140650395835072',\n",
-                            " b'<Divide>{140650395835168}(2),140650395835024,140650395835120',\n",
-                            " b'<Minus>{140650395834256}(2),140650395832960,140650395835168',\n",
-                            " b'<Elem>{140649582656048}(2),140649582360320,1,140650395697104,2,140650395834256']"
+                            "['simpleExample.pickle',\n",
+                            " 'simpleExample~02.pickle',\n",
+                            " 'simpleExample~00.pickle',\n",
+                            " 'simpleExample~03.pickle',\n",
+                            " 'simpleExample~01.pickle']"
                         ]
                     },
-                    "execution_count": 84,
+                    "execution_count": 36,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "elemExpr.getSignature()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## bioLinearUtility"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "&lt;bioLinearUtility&gt;{identifier}(numberOfTerms), beta1_exprId, beta1_uniqueId, beta1_name, variable1_exprId, variable1_uniqueId, variable1_name, etc...\n",
-                "\n",
-                "where 6 entries are provided for each term:\n",
-                "    - beta1_exprId is the expression id of the beta parameter\n",
-                "    - beta1_uniqueId is the unique id of the beta parameter\n",
-                "    - beta1_name is the name of the parameter\n",
-                "    - variable1_exprId is the expression id of the variable\n",
-                "    - variable1_uniqueId is the unique id of the variable\n",
-                "    - variable1_name is the name of the variable\n"
+                "myBiogeme.files_of_type('pickle')"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 85,
+            "execution_count": null,
             "metadata": {},
-            "outputs": [
-                {
-                    "data": {
-                        "text/plain": [
-                            "[b'<Beta>{140650395694512}\"beta1\"[0],0,0',\n",
-                            " b'<Beta>{140650395694416}\"beta2\"[0],1,1',\n",
-                            " b'<Beta>{140650395694560}\"beta3\"[1],2,0',\n",
-                            " b'<Variable>{140650658462208}\"Variable1\",5,2',\n",
-                            " b'<Variable>{140650658462160}\"Variable2\",6,3',\n",
-                            " b'<Variable>{140650658460672}\"newvar\",11,8',\n",
-                            " b'<bioLinearUtility>{140650658462256}(3),140650395694512,0,beta1,140650658462208,5,Variable1,140650395694416,1,beta2,140650658462160,6,Variable2,140650395694560,2,beta3,140650658460672,11,newvar']"
-                        ]
-                    },
-                    "execution_count": 85,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                }
-            ],
-            "source": [
-                "expr13.getSignature()"
-            ]
+            "outputs": [],
+            "source": []
         }
     ],
     "metadata": {
         "kernelspec": {
-            "display_name": "Python 3",
+            "display_name": "Python 3 (ipykernel)",
             "language": "python",
             "name": "python3"
         },
         "language_info": {
             "codemirror_mode": {
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.9.5"
+            "version": "3.10.4"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 2
 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.filenames-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.filenames-checkpoint.ipynb`

 * *Files 2% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9998214285714286%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2021-08-04 16:38:43.667581\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.8 [2021-08-04]\\n')], delete: [0]}}}}}"}*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:56:50.143102\n"
+                        "2021-08-04 16:38:43.667581\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.8 [2021-08-04]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.loglikelihood-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.loglikelihood-checkpoint.ipynb`

 * *Files 10% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9761704441391942%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2022-08-09 11:13:29.583678\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9b [2022-08-09]\\n')], delete: [0]}}}}, 6: "*

 * *            "{'execution_count': 4}, 9: {'execution_count': 5, 'outputs': {0: {'text': "*

 * *            "['MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0.0`, 2:(beta(init=0)[elid:None "*

 * *            'id:None] + (sigma(init=1)[elid:None id:None] * bioDraws("V2", '*

 * *            '"NORMAL"))))))\\n\']}}}, 11: {\'execution_cou […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:57:02.611989\n"
+                        "2022-08-09 11:13:29.583678\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9b [2022-08-09]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -64,14 +64,25 @@
         },
         {
             "cell_type": "code",
             "execution_count": 3,
             "metadata": {},
             "outputs": [],
             "source": [
+                "import biogeme.messaging as msg\n",
+                "logger = msg.bioMessage()\n",
+                "logger.setDebug()"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 4,
+            "metadata": {},
+            "outputs": [],
+            "source": [
                 "import numpy as np\n",
                 "import pandas as pd\n",
                 "import biogeme.database as db\n",
                 "import biogeme.loglikelihood as ll\n",
                 "import biogeme.expressions as ex\n",
                 "import biogeme.models as md"
             ]
@@ -88,22 +99,22 @@
             "metadata": {},
             "source": [
                 "Let's consider first a simple choice model."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 4,
+            "execution_count": 5,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0`, 2:(beta(0) + (sigma(1) * bioDraws(\"V2\", \"NORMAL\"))))))\n"
+                        "MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0.0`, 2:(beta(init=0)[elid:None id:None] + (sigma(init=1)[elid:None id:None] * bioDraws(\"V2\", \"NORMAL\"))))))\n"
                     ]
                 }
             ],
             "source": [
                 "V1 = 0\n",
                 "beta = ex.Beta('beta', 0, None, None, 0)\n",
                 "sigma = ex.Beta('sigma', 1, 0, None, 0)\n",
@@ -119,22 +130,22 @@
             "metadata": {},
             "source": [
                 "The first function simply takes the log of the probability for each observation."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 5,
+            "execution_count": 6,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "log(MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0`, 2:(beta(0) + (sigma(1) * bioDraws(\"V2\", \"NORMAL\")))))))\n"
+                        "log(MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0.0`, 2:(beta(init=0)[elid:None id:None] + (sigma(init=1)[elid:None id:None] * bioDraws(\"V2\", \"NORMAL\")))))))\n"
                     ]
                 }
             ],
             "source": [
                 "loglike = ll.loglikelihood(prob)\n",
                 "print(loglike)"
             ]
@@ -144,22 +155,22 @@
             "metadata": {},
             "source": [
                 "The second function also involves the integral using Monte-Carlo simulation."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 6,
+            "execution_count": 7,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "log(MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0`, 2:(beta(0) + (sigma(1) * bioDraws(\"V2\", \"NORMAL\")))))))\n"
+                        "log(MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0.0`, 2:(beta(init=0)[elid:None id:None] + (sigma(init=1)[elid:None id:None] * bioDraws(\"V2\", \"NORMAL\")))))))\n"
                     ]
                 }
             ],
             "source": [
                 "loglike = ll.mixedloglikelihood(condprob)\n",
                 "print(loglike)"
             ]
@@ -169,15 +180,15 @@
             "metadata": {},
             "source": [
                 "Regression models are often used in the context of hybrid choice models. Consider the following model."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 7,
+            "execution_count": 8,
             "metadata": {},
             "outputs": [],
             "source": [
                 "x = ex.Variable('x')\n",
                 "y = ex.Variable('y')\n",
                 "beta = ex.Beta('beta', 1, None, None, 0)\n",
                 "sigma = ex.Beta('sigma', 1, None, None, 0)\n",
@@ -195,22 +206,22 @@
                 " \n",
                 " where $\\phi(\\cdot)$ is the pdf of the normal distribution.\n",
                 "\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 8,
+            "execution_count": 9,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "exp(((((-(((y - (intercept(0) + (beta(1) * x))) / sigma(1)) ** `2`)) / `2`) - log(sigma(1))) - `0.9189385332`))\n"
+                        "exp(((((-(((y [elid:None id:None] - (intercept(init=0)[elid:None id:None] + (beta(init=1)[elid:None id:None] * x [elid:None id:None]))) / sigma(init=1)[elid:None id:None]) ** `2.0`)) / `2.0`) - log(sigma(init=1)[elid:None id:None])) - `0.9189385332`))\n"
                     ]
                 }
             ],
             "source": [
                 "like = ll.likelihoodregression(y, model, sigma)\n",
                 "print(like)"
             ]
@@ -223,22 +234,22 @@
                 "\n",
                 "\\\\[-\\left( \\frac{(y-m)^2}{2\\sigma^2} \\right) -\n",
                 "              \\log(\\sigma) - \\frac{1}{2}\\log(2\\pi).\\\\]"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 9,
+            "execution_count": 10,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "((((-(((y - (intercept(0) + (beta(1) * x))) / sigma(1)) ** `2`)) / `2`) - log(sigma(1))) - `0.9189385332`)\n"
+                        "((((-(((y [elid:None id:None] - (intercept(init=0)[elid:None id:None] + (beta(init=1)[elid:None id:None] * x [elid:None id:None]))) / sigma(init=1)[elid:None id:None]) ** `2.0`)) / `2.0`) - log(sigma(init=1)[elid:None id:None])) - `0.9189385332`)\n"
                     ]
                 }
             ],
             "source": [
                 "loglike = ll.loglikelihoodregression(y, model, sigma)\n",
                 "print(loglike)"
             ]
@@ -248,100 +259,107 @@
             "metadata": {},
             "source": [
                 "We compare the two on a small database"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 10,
+            "execution_count": 11,
             "metadata": {},
             "outputs": [],
             "source": [
                 "df = pd.DataFrame({'x': [-2, -1, 0, 1, 2],\n",
                 "                   'y': [1, 1, 1, 1, 1]})\n",
                 "myData = db.Database('test', df)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 11,
+            "execution_count": 12,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "array([0.00443185, 0.05399097, 0.24197073, 0.39894229, 0.24197073])"
                         ]
                     },
-                    "execution_count": 11,
+                    "execution_count": 12,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "lr = like.getValue_c(myData)\n",
+                "lr = like.getValue_c(myData, prepareIds=True)\n",
                 "lr"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 12,
+            "execution_count": 13,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "array([-5.41893852, -2.91893852, -1.41893852, -0.91893852, -1.41893852])"
                         ]
                     },
-                    "execution_count": 12,
+                    "execution_count": 13,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "np.log(lr)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 13,
+            "execution_count": 14,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "array([-5.41893852, -2.91893852, -1.41893852, -0.91893852, -1.41893852])"
                         ]
                     },
-                    "execution_count": 13,
+                    "execution_count": 14,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "loglike.getValue_c(myData)"
+                "loglike.getValue_c(myData, prepareIds=True)"
             ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": null,
+            "metadata": {},
+            "outputs": [],
+            "source": []
         }
     ],
     "metadata": {
         "kernelspec": {
-            "display_name": "Python 3",
+            "display_name": "Python 3 (ipykernel)",
             "language": "python",
             "name": "python3"
         },
         "language_info": {
             "codemirror_mode": {
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.9.5"
+            "version": "3.10.4"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 4
 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.messaging-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.messaging-checkpoint.ipynb`

 * *Files 7% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9992615318118414%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2021-08-04 16:39:10.087165\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.8 [2021-08-04]\\n')], delete: [0]}}}}, 15: "*

 * *            "{'outputs': {0: {'text': ['[16:39:10] < Warning >   A test\\n']}}}, 17: {'outputs': "*

 * *            "{0: {'text': ['[16:39:10] < General >   A general message\\n']}}}, 18: {'outputs': "*

 * *            "{0: {'text': ['[16:39:10] < Warning >   A warning message\\n']}}}, 19: {'outputs': "*

 * *            "{0: {'tex […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:57:16.266254\n"
+                        "2021-08-04 16:39:10.087165\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.8 [2021-08-04]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -152,15 +152,15 @@
             "execution_count": 8,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < Warning >   A test\n"
+                        "[16:39:10] < Warning >   A test\n"
                     ]
                 }
             ],
             "source": [
                 "logger.addMessage(\"A test\", 1)"
             ]
         },
@@ -176,15 +176,15 @@
             "execution_count": 9,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < General >   A general message\n"
+                        "[16:39:10] < General >   A general message\n"
                     ]
                 }
             ],
             "source": [
                 "logger.general(\"A general message\")"
             ]
         },
@@ -193,15 +193,15 @@
             "execution_count": 10,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < Warning >   A warning message\n"
+                        "[16:39:10] < Warning >   A warning message\n"
                     ]
                 }
             ],
             "source": [
                 "logger.warning(\"A warning message\")"
             ]
         },
@@ -210,15 +210,15 @@
             "execution_count": 11,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < Detailed >  A detailed message\n"
+                        "[16:39:10] < Detailed >  A detailed message\n"
                     ]
                 }
             ],
             "source": [
                 "logger.detailed(\"A detailed message\")"
             ]
         },
@@ -243,21 +243,21 @@
             "execution_count": 13,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "*** Messages from biogeme 3.2.7 [2021-07-19]\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < General >   A general message\n",
-                        "[10:57:16] < Warning >   A warning message\n",
-                        "[10:57:16] < Detailed >  A detailed message\n",
-                        "[10:57:16] < Debug >     A debug message\n",
+                        "*** Messages from biogeme 3.2.8 [2021-08-04]\n",
+                        "[16:39:10] < Warning >   A test\n",
+                        "[16:39:10] < Warning >   A test\n",
+                        "[16:39:10] < General >   A general message\n",
+                        "[16:39:10] < Warning >   A warning message\n",
+                        "[16:39:10] < Detailed >  A detailed message\n",
+                        "[16:39:10] < Debug >     A debug message\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "print(logger.allMessages())"
             ]
@@ -274,15 +274,15 @@
             "execution_count": 14,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < General >   Log file created: _test.log\n"
+                        "[16:39:10] < General >   Log file created: _test.log\n"
                     ]
                 }
             ],
             "source": [
                 "theFile = logger.createLog(fileName=\"_test\")"
             ]
         },
@@ -291,23 +291,23 @@
             "execution_count": 15,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "*** File created 2021-07-19 10:57:16.322320 ***\n",
-                        "*** Log file from biogeme 3.2.7 [2021-07-19]\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < General >   A general message\n",
-                        "[10:57:16] < Warning >   A warning message\n",
-                        "[10:57:16] < Detailed >  A detailed message\n",
-                        "[10:57:16] < Debug >     A debug message\n",
-                        "[10:57:16] < General >   Log file created: _test.log\n",
+                        "*** File created 2021-08-04 16:39:10.145983 ***\n",
+                        "*** Log file from biogeme 3.2.8 [2021-08-04]\n",
+                        "[16:39:10] < Warning >   A test\n",
+                        "[16:39:10] < Warning >   A test\n",
+                        "[16:39:10] < General >   A general message\n",
+                        "[16:39:10] < Warning >   A warning message\n",
+                        "[16:39:10] < Detailed >  A detailed message\n",
+                        "[16:39:10] < Debug >     A debug message\n",
+                        "[16:39:10] < General >   Log file created: _test.log\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "with open(theFile) as f:\n",
                 "    print(f.read())"
@@ -325,20 +325,20 @@
             "execution_count": 16,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "*** Messages from biogeme 3.2.7 [2021-07-19]\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < General >   A general message\n",
-                        "[10:57:16] < Warning >   A warning message\n",
-                        "[10:57:16] < General >   Log file created: _test.log\n",
+                        "*** Messages from biogeme 3.2.8 [2021-08-04]\n",
+                        "[16:39:10] < Warning >   A test\n",
+                        "[16:39:10] < Warning >   A test\n",
+                        "[16:39:10] < General >   A general message\n",
+                        "[16:39:10] < Warning >   A warning message\n",
+                        "[16:39:10] < General >   Log file created: _test.log\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "print(logger.allMessages(screenLevel=2))"
             ]
@@ -355,15 +355,15 @@
             "execution_count": 17,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < General >   Log file created: _test~00.log\n"
+                        "[16:39:10] < General >   Log file created: _test~00.log\n"
                     ]
                 }
             ],
             "source": [
                 "theFile = logger.createLog(fileLevel=2, fileName=\"_test\")"
             ]
         },
@@ -372,22 +372,22 @@
             "execution_count": 18,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "*** File created 2021-07-19 10:57:16.334764 ***\n",
-                        "*** Log file from biogeme 3.2.7 [2021-07-19]\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < General >   A general message\n",
-                        "[10:57:16] < Warning >   A warning message\n",
-                        "[10:57:16] < General >   Log file created: _test.log\n",
-                        "[10:57:16] < General >   Log file created: _test~00.log\n",
+                        "*** File created 2021-08-04 16:39:10.158639 ***\n",
+                        "*** Log file from biogeme 3.2.8 [2021-08-04]\n",
+                        "[16:39:10] < Warning >   A test\n",
+                        "[16:39:10] < Warning >   A test\n",
+                        "[16:39:10] < General >   A general message\n",
+                        "[16:39:10] < Warning >   A warning message\n",
+                        "[16:39:10] < General >   Log file created: _test.log\n",
+                        "[16:39:10] < General >   Log file created: _test~00.log\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "with open(theFile) as f:\n",
                 "    print(f.read())"
@@ -405,15 +405,15 @@
             "execution_count": 19,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "*** Messages from biogeme 3.2.7 [2021-07-19]\n",
+                        "*** Messages from biogeme 3.2.8 [2021-08-04]\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "logger.resetMessages()\n",
                 "print(logger.allMessages())"
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.optimization-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.optimization-checkpoint.ipynb`

 * *Files 0% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9998336092644129%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2021-08-04 16:40:09.623045\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.8 [2021-08-04]\\n')], delete: [0]}}}}, 17: "*

 * *            "{'outputs': {0: {'text': {insert: [(0, "*

 * *            "'/Users/michelbierlaire/opt/anaconda3/envs/python39/lib/python3.9/site-packages/biogeme/optimization.py:74: "*

 * *            "OptimizeWarning: Unknown solver options: myparam\\n')], delete: [0]}}}}, 18: "*

 * *            "{'outputs': {0: {'text': {insert: [ […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 11:07:05.731291\n"
+                        "2021-08-04 16:40:09.623045\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.8 [2021-08-04]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -236,15 +236,15 @@
             "execution_count": 11,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stderr",
                     "output_type": "stream",
                     "text": [
-                        "/Users/michelbierlaire/opt/anaconda3/envs/python39/lib/python3.9/site-packages/biogeme-3.2.7-py3.9-macosx-10.9-x86_64.egg/biogeme/optimization.py:74: OptimizeWarning: Unknown solver options: myparam\n",
+                        "/Users/michelbierlaire/opt/anaconda3/envs/python39/lib/python3.9/site-packages/biogeme/optimization.py:74: OptimizeWarning: Unknown solver options: myparam\n",
                         "  results = sc.minimize(\n"
                     ]
                 },
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
@@ -329,15 +329,15 @@
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "Algorithm:\tscipy.optimize\n",
                         "Cause of termination:\tCONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL\n",
                         "Number of iterations:\t13\n",
                         "Number of function evaluations:\t16\n",
-                        "Optimization time:\t0:00:00.004741\n"
+                        "Optimization time:\t0:00:00.005387\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -441,15 +441,15 @@
                         "Algorithm:\tUnconstrained Newton with line search\n",
                         "Relative gradient:\t3.43067908440321e-07\n",
                         "Number of iterations:\t3\n",
                         "Number of function evaluations:\t10\n",
                         "Number of gradient evaluations:\t10\n",
                         "Number of hessian evaluations:\t4\n",
                         "Cause of termination:\tRelative gradient = 3.4e-07 <= 6.1e-06\n",
-                        "Optimization time:\t0:00:00.003077\n"
+                        "Optimization time:\t0:00:00.002763\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -555,15 +555,15 @@
                         "Algorithm:\tUnconstrained Newton with line search\n",
                         "Relative gradient:\t0.015380029144206175\n",
                         "Number of iterations:\t2\n",
                         "Number of function evaluations:\t7\n",
                         "Number of gradient evaluations:\t7\n",
                         "Number of hessian evaluations:\t3\n",
                         "Cause of termination:\tRelative gradient = 0.015 <= 0.1\n",
-                        "Optimization time:\t0:00:00.002197\n"
+                        "Optimization time:\t0:00:00.001935\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -667,15 +667,15 @@
                         "Algorithm:\tUnconstrained Newton with trust region\n",
                         "Relative gradient:\t3.289367618372832e-07\n",
                         "Cause of termination:\tRelative gradient = 3.3e-07 <= 6.1e-06\n",
                         "Number of iterations:\t3\n",
                         "Number of function evaluations:\t6\n",
                         "Number of gradient evaluations:\t4\n",
                         "Number of hessian evaluations:\t4\n",
-                        "Optimization time:\t0:00:00.001875\n"
+                        "Optimization time:\t0:00:00.001914\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -783,15 +783,15 @@
                         "Algorithm:\tUnconstrained Newton with trust region\n",
                         "Relative gradient:\t2.0182963630997235\n",
                         "Cause of termination:\tMaximum number of iterations reached: 3\n",
                         "Number of iterations:\t3\n",
                         "Number of function evaluations:\t6\n",
                         "Number of gradient evaluations:\t4\n",
                         "Number of hessian evaluations:\t4\n",
-                        "Optimization time:\t0:00:00.001724\n"
+                        "Optimization time:\t0:00:00.001829\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -897,15 +897,15 @@
                         "Algorithm:\tUnconstrained Newton with trust region\n",
                         "Relative gradient:\t0.014746524905603029\n",
                         "Cause of termination:\tRelative gradient = 0.015 <= 0.1\n",
                         "Number of iterations:\t2\n",
                         "Number of function evaluations:\t4\n",
                         "Number of gradient evaluations:\t3\n",
                         "Number of hessian evaluations:\t3\n",
-                        "Optimization time:\t0:00:00.001545\n"
+                        "Optimization time:\t0:00:00.001431\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -1008,15 +1008,15 @@
                     "text": [
                         "Algorithm:\tInverse BFGS with line search\n",
                         "Relative gradient:\t5.933646980468922e-07\n",
                         "Cause of termination:\tRelative gradient = 5.9e-07 <= 6.1e-06\n",
                         "Number of iterations:\t5\n",
                         "Number of function evaluations:\t28\n",
                         "Number of gradient evaluations:\t6\n",
-                        "Optimization time:\t0:00:00.004124\n"
+                        "Optimization time:\t0:00:00.003773\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -1119,15 +1119,15 @@
                     "text": [
                         "Algorithm:\tBFGS with trust region\n",
                         "Relative gradient:\t5.039394505504404e-07\n",
                         "Cause of termination:\tRelative gradient = 5e-07 <= 6.1e-06\n",
                         "Number of iterations:\t14\n",
                         "Number of function evaluations:\t23\n",
                         "Number of gradient evaluations:\t9\n",
-                        "Optimization time:\t0:00:00.006114\n"
+                        "Optimization time:\t0:00:00.007021\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -1241,15 +1241,15 @@
                         "Relative projected gradient:\t3.2893676168569793e-07\n",
                         "Relative change:\t0.00022882036808896666\n",
                         "Number of iterations:\t3\n",
                         "Number of function evaluations:\t10\n",
                         "Number of gradient evaluations:\t4\n",
                         "Number of hessian evaluations:\t4\n",
                         "Cause of termination:\tRelative gradient = 3.3e-07 <= 6.1e-06\n",
-                        "Optimization time:\t0:00:00.002401\n"
+                        "Optimization time:\t0:00:00.002381\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -1357,15 +1357,15 @@
                         "Relative projected gradient:\t2.790944329115531e-06\n",
                         "Relative change:\t4.2680917955839615e-05\n",
                         "Number of iterations:\t4\n",
                         "Number of function evaluations:\t13\n",
                         "Number of gradient evaluations:\t5\n",
                         "Number of hessian evaluations:\t3\n",
                         "Cause of termination:\tRelative gradient = 2.8e-06 <= 6.1e-06\n",
-                        "Optimization time:\t0:00:00.003632\n"
+                        "Optimization time:\t0:00:00.003114\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -1473,15 +1473,15 @@
                         "Relative projected gradient:\t1.3873770983933678e-06\n",
                         "Relative change:\t6.637427884398361e-08\n",
                         "Number of iterations:\t14\n",
                         "Number of function evaluations:\t31\n",
                         "Number of gradient evaluations:\t9\n",
                         "Number of hessian evaluations:\t0\n",
                         "Cause of termination:\tRelative change = 6.64e-08 <= 1e-05\n",
-                        "Optimization time:\t0:00:00.008617\n"
+                        "Optimization time:\t0:00:00.008764\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -1588,15 +1588,15 @@
                         "Relative projected gradient:\t3.2893676168569793e-07\n",
                         "Relative change:\t0.00022882036808896666\n",
                         "Number of iterations:\t3\n",
                         "Number of function evaluations:\t10\n",
                         "Number of gradient evaluations:\t4\n",
                         "Number of hessian evaluations:\t4\n",
                         "Cause of termination:\tRelative gradient = 3.3e-07 <= 6.1e-06\n",
-                        "Optimization time:\t0:00:00.002894\n"
+                        "Optimization time:\t0:00:00.002530\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
@@ -1696,15 +1696,15 @@
                         "Relative projected gradient:\t1.3873770983933678e-06\n",
                         "Relative change:\t6.637427884398361e-08\n",
                         "Number of iterations:\t14\n",
                         "Number of function evaluations:\t31\n",
                         "Number of gradient evaluations:\t9\n",
                         "Number of hessian evaluations:\t0\n",
                         "Cause of termination:\tRelative change = 6.64e-08 <= 1e-05\n",
-                        "Optimization time:\t0:00:00.008677\n"
+                        "Optimization time:\t0:00:00.010334\n"
                     ]
                 }
             ],
             "source": [
                 "for k, v in results.data.optimizationMessages.items():\n",
                 "    print(f'{k}:\\t{v}')"
             ]
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.results-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.results-checkpoint.ipynb`

 * *Files 20% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9691111462626676%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2022-06-29 19:08:27.263630\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9b [2022-06-29]\\n')], delete: [0]}}}}, 12: "*

 * *            "{'outputs': {1: {'text': {insert: [(2, 'Output file "*

 * *            "(HTML):\\t\\t\\tsimpleExample~05.html\\n'), (6, 'Init log "*

 * *            "likelihood:\\t\\t-67.5536\\n'), (8, 'Likelihood ratio test "*

 * *            "(init):\\t\\t0.9762237\\n'), (9, 'Rho square (init):\\t\\t\\t0.00723\\n'), (10, 'Rho "*

 * *   […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 11:11:12.386468\n"
+                        "2022-06-29 19:08:27.263630\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9b [2022-06-29]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -142,36 +142,50 @@
         },
         {
             "cell_type": "code",
             "execution_count": 7,
             "metadata": {},
             "outputs": [
                 {
+                    "name": "stderr",
+                    "output_type": "stream",
+                    "text": [
+                        "100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00<00:00, 433.11it/s]"
+                    ]
+                },
+                {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "\n",
                         "Results for model simpleExample\n",
-                        "Output file (HTML):\t\t\tsimpleExample~14.html\n",
+                        "Output file (HTML):\t\t\tsimpleExample~05.html\n",
                         "Nbr of parameters:\t\t2\n",
                         "Sample size:\t\t\t5\n",
                         "Excluded data:\t\t\t0\n",
-                        "Init log likelihood:\t\t-67.73691\n",
+                        "Init log likelihood:\t\t-67.5536\n",
                         "Final log likelihood:\t\t-67.06549\n",
-                        "Likelihood ratio test (init):\t\t1.342839\n",
-                        "Rho square (init):\t\t\t0.00991\n",
-                        "Rho bar square (init):\t\t\t-0.0196\n",
+                        "Likelihood ratio test (init):\t\t0.9762237\n",
+                        "Rho square (init):\t\t\t0.00723\n",
+                        "Rho bar square (init):\t\t\t-0.0224\n",
                         "Akaike Information Criterion:\t138.131\n",
                         "Bayesian Information Criterion:\t137.3499\n",
-                        "Final gradient norm:\t\t2.887991e-05\n",
-                        "beta1          : -1.27[0.115 -11.1 0][0.0137 -92.8 0][0.0125 -102 0]\n",
-                        "beta2          : 1.25[0.0848 14.7 0][0.0591 21.1 0][0.054 23.1 0]\n",
+                        "Final gradient norm:\t\t0.0001314937\n",
+                        "beta1          : -1.27[0.115 -11.1 0][0.0137 -92.8 0][0.016 -79.5 0]\n",
+                        "beta2          : 1.25[0.0848 14.7 0][0.0591 21.1 0][0.0689 18.1 0]\n",
                         "('beta2', 'beta1'):\t0.00167\t0.171\t19.3\t0\t0.000811\t1\t55.6\t0\n",
                         "\n"
                     ]
+                },
+                {
+                    "name": "stderr",
+                    "output_type": "stream",
+                    "text": [
+                        "\n"
+                    ]
                 }
             ],
             "source": [
                 "myBiogeme = bio.BIOGEME(myData, dictOfExpressions)\n",
                 "myBiogeme.modelName = 'simpleExample'\n",
                 "results = myBiogeme.estimate(bootstrap=10)\n",
                 "print(results)"
@@ -189,21 +203,21 @@
             "execution_count": 8,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "simpleExample~18.pickle\n"
+                        "simpleExample~12.pickle\n"
                     ]
                 }
             ],
             "source": [
-                "f = results.writePickle()\n",
-                "print(f)"
+                "the_pickle_file = results.writePickle()\n",
+                "print(the_pickle_file)"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Results can be imported from a file previously generated"
@@ -216,35 +230,35 @@
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "\n",
                         "Results for model simpleExample\n",
-                        "Output file (HTML):\t\t\tsimpleExample~14.html\n",
+                        "Output file (HTML):\t\t\tsimpleExample~05.html\n",
                         "Nbr of parameters:\t\t2\n",
                         "Sample size:\t\t\t5\n",
                         "Excluded data:\t\t\t0\n",
-                        "Init log likelihood:\t\t-67.73691\n",
+                        "Init log likelihood:\t\t-67.5536\n",
                         "Final log likelihood:\t\t-67.06549\n",
-                        "Likelihood ratio test (init):\t\t1.342839\n",
-                        "Rho square (init):\t\t\t0.00991\n",
-                        "Rho bar square (init):\t\t\t-0.0196\n",
+                        "Likelihood ratio test (init):\t\t0.9762237\n",
+                        "Rho square (init):\t\t\t0.00723\n",
+                        "Rho bar square (init):\t\t\t-0.0224\n",
                         "Akaike Information Criterion:\t138.131\n",
                         "Bayesian Information Criterion:\t137.3499\n",
-                        "Final gradient norm:\t\t2.887991e-05\n",
-                        "beta1          : -1.27[0.115 -11.1 0][0.0137 -92.8 0][0.0125 -102 0]\n",
-                        "beta2          : 1.25[0.0848 14.7 0][0.0591 21.1 0][0.054 23.1 0]\n",
+                        "Final gradient norm:\t\t0.0001314937\n",
+                        "beta1          : -1.27[0.115 -11.1 0][0.0137 -92.8 0][0.016 -79.5 0]\n",
+                        "beta2          : 1.25[0.0848 14.7 0][0.0591 21.1 0][0.0689 18.1 0]\n",
                         "('beta2', 'beta1'):\t0.00167\t0.171\t19.3\t0\t0.000811\t1\t55.6\t0\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
-                "readResults = res.bioResults(pickleFile=f)\n",
+                "readResults = res.bioResults(pickleFile=the_pickle_file)\n",
                 "print(readResults)"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
@@ -253,80 +267,96 @@
         },
         {
             "cell_type": "code",
             "execution_count": 10,
             "metadata": {},
             "outputs": [
                 {
+                    "name": "stderr",
+                    "output_type": "stream",
+                    "text": [
+                        "/Users/michelbierlaire/ToBackupOnGoogleDrive/github/biogeme/biogeme/results.py:735: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n",
+                        "  h += table.to_latex(float_format=formatting)\n"
+                    ]
+                },
+                {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "%% This file is designed to be included into a LaTeX document\n",
                         "%% See http://www.latex-project.org for information about LaTeX\n",
-                        "%% simpleExample - Report from biogeme 3.2.7 [2021-07-19]\n",
-                        "%% biogeme 3.2.7 [2021-07-19]\n",
+                        "%% simpleExample - Report from biogeme 3.2.9b [2022-06-29]\n",
+                        "%% biogeme 3.2.9b [2022-06-29]\n",
                         "%% Version entirely written in Python\n",
                         "%% Home page: http://biogeme.epfl.ch\n",
                         "%% Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "%% Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n",
-                        "%% This file has automatically been generated on 2021-07-19 11:11:13.007730</p>\n",
+                        "%% This file has automatically been generated on 2022-06-29 19:08:27.917313</p>\n",
                         "\n",
                         "%%Database name: test\n",
                         "\n",
                         "%% General statistics\n",
                         "\\section{General statistics}\n",
                         "\\begin{tabular}{ll}\n",
                         "Number of estimated parameters & 2 \\\\\n",
                         "Sample size & 5 \\\\\n",
                         "Excluded observations & 0 \\\\\n",
-                        "Init log likelihood & -67.73691 \\\\\n",
+                        "Init log likelihood & -67.5536 \\\\\n",
                         "Final log likelihood & -67.06549 \\\\\n",
-                        "Likelihood ratio test for the init. model & 1.342839 \\\\\n",
-                        "Rho-square for the init. model & 0.00991 \\\\\n",
-                        "Rho-square-bar for the init. model & -0.0196 \\\\\n",
+                        "Likelihood ratio test for the init. model & 0.9762237 \\\\\n",
+                        "Rho-square for the init. model & 0.00723 \\\\\n",
+                        "Rho-square-bar for the init. model & -0.0224 \\\\\n",
                         "Akaike Information Criterion & 138.131 \\\\\n",
                         "Bayesian Information Criterion & 137.3499 \\\\\n",
-                        "Final gradient norm & 2.8880E-05 \\\\\n",
-                        "Bootstrapping time & 0:00:00.033336 \\\\\n",
+                        "Final gradient norm & 1.3149E-04 \\\\\n",
+                        "Bootstrapping time & 0:00:00.034716 \\\\\n",
                         "Nbr of threads & 16 \\\\\n",
                         "Algorithm & \\verb$Newton with trust region for simple bound constraints$ \\\\\n",
                         "Proportion analytical hessian & \\verb$100.0%$ \\\\\n",
-                        "Relative projected gradient & \\verb$5.401448e-07$ \\\\\n",
-                        "Relative change & \\verb$2.058044e-06$ \\\\\n",
-                        "Number of iterations & \\verb$3$ \\\\\n",
-                        "Number of function evaluations & \\verb$10$ \\\\\n",
-                        "Number of gradient evaluations & \\verb$4$ \\\\\n",
-                        "Number of hessian evaluations & \\verb$4$ \\\\\n",
-                        "Cause of termination & \\verb$Relative change = 2.06e-06 <= 1e-05$ \\\\\n",
-                        "Optimization time & \\verb$0:00:00.003768$ \\\\\n",
+                        "Relative projected gradient & \\verb$2.390418e-06$ \\\\\n",
+                        "Relative change & \\verb$0.001379638$ \\\\\n",
+                        "Number of iterations & \\verb$2$ \\\\\n",
+                        "Number of function evaluations & \\verb$7$ \\\\\n",
+                        "Number of gradient evaluations & \\verb$3$ \\\\\n",
+                        "Number of hessian evaluations & \\verb$3$ \\\\\n",
+                        "Cause of termination & \\verb$Relative gradient = 2.4e-06 <= 6.1e-06$ \\\\\n",
+                        "Optimization time & \\verb$0:00:00.002434$ \\\\\n",
                         "\\end{tabular}\n",
                         "\n",
                         "%%Parameter estimates\n",
                         "\\section{Parameter estimates}\n",
-                        "\\begin{tabular}{lrrrrrrrrrr}\n",
+                        "\\begin{tabular}{lrrrr}\n",
                         "\\toprule\n",
-                        "{} &  Value &  Std err &  t-test &  p-value &  Rob. Std err &  Rob. t-test &  Rob. p-value &  Bootstrap[10] Std err &  Bootstrap t-test &  Bootstrap p-value \\\\\n",
+                        "{} &  Value &  Rob. Std err &  Rob. t-test &  Rob. p-value \\\\\n",
                         "\\midrule\n",
-                        "beta1 &  -1.27 &    0.115 &   -11.1 &      0.0 &        0.0137 &        -92.8 &           0.0 &                 0.0125 &            -102.0 &                0.0 \\\\\n",
-                        "beta2 &   1.25 &   0.0848 &    14.7 &      0.0 &        0.0591 &         21.1 &           0.0 &                  0.054 &              23.1 &                0.0 \\\\\n",
+                        "beta1 &  -1.27 &        0.0137 &        -92.8 &           0.0 \\\\\n",
+                        "beta2 &   1.25 &        0.0591 &         21.1 &           0.0 \\\\\n",
                         "\\bottomrule\n",
                         "\\end{tabular}\n",
                         "\n",
                         "%%Correlation\n",
                         "\\section{Correlation}\n",
                         "\\begin{tabular}{lrrrrrrrrrrrr}\n",
                         "\\toprule\n",
                         "{} &  Covariance &  Correlation &  t-test &  p-value &  Rob. cov. &  Rob. corr. &  Rob. t-test &  Rob. p-value &  Boot. cov. &  Boot. corr. &  Boot. t-test &  Boot. p-value \\\\\n",
                         "\\midrule\n",
-                        "beta2-beta1 &     0.00167 &        0.171 &    19.3 &      0.0 &   0.000811 &         1.0 &         55.6 &           0.0 &    0.000678 &          1.0 &          60.8 &            0.0 \\\\\n",
+                        "beta2-beta1 &     0.00167 &        0.171 &    19.3 &      0.0 &   0.000811 &         1.0 &         55.6 &           0.0 &      0.0011 &          1.0 &          47.7 &            0.0 \\\\\n",
                         "\\bottomrule\n",
                         "\\end{tabular}\n",
                         "\n"
                     ]
+                },
+                {
+                    "name": "stderr",
+                    "output_type": "stream",
+                    "text": [
+                        "/Users/michelbierlaire/ToBackupOnGoogleDrive/github/biogeme/biogeme/results.py:740: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n",
+                        "  h += table.to_latex(float_format=formatting)\n"
+                    ]
                 }
             ],
             "source": [
                 "print(readResults.getLaTeX())"
             ]
         },
         {
@@ -345,17 +375,17 @@
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "<html>\n",
                         "<head>\n",
                         "<script src=\"http://transp-or.epfl.ch/biogeme/sorttable.js\"></script>\n",
                         "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n",
-                        "<title>simpleExample - Report from biogeme 3.2.7 [2021-07-19]</title>\n",
+                        "<title>simpleExample - Report from biogeme 3.2.9b [2022-06-29]</title>\n",
                         "<meta name=\"keywords\" content=\"biogeme, discrete choice, random utility\">\n",
-                        "<meta name=\"description\" content=\"Report from biogeme 3.2.7 [2021-07-19]\">\n",
+                        "<meta name=\"description\" content=\"Report from biogeme 3.2.9b [2022-06-29]\">\n",
                         "<meta name=\"author\" content=\"{bv.author}\">\n",
                         "<style type=text/css>\n",
                         ".biostyle\n",
                         "\t{font-size:10.0pt;\n",
                         "\tfont-weight:400;\n",
                         "\tfont-style:normal;\n",
                         "\tfont-family:Courier;}\n",
@@ -364,64 +394,64 @@
                         "\tfont-weight:400;\n",
                         "\tfont-style:normal;\n",
                         "\tfont-family:Courier;\n",
                         "        color:red}\n",
                         "</style>\n",
                         "</head>\n",
                         "<body bgcolor=\"#ffffff\">\n",
-                        "<p>biogeme 3.2.7 [2021-07-19]</p>\n",
+                        "<p>biogeme 3.2.9b [2022-06-29]</p>\n",
                         "<p><a href=\"https://www.python.org/\" target=\"_blank\">Python</a> package</p>\n",
                         "<p>Home page: <a href=\"http://biogeme.epfl.ch\" target=\"_blank\">http://biogeme.epfl.ch</a></p>\n",
                         "<p>Submit questions to <a href=\"https://groups.google.com/d/forum/biogeme\" target=\"_blank\">https://groups.google.com/d/forum/biogeme</a></p>\n",
                         "<p><a href=\"http://people.epfl.ch/michel.bierlaire\">Michel Bierlaire</a>, <a href=\"http://transp-or.epfl.ch\">Transport and Mobility Laboratory</a>, <a href=\"http://www.epfl.ch\">Ecole Polytechnique F&#233;d&#233;rale de Lausanne (EPFL)</a></p>\n",
-                        "<p>This file has automatically been generated on 2021-07-19 11:11:13.038612</p>\n",
+                        "<p>This file has automatically been generated on 2022-06-29 19:08:28.093081</p>\n",
                         "<table>\n",
-                        "<tr class=biostyle><td align=right><strong>Report file</strong>:\t</td><td>simpleExample~14.html</td></tr>\n",
+                        "<tr class=biostyle><td align=right><strong>Report file</strong>:\t</td><td>simpleExample~05.html</td></tr>\n",
                         "<tr class=biostyle><td align=right><strong>Database name</strong>:\t</td><td>test</td></tr>\n",
                         "</table>\n",
                         "<h1>Estimation report</h1>\n",
                         "<table border=\"0\">\n",
                         "<tr class=biostyle><td align=right ><strong>Number of estimated parameters</strong>: </td> <td>2</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Sample size</strong>: </td> <td>5</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Excluded observations</strong>: </td> <td>0</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Init log likelihood</strong>: </td> <td>-67.73691</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Init log likelihood</strong>: </td> <td>-67.5536</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Final log likelihood</strong>: </td> <td>-67.06549</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Likelihood ratio test for the init. model</strong>: </td> <td>1.342839</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Rho-square for the init. model</strong>: </td> <td>0.00991</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Rho-square-bar for the init. model</strong>: </td> <td>-0.0196</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Likelihood ratio test for the init. model</strong>: </td> <td>0.9762237</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Rho-square for the init. model</strong>: </td> <td>0.00723</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Rho-square-bar for the init. model</strong>: </td> <td>-0.0224</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Akaike Information Criterion</strong>: </td> <td>138.131</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Bayesian Information Criterion</strong>: </td> <td>137.3499</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Final gradient norm</strong>: </td> <td>2.8880E-05</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Bootstrapping time</strong>: </td> <td>0:00:00.033336</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Final gradient norm</strong>: </td> <td>1.3149E-04</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Bootstrapping time</strong>: </td> <td>0:00:00.034716</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Nbr of threads</strong>: </td> <td>16</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Algorithm</strong>: </td> <td>Newton with trust region for simple bound constraints</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Proportion analytical hessian</strong>: </td> <td>100.0%</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Relative projected gradient</strong>: </td> <td>5.401448e-07</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Relative change</strong>: </td> <td>2.0580436087508352e-06</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Number of iterations</strong>: </td> <td>3</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Number of function evaluations</strong>: </td> <td>10</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Number of gradient evaluations</strong>: </td> <td>4</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Number of hessian evaluations</strong>: </td> <td>4</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Cause of termination</strong>: </td> <td>Relative change = 2.06e-06 <= 1e-05</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Optimization time</strong>: </td> <td>0:00:00.003768</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Relative projected gradient</strong>: </td> <td>2.390418e-06</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Relative change</strong>: </td> <td>0.0013796384032595055</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Number of iterations</strong>: </td> <td>2</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Number of function evaluations</strong>: </td> <td>7</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Number of gradient evaluations</strong>: </td> <td>3</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Number of hessian evaluations</strong>: </td> <td>3</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Cause of termination</strong>: </td> <td>Relative gradient = 2.4e-06 <= 6.1e-06</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Optimization time</strong>: </td> <td>0:00:00.002434</td></tr>\n",
                         "</table>\n",
                         "<h1>Estimated parameters</h1>\n",
                         "<table border=\"1\">\n",
-                        "<tr class=biostyle><th>Name</th><th>Value</th><th>Std err</th><th>t-test</th><th>p-value</th><th>Rob. Std err</th><th>Rob. t-test</th><th>Rob. p-value</th><th>Bootstrap[10] Std err</th><th>Bootstrap t-test</th><th>Bootstrap p-value</th></tr>\n",
-                        "<tr class=biostyle><td>beta1</td><td>-1.27</td><td>0.115</td><td>-11.1</td><td>0</td><td>0.0137</td><td>-92.8</td><td>0</td><td>0.0125</td><td>-102</td><td>0</td></tr>\n",
-                        "<tr class=biostyle><td>beta2</td><td>1.25</td><td>0.0848</td><td>14.7</td><td>0</td><td>0.0591</td><td>21.1</td><td>0</td><td>0.054</td><td>23.1</td><td>0</td></tr>\n",
+                        "<tr class=biostyle><th>Name</th><th>Value</th><th>Rob. Std err</th><th>Rob. t-test</th><th>Rob. p-value</th></tr>\n",
+                        "<tr class=biostyle><td>beta1</td><td>-1.27</td><td>0.0137</td><td>-92.8</td><td>0</td></tr>\n",
+                        "<tr class=biostyle><td>beta2</td><td>1.25</td><td>0.0591</td><td>21.1</td><td>0</td></tr>\n",
                         "</table>\n",
                         "<h2>Correlation of coefficients</h2>\n",
                         "<table border=\"1\">\n",
                         "<tr class=biostyle><th>Coefficient1</th><th>Coefficient2</th><th>Covariance</th><th>Correlation</th><th>t-test</th><th>p-value</th><th>Rob. cov.</th><th>Rob. corr.</th><th>Rob. t-test</th><th>Rob. p-value</th><th>Boot. cov.</th><th>Boot. corr.</th><th>Boot. t-test</th><th>Boot. p-value</th></tr>\n",
-                        "<tr class=biostyle><td>beta2</td><td>beta1</td><td>0.00167</td><td>0.171</td><td>19.3</td><td>0</td><td>0.000811</td><td>1</td><td>55.6</td><td>0</td><td>0.000678</td><td>1</td><td>60.8</td><td>0</td></tr>\n",
+                        "<tr class=biostyle><td>beta2</td><td>beta1</td><td>0.00167</td><td>0.171</td><td>19.3</td><td>0</td><td>0.000811</td><td>1</td><td>55.6</td><td>0</td><td>0.0011</td><td>1</td><td>47.7</td><td>0</td></tr>\n",
                         "</table>\n",
-                        "<p>Smallest eigenvalue: 73.0541</p>\n",
+                        "<p>Smallest eigenvalue: 73.054</p>\n",
                         "<p>Largest eigenvalue: 147.802</p>\n",
-                        "<p>Condition number: 2.02318</p>\n",
+                        "<p>Condition number: 2.02319</p>\n",
                         "</html>\n"
                     ]
                 }
             ],
             "source": [
                 "print(readResults.getHtml())"
             ]
@@ -440,23 +470,23 @@
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "{'Number of estimated parameters': (2, ''),\n",
                             " 'Sample size': (5, ''),\n",
                             " 'Excluded observations': (0, ''),\n",
-                            " 'Init log likelihood': (-67.73690998796737, '.7g'),\n",
-                            " 'Final log likelihood': (-67.06549047946919, '.7g'),\n",
-                            " 'Likelihood ratio test for the init. model': (1.3428390169963507, '.7g'),\n",
-                            " 'Rho-square for the init. model': (0.009912166182624027, '.3g'),\n",
-                            " 'Rho-square-bar for the init. model': (-0.019613833753825416, '.3g'),\n",
-                            " 'Akaike Information Criterion': (138.13098095893838, '.7g'),\n",
-                            " 'Bayesian Information Criterion': (137.3498567838066, '.7g'),\n",
-                            " 'Final gradient norm': (2.8879908411669447e-05, '.4E'),\n",
-                            " 'Bootstrapping time': (datetime.timedelta(microseconds=33336), ''),\n",
+                            " 'Init log likelihood': (-67.55360233858966, '.7g'),\n",
+                            " 'Final log likelihood': (-67.06549047952232, '.7g'),\n",
+                            " 'Likelihood ratio test for the init. model': (0.976223718134662, '.7g'),\n",
+                            " 'Rho-square for the init. model': (0.0072255489295868225, '.3g'),\n",
+                            " 'Rho-square-bar for the init. model': (-0.022380570222663154, '.3g'),\n",
+                            " 'Akaike Information Criterion': (138.13098095904465, '.7g'),\n",
+                            " 'Bayesian Information Criterion': (137.34985678391286, '.7g'),\n",
+                            " 'Final gradient norm': (0.00013149371433604645, '.4E'),\n",
+                            " 'Bootstrapping time': (datetime.timedelta(microseconds=34716), ''),\n",
                             " 'Nbr of threads': (16, '')}"
                         ]
                     },
                     "execution_count": 12,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
@@ -496,23 +526,23 @@
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "Number of estimated parameters:\t2\n",
                         "Sample size:\t5\n",
                         "Excluded observations:\t0\n",
-                        "Init log likelihood:\t-67.73691\n",
+                        "Init log likelihood:\t-67.5536\n",
                         "Final log likelihood:\t-67.06549\n",
-                        "Likelihood ratio test for the init. model:\t1.342839\n",
-                        "Rho-square for the init. model:\t0.00991\n",
-                        "Rho-square-bar for the init. model:\t-0.0196\n",
+                        "Likelihood ratio test for the init. model:\t0.9762237\n",
+                        "Rho-square for the init. model:\t0.00723\n",
+                        "Rho-square-bar for the init. model:\t-0.0224\n",
                         "Akaike Information Criterion:\t138.131\n",
                         "Bayesian Information Criterion:\t137.3499\n",
-                        "Final gradient norm:\t2.8880E-05\n",
-                        "Bootstrapping time:\t0:00:00.033336\n",
+                        "Final gradient norm:\t1.3149E-04\n",
+                        "Bootstrapping time:\t0:00:00.034716\n",
                         "Nbr of threads:\t16\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "print(results.printGeneralStatistics())"
@@ -548,68 +578,42 @@
                             "    }\n",
                             "</style>\n",
                             "<table border=\"1\" class=\"dataframe\">\n",
                             "  <thead>\n",
                             "    <tr style=\"text-align: right;\">\n",
                             "      <th></th>\n",
                             "      <th>Value</th>\n",
-                            "      <th>Std err</th>\n",
-                            "      <th>t-test</th>\n",
-                            "      <th>p-value</th>\n",
                             "      <th>Rob. Std err</th>\n",
                             "      <th>Rob. t-test</th>\n",
                             "      <th>Rob. p-value</th>\n",
-                            "      <th>Bootstrap[10] Std err</th>\n",
-                            "      <th>Bootstrap t-test</th>\n",
-                            "      <th>Bootstrap p-value</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>beta1</th>\n",
                             "      <td>-1.273264</td>\n",
-                            "      <td>0.115144</td>\n",
-                            "      <td>-11.057995</td>\n",
-                            "      <td>0.0</td>\n",
                             "      <td>0.013724</td>\n",
-                            "      <td>-92.777227</td>\n",
-                            "      <td>0.0</td>\n",
-                            "      <td>0.012541</td>\n",
-                            "      <td>-101.526827</td>\n",
+                            "      <td>-92.776307</td>\n",
                             "      <td>0.0</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>beta2</th>\n",
-                            "      <td>1.248769</td>\n",
-                            "      <td>0.084830</td>\n",
-                            "      <td>14.720837</td>\n",
-                            "      <td>0.0</td>\n",
+                            "      <td>1.248770</td>\n",
                             "      <td>0.059086</td>\n",
-                            "      <td>21.134798</td>\n",
-                            "      <td>0.0</td>\n",
-                            "      <td>0.054043</td>\n",
-                            "      <td>23.106935</td>\n",
+                            "      <td>21.134842</td>\n",
                             "      <td>0.0</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "          Value   Std err     t-test  p-value  Rob. Std err  Rob. t-test  \\\n",
-                            "beta1 -1.273264  0.115144 -11.057995      0.0      0.013724   -92.777227   \n",
-                            "beta2  1.248769  0.084830  14.720837      0.0      0.059086    21.134798   \n",
-                            "\n",
-                            "       Rob. p-value  Bootstrap[10] Std err  Bootstrap t-test  \\\n",
-                            "beta1           0.0               0.012541       -101.526827   \n",
-                            "beta2           0.0               0.054043         23.106935   \n",
-                            "\n",
-                            "       Bootstrap p-value  \n",
-                            "beta1                0.0  \n",
-                            "beta2                0.0  "
+                            "          Value  Rob. Std err  Rob. t-test  Rob. p-value\n",
+                            "beta1 -1.273264      0.013724   -92.776307           0.0\n",
+                            "beta2  1.248770      0.059086    21.134842           0.0"
                         ]
                     },
                     "execution_count": 14,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -665,38 +669,38 @@
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>beta2-beta1</th>\n",
                             "      <td>0.001671</td>\n",
                             "      <td>0.171121</td>\n",
-                            "      <td>19.280038</td>\n",
+                            "      <td>19.28005</td>\n",
                             "      <td>0.0</td>\n",
                             "      <td>0.000811</td>\n",
                             "      <td>1.0</td>\n",
-                            "      <td>55.597868</td>\n",
+                            "      <td>55.598175</td>\n",
                             "      <td>0.0</td>\n",
-                            "      <td>0.000678</td>\n",
-                            "      <td>0.999969</td>\n",
-                            "      <td>60.768382</td>\n",
+                            "      <td>0.001103</td>\n",
+                            "      <td>0.999955</td>\n",
+                            "      <td>47.67909</td>\n",
                             "      <td>0.0</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "             Covariance  Correlation     t-test  p-value  Rob. cov.  \\\n",
-                            "beta2-beta1    0.001671     0.171121  19.280038      0.0   0.000811   \n",
+                            "             Covariance  Correlation    t-test  p-value  Rob. cov.  \\\n",
+                            "beta2-beta1    0.001671     0.171121  19.28005      0.0   0.000811   \n",
                             "\n",
                             "             Rob. corr.  Rob. t-test  Rob. p-value  Boot. cov.  Boot. corr.  \\\n",
-                            "beta2-beta1         1.0    55.597868           0.0    0.000678     0.999969   \n",
+                            "beta2-beta1         1.0    55.598175           0.0    0.001103     0.999955   \n",
                             "\n",
                             "             Boot. t-test  Boot. p-value  \n",
-                            "beta2-beta1     60.768382            0.0  "
+                            "beta2-beta1      47.67909            0.0  "
                         ]
                     },
                     "execution_count": 15,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -715,15 +719,15 @@
             "cell_type": "code",
             "execution_count": 16,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "{'beta1': -1.2732636016571277, 'beta2': 1.2487688778887986}"
+                            "{'beta1': -1.2732640875536856, 'beta2': 1.248769699775698}"
                         ]
                     },
                     "execution_count": 16,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -735,15 +739,15 @@
             "cell_type": "code",
             "execution_count": 17,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "{'beta2': 1.2487688778887986}"
+                            "{'beta2': 1.248769699775698}"
                         ]
                     },
                     "execution_count": 17,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -921,30 +925,30 @@
                             "      <th>beta1</th>\n",
                             "      <th>beta2</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>beta1</th>\n",
-                            "      <td>0.000157</td>\n",
-                            "      <td>0.000678</td>\n",
+                            "      <td>0.000256</td>\n",
+                            "      <td>0.001103</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>beta2</th>\n",
-                            "      <td>0.000678</td>\n",
-                            "      <td>0.002921</td>\n",
+                            "      <td>0.001103</td>\n",
+                            "      <td>0.004748</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
                             "          beta1     beta2\n",
-                            "beta1  0.000157  0.000678\n",
-                            "beta2  0.000678  0.002921"
+                            "beta1  0.000256  0.001103\n",
+                            "beta2  0.001103  0.004748"
                         ]
                     },
                     "execution_count": 20,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -963,24 +967,24 @@
             "cell_type": "code",
             "execution_count": 21,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "[{'beta1': -1.277712611634195, 'beta2': 1.2295568140732054},\n",
-                            " {'beta1': -1.277712611634195, 'beta2': 1.2295568140732054},\n",
-                            " {'beta1': -1.2538348107689954, 'beta2': 1.3316123801282882},\n",
-                            " {'beta1': -1.2823937362828728, 'beta2': 1.2091956038603253},\n",
-                            " {'beta1': -1.2573978799535253, 'beta2': 1.3165120810084867},\n",
-                            " {'beta1': -1.2649797742016953, 'beta2': 1.2842631765105148},\n",
-                            " {'beta1': -1.2925578214634943, 'beta2': 1.164322217511046},\n",
-                            " {'beta1': -1.2732636016571277, 'beta2': 1.2487688778887986},\n",
-                            " {'beta1': -1.2611085813021108, 'beta2': 1.300751700209863},\n",
-                            " {'beta1': -1.2823937362828728, 'beta2': 1.2091956038603253}]"
+                            "[{'beta1': -1.2925578214672562, 'beta2': 1.1643222175105554},\n",
+                            " {'beta1': -1.2471072737744642, 'beta2': 1.3600596419340159},\n",
+                            " {'beta1': -1.2777126116343736, 'beta2': 1.229556814073922},\n",
+                            " {'beta1': -1.2732640875536856, 'beta2': 1.248769699775698},\n",
+                            " {'beta1': -1.2690260405244063, 'beta2': 1.2669668838387975},\n",
+                            " {'beta1': -1.2471072737744642, 'beta2': 1.3600596419340159},\n",
+                            " {'beta1': -1.2732640875536856, 'beta2': 1.248769699775698},\n",
+                            " {'beta1': -1.257397879949385, 'beta2': 1.3165120809947877},\n",
+                            " {'beta1': -1.2925578214672562, 'beta2': 1.1643222175105554},\n",
+                            " {'beta1': -1.2690260405244063, 'beta2': 1.2669668838387977}]"
                         ]
                     },
                     "execution_count": 21,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -1000,15 +1004,15 @@
             "cell_type": "code",
             "execution_count": 22,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'                                                                  simpleExample\\nFrom biogeme 3.2.7                                      2021-07-19 11:11:13  \\nEND\\n   0      beta1 F  -1.273263601657e+00 +1.372388079639e-02\\n   0      beta2 F  +1.248768877889e+00 +5.908591637054e-02\\n  -1\\n       5                  0                   0 -6.706549047947e+01\\n   0   0  2021-07-19 11:11:13\\n  99999\\n'"
+                            "'                                                                  simpleExample\\nFrom biogeme 3.2.9b                                     2022-06-29 19:08:28  \\nEND\\n   0      beta1 F  -1.273264087554e+00 +1.372402216626e-02\\n   0      beta2 F  +1.248769699776e+00 +5.908583062960e-02\\n  -1\\n       5                  0                   0 -6.706549047952e+01\\n   0   0  2022-06-29 19:08:28\\n  99999\\n'"
                         ]
                     },
                     "execution_count": 22,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -1023,53 +1027,246 @@
                 "# Miscellaneous functions"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Calculation of the $p$-value"
+                "## Likelihood ratio test"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "Let's first estimate a constrained model"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 23,
             "metadata": {},
             "outputs": [
                 {
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "Results for model simpleExampleConstrained\n",
+                        "Nbr of parameters:\t\t1\n",
+                        "Sample size:\t\t\t5\n",
+                        "Excluded data:\t\t\t0\n",
+                        "Final log likelihood:\t\t-114.7702\n",
+                        "Akaike Information Criterion:\t231.5403\n",
+                        "Bayesian Information Criterion:\t231.1498\n",
+                        "\n"
+                    ]
+                }
+            ],
+            "source": [
+                "beta2_constrained = Beta('beta2_constrained', 2.0, -3, 10, 1)\n",
+                "likelihood_constrained = -beta1**2 * Variable1 - exp(beta2_constrained * beta1) * \\\n",
+                "    Variable2 - beta2_constrained**4\n",
+                "myBiogemeConstrained = bio.BIOGEME(myData, likelihood_constrained)\n",
+                "myBiogemeConstrained.modelName = 'simpleExampleConstrained'\n",
+                "results_constrained = myBiogemeConstrained.estimate()\n",
+                "print(results_constrained.shortSummary())"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "We can now perform a likelihood ratio test."
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 24,
+            "metadata": {},
+            "outputs": [
+                {
+                    "data": {
+                        "text/plain": [
+                            "LRTuple(message='H0 can be rejected at level 0.95', statistic=95.4093641320429, threshold=3.841458820694124)"
+                        ]
+                    },
+                    "execution_count": 24,
+                    "metadata": {},
+                    "output_type": "execute_result"
+                }
+            ],
+            "source": [
+                "results.likelihood_ratio_test(results_constrained, 0.95)"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "## Calculation of the $p$-value"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 25,
+            "metadata": {},
+            "outputs": [
+                {
                     "data": {
                         "text/plain": [
                             "0.04999579029644097"
                         ]
                     },
-                    "execution_count": 23,
+                    "execution_count": 25,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "res.calcPValue(1.96)"
             ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "# Compilation of results"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 26,
+            "metadata": {},
+            "outputs": [],
+            "source": [
+                "dict_of_results = {'Model A': readResults, 'Model B': the_pickle_file}"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 27,
+            "metadata": {},
+            "outputs": [],
+            "source": [
+                "df = res.compileEstimationResults(dict_of_results)"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 28,
+            "metadata": {},
+            "outputs": [
+                {
+                    "data": {
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Model A</th>\n",
+                            "      <th>Model B</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>Number of estimated parameters</th>\n",
+                            "      <td>2.000000</td>\n",
+                            "      <td>2.000000</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>Sample size</th>\n",
+                            "      <td>5.000000</td>\n",
+                            "      <td>5.000000</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>Final log likelihood</th>\n",
+                            "      <td>-67.065490</td>\n",
+                            "      <td>-67.065490</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>Akaike Information Criterion</th>\n",
+                            "      <td>138.130981</td>\n",
+                            "      <td>138.130981</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>Bayesian Information Criterion</th>\n",
+                            "      <td>137.349857</td>\n",
+                            "      <td>137.349857</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>-1.273264</td>\n",
+                            "      <td>-1.273264</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>1.248770</td>\n",
+                            "      <td>1.248770</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "                                   Model A     Model B\n",
+                            "Number of estimated parameters    2.000000    2.000000\n",
+                            "Sample size                       5.000000    5.000000\n",
+                            "Final log likelihood            -67.065490  -67.065490\n",
+                            "Akaike Information Criterion    138.130981  138.130981\n",
+                            "Bayesian Information Criterion  137.349857  137.349857\n",
+                            "beta1                            -1.273264   -1.273264\n",
+                            "beta2                             1.248770    1.248770"
+                        ]
+                    },
+                    "execution_count": 28,
+                    "metadata": {},
+                    "output_type": "execute_result"
+                }
+            ],
+            "source": [
+                "df"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": null,
+            "metadata": {},
+            "outputs": [],
+            "source": []
         }
     ],
     "metadata": {
         "kernelspec": {
-            "display_name": "Python 3",
+            "display_name": "Python 3 (ipykernel)",
             "language": "python",
             "name": "python3"
         },
         "language_info": {
             "codemirror_mode": {
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.9.5"
+            "version": "3.10.0"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 2
 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/.ipynb_checkpoints/biogeme.version-checkpoint.ipynb` & `biogeme-3.2.9/examples/notebooks/biogeme.version.ipynb`

 * *Files 6% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9943030753968254%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2021-10-26 16:04:37.689380\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9a [2021-10-26]\\n')], delete: [0]}}}}, 6: "*

 * *            '{\'outputs\': {0: {\'data\': {\'text/plain\': ["\'3.2.9a\'"]}}}}, 8: {\'outputs\': '*

 * *            "{0: {'text': {insert: [(0, 'biogeme 3.2.9a [2021-10-26]\\n')], delete: [0]}}}}, 10: "*

 * *            "{'outputs': {0: {'text': {insert: [(0, '<p>biogeme 3.2.9a [2021-10-26]</p>\\n')], "*

 * *            "delete: [0 […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 11:11:42.295725\n"
+                        "2021-10-26 16:04:37.689380\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9a [2021-10-26]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -73,15 +73,15 @@
             "cell_type": "code",
             "execution_count": 3,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'3.2.7'"
+                            "'3.2.9a'"
                         ]
                     },
                     "execution_count": 3,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -101,15 +101,15 @@
             "execution_count": 4,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9a [2021-10-26]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -130,15 +130,15 @@
             "execution_count": 5,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "<p>biogeme 3.2.7 [2021-07-19]</p>\n",
+                        "<p>biogeme 3.2.9a [2021-10-26]</p>\n",
                         "<p><a href=\"https://www.python.org/\" target=\"_blank\">Python</a> package</p>\n",
                         "<p>Home page: <a href=\"http://biogeme.epfl.ch\" target=\"_blank\">http://biogeme.epfl.ch</a></p>\n",
                         "<p>Submit questions to <a href=\"https://groups.google.com/d/forum/biogeme\" target=\"_blank\">https://groups.google.com/d/forum/biogeme</a></p>\n",
                         "<p><a href=\"http://people.epfl.ch/michel.bierlaire\">Michel Bierlaire</a>, <a href=\"http://transp-or.epfl.ch\">Transport and Mobility Laboratory</a>, <a href=\"http://www.epfl.ch\">Ecole Polytechnique F&#233;d&#233;rale de Lausanne (EPFL)</a></p>\n",
                         "\n"
                     ]
                 }
@@ -159,15 +159,15 @@
             "execution_count": 6,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "%% biogeme 3.2.7 [2021-07-19]\n",
+                        "%% biogeme 3.2.9a [2021-10-26]\n",
                         "%% Version entirely written in Python\n",
                         "%% Home page: http://biogeme.epfl.ch\n",
                         "%% Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "%% Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -188,26 +188,26 @@
             "execution_count": 7,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "3.2.7\n"
+                        "3.2.9a\n"
                     ]
                 }
             ],
             "source": [
                 "print(ver.__version__)"
             ]
         }
     ],
     "metadata": {
         "kernelspec": {
-            "display_name": "Python 3",
+            "display_name": "Python 3 (ipykernel)",
             "language": "python",
             "name": "python3"
         },
         "language_info": {
             "codemirror_mode": {
                 "name": "ipython",
                 "version": 3
```

### Comparing `biogeme-3.2.8/examples/notebooks/FirstModelWithPandasBiogeme.ipynb` & `biogeme-3.2.9/examples/notebooks/FirstModelWithPandasBiogeme.ipynb`

 * *Files 0% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9999723086349924%*

 * *Differences: {"'cells'": '{3: {\'outputs\': {0: {\'data\': {\'text/plain\': ["\'3.2.9a\'"]}}}}, 33: '*

 * *            "{'outputs': {0: {'text': {insert: [(2, 'Output file "*

 * *            "(HTML):\\t\\t\\t01logit.html\\n')], delete: [2]}}}}}"}*

```diff
@@ -32,15 +32,15 @@
             "cell_type": "code",
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'3.2.7'"
+                            "'3.2.9a'"
                         ]
                     },
                     "execution_count": 2,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -1106,15 +1106,15 @@
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "\n",
                         "Results for model 01logit\n",
-                        "Output file (HTML):\t\t\t01logit~00.html\n",
+                        "Output file (HTML):\t\t\t01logit.html\n",
                         "Nbr of parameters:\t\t4\n",
                         "Sample size:\t\t\t6768\n",
                         "Excluded data:\t\t\t3960\n",
                         "Init log likelihood:\t\t-6964.663\n",
                         "Final log likelihood:\t\t-5331.252\n",
                         "Likelihood ratio test (init):\t\t3266.822\n",
                         "Rho square (init):\t\t\t0.235\n",
```

### Comparing `biogeme-3.2.8/examples/notebooks/Hamabs.ipynb` & `biogeme-3.2.9/examples/notebooks/Hamabs.ipynb`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/notebooks/My first model.ipynb` & `biogeme-3.2.9/examples/notebooks/My first model.ipynb`

 * *Files 0% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9999723086349924%*

 * *Differences: {"'cells'": '{3: {\'outputs\': {0: {\'data\': {\'text/plain\': ["\'3.2.8\'"]}}}}, 33: '*

 * *            "{'outputs': {0: {'text': {insert: [(2, 'Output file "*

 * *            "(HTML):\\t\\t\\t01logit~00.html\\n')], delete: [2]}}}}}"}*

```diff
@@ -32,15 +32,15 @@
             "cell_type": "code",
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'3.2.7'"
+                            "'3.2.8'"
                         ]
                     },
                     "execution_count": 2,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -1108,15 +1108,15 @@
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "\n",
                         "Results for model 01logit\n",
-                        "Output file (HTML):\t\t\t01logit~01.html\n",
+                        "Output file (HTML):\t\t\t01logit~00.html\n",
                         "Nbr of parameters:\t\t4\n",
                         "Sample size:\t\t\t6768\n",
                         "Excluded data:\t\t\t3960\n",
                         "Init log likelihood:\t\t-5331.252\n",
                         "Final log likelihood:\t\t-5331.252\n",
                         "Likelihood ratio test (init):\t\t-0\n",
                         "Rho square (init):\t\t\t0\n",
```

### Comparing `biogeme-3.2.8/examples/notebooks/biogeme.algorithms.ipynb` & `biogeme-3.2.9/examples/notebooks/biogeme.algorithms.ipynb`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9999627976190476%*

 * *Differences: {"'cells'": "{4: {'outputs': {0: {'text': ['2021-10-26 15:15:24.503452\\n']}}}, 5: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9a [2021-10-26]\\n')], delete: [0]}}}}}"}*

```diff
@@ -33,15 +33,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 11:08:54.689460\n"
+                        "2021-10-26 15:15:24.503452\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -51,15 +51,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9a [2021-10-26]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/biogeme.biogeme.ipynb` & `biogeme-3.2.9/examples/notebooks/biogeme.optimization.ipynb`

 * *Files 19% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9579314709948255%*

 * *Differences: {"'cells'": "{0: {'source': ['# Module biogeme.optimization ']}, 2: {'source': ['This webpage is "*

 * *            'for programmers who need examples of use of the functions of the class. The examples '*

 * *            'are designed to illustrate the syntax. They do not correspond to any meaningful '*

 * *            "model. For examples of models, visit  [biogeme.epfl.ch](http://biogeme.epfl.ch).']}, "*

 * *            "3: {'outputs': {0: {'text': ['2021-10-26 16:03:50.675276\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'tex […]*

```diff
@@ -1,40 +1,40 @@
 {
     "cells": [
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "# Module biogeme.biogeme "
+                "# Module biogeme.optimization "
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## Examples of use of each function"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "This webpage is for programmers who need examples of use of the functions of the module. The examples are designed to illustrate the syntax. They do not correspond to any meaningful model. For examples of models, visit  [biogeme.epfl.ch](http://biogeme.epfl.ch)."
+                "This webpage is for programmers who need examples of use of the functions of the class. The examples are designed to illustrate the syntax. They do not correspond to any meaningful model. For examples of models, visit  [biogeme.epfl.ch](http://biogeme.epfl.ch)."
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:40:30.882517\n"
+                        "2021-10-26 16:03:50.675276\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9a [2021-10-26]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -64,268 +64,293 @@
         },
         {
             "cell_type": "code",
             "execution_count": 3,
             "metadata": {},
             "outputs": [],
             "source": [
-                "import biogeme.biogeme as bio\n",
-                "import biogeme.database as db\n",
-                "import pandas as pd\n",
                 "import numpy as np\n",
-                "from biogeme.expressions import Beta, Variable, exp"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Define the verbosity of Biogeme"
+                "import pandas as pd"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 4,
             "metadata": {},
             "outputs": [],
             "source": [
-                "import biogeme.messaging as msg\n",
-                "logger = msg.bioMessage()\n",
-                "logger.setDetailed()"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "##  Definition of a database"
+                "%matplotlib inline\n",
+                "import matplotlib\n",
+                "import matplotlib.pyplot as plt"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 5,
             "metadata": {},
             "outputs": [],
             "source": [
-                "df = pd.DataFrame({'Person':[1,1,1,2,2],\n",
-                "                   'Exclude':[0,0,1,0,1],\n",
-                "                   'Variable1':[1,2,3,4,5],\n",
-                "                   'Variable2':[10,20,30,40,50],\n",
-                "                   'Choice':[1,2,3,1,2],\n",
-                "                   'Av1':[0,1,1,1,1],\n",
-                "                   'Av2':[1,1,1,1,1],\n",
-                "                   'Av3':[0,1,1,1,1]})\n",
-                "myData = db.Database('test', df)"
+                "import biogeme.optimization as opt\n",
+                "import biogeme.biogeme as bio\n",
+                "import biogeme.database as db\n",
+                "import biogeme.models as models\n",
+                "from biogeme.expressions import Beta, Variable\n"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "## Definition of various expressions"
+                "Define the verbosity of Biogeme"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 6,
             "metadata": {},
             "outputs": [],
             "source": [
-                "Variable1=Variable('Variable1')\n",
-                "Variable2=Variable('Variable2')\n",
-                "beta1 = Beta('beta1', -1.0, -3, 3, 0)\n",
-                "beta2 = Beta('beta2', 2.0, -3, 10, 0)\n",
-                "likelihood = -beta1**2 * Variable1 - exp(beta2 * beta1) \\\n",
-                "    * Variable2 - beta2**4\n",
-                "simul = beta1 / Variable1 + beta2 / Variable2\n",
-                "dictOfExpressions = {'loglike': likelihood, \n",
-                "                     'beta1': beta1,\n",
-                "                     'simul': simul}"
+                "import biogeme.messaging as msg\n",
+                "logger = msg.bioMessage()\n",
+                "logger.setSilent()\n",
+                "#logger.setDetailed()\n",
+                "#logger.setDebug()"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "## Creation of the BIOGEME object"
+                "# Biogeme example"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 7,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < General >   Remove 6 unused variables from the database as only 2 are used.\n",
-                        "[10:40:31] < Detailed >  It is suggested to scale the following variables.\n",
-                        "[10:40:31] < Detailed >  Multiply Variable2 by\t0.01 because the largest (abs) value is\t50\n",
-                        "[10:40:31] < Detailed >  To remove this feature, set the parameter suggestScales to False when creating the BIOGEME object.\n",
-                        "simpleExample: database [test]{'loglike': ((((-(beta1(-1.0) ** `2`)) * Variable1) - (exp((beta2(2.0) * beta1(-1.0))) * Variable2)) - (beta2(2.0) ** `4`)), 'beta1': beta1(-1.0), 'simul': ((beta1(-1.0) / Variable1) + (beta2(2.0) / Variable2))}\n",
-                        "simpleExample: database [test]{'loglike': ((((-(beta1(-1.0) ** `2`)) * Variable1) - (exp((beta2(2.0) * beta1(-1.0))) * Variable2)) - (beta2(2.0) ** `4`)), 'beta1': beta1(-1.0), 'simul': ((beta1(-1.0) / Variable1) + (beta2(2.0) / Variable2))}\n"
+                        "simpleExample: database [test]{'loglike': _bioLogLogitFullChoiceSet(1:(beta1(0) * Variable1), 2:(beta2(0) * Variable2), 3:`0`)}\n",
+                        "simpleExample: database [test]{'loglike': _bioLogLogitFullChoiceSet(1:(beta1(0) * Variable1), 2:(beta2(0) * Variable2), 3:`0`)}\n"
                     ]
                 }
             ],
             "source": [
-                "myBiogeme = bio.BIOGEME(myData, dictOfExpressions)\n",
+                "df = pd.DataFrame({'Person': [1, 1, 1, 2, 2],\n",
+                "                   'Exclude': [0, 0, 1, 0, 1],\n",
+                "                   'Variable1': [1, 2, 3, 4, 5],\n",
+                "                   'Variable2': [10, 20, 30,40, 50],\n",
+                "                   'Choice': [1, 2, 3, 1, 2],\n",
+                "                   'Av1': [0, 1, 1, 1, 1],\n",
+                "                   'Av2': [1, 1, 1, 1, 1],\n",
+                "                   'Av3': [0, 1, 1, 1, 1]})\n",
+                "myData = db.Database('test', df)\n",
+                "\n",
+                "Choice = Variable('Choice')\n",
+                "Variable1 = Variable('Variable1')\n",
+                "Variable2 = Variable('Variable2')\n",
+                "beta1 = Beta('beta1', 0, None, None, 0)\n",
+                "beta2 = Beta('beta2', 0, None, None, 0)\n",
+                "V1 = beta1 * Variable1\n",
+                "V2 = beta2 * Variable2\n",
+                "V3 = 0\n",
+                "V ={1: V1,2: V2,3: V3}\n",
+                "\n",
+                "likelihood = models.loglogit(V, av=None, i=Choice)\n",
+                "myBiogeme = bio.BIOGEME(myData, likelihood)\n",
                 "myBiogeme.modelName = 'simpleExample'\n",
+                "myBiogeme.saveIterations = False\n",
+                "myBiogeme.generateHtml = False\n",
+                "myBiogeme.generatePickle = False\n",
                 "print(myBiogeme)"
             ]
         },
         {
-            "cell_type": "markdown",
+            "cell_type": "code",
+            "execution_count": 8,
             "metadata": {},
+            "outputs": [],
             "source": [
-                "Note that, by default, Biogeme removes the unused variables from the database to optimize space."
+                "f, g, h, gdiff, hdiff = myBiogeme.checkDerivatives(verbose=True)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 8,
+            "execution_count": 9,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "Index(['Person', 'Exclude', 'Variable1', 'Variable2', 'Choice', 'Av1', 'Av2',\n",
-                            "       'Av3'],\n",
-                            "      dtype='object')"
+                            "array([6.03961326e-07, 6.11038797e-05])"
                         ]
                     },
-                    "execution_count": 8,
+                    "execution_count": 9,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myBiogeme.database.data.columns"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## calculateInitLikelihood"
+                "gdiff"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 9,
+            "execution_count": 10,
             "metadata": {},
             "outputs": [
                 {
-                    "name": "stdout",
-                    "output_type": "stream",
-                    "text": [
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -115.3003\n"
-                    ]
-                },
-                {
                     "data": {
                         "text/plain": [
-                            "-115.30029248549191"
+                            "array([[ 8.31415072e-07, -4.16670705e-05],\n",
+                            "       [-4.27475899e-06,  8.33270355e-04]])"
                         ]
                     },
-                    "execution_count": 9,
+                    "execution_count": 10,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myBiogeme.calculateInitLikelihood()"
+                "hdiff"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "## calculateLikelihood"
+                "## scipy"
             ]
         },
         {
-            "cell_type": "code",
-            "execution_count": 10,
+            "cell_type": "markdown",
             "metadata": {},
-            "outputs": [
-                {
-                    "name": "stdout",
-                    "output_type": "stream",
-                    "text": [
-                        "[0.0, 3.0]\n"
-                    ]
-                }
-            ],
             "source": [
-                "x = myBiogeme.betaInitValues\n",
-                "xplus = [v + 1 for v in x]\n",
-                "print(xplus)"
+                "This is the optimization algorithm from scipy. It is possible to transfer parameters to the algorithm. We include here an irrelevant parameter to illustrate the warning. "
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 11,
             "metadata": {},
             "outputs": [
                 {
-                    "name": "stdout",
+                    "name": "stderr",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):       -555\n"
+                        "/Users/michelbierlaire/opt/anaconda3/envs/python39/lib/python3.9/site-packages/biogeme-3.2.9a0-py3.9-macosx-10.9-x86_64.egg/biogeme/optimization.py:74: OptimizeWarning: Unknown solver options: myparam\n",
+                        "  results = sc.minimize(\n"
                     ]
                 },
                 {
                     "data": {
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.144546</td>\n",
+                            "      <td>0.391017</td>\n",
+                            "      <td>0.369666</td>\n",
+                            "      <td>0.711632</td>\n",
+                            "      <td>0.366198</td>\n",
+                            "      <td>0.394720</td>\n",
+                            "      <td>0.693049</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.023502</td>\n",
+                            "      <td>0.036947</td>\n",
+                            "      <td>0.636086</td>\n",
+                            "      <td>0.524720</td>\n",
+                            "      <td>0.034280</td>\n",
+                            "      <td>0.685574</td>\n",
+                            "      <td>0.492982</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
                         "text/plain": [
-                            "-111.0"
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144546  0.391017  0.369666  0.711632      0.366198     0.394720   \n",
+                            "beta2  0.023502  0.036947  0.636086  0.524720      0.034280     0.685574   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693049  \n",
+                            "beta2      0.492982  "
                         ]
                     },
                     "execution_count": 11,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myBiogeme.calculateLikelihood(xplus, scaled=True)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "It is possible to calculate the likelihood based only on a sample of the data"
+                "results = myBiogeme.estimate(algorithm=opt.scipy, \n",
+                "                             algoParameters={'myparam':3})\n",
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 12,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < Detailed >  Use 50.0% of the data.\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 2):       -555\n"
+                        "Algorithm:\tscipy.optimize\n",
+                        "Cause of termination:\tCONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL\n",
+                        "Number of iterations:\t13\n",
+                        "Number of function evaluations:\t16\n",
+                        "Optimization time:\t0:00:00.005071\n"
                     ]
-                },
-                {
-                    "data": {
-                        "text/plain": [
-                            "-277.5"
-                        ]
-                    },
-                    "execution_count": 12,
-                    "metadata": {},
-                    "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myBiogeme.calculateLikelihood(xplus, scaled=True, batch=0.5)"
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "## Newton with linesearch"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 13,
             "metadata": {},
             "outputs": [
@@ -346,92 +371,98 @@
                             "        text-align: right;\n",
                             "    }\n",
                             "</style>\n",
                             "<table border=\"1\" class=\"dataframe\">\n",
                             "  <thead>\n",
                             "    <tr style=\"text-align: right;\">\n",
                             "      <th></th>\n",
-                            "      <th>Person</th>\n",
-                            "      <th>Exclude</th>\n",
-                            "      <th>Variable1</th>\n",
-                            "      <th>Variable2</th>\n",
-                            "      <th>Choice</th>\n",
-                            "      <th>Av1</th>\n",
-                            "      <th>Av2</th>\n",
-                            "      <th>Av3</th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
-                            "      <th>2</th>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>3</td>\n",
-                            "      <td>30</td>\n",
-                            "      <td>3</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>4</th>\n",
-                            "      <td>2</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>5</td>\n",
-                            "      <td>50</td>\n",
-                            "      <td>2</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.144545</td>\n",
+                            "      <td>0.391017</td>\n",
+                            "      <td>0.369665</td>\n",
+                            "      <td>0.711632</td>\n",
+                            "      <td>0.366198</td>\n",
+                            "      <td>0.394720</td>\n",
+                            "      <td>0.693050</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.023502</td>\n",
+                            "      <td>0.036947</td>\n",
+                            "      <td>0.636086</td>\n",
+                            "      <td>0.524720</td>\n",
+                            "      <td>0.034280</td>\n",
+                            "      <td>0.685573</td>\n",
+                            "      <td>0.492982</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3\n",
-                            "2       1        1          3         30       3    1    1    1\n",
-                            "4       2        1          5         50       2    1    1    1"
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144545  0.391017  0.369665  0.711632      0.366198     0.394720   \n",
+                            "beta2  0.023502  0.036947  0.636086  0.524720      0.034280     0.685573   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693050  \n",
+                            "beta2      0.492982  "
                         ]
                     },
                     "execution_count": 13,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myBiogeme.database.data"
+                "results = myBiogeme.estimate(algorithm=opt.newtonLineSearchForBiogeme)\n",
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 14,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < Detailed >  Use 60.0% of the data.\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 3):       -555\n"
+                        "Algorithm:\tUnconstrained Newton with line search\n",
+                        "Relative gradient:\t3.43067908440321e-07\n",
+                        "Number of iterations:\t3\n",
+                        "Number of function evaluations:\t10\n",
+                        "Number of gradient evaluations:\t10\n",
+                        "Number of hessian evaluations:\t4\n",
+                        "Cause of termination:\tRelative gradient = 3.4e-07 <= 6.1e-06\n",
+                        "Optimization time:\t0:00:00.003244\n"
                     ]
-                },
-                {
-                    "data": {
-                        "text/plain": [
-                            "-185.0"
-                        ]
-                    },
-                    "execution_count": 14,
-                    "metadata": {},
-                    "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myBiogeme.calculateLikelihood(xplus, scaled=True, batch=0.6)"
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "Changing the requested precision\n"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 15,
             "metadata": {},
             "outputs": [
@@ -452,112 +483,100 @@
                             "        text-align: right;\n",
                             "    }\n",
                             "</style>\n",
                             "<table border=\"1\" class=\"dataframe\">\n",
                             "  <thead>\n",
                             "    <tr style=\"text-align: right;\">\n",
                             "      <th></th>\n",
-                            "      <th>Person</th>\n",
-                            "      <th>Exclude</th>\n",
-                            "      <th>Variable1</th>\n",
-                            "      <th>Variable2</th>\n",
-                            "      <th>Choice</th>\n",
-                            "      <th>Av1</th>\n",
-                            "      <th>Av2</th>\n",
-                            "      <th>Av3</th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
-                            "      <th>0</th>\n",
-                            "      <td>1</td>\n",
-                            "      <td>0</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>10</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>0</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>0</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>3</th>\n",
-                            "      <td>2</td>\n",
-                            "      <td>0</td>\n",
-                            "      <td>4</td>\n",
-                            "      <td>40</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>2</th>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>3</td>\n",
-                            "      <td>30</td>\n",
-                            "      <td>3</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.144317</td>\n",
+                            "      <td>0.390742</td>\n",
+                            "      <td>0.369340</td>\n",
+                            "      <td>0.711874</td>\n",
+                            "      <td>0.365691</td>\n",
+                            "      <td>0.394641</td>\n",
+                            "      <td>0.693108</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.023428</td>\n",
+                            "      <td>0.036930</td>\n",
+                            "      <td>0.634377</td>\n",
+                            "      <td>0.525835</td>\n",
+                            "      <td>0.034256</td>\n",
+                            "      <td>0.683887</td>\n",
+                            "      <td>0.494047</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3\n",
-                            "0       1        0          1         10       1    0    1    0\n",
-                            "3       2        0          4         40       1    1    1    1\n",
-                            "2       1        1          3         30       3    1    1    1"
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144317  0.390742  0.369340  0.711874      0.365691     0.394641   \n",
+                            "beta2  0.023428  0.036930  0.634377  0.525835      0.034256     0.683887   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693108  \n",
+                            "beta2      0.494047  "
                         ]
                     },
                     "execution_count": 15,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myBiogeme.database.data"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "By default, each observation has the same probability to be selected in the sample. It is possible to define the selection probability to be proportional to the values of a column of the database, using the parameter 'weights'. "
+                "results = myBiogeme.\\\n",
+                "estimate(algorithm=opt.newtonLineSearchForBiogeme,\n",
+                "         algoParameters={'tolerance': 0.1})\n",
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 16,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < Detailed >  Use 60.0% of the data.\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 3):       -555\n"
+                        "Algorithm:\tUnconstrained Newton with line search\n",
+                        "Relative gradient:\t0.015380029144206175\n",
+                        "Number of iterations:\t2\n",
+                        "Number of function evaluations:\t7\n",
+                        "Number of gradient evaluations:\t7\n",
+                        "Number of hessian evaluations:\t3\n",
+                        "Cause of termination:\tRelative gradient = 0.015 <= 0.1\n",
+                        "Optimization time:\t0:00:00.001905\n"
                     ]
-                },
-                {
-                    "data": {
-                        "text/plain": [
-                            "-185.0"
-                        ]
-                    },
-                    "execution_count": 16,
-                    "metadata": {},
-                    "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myBiogeme.columnForBatchSamplingWeights = 'Variable2'\n",
-                "myBiogeme.calculateLikelihood(xplus, scaled=True, batch=0.6)"
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "## Newton with trust region"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 17,
             "metadata": {},
             "outputs": [
@@ -578,378 +597,439 @@
                             "        text-align: right;\n",
                             "    }\n",
                             "</style>\n",
                             "<table border=\"1\" class=\"dataframe\">\n",
                             "  <thead>\n",
                             "    <tr style=\"text-align: right;\">\n",
                             "      <th></th>\n",
-                            "      <th>Person</th>\n",
-                            "      <th>Exclude</th>\n",
-                            "      <th>Variable1</th>\n",
-                            "      <th>Variable2</th>\n",
-                            "      <th>Choice</th>\n",
-                            "      <th>Av1</th>\n",
-                            "      <th>Av2</th>\n",
-                            "      <th>Av3</th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
-                            "      <th>4</th>\n",
-                            "      <td>2</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>5</td>\n",
-                            "      <td>50</td>\n",
-                            "      <td>2</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>3</th>\n",
-                            "      <td>2</td>\n",
-                            "      <td>0</td>\n",
-                            "      <td>4</td>\n",
-                            "      <td>40</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>2</th>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>3</td>\n",
-                            "      <td>30</td>\n",
-                            "      <td>3</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
-                            "      <td>1</td>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.144545</td>\n",
+                            "      <td>0.391017</td>\n",
+                            "      <td>0.369665</td>\n",
+                            "      <td>0.711632</td>\n",
+                            "      <td>0.366198</td>\n",
+                            "      <td>0.394720</td>\n",
+                            "      <td>0.693050</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.023502</td>\n",
+                            "      <td>0.036947</td>\n",
+                            "      <td>0.636086</td>\n",
+                            "      <td>0.524720</td>\n",
+                            "      <td>0.034280</td>\n",
+                            "      <td>0.685573</td>\n",
+                            "      <td>0.492982</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3\n",
-                            "4       2        1          5         50       2    1    1    1\n",
-                            "3       2        0          4         40       1    1    1    1\n",
-                            "2       1        1          3         30       3    1    1    1"
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144545  0.391017  0.369665  0.711632      0.366198     0.394720   \n",
+                            "beta2  0.023502  0.036947  0.636086  0.524720      0.034280     0.685573   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693050  \n",
+                            "beta2      0.492982  "
                         ]
                     },
                     "execution_count": 17,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myBiogeme.database.data"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## calculateLikelihoodAndDerivatives"
+                "results = myBiogeme.estimate(algorithm=opt.newtonTrustRegionForBiogeme)\n",
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 18,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
-                        "f = -111.0\n",
-                        "g = [ -90. -108.]\n",
-                        "h = [[-270.  -30.]\n",
-                        " [ -30. -108.]]\n",
-                        "bhhh = [[ 9900.  9720.]\n",
-                        " [ 9720. 11664.]]\n"
+                        "Algorithm:\tUnconstrained Newton with trust region\n",
+                        "Relative gradient:\t3.289367618372832e-07\n",
+                        "Cause of termination:\tRelative gradient = 3.3e-07 <= 6.1e-06\n",
+                        "Number of iterations:\t3\n",
+                        "Number of function evaluations:\t6\n",
+                        "Number of gradient evaluations:\t4\n",
+                        "Number of hessian evaluations:\t4\n",
+                        "Optimization time:\t0:00:00.001830\n"
                     ]
                 }
             ],
             "source": [
-                "f, g, h, bhhh = myBiogeme.\\\n",
-                "    calculateLikelihoodAndDerivatives(xplus,\n",
-                "                                      scaled=True,\n",
-                "                                      hessian=True,\n",
-                "                                      bhhh=True)\n",
-                "print(f'f = {f}')\n",
-                "print(f'g = {g}')\n",
-                "print(f'h = {h}')\n",
-                "print(f'bhhh = {bhhh}')"
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Now the unscaled version"
+                "We illustrate the parameters. We use the truncated conjugate gradient instead of dogleg for the trust region subproblem, starting with a small trust region of radius 0.001, and a maximum of 3 iterations."
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 19,
             "metadata": {},
             "outputs": [
                 {
-                    "name": "stdout",
-                    "output_type": "stream",
-                    "text": [
-                        "[10:40:31] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
-                        "f = -555.0\n",
-                        "g = [-450. -540.]\n",
-                        "h = [[-1350.  -150.]\n",
-                        " [ -150.  -540.]]\n",
-                        "bhhh = [[49500. 48600.]\n",
-                        " [48600. 58320.]]\n"
-                    ]
+                    "data": {
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.000053</td>\n",
+                            "      <td>0.348093</td>\n",
+                            "      <td>0.000151</td>\n",
+                            "      <td>0.99988</td>\n",
+                            "      <td>0.308910</td>\n",
+                            "      <td>0.000170</td>\n",
+                            "      <td>0.999864</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.007000</td>\n",
+                            "      <td>0.032583</td>\n",
+                            "      <td>0.214830</td>\n",
+                            "      <td>0.82990</td>\n",
+                            "      <td>0.030019</td>\n",
+                            "      <td>0.233173</td>\n",
+                            "      <td>0.815627</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "          Value   Std err    t-test  p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.000053  0.348093  0.000151  0.99988      0.308910     0.000170   \n",
+                            "beta2  0.007000  0.032583  0.214830  0.82990      0.030019     0.233173   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.999864  \n",
+                            "beta2      0.815627  "
+                        ]
+                    },
+                    "execution_count": 19,
+                    "metadata": {},
+                    "output_type": "execute_result"
                 }
             ],
             "source": [
-                "f, g, h, bhhh = myBiogeme.\\\n",
-                "    calculateLikelihoodAndDerivatives(xplus,\n",
-                "                                      scaled=False,\n",
-                "                                      hessian=True,\n",
-                "                                      bhhh=True)\n",
-                "print(f'f = {f}')\n",
-                "print(f'g = {g}')\n",
-                "print(f'h = {h}')\n",
-                "print(f'bhhh = {bhhh}')"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Using only a sample of the data"
+                "results = myBiogeme.\\\n",
+                "estimate(algorithm=opt.newtonTrustRegionForBiogeme,\n",
+                "         algoParameters={'dogleg':False,\n",
+                "                         'radius':0.001,\n",
+                "                         'maxiter':3})\n",
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 20,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < Detailed >  Use 50.0% of the data.\n",
-                        "[10:40:31] < General >   Log likelihood (N = 2):       -555 Gradient norm:      7e+02 Hessian norm:       1e+03 BHHH norm:       1e+05\n",
-                        "f = -277.5\n",
-                        "g = [-225. -270.]\n",
-                        "h = [[-675.  -75.]\n",
-                        " [ -75. -270.]]\n",
-                        "bhhh = [[24750. 24300.]\n",
-                        " [24300. 29160.]]\n"
+                        "Algorithm:\tUnconstrained Newton with trust region\n",
+                        "Relative gradient:\t2.0182963630997235\n",
+                        "Cause of termination:\tMaximum number of iterations reached: 3\n",
+                        "Number of iterations:\t3\n",
+                        "Number of function evaluations:\t6\n",
+                        "Number of gradient evaluations:\t4\n",
+                        "Number of hessian evaluations:\t4\n",
+                        "Optimization time:\t0:00:00.002176\n"
                     ]
                 }
             ],
             "source": [
-                "f, g, h, bhhh = myBiogeme.\\\n",
-                "    calculateLikelihoodAndDerivatives(xplus,\n",
-                "                                      scaled=True,\n",
-                "                                      batch=0.5,\n",
-                "                                      hessian=True,\n",
-                "                                      bhhh=True)\n",
-                "print(f'f = {f}')\n",
-                "print(f'g = {g}')\n",
-                "print(f'h = {h}')\n",
-                "print(f'bhhh = {bhhh}')"
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "## likelihoodFiniteDifferenceHessian"
+                "Changing the requested precision\n"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 21,
             "metadata": {},
             "outputs": [
                 {
-                    "name": "stdout",
-                    "output_type": "stream",
-                    "text": [
-                        "[10:40:31] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02  \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):       -555 Gradient norm:      7e+02  \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -555.0002 Gradient norm:      7e+02  \n"
-                    ]
-                },
-                {
                     "data": {
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.144317</td>\n",
+                            "      <td>0.390742</td>\n",
+                            "      <td>0.369340</td>\n",
+                            "      <td>0.711874</td>\n",
+                            "      <td>0.365691</td>\n",
+                            "      <td>0.394641</td>\n",
+                            "      <td>0.693108</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.023428</td>\n",
+                            "      <td>0.036930</td>\n",
+                            "      <td>0.634377</td>\n",
+                            "      <td>0.525835</td>\n",
+                            "      <td>0.034256</td>\n",
+                            "      <td>0.683887</td>\n",
+                            "      <td>0.494047</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
                         "text/plain": [
-                            "array([[-1380.00020229,  -150.        ],\n",
-                            "       [ -150.0000451 ,  -540.00005396]])"
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144317  0.390742  0.369340  0.711874      0.365691     0.394641   \n",
+                            "beta2  0.023428  0.036930  0.634377  0.525835      0.034256     0.683887   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693108  \n",
+                            "beta2      0.494047  "
                         ]
                     },
                     "execution_count": 21,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "myBiogeme.likelihoodFiniteDifferenceHessian(xplus)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## checkDerivatives"
+                "results = myBiogeme.\\\n",
+                "estimate(algorithm=opt.newtonTrustRegionForBiogeme,\n",
+                "         algoParameters={'tolerance':0.1})\n",
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 22,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < Detailed >  x\t\tGradient\tFinDiff\t\tDifference\n",
-                        "[10:40:31] < Detailed >  beta1          \t-1.060058E+01\t-1.060058E+01\t-5.427932E-06\n",
-                        "[10:40:31] < Detailed >  beta2          \t-1.396997E+02\t-1.396997E+02\t+2.608000E-05\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < Detailed >  Row\t\tCol\t\tHessian\tFinDiff\t\tDifference\n",
-                        "[10:40:31] < Detailed >  beta1          \tbeta1          \t-1.112012E+02\t-1.112012E+02\t-8.045522E-06\n",
-                        "[10:40:31] < Detailed >  beta1          \tbeta2          \t+2.030029E+01\t+2.030029E+01\t+7.365980E-09\n",
-                        "[10:40:31] < Detailed >  beta2          \tbeta1          \t+2.030029E+01\t+2.030029E+01\t-1.613879E-07\n",
-                        "[10:40:31] < Detailed >  beta2          \tbeta2          \t-2.603003E+02\t-2.603003E+02\t+2.229281E-05\n"
+                        "Algorithm:\tUnconstrained Newton with trust region\n",
+                        "Relative gradient:\t0.014746524905603029\n",
+                        "Cause of termination:\tRelative gradient = 0.015 <= 0.1\n",
+                        "Number of iterations:\t2\n",
+                        "Number of function evaluations:\t4\n",
+                        "Number of gradient evaluations:\t3\n",
+                        "Number of hessian evaluations:\t3\n",
+                        "Optimization time:\t0:00:00.001590\n"
                     ]
                 }
             ],
             "source": [
-                "f, g, h, gdiff, hdiff = myBiogeme.checkDerivatives(verbose=True)"
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "## BFGS with line search"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 23,
             "metadata": {},
             "outputs": [
                 {
-                    "name": "stdout",
-                    "output_type": "stream",
-                    "text": [
-                        "f = -115.30029248549191\n",
-                        "g = [ -10.60058497 -139.69970751]\n",
-                        "h = [[-111.20116994   20.30029249]\n",
-                        " [  20.30029249 -260.30029249]]\n",
-                        "gdiff = [-5.42793187e-06  2.60800035e-05]\n",
-                        "hdiff = [[-8.04552171e-06  7.36597983e-09]\n",
-                        " [-1.61387920e-07  2.22928137e-05]]\n"
-                    ]
-                },
-                {
                     "data": {
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.144545</td>\n",
+                            "      <td>0.391017</td>\n",
+                            "      <td>0.369665</td>\n",
+                            "      <td>0.711632</td>\n",
+                            "      <td>0.366198</td>\n",
+                            "      <td>0.394720</td>\n",
+                            "      <td>0.693050</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.023502</td>\n",
+                            "      <td>0.036947</td>\n",
+                            "      <td>0.636086</td>\n",
+                            "      <td>0.524720</td>\n",
+                            "      <td>0.034280</td>\n",
+                            "      <td>0.685573</td>\n",
+                            "      <td>0.492982</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
                         "text/plain": [
-                            "array([[-8.04552171e-06,  7.36597983e-09],\n",
-                            "       [-1.61387920e-07,  2.22928137e-05]])"
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144545  0.391017  0.369665  0.711632      0.366198     0.394720   \n",
+                            "beta2  0.023502  0.036947  0.636086  0.524720      0.034280     0.685573   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693050  \n",
+                            "beta2      0.492982  "
                         ]
                     },
                     "execution_count": 23,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "print(f'f = {f}')\n",
-                "print(f'g = {g}')\n",
-                "print(f'h = {h}')\n",
-                "print(f'gdiff = {gdiff}')\n",
-                "print(f'hdiff = {hdiff}')\n",
-                "hdiff"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## estimate"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "During estimation, it is possible to save intermediate results, in case the estimation must be interrupted. "
+                "results = myBiogeme.estimate(algorithm=opt.bfgsLineSearchForBiogeme)\n",
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 24,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:40:31] < General >   *** Initial values of the parameters are obtained from the file __simpleExample.iter\n",
-                        "[10:40:31] < Detailed >  Parameter values restored from __simpleExample.iter\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -115.3003\n",
-                        "[10:40:31] < Detailed >  ** Optimization: Newton with trust region for simple bounds\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -115.3003 Gradient norm:      1e+02 Hessian norm:       3e+02 \n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -69.98205\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -69.98205 Gradient norm:      3e+01 Hessian norm:       2e+02 \n",
-                        "[10:40:31] < Detailed >  1 f=  13.99641 projected rel. grad.=  0.28 rel. change=  0.38 delta=     2 rho=   1.1 ++\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -67.07892\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -67.07892 Gradient norm:          2 Hessian norm:       2e+02 \n",
-                        "[10:40:31] < Detailed >  2 f=  13.41578 projected rel. grad.= 0.021 rel. change=  0.15 delta=     4 rho=     1 ++\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -67.06549\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      0.007 Hessian norm:       2e+02 \n",
-                        "[10:40:31] < Detailed >  3 f=   13.4131 projected rel. grad.=8.1e-05 rel. change= 0.011 delta=     8 rho=     1 ++\n",
-                        "[10:40:31] < Detailed >  Log likelihood (N = 5):  -67.06549\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      1e-07 Hessian norm:       2e+02 \n",
-                        "[10:40:31] < Detailed >  4 f=   13.4131 projected rel. grad.=1.2e-09 rel. change=4.4e-05 delta=    16 rho=     1 ++\n",
-                        "[10:40:31] < Detailed >  Proportion of Hessian calculation: 100.0%\n",
-                        "[10:40:31] < General >   Log likelihood (N = 5):  -67.06549 Gradient norm:      1e-07 Hessian norm:       2e+02 BHHH norm:       7e+01\n",
-                        "[10:40:31] < General >   Re-estimate the model 10 times for bootstrapping\n"
-                    ]
-                },
-                {
-                    "name": "stderr",
-                    "output_type": "stream",
-                    "text": [
-                        "100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00<00:00, 361.05it/s]"
-                    ]
-                },
-                {
-                    "name": "stdout",
-                    "output_type": "stream",
-                    "text": [
-                        "[10:40:32] < General >   Results saved in file simpleExample~08.html\n",
-                        "[10:40:32] < General >   Results saved in file simpleExample~11.pickle\n"
-                    ]
-                },
-                {
-                    "name": "stderr",
-                    "output_type": "stream",
-                    "text": [
-                        "\n"
+                        "Algorithm:\tInverse BFGS with line search\n",
+                        "Relative gradient:\t5.933646980468922e-07\n",
+                        "Cause of termination:\tRelative gradient = 5.9e-07 <= 6.1e-06\n",
+                        "Number of iterations:\t5\n",
+                        "Number of function evaluations:\t28\n",
+                        "Number of gradient evaluations:\t6\n",
+                        "Optimization time:\t0:00:00.003693\n"
                     ]
                 }
             ],
             "source": [
-                "results = myBiogeme.estimate(bootstrap=10)"
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "## BFGS with trust region"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 25,
             "metadata": {},
             "outputs": [
@@ -977,119 +1057,97 @@
                             "      <th>Value</th>\n",
                             "      <th>Std err</th>\n",
                             "      <th>t-test</th>\n",
                             "      <th>p-value</th>\n",
                             "      <th>Rob. Std err</th>\n",
                             "      <th>Rob. t-test</th>\n",
                             "      <th>Rob. p-value</th>\n",
-                            "      <th>Bootstrap[10] Std err</th>\n",
-                            "      <th>Bootstrap t-test</th>\n",
-                            "      <th>Bootstrap p-value</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>beta1</th>\n",
-                            "      <td>-1.273264</td>\n",
-                            "      <td>0.115144</td>\n",
-                            "      <td>-11.057997</td>\n",
-                            "      <td>0.0</td>\n",
-                            "      <td>0.013724</td>\n",
-                            "      <td>-92.776664</td>\n",
-                            "      <td>0.0</td>\n",
-                            "      <td>0.017135</td>\n",
-                            "      <td>-74.307129</td>\n",
-                            "      <td>0.0</td>\n",
+                            "      <td>0.144546</td>\n",
+                            "      <td>0.391018</td>\n",
+                            "      <td>0.369667</td>\n",
+                            "      <td>0.711631</td>\n",
+                            "      <td>0.366198</td>\n",
+                            "      <td>0.394721</td>\n",
+                            "      <td>0.693048</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>beta2</th>\n",
-                            "      <td>1.248769</td>\n",
-                            "      <td>0.084830</td>\n",
-                            "      <td>14.720836</td>\n",
-                            "      <td>0.0</td>\n",
-                            "      <td>0.059086</td>\n",
-                            "      <td>21.134794</td>\n",
-                            "      <td>0.0</td>\n",
-                            "      <td>0.075144</td>\n",
-                            "      <td>16.618264</td>\n",
-                            "      <td>0.0</td>\n",
+                            "      <td>0.023502</td>\n",
+                            "      <td>0.036947</td>\n",
+                            "      <td>0.636087</td>\n",
+                            "      <td>0.524720</td>\n",
+                            "      <td>0.034280</td>\n",
+                            "      <td>0.685574</td>\n",
+                            "      <td>0.492982</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "          Value   Std err     t-test  p-value  Rob. Std err  Rob. t-test  \\\n",
-                            "beta1 -1.273264  0.115144 -11.057997      0.0      0.013724   -92.776664   \n",
-                            "beta2  1.248769  0.084830  14.720836      0.0      0.059086    21.134794   \n",
-                            "\n",
-                            "       Rob. p-value  Bootstrap[10] Std err  Bootstrap t-test  \\\n",
-                            "beta1           0.0               0.017135        -74.307129   \n",
-                            "beta2           0.0               0.075144         16.618264   \n",
-                            "\n",
-                            "       Bootstrap p-value  \n",
-                            "beta1                0.0  \n",
-                            "beta2                0.0  "
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144546  0.391018  0.369667  0.711631      0.366198     0.394721   \n",
+                            "beta2  0.023502  0.036947  0.636087  0.524720      0.034280     0.685574   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693048  \n",
+                            "beta2      0.492982  "
                         ]
                     },
                     "execution_count": 25,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
+                "results = myBiogeme.estimate(algorithm=opt.bfgsTrustRegionForBiogeme)\n",
                 "results.getEstimatedParameters()"
             ]
         },
         {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "The values of the intermediate results saved can be retrieved as follows. "
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Formula before"
-            ]
-        },
-        {
             "cell_type": "code",
             "execution_count": 26,
             "metadata": {},
             "outputs": [
                 {
-                    "data": {
-                        "text/plain": [
-                            "((((-(beta1(-1.0) ** `2`)) * Variable1) - (exp((beta2(2.0000002) * beta1(-1.0))) * Variable2)) - (beta2(2.0000002) ** `4`))"
-                        ]
-                    },
-                    "execution_count": 26,
-                    "metadata": {},
-                    "output_type": "execute_result"
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "Algorithm:\tBFGS with trust region\n",
+                        "Relative gradient:\t5.039394505504404e-07\n",
+                        "Cause of termination:\tRelative gradient = 5e-07 <= 6.1e-06\n",
+                        "Number of iterations:\t14\n",
+                        "Number of function evaluations:\t23\n",
+                        "Number of gradient evaluations:\t9\n",
+                        "Optimization time:\t0:00:00.007478\n"
+                    ]
                 }
             ],
             "source": [
-                "myBiogeme.loglike"
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "## simulate"
+                "## Newton/BFGS with trust region for simple bounds"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Simulate with the default values for the parameters"
+                "This is the default algorithm used by Biogeme. It is the implementation of the algorithm proposed by [Conn et al. (1988)](https://www.ams.org/journals/mcom/1988-50-182/S0025-5718-1988-0929544-3/S0025-5718-1988-0929544-3.pdf)."
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 27,
             "metadata": {},
             "outputs": [
@@ -1110,92 +1168,108 @@
                             "        text-align: right;\n",
                             "    }\n",
                             "</style>\n",
                             "<table border=\"1\" class=\"dataframe\">\n",
                             "  <thead>\n",
                             "    <tr style=\"text-align: right;\">\n",
                             "      <th></th>\n",
-                            "      <th>loglike</th>\n",
-                            "      <th>beta1</th>\n",
-                            "      <th>simul</th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
-                            "      <th>0</th>\n",
-                            "      <td>-25.413417</td>\n",
-                            "      <td>-1.0</td>\n",
-                            "      <td>-0.20</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>1</th>\n",
-                            "      <td>-20.706712</td>\n",
-                            "      <td>-1.0</td>\n",
-                            "      <td>-0.40</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>2</th>\n",
-                            "      <td>-27.766769</td>\n",
-                            "      <td>-1.0</td>\n",
-                            "      <td>-0.16</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>3</th>\n",
-                            "      <td>-27.766769</td>\n",
-                            "      <td>-1.0</td>\n",
-                            "      <td>-0.16</td>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.144545</td>\n",
+                            "      <td>0.391017</td>\n",
+                            "      <td>0.369665</td>\n",
+                            "      <td>0.711632</td>\n",
+                            "      <td>0.366198</td>\n",
+                            "      <td>0.394720</td>\n",
+                            "      <td>0.693050</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
-                            "      <th>4</th>\n",
-                            "      <td>-27.766769</td>\n",
-                            "      <td>-1.0</td>\n",
-                            "      <td>-0.16</td>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.023502</td>\n",
+                            "      <td>0.036947</td>\n",
+                            "      <td>0.636086</td>\n",
+                            "      <td>0.524720</td>\n",
+                            "      <td>0.034280</td>\n",
+                            "      <td>0.685573</td>\n",
+                            "      <td>0.492982</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "     loglike  beta1  simul\n",
-                            "0 -25.413417   -1.0  -0.20\n",
-                            "1 -20.706712   -1.0  -0.40\n",
-                            "2 -27.766769   -1.0  -0.16\n",
-                            "3 -27.766769   -1.0  -0.16\n",
-                            "4 -27.766769   -1.0  -0.16"
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144545  0.391017  0.369665  0.711632      0.366198     0.394720   \n",
+                            "beta2  0.023502  0.036947  0.636086  0.524720      0.034280     0.685573   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693050  \n",
+                            "beta2      0.492982  "
                         ]
                     },
                     "execution_count": 27,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "simulationWithDefaultBetas = myBiogeme.simulate()\n",
-                "simulationWithDefaultBetas"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Simulate with the estimated values for the parameters"
+                "results = myBiogeme.\\\n",
+                "estimate(algorithm=opt.simpleBoundsNewtonAlgorithmForBiogeme)\n",
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 28,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "{'beta1': -1.2732639872136933, 'beta2': 1.2487688099301195}\n"
+                        "Algorithm:\tNewton with trust region for simple bound constraints\n",
+                        "Proportion analytical hessian:\t100.0%\n",
+                        "Relative projected gradient:\t3.2893676168569793e-07\n",
+                        "Relative change:\t0.00022882036808896666\n",
+                        "Number of iterations:\t3\n",
+                        "Number of function evaluations:\t10\n",
+                        "Number of gradient evaluations:\t4\n",
+                        "Number of hessian evaluations:\t4\n",
+                        "Cause of termination:\tRelative gradient = 3.3e-07 <= 6.1e-06\n",
+                        "Optimization time:\t0:00:00.003137\n"
                     ]
-                },
+                }
+            ],
+            "source": [
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "When the second derivatives are too computationally expensive to calculate, it is possible to avoid calculating them at each successful iteration. The parameter 'proportionAnalyticalHessian' allows to control that."
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 29,
+            "metadata": {},
+            "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
                             "    .dataframe tbody tr th:only-of-type {\n",
                             "        vertical-align: middle;\n",
@@ -1209,85 +1283,107 @@
                             "        text-align: right;\n",
                             "    }\n",
                             "</style>\n",
                             "<table border=\"1\" class=\"dataframe\">\n",
                             "  <thead>\n",
                             "    <tr style=\"text-align: right;\">\n",
                             "      <th></th>\n",
-                            "      <th>loglike</th>\n",
-                            "      <th>beta1</th>\n",
-                            "      <th>simul</th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
-                            "      <th>0</th>\n",
-                            "      <td>-17.073530</td>\n",
-                            "      <td>-1.273264</td>\n",
-                            "      <td>-0.287097</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>1</th>\n",
-                            "      <td>-9.752666</td>\n",
-                            "      <td>-1.273264</td>\n",
-                            "      <td>-0.574194</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>2</th>\n",
-                            "      <td>-20.733962</td>\n",
-                            "      <td>-1.273264</td>\n",
-                            "      <td>-0.229677</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>3</th>\n",
-                            "      <td>-20.733962</td>\n",
-                            "      <td>-1.273264</td>\n",
-                            "      <td>-0.229677</td>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.144545</td>\n",
+                            "      <td>0.391017</td>\n",
+                            "      <td>0.369665</td>\n",
+                            "      <td>0.711632</td>\n",
+                            "      <td>0.366198</td>\n",
+                            "      <td>0.394720</td>\n",
+                            "      <td>0.693050</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
-                            "      <th>4</th>\n",
-                            "      <td>-20.733962</td>\n",
-                            "      <td>-1.273264</td>\n",
-                            "      <td>-0.229677</td>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.023502</td>\n",
+                            "      <td>0.036947</td>\n",
+                            "      <td>0.636086</td>\n",
+                            "      <td>0.524721</td>\n",
+                            "      <td>0.034280</td>\n",
+                            "      <td>0.685573</td>\n",
+                            "      <td>0.492982</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "     loglike     beta1     simul\n",
-                            "0 -17.073530 -1.273264 -0.287097\n",
-                            "1  -9.752666 -1.273264 -0.574194\n",
-                            "2 -20.733962 -1.273264 -0.229677\n",
-                            "3 -20.733962 -1.273264 -0.229677\n",
-                            "4 -20.733962 -1.273264 -0.229677"
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144545  0.391017  0.369665  0.711632      0.366198     0.394720   \n",
+                            "beta2  0.023502  0.036947  0.636086  0.524721      0.034280     0.685573   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693050  \n",
+                            "beta2      0.492982  "
                         ]
                     },
-                    "execution_count": 28,
+                    "execution_count": 29,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "print(results.getBetaValues())\n",
-                "simulationWithEstimatedBetas =\\\n",
-                "    myBiogeme.simulate(results.getBetaValues())\n",
-                "simulationWithEstimatedBetas"
+                "results = myBiogeme.\\\n",
+                "estimate(algorithm=opt.simpleBoundsNewtonAlgorithmForBiogeme,\n",
+                "         algoParameters = {'proportionAnalyticalHessian': 0.5})\n",
+                "results.getEstimatedParameters()"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 30,
+            "metadata": {},
+            "outputs": [
+                {
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "Algorithm:\tHybrid Newton [50.0%] with trust region for simple bound constraints\n",
+                        "Proportion analytical hessian:\t60.0%\n",
+                        "Relative projected gradient:\t2.790944329115531e-06\n",
+                        "Relative change:\t4.2680917955839615e-05\n",
+                        "Number of iterations:\t4\n",
+                        "Number of function evaluations:\t13\n",
+                        "Number of gradient evaluations:\t5\n",
+                        "Number of hessian evaluations:\t3\n",
+                        "Cause of termination:\tRelative gradient = 2.8e-06 <= 6.1e-06\n",
+                        "Optimization time:\t0:00:00.003492\n"
+                    ]
+                }
+            ],
+            "source": [
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "## confidenceIntervals"
+                "If the parameter is set to zero, the second derivatives are not used at all, and the algorithm relies only on the BFGS update."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 29,
+            "execution_count": 31,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -1303,78 +1399,107 @@
                             "        text-align: right;\n",
                             "    }\n",
                             "</style>\n",
                             "<table border=\"1\" class=\"dataframe\">\n",
                             "  <thead>\n",
                             "    <tr style=\"text-align: right;\">\n",
                             "      <th></th>\n",
-                            "      <th>loglike</th>\n",
-                            "      <th>beta1</th>\n",
-                            "      <th>simul</th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
-                            "      <th>0</th>\n",
-                            "      <td>-17.689026</td>\n",
-                            "      <td>-1.302323</td>\n",
-                            "      <td>-0.297597</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>1</th>\n",
-                            "      <td>-10.034047</td>\n",
-                            "      <td>-1.302323</td>\n",
-                            "      <td>-0.595193</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>2</th>\n",
-                            "      <td>-21.715671</td>\n",
-                            "      <td>-1.302323</td>\n",
-                            "      <td>-0.238077</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>3</th>\n",
-                            "      <td>-21.715671</td>\n",
-                            "      <td>-1.302323</td>\n",
-                            "      <td>-0.238077</td>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.144547</td>\n",
+                            "      <td>0.391018</td>\n",
+                            "      <td>0.369669</td>\n",
+                            "      <td>0.711629</td>\n",
+                            "      <td>0.366198</td>\n",
+                            "      <td>0.394723</td>\n",
+                            "      <td>0.693047</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
-                            "      <th>4</th>\n",
-                            "      <td>-21.715671</td>\n",
-                            "      <td>-1.302323</td>\n",
-                            "      <td>-0.238077</td>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.023502</td>\n",
+                            "      <td>0.036947</td>\n",
+                            "      <td>0.636088</td>\n",
+                            "      <td>0.524719</td>\n",
+                            "      <td>0.034280</td>\n",
+                            "      <td>0.685574</td>\n",
+                            "      <td>0.492981</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "     loglike     beta1     simul\n",
-                            "0 -17.689026 -1.302323 -0.297597\n",
-                            "1 -10.034047 -1.302323 -0.595193\n",
-                            "2 -21.715671 -1.302323 -0.238077\n",
-                            "3 -21.715671 -1.302323 -0.238077\n",
-                            "4 -21.715671 -1.302323 -0.238077"
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144547  0.391018  0.369669  0.711629      0.366198     0.394723   \n",
+                            "beta2  0.023502  0.036947  0.636088  0.524719      0.034280     0.685574   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693047  \n",
+                            "beta2      0.492981  "
                         ]
                     },
-                    "execution_count": 29,
+                    "execution_count": 31,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "drawsFromBetas =\\\n",
-                "    results.getBetasForSensitivityAnalysis(myBiogeme.freeBetaNames)\n",
-                "left, right = myBiogeme.confidenceIntervals(drawsFromBetas)\n",
-                "left"
+                "results = myBiogeme.\\\n",
+                "estimate(algorithm=opt.simpleBoundsNewtonAlgorithmForBiogeme,\n",
+                "         algoParameters = {'proportionAnalyticalHessian': 0})\n",
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 30,
+            "execution_count": 32,
+            "metadata": {},
+            "outputs": [
+                {
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "Algorithm:\tBFGS with trust region for simple bound constraints\n",
+                        "Proportion analytical hessian:\t0.0%\n",
+                        "Relative projected gradient:\t1.3873770983933678e-06\n",
+                        "Relative change:\t6.637427884398361e-08\n",
+                        "Number of iterations:\t14\n",
+                        "Number of function evaluations:\t31\n",
+                        "Number of gradient evaluations:\t9\n",
+                        "Number of hessian evaluations:\t0\n",
+                        "Cause of termination:\tRelative change = 6.64e-08 <= 1e-05\n",
+                        "Optimization time:\t0:00:00.008565\n"
+                    ]
+                }
+            ],
+            "source": [
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "There are shortcuts to call the BFGS and the Newton versions"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 33,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -1390,148 +1515,202 @@
                             "        text-align: right;\n",
                             "    }\n",
                             "</style>\n",
                             "<table border=\"1\" class=\"dataframe\">\n",
                             "  <thead>\n",
                             "    <tr style=\"text-align: right;\">\n",
                             "      <th></th>\n",
-                            "      <th>loglike</th>\n",
-                            "      <th>beta1</th>\n",
-                            "      <th>simul</th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
-                            "      <th>0</th>\n",
-                            "      <td>-16.974003</td>\n",
-                            "      <td>-1.255223</td>\n",
-                            "      <td>-0.280663</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>1</th>\n",
-                            "      <td>-9.619739</td>\n",
-                            "      <td>-1.255223</td>\n",
-                            "      <td>-0.561327</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>2</th>\n",
-                            "      <td>-20.443982</td>\n",
-                            "      <td>-1.255223</td>\n",
-                            "      <td>-0.224531</td>\n",
-                            "    </tr>\n",
-                            "    <tr>\n",
-                            "      <th>3</th>\n",
-                            "      <td>-20.443982</td>\n",
-                            "      <td>-1.255223</td>\n",
-                            "      <td>-0.224531</td>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.144545</td>\n",
+                            "      <td>0.391017</td>\n",
+                            "      <td>0.369665</td>\n",
+                            "      <td>0.711632</td>\n",
+                            "      <td>0.366198</td>\n",
+                            "      <td>0.394720</td>\n",
+                            "      <td>0.693050</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
-                            "      <th>4</th>\n",
-                            "      <td>-20.443982</td>\n",
-                            "      <td>-1.255223</td>\n",
-                            "      <td>-0.224531</td>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.023502</td>\n",
+                            "      <td>0.036947</td>\n",
+                            "      <td>0.636086</td>\n",
+                            "      <td>0.524720</td>\n",
+                            "      <td>0.034280</td>\n",
+                            "      <td>0.685573</td>\n",
+                            "      <td>0.492982</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "     loglike     beta1     simul\n",
-                            "0 -16.974003 -1.255223 -0.280663\n",
-                            "1  -9.619739 -1.255223 -0.561327\n",
-                            "2 -20.443982 -1.255223 -0.224531\n",
-                            "3 -20.443982 -1.255223 -0.224531\n",
-                            "4 -20.443982 -1.255223 -0.224531"
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144545  0.391017  0.369665  0.711632      0.366198     0.394720   \n",
+                            "beta2  0.023502  0.036947  0.636086  0.524720      0.034280     0.685573   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693050  \n",
+                            "beta2      0.492982  "
                         ]
                     },
-                    "execution_count": 30,
+                    "execution_count": 33,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "right"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "## validate"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "The validation consists in organizing the data into several slices of about the same size, randomly defined. \n",
-                "Each slide is considered as a validation dataset. The model is then re-estimated using all the data except the slice, and the estimated model is applied on the validation set (i.e. the slice). The value of the log likelihood for each observation in the validation set is reported in a dataframe. As this is done for each slice, the output is a list of dataframes, each corresponding to one of these exercises.   "
+                "results = myBiogeme.\\\n",
+                "estimate(algorithm=opt.bioNewton)\n",
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 35,
+            "execution_count": 34,
             "metadata": {},
-            "outputs": [],
+            "outputs": [
+                {
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "Algorithm:\tNewton with trust region for simple bound constraints\n",
+                        "Proportion analytical hessian:\t100.0%\n",
+                        "Relative projected gradient:\t3.2893676168569793e-07\n",
+                        "Relative change:\t0.00022882036808896666\n",
+                        "Number of iterations:\t3\n",
+                        "Number of function evaluations:\t10\n",
+                        "Number of gradient evaluations:\t4\n",
+                        "Number of hessian evaluations:\t4\n",
+                        "Cause of termination:\tRelative gradient = 3.3e-07 <= 6.1e-06\n",
+                        "Optimization time:\t0:00:00.002522\n"
+                    ]
+                }
+            ],
             "source": [
-                "logger.setSilent()\n",
-                "validationData = myData.split(slices=5)\n",
-                "validation_results = myBiogeme.validate(results, validationData)"
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 36,
+            "execution_count": 35,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Value</th>\n",
+                            "      <th>Std err</th>\n",
+                            "      <th>t-test</th>\n",
+                            "      <th>p-value</th>\n",
+                            "      <th>Rob. Std err</th>\n",
+                            "      <th>Rob. t-test</th>\n",
+                            "      <th>Rob. p-value</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>0.144547</td>\n",
+                            "      <td>0.391018</td>\n",
+                            "      <td>0.369669</td>\n",
+                            "      <td>0.711629</td>\n",
+                            "      <td>0.366198</td>\n",
+                            "      <td>0.394723</td>\n",
+                            "      <td>0.693047</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>0.023502</td>\n",
+                            "      <td>0.036947</td>\n",
+                            "      <td>0.636088</td>\n",
+                            "      <td>0.524719</td>\n",
+                            "      <td>0.034280</td>\n",
+                            "      <td>0.685574</td>\n",
+                            "      <td>0.492981</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
                         "text/plain": [
-                            "[   Loglikelihood\n",
-                            " 2     -13.547382,\n",
-                            "    Loglikelihood\n",
-                            " 1     -10.126055,\n",
-                            "    Loglikelihood\n",
-                            " 3     -16.968709,\n",
-                            "    Loglikelihood\n",
-                            " 0      -6.704727,\n",
-                            "    Loglikelihood\n",
-                            " 4     -20.390037]"
+                            "          Value   Std err    t-test   p-value  Rob. Std err  Rob. t-test  \\\n",
+                            "beta1  0.144547  0.391018  0.369669  0.711629      0.366198     0.394723   \n",
+                            "beta2  0.023502  0.036947  0.636088  0.524719      0.034280     0.685574   \n",
+                            "\n",
+                            "       Rob. p-value  \n",
+                            "beta1      0.693047  \n",
+                            "beta2      0.492981  "
                         ]
                     },
-                    "execution_count": 36,
+                    "execution_count": 35,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "validation_results"
+                "results = myBiogeme.\\\n",
+                "estimate(algorithm=opt.bioBfgs)\n",
+                "results.getEstimatedParameters()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 38,
+            "execution_count": 36,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "Log likelihood for 1 validation data: -13.547381997593472\n",
-                        "Log likelihood for 1 validation data: -10.12605473847826\n",
-                        "Log likelihood for 1 validation data: -16.968709256708685\n",
-                        "Log likelihood for 1 validation data: -6.704727479363046\n",
-                        "Log likelihood for 1 validation data: -20.390036515823898\n"
+                        "Algorithm:\tBFGS with trust region for simple bound constraints\n",
+                        "Proportion analytical hessian:\t0.0%\n",
+                        "Relative projected gradient:\t1.3873770983933678e-06\n",
+                        "Relative change:\t6.637427884398361e-08\n",
+                        "Number of iterations:\t14\n",
+                        "Number of function evaluations:\t31\n",
+                        "Number of gradient evaluations:\t9\n",
+                        "Number of hessian evaluations:\t0\n",
+                        "Cause of termination:\tRelative change = 6.64e-08 <= 1e-05\n",
+                        "Optimization time:\t0:00:00.008666\n"
                     ]
                 }
             ],
             "source": [
-                "for slide in validation_results:\n",
-                "    print(f'Log likelihood for {slide.shape[0]} '\n",
-                "          f'validation data: {slide[\"Loglikelihood\"].sum()}')\n"
+                "for k, v in results.data.optimizationMessages.items():\n",
+                "    print(f'{k}:\\t{v}')"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "metadata": {},
             "outputs": [],
```

### Comparing `biogeme-3.2.8/examples/notebooks/biogeme.database.ipynb` & `biogeme-3.2.9/examples/notebooks/biogeme.database.ipynb`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9836751500814002%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2022-08-09 11:23:26.647742\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9b [2022-08-09]\\n')], delete: [0]}}}}, 13: "*

 * *            "{'outputs': {0: {'text': ['[11. 22. 33. 44. 55.]\\n']}}}, 16: {'outputs': {0: "*

 * *            "{'text': ['[False  True  True  True  True]\\n']}}}, 19: {'outputs': {0: {'data': "*

 * *            "{'text/plain': ['{1.0: (2, 4.0), 2.0: (2, 5.0), 3.0: (1, 4.0)}']}}}}, 22: "*

 * *            "{'execution_count': 10, ' […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:55:23.580890\n"
+                        "2022-08-09 11:23:26.647742\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9b [2022-08-09]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -165,20 +165,15 @@
             "execution_count": 7,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "0    11\n",
-                        "1    22\n",
-                        "2    33\n",
-                        "3    44\n",
-                        "4    55\n",
-                        "dtype: int64\n"
+                        "[11. 22. 33. 44. 55.]\n"
                     ]
                 }
             ],
             "source": [
                 "Variable1 = Variable('Variable1')\n",
                 "Variable2 = Variable('Variable2')\n",
                 "expr = Variable1 + Variable2\n",
@@ -216,20 +211,15 @@
             "execution_count": 8,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "0    False\n",
-                        "1     True\n",
-                        "2     True\n",
-                        "3     True\n",
-                        "4     True\n",
-                        "dtype: bool\n"
+                        "[False  True  True  True  True]\n"
                     ]
                 }
             ],
             "source": [
                 "Av1 = Variable('Av1')\n",
                 "Av2 = Variable('Av2')\n",
                 "Av3 = Variable('Av3')\n",
@@ -267,15 +257,15 @@
             "cell_type": "code",
             "execution_count": 9,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "{1: (2, 4), 2: (2, 5), 3: (1, 4)}"
+                            "{1.0: (2, 4.0), 2.0: (2, 5.0), 3.0: (1, 4.0)}"
                         ]
                     },
                     "execution_count": 9,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -283,55 +273,14 @@
                 "myData.choiceAvailabilityStatistics(avail, Choice)"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "## sumFromDatabase"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "Calculates the value of an expression for each entry in the database, and retturns the sum.\n",
-                "\n",
-                "        Args:\n",
-                "            expression: object of type biogeme.expressions \n",
-                "            \n",
-                "        Returns:\n",
-                "            Sum of the expressions over the database.\n"
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": 10,
-            "metadata": {},
-            "outputs": [
-                {
-                    "name": "stdout",
-                    "output_type": "stream",
-                    "text": [
-                        "50.0\n"
-                    ]
-                }
-            ],
-            "source": [
-                "Variable1 = Variable('Variable1')\n",
-                "Variable2 = Variable('Variable2')\n",
-                "expression = Variable2 / Variable1\n",
-                "result = myData.sumFromDatabase(expression)\n",
-                "print(result)"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
                 "## Suggest scaling"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
@@ -345,37 +294,37 @@
                 "        A Pandas dataframe where each row contains the name of\n",
                 "        the variable, the suggested scale s and the laergest value in the column. \n",
                 "        Ideally, the column should be multiplied by s. \n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 11,
+            "execution_count": 10,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "Index(['Person', 'Exclude', 'Variable1', 'Variable2', 'Choice', 'Av1', 'Av2',\n",
                             "       'Av3'],\n",
                             "      dtype='object')"
                         ]
                     },
-                    "execution_count": 11,
+                    "execution_count": 10,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data.columns"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 12,
+            "execution_count": 11,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -412,26 +361,26 @@
                             "</div>"
                         ],
                         "text/plain": [
                             "      Column  Scale  Largest\n",
                             "3  Variable2   0.01       50"
                         ]
                     },
-                    "execution_count": 12,
+                    "execution_count": 11,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.suggestScaling()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 13,
+            "execution_count": 12,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -468,15 +417,15 @@
                             "</div>"
                         ],
                         "text/plain": [
                             "      Column  Scale  Largest\n",
                             "1  Variable2   0.01       50"
                         ]
                     },
-                    "execution_count": 13,
+                    "execution_count": 12,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.suggestScaling(columns=['Variable1', 'Variable2'])"
             ]
@@ -499,15 +448,15 @@
                 "\n",
                 "              scale: value of the scale. All values of the \n",
                 "              column will be multiplied by that scale.\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 14,
+            "execution_count": 13,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -602,35 +551,35 @@
                             "0       1        0          1         10       1    0    1    0\n",
                             "1       1        0          2         20       2    1    1    1\n",
                             "2       1        1          3         30       3    1    1    1\n",
                             "3       2        0          4         40       1    1    1    1\n",
                             "4       2        1          5         50       2    1    1    1"
                         ]
                     },
-                    "execution_count": 14,
+                    "execution_count": 13,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 15,
+            "execution_count": 14,
             "metadata": {},
             "outputs": [],
             "source": [
                 "myData.scaleColumn('Variable2', 0.01)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 16,
+            "execution_count": 15,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -725,15 +674,15 @@
                             "0       1        0          1        0.1       1    0    1    0\n",
                             "1       1        0          2        0.2       2    1    1    1\n",
                             "2       1        1          3        0.3       3    1    1    1\n",
                             "3       2        0          4        0.4       1    1    1    1\n",
                             "4       2        1          5        0.5       2    1    1    1"
                         ]
                     },
-                    "execution_count": 16,
+                    "execution_count": 15,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data"
             ]
@@ -761,15 +710,15 @@
                 "\n",
                 "        Raises:\n",
                 "              ValueError: if the column name already exists."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 17,
+            "execution_count": 16,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "[0.1, 0.4, 0.8999999999999999, 1.6, 2.5]\n"
@@ -783,15 +732,15 @@
                 "expression = Variable2 * Variable1\n",
                 "result = myData.addColumn(expression, 'NewVariable')\n",
                 "print(myData.data['NewVariable'].tolist())"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 18,
+            "execution_count": 17,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -892,15 +841,15 @@
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "1       1        0          2        0.2       2    1    1    1          0.4\n",
                             "2       1        1          3        0.3       3    1    1    1          0.9\n",
                             "3       2        0          4        0.4       1    1    1    1          1.6\n",
                             "4       2        1          5        0.5       2    1    1    1          2.5"
                         ]
                     },
-                    "execution_count": 18,
+                    "execution_count": 17,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data"
             ]
@@ -917,15 +866,15 @@
             "metadata": {},
             "source": [
                 "Shuffle the data, and split the data into slices. For each slide, an estimation and a validation sets are generated. The validation set is the slice itself. The estimation set is the rest of the data. "
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 19,
+            "execution_count": 18,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "==========\n",
@@ -1001,24 +950,24 @@
             "metadata": {},
             "source": [
                 "Here, count the number of entries for individual 1."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 20,
+            "execution_count": 19,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "3"
                         ]
                     },
-                    "execution_count": 20,
+                    "execution_count": 19,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.count('Person',1)"
             ]
@@ -1041,15 +990,15 @@
                 "           describing the expression to evaluate\n",
                 "        Returns:\n",
                 "           Nothing."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 21,
+            "execution_count": 20,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -1124,15 +1073,15 @@
                         "text/plain": [
                             "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  NewVariable\n",
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "1       1        0          2        0.2       2    1    1    1          0.4\n",
                             "3       2        0          4        0.4       1    1    1    1          1.6"
                         ]
                     },
-                    "execution_count": 21,
+                    "execution_count": 20,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "Exclude = Variable('Exclude')\n",
                 "myData.remove(Exclude)\n",
@@ -1153,35 +1102,35 @@
                 "Dumps the database in a CSV formatted file.\n",
                 "\n",
                 "        Returns:  name of the file"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 22,
+            "execution_count": 21,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'test_dumped~05.dat'"
+                            "'test_dumped~00.dat'"
                         ]
                     },
-                    "execution_count": 22,
+                    "execution_count": 21,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.dumpOnFile()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 23,
+            "execution_count": 22,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "__rowId\tPerson\tExclude\tVariable1\tVariable2\tChoice\tAv1\tAv2\tAv3\tNewVariable\n",
@@ -1234,15 +1183,15 @@
             "metadata": {},
             "source": [
                 "List native types and their description"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 24,
+            "execution_count": 23,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "['UNIFORM: Uniform U[0, 1]',\n",
                             " 'UNIFORM_ANTI: Antithetic uniform U[0, 1]',\n",
@@ -1263,26 +1212,26 @@
                             " 'NORMAL_HALTON2: Normal draws from Halton base 2 sequence',\n",
                             " 'NORMAL_HALTON3: Normal draws from Halton base 3 sequence',\n",
                             " 'NORMAL_HALTON5: Normal draws from Halton base 5 sequence',\n",
                             " 'NORMAL_MLHS: Normal draws from Modified Latin Hypercube Sampling',\n",
                             " 'NORMAL_MLHS_ANTI: Antithetic normal draws from Modified Latin Hypercube Sampling']"
                         ]
                     },
-                    "execution_count": 24,
+                    "execution_count": 23,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.descriptionOfNativeDraws()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 25,
+            "execution_count": 24,
             "metadata": {},
             "outputs": [],
             "source": [
                 "randomDraws1 = bioDraws('randomDraws1', 'NORMAL_MLHS_ANTI')\n",
                 "randomDraws2 = bioDraws('randomDraws2', 'UNIFORM_MLHS_ANTI')\n",
                 "randomDraws3 = bioDraws('randomDraws3', 'UNIFORMSYM_MLHS_ANTI')"
             ]
@@ -1292,15 +1241,15 @@
             "metadata": {},
             "source": [
                 "We build an expression that involves the three random variables"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 26,
+            "execution_count": 25,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "{'randomDraws1': 'NORMAL_MLHS_ANTI', 'randomDraws2': 'UNIFORM_MLHS_ANTI', 'randomDraws3': 'UNIFORMSYM_MLHS_ANTI'}\n"
@@ -1311,15 +1260,15 @@
                 "x = randomDraws1 + randomDraws2 + randomDraws3\n",
                 "types = x.dictOfDraws()\n",
                 "print(types)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 27,
+            "execution_count": 26,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "array([[[-0.5605896 ,  0.17260212, -0.35933972],\n",
                             "        [-0.13811324,  0.53162299,  0.85919231],\n",
@@ -1351,15 +1300,15 @@
                             "        [-0.79534986,  0.40343658, -0.03577992],\n",
                             "        [-0.94867479,  0.64723909,  0.77071189],\n",
                             "        [ 1.04456302,  0.11702105, -0.44668319],\n",
                             "        [-0.15248012,  0.56738015, -0.51955543],\n",
                             "        [ 0.35858978,  0.66669537,  0.98648324]]])"
                         ]
                     },
-                    "execution_count": 27,
+                    "execution_count": 26,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "theDrawsTable = myData.generateDraws(types,                         \n",
                 "                                     ['randomDraws1',\n",
@@ -1402,15 +1351,15 @@
             "metadata": {},
             "source": [
                 "We first define functions returning draws, given the number of observations, and the number of draws"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 28,
+            "execution_count": 27,
             "metadata": {},
             "outputs": [],
             "source": [
                 "def logNormalDraws(sampleSize, numberOfDraws):\n",
                 "    return np.exp(np.random.randn(sampleSize, numberOfDraws))\n",
                 "\n",
                 "def exponentialDraws(sampleSize, numberOfDraws):\n",
@@ -1422,15 +1371,15 @@
             "metadata": {},
             "source": [
                 "We associate these functions with a name"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 29,
+            "execution_count": 28,
             "metadata": {},
             "outputs": [],
             "source": [
                 "dict = {'LOGNORMAL': (logNormalDraws, \n",
                 "                      'Draws from lognormal distribution'), \n",
                 "        'EXP': (exponentialDraws,\n",
                 "                'Draws from exponential distributions')}\n",
@@ -1442,15 +1391,15 @@
             "metadata": {},
             "source": [
                 "We can now generate draws from these distributions"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 30,
+            "execution_count": 29,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "[[[2.15336577 0.35541854]\n",
@@ -1517,15 +1466,15 @@
                 "\n",
                 "        Returns:\n",
                 "            pandas dataframe with the sample.\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 31,
+            "execution_count": 30,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -1600,26 +1549,26 @@
                         "text/plain": [
                             "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  NewVariable\n",
                             "3       2        0          4        0.4       1    1    1    1          1.6\n",
                             "3       2        0          4        0.4       1    1    1    1          1.6\n",
                             "1       1        0          2        0.2       2    1    1    1          0.4"
                         ]
                     },
-                    "execution_count": 31,
+                    "execution_count": 30,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.sampleWithReplacement()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 32,
+            "execution_count": 31,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -1733,15 +1682,15 @@
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "0       1        0          1        0.1       1    0    1    0          0.1\n",
                             "1       1        0          2        0.2       2    1    1    1          0.4"
                         ]
                     },
-                    "execution_count": 32,
+                    "execution_count": 31,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.sampleWithReplacement(6)"
             ]
@@ -1762,15 +1711,15 @@
                 "        Args:\n",
                 "           columnName: name of the columns that identifies\n",
                 "           individuals.\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 33,
+            "execution_count": 32,
             "metadata": {},
             "outputs": [],
             "source": [
                 "myPanelData = db.Database('test', df)"
             ]
         },
         {
@@ -1778,35 +1727,35 @@
             "metadata": {},
             "source": [
                 "Data is not considered panel yet"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 34,
+            "execution_count": 33,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "False"
                         ]
                     },
-                    "execution_count": 34,
+                    "execution_count": 33,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myPanelData.isPanel()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 35,
+            "execution_count": 34,
             "metadata": {},
             "outputs": [],
             "source": [
                 "myPanelData.panel('Person')"
             ]
         },
         {
@@ -1814,15 +1763,15 @@
             "metadata": {},
             "source": [
                 "Now it is panel"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 36,
+            "execution_count": 35,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "True\n"
@@ -1831,31 +1780,26 @@
             ],
             "source": [
                 "print(myPanelData.isPanel())"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 37,
+            "execution_count": 36,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "biogeme database test:\n",
-                        "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  NewVariable  \\\n",
-                        "0       1        0          1        0.1       1    0    1    0          0.1   \n",
-                        "1       1        0          2        0.2       2    1    1    1          0.4   \n",
-                        "2       2        0          4        0.4       1    1    1    1          1.6   \n",
-                        "\n",
-                        "   _biogroups  \n",
-                        "0           1  \n",
-                        "1           1  \n",
-                        "2           2  \n",
+                        "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  NewVariable\n",
+                        "0       1        0          1        0.1       1    0    1    0          0.1\n",
+                        "1       1        0          2        0.2       2    1    1    1          0.4\n",
+                        "2       2        0          4        0.4       1    1    1    1          1.6\n",
                         "Panel data\n",
                         "   0  1\n",
                         "1  0  1\n",
                         "2  2  2\n"
                     ]
                 }
             ],
@@ -1868,15 +1812,15 @@
             "metadata": {},
             "source": [
                 "When draws are generated for panel data, a set of draws is generated per person, not per observation."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 38,
+            "execution_count": 37,
             "metadata": {},
             "outputs": [],
             "source": [
                 "randomDraws1 = bioDraws('randomDraws1', 'NORMAL')\n",
                 "randomDraws2 = bioDraws('randomDraws2', 'UNIFORM_HALTON3')"
             ]
         },
@@ -1885,15 +1829,15 @@
             "metadata": {},
             "source": [
                 "We build an expression that involves the two random variables"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 39,
+            "execution_count": 38,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "[[[-1.57792232  0.7037037 ]\n",
@@ -1947,44 +1891,44 @@
                 "            Number of observations.\n",
                 "\n",
                 "        See:  getSampleSize()\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 40,
+            "execution_count": 39,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "3"
                         ]
                     },
-                    "execution_count": 40,
+                    "execution_count": 39,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.getNumberOfObservations()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 41,
+            "execution_count": 40,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "3"
                         ]
                     },
-                    "execution_count": 41,
+                    "execution_count": 40,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myPanelData.getNumberOfObservations()"
             ]
@@ -2008,44 +1952,44 @@
                 "           Sample size.\n",
                 "\n",
                 "        See: getNumberOfObservations()\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 42,
+            "execution_count": 41,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "3"
                         ]
                     },
-                    "execution_count": 42,
+                    "execution_count": 41,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.getSampleSize()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 43,
+            "execution_count": 42,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "2"
                         ]
                     },
-                    "execution_count": 43,
+                    "execution_count": 42,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myPanelData.getSampleSize()"
             ]
@@ -2069,15 +2013,15 @@
                 "\n",
                 "        Returns:\n",
                 "            pandas dataframe with the sample.\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 44,
+            "execution_count": 43,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -2166,15 +2110,15 @@
                             "1  0  1\n",
                             "1  0  1\n",
                             "1  0  1\n",
                             "2  2  2\n",
                             "1  0  1"
                         ]
                     },
-                    "execution_count": 44,
+                    "execution_count": 43,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myPanelData.sampleIndividualMapWithReplacement(10)"
             ]
@@ -2191,15 +2135,15 @@
             "metadata": {},
             "source": [
                 "It is possible as well to sample without replacement. This is typically useful for stochastic algorithms that use only part of the database. "
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 45,
+            "execution_count": 44,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -2300,15 +2244,15 @@
                             "0       1        0          1         10       1    0    1    0       1\n",
                             "1       1        0          2         20       2    1    1    1       5\n",
                             "2       1        1          3         30       3    1    1    1       1\n",
                             "3       2        0          4         40       1    1    1    1       1\n",
                             "4       2        1          5         50       2    1    1    1       5"
                         ]
                     },
-                    "execution_count": 45,
+                    "execution_count": 44,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "df = pd.DataFrame({'Person': [1, 1, 1, 2, 2],\n",
                 "                   'Exclude': [0, 0, 1, 0, 1],\n",
@@ -2321,38 +2265,38 @@
                 "                   'Weight': [1, 5, 1, 1, 5]})\n",
                 "myData = db.Database('test', df)\n",
                 "myData.data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 46,
+            "execution_count": 45,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "1    2\n",
                             "2    2\n",
                             "3    1\n",
                             "Name: Choice, dtype: int64"
                         ]
                     },
-                    "execution_count": 46,
+                    "execution_count": 45,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data.Choice.value_counts()"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 47,
+            "execution_count": 46,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -2440,39 +2384,39 @@
                             "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  Weight\n",
                             "3       2        0          4         40       1    1    1    1       1\n",
                             "4       2        1          5         50       2    1    1    1       5\n",
                             "2       1        1          3         30       3    1    1    1       1\n",
                             "1       1        0          2         20       2    1    1    1       5"
                         ]
                     },
-                    "execution_count": 47,
+                    "execution_count": 46,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.sampleWithoutReplacement(0.7)\n",
                 "myData.data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 48,
+            "execution_count": 47,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "2    2\n",
                             "1    1\n",
                             "3    1\n",
                             "Name: Choice, dtype: int64"
                         ]
                     },
-                    "execution_count": 48,
+                    "execution_count": 47,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data.Choice.value_counts()"
             ]
@@ -2482,15 +2426,15 @@
             "metadata": {},
             "source": [
                 "The sampling does not have to be uniform. Here, we oversample data corresponding to Choice = 2"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 49,
+            "execution_count": 48,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -2578,63 +2522,63 @@
                             "   Person  Exclude  Variable1  Variable2  Choice  Av1  Av2  Av3  Weight\n",
                             "1       1        0          2         20       2    1    1    1       5\n",
                             "4       2        1          5         50       2    1    1    1       5\n",
                             "2       1        1          3         30       3    1    1    1       1\n",
                             "0       1        0          1         10       1    0    1    0       1"
                         ]
                     },
-                    "execution_count": 49,
+                    "execution_count": 48,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.sampleWithoutReplacement(0.7, 'Weight')\n",
                 "myData.data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 50,
+            "execution_count": 49,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "2    2\n",
                             "3    1\n",
                             "1    1\n",
                             "Name: Choice, dtype: int64"
                         ]
                     },
-                    "execution_count": 50,
+                    "execution_count": 49,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "myData.data.Choice.value_counts()"
             ]
         }
     ],
     "metadata": {
         "kernelspec": {
-            "display_name": "Python 3",
+            "display_name": "Python 3 (ipykernel)",
             "language": "python",
             "name": "python3"
         },
         "language_info": {
             "codemirror_mode": {
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.9.5"
+            "version": "3.10.4"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 2
 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/biogeme.distributions.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.distributions-checkpoint.ipynb`

 * *Files 2% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.999934668989547%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2021-08-04 16:37:51.809873\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.8 [2021-08-04]\\n')], delete: [0]}}}}}"}*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:55:52.658179\n"
+                        "2021-08-04 16:37:51.809873\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.8 [2021-08-04]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/biogeme.draws.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.draws-checkpoint.ipynb`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9999503968253969%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2021-08-04 16:38:09.707948\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.8 [2021-08-04]\\n')], delete: [0]}}}}}"}*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:56:10.201916\n"
+                        "2021-08-04 16:38:09.707948\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.8 [2021-08-04]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/biogeme.filenames.ipynb` & `biogeme-3.2.9/examples/notebooks/biogeme.filenames.ipynb`

 * *Files 5% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9996651785714286%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2021-10-26 16:02:47.229160\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9a [2021-10-26]\\n')], delete: [0]}}}}, 7: "*

 * *            '{\'outputs\': {0: {\'data\': {\'text/plain\': ["\'test~01.dat\'"]}}}}, 10: '*

 * *            '{\'outputs\': {0: {\'data\': {\'text/plain\': ["\'test~02.dat\'"]}}}}, 13: '*

 * *            '{\'outputs\': {0: {\'data\': {\'text/plain\': ["\'test~03.dat\'"]}}}}}'}*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:56:50.143102\n"
+                        "2021-10-26 16:02:47.229160\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9a [2021-10-26]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -82,15 +82,15 @@
             "cell_type": "code",
             "execution_count": 4,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'test.dat'"
+                            "'test~01.dat'"
                         ]
                     },
                     "execution_count": 4,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -119,15 +119,15 @@
             "cell_type": "code",
             "execution_count": 6,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'test~00.dat'"
+                            "'test~02.dat'"
                         ]
                     },
                     "execution_count": 6,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -156,15 +156,15 @@
             "cell_type": "code",
             "execution_count": 8,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'test~01.dat'"
+                            "'test~03.dat'"
                         ]
                     },
                     "execution_count": 8,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
```

### Comparing `biogeme-3.2.8/examples/notebooks/biogeme.loglikelihood.ipynb` & `biogeme-3.2.9/examples/notebooks/biogeme.loglikelihood.ipynb`

 * *Files 10% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9761704441391942%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2022-08-09 11:13:29.583678\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9b [2022-08-09]\\n')], delete: [0]}}}}, 6: "*

 * *            "{'execution_count': 4}, 9: {'execution_count': 5, 'outputs': {0: {'text': "*

 * *            "['MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0.0`, 2:(beta(init=0)[elid:None "*

 * *            'id:None] + (sigma(init=1)[elid:None id:None] * bioDraws("V2", '*

 * *            '"NORMAL"))))))\\n\']}}}, 11: {\'execution_cou […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:57:02.611989\n"
+                        "2022-08-09 11:13:29.583678\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9b [2022-08-09]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -64,14 +64,25 @@
         },
         {
             "cell_type": "code",
             "execution_count": 3,
             "metadata": {},
             "outputs": [],
             "source": [
+                "import biogeme.messaging as msg\n",
+                "logger = msg.bioMessage()\n",
+                "logger.setDebug()"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 4,
+            "metadata": {},
+            "outputs": [],
+            "source": [
                 "import numpy as np\n",
                 "import pandas as pd\n",
                 "import biogeme.database as db\n",
                 "import biogeme.loglikelihood as ll\n",
                 "import biogeme.expressions as ex\n",
                 "import biogeme.models as md"
             ]
@@ -88,22 +99,22 @@
             "metadata": {},
             "source": [
                 "Let's consider first a simple choice model."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 4,
+            "execution_count": 5,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0`, 2:(beta(0) + (sigma(1) * bioDraws(\"V2\", \"NORMAL\"))))))\n"
+                        "MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0.0`, 2:(beta(init=0)[elid:None id:None] + (sigma(init=1)[elid:None id:None] * bioDraws(\"V2\", \"NORMAL\"))))))\n"
                     ]
                 }
             ],
             "source": [
                 "V1 = 0\n",
                 "beta = ex.Beta('beta', 0, None, None, 0)\n",
                 "sigma = ex.Beta('sigma', 1, 0, None, 0)\n",
@@ -119,22 +130,22 @@
             "metadata": {},
             "source": [
                 "The first function simply takes the log of the probability for each observation."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 5,
+            "execution_count": 6,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "log(MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0`, 2:(beta(0) + (sigma(1) * bioDraws(\"V2\", \"NORMAL\")))))))\n"
+                        "log(MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0.0`, 2:(beta(init=0)[elid:None id:None] + (sigma(init=1)[elid:None id:None] * bioDraws(\"V2\", \"NORMAL\")))))))\n"
                     ]
                 }
             ],
             "source": [
                 "loglike = ll.loglikelihood(prob)\n",
                 "print(loglike)"
             ]
@@ -144,22 +155,22 @@
             "metadata": {},
             "source": [
                 "The second function also involves the integral using Monte-Carlo simulation."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 6,
+            "execution_count": 7,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "log(MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0`, 2:(beta(0) + (sigma(1) * bioDraws(\"V2\", \"NORMAL\")))))))\n"
+                        "log(MonteCarlo(exp(_bioLogLogitFullChoiceSet(1:`0.0`, 2:(beta(init=0)[elid:None id:None] + (sigma(init=1)[elid:None id:None] * bioDraws(\"V2\", \"NORMAL\")))))))\n"
                     ]
                 }
             ],
             "source": [
                 "loglike = ll.mixedloglikelihood(condprob)\n",
                 "print(loglike)"
             ]
@@ -169,15 +180,15 @@
             "metadata": {},
             "source": [
                 "Regression models are often used in the context of hybrid choice models. Consider the following model."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 7,
+            "execution_count": 8,
             "metadata": {},
             "outputs": [],
             "source": [
                 "x = ex.Variable('x')\n",
                 "y = ex.Variable('y')\n",
                 "beta = ex.Beta('beta', 1, None, None, 0)\n",
                 "sigma = ex.Beta('sigma', 1, None, None, 0)\n",
@@ -195,22 +206,22 @@
                 " \n",
                 " where $\\phi(\\cdot)$ is the pdf of the normal distribution.\n",
                 "\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 8,
+            "execution_count": 9,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "exp(((((-(((y - (intercept(0) + (beta(1) * x))) / sigma(1)) ** `2`)) / `2`) - log(sigma(1))) - `0.9189385332`))\n"
+                        "exp(((((-(((y [elid:None id:None] - (intercept(init=0)[elid:None id:None] + (beta(init=1)[elid:None id:None] * x [elid:None id:None]))) / sigma(init=1)[elid:None id:None]) ** `2.0`)) / `2.0`) - log(sigma(init=1)[elid:None id:None])) - `0.9189385332`))\n"
                     ]
                 }
             ],
             "source": [
                 "like = ll.likelihoodregression(y, model, sigma)\n",
                 "print(like)"
             ]
@@ -223,22 +234,22 @@
                 "\n",
                 "\\\\[-\\left( \\frac{(y-m)^2}{2\\sigma^2} \\right) -\n",
                 "              \\log(\\sigma) - \\frac{1}{2}\\log(2\\pi).\\\\]"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 9,
+            "execution_count": 10,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "((((-(((y - (intercept(0) + (beta(1) * x))) / sigma(1)) ** `2`)) / `2`) - log(sigma(1))) - `0.9189385332`)\n"
+                        "((((-(((y [elid:None id:None] - (intercept(init=0)[elid:None id:None] + (beta(init=1)[elid:None id:None] * x [elid:None id:None]))) / sigma(init=1)[elid:None id:None]) ** `2.0`)) / `2.0`) - log(sigma(init=1)[elid:None id:None])) - `0.9189385332`)\n"
                     ]
                 }
             ],
             "source": [
                 "loglike = ll.loglikelihoodregression(y, model, sigma)\n",
                 "print(loglike)"
             ]
@@ -248,100 +259,107 @@
             "metadata": {},
             "source": [
                 "We compare the two on a small database"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 10,
+            "execution_count": 11,
             "metadata": {},
             "outputs": [],
             "source": [
                 "df = pd.DataFrame({'x': [-2, -1, 0, 1, 2],\n",
                 "                   'y': [1, 1, 1, 1, 1]})\n",
                 "myData = db.Database('test', df)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 11,
+            "execution_count": 12,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "array([0.00443185, 0.05399097, 0.24197073, 0.39894229, 0.24197073])"
                         ]
                     },
-                    "execution_count": 11,
+                    "execution_count": 12,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "lr = like.getValue_c(myData)\n",
+                "lr = like.getValue_c(myData, prepareIds=True)\n",
                 "lr"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 12,
+            "execution_count": 13,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "array([-5.41893852, -2.91893852, -1.41893852, -0.91893852, -1.41893852])"
                         ]
                     },
-                    "execution_count": 12,
+                    "execution_count": 13,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "np.log(lr)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 13,
+            "execution_count": 14,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "array([-5.41893852, -2.91893852, -1.41893852, -0.91893852, -1.41893852])"
                         ]
                     },
-                    "execution_count": 13,
+                    "execution_count": 14,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
-                "loglike.getValue_c(myData)"
+                "loglike.getValue_c(myData, prepareIds=True)"
             ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": null,
+            "metadata": {},
+            "outputs": [],
+            "source": []
         }
     ],
     "metadata": {
         "kernelspec": {
-            "display_name": "Python 3",
+            "display_name": "Python 3 (ipykernel)",
             "language": "python",
             "name": "python3"
         },
         "language_info": {
             "codemirror_mode": {
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.9.5"
+            "version": "3.10.4"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 4
 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/biogeme.messaging.ipynb` & `biogeme-3.2.9/examples/notebooks/biogeme.messaging.ipynb`

 * *Files 7% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9992615318118414%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2021-10-26 16:03:12.890354\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9a [2021-10-26]\\n')], delete: [0]}}}}, 15: "*

 * *            "{'outputs': {0: {'text': ['[16:03:12] < Warning >   A test\\n']}}}, 17: {'outputs': "*

 * *            "{0: {'text': ['[16:03:12] < General >   A general message\\n']}}}, 18: {'outputs': "*

 * *            "{0: {'text': ['[16:03:12] < Warning >   A warning message\\n']}}}, 19: {'outputs': "*

 * *            "{0: {'te […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 10:57:16.266254\n"
+                        "2021-10-26 16:03:12.890354\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9a [2021-10-26]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -152,15 +152,15 @@
             "execution_count": 8,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < Warning >   A test\n"
+                        "[16:03:12] < Warning >   A test\n"
                     ]
                 }
             ],
             "source": [
                 "logger.addMessage(\"A test\", 1)"
             ]
         },
@@ -176,15 +176,15 @@
             "execution_count": 9,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < General >   A general message\n"
+                        "[16:03:12] < General >   A general message\n"
                     ]
                 }
             ],
             "source": [
                 "logger.general(\"A general message\")"
             ]
         },
@@ -193,15 +193,15 @@
             "execution_count": 10,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < Warning >   A warning message\n"
+                        "[16:03:12] < Warning >   A warning message\n"
                     ]
                 }
             ],
             "source": [
                 "logger.warning(\"A warning message\")"
             ]
         },
@@ -210,15 +210,15 @@
             "execution_count": 11,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < Detailed >  A detailed message\n"
+                        "[16:03:12] < Detailed >  A detailed message\n"
                     ]
                 }
             ],
             "source": [
                 "logger.detailed(\"A detailed message\")"
             ]
         },
@@ -243,21 +243,21 @@
             "execution_count": 13,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "*** Messages from biogeme 3.2.7 [2021-07-19]\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < General >   A general message\n",
-                        "[10:57:16] < Warning >   A warning message\n",
-                        "[10:57:16] < Detailed >  A detailed message\n",
-                        "[10:57:16] < Debug >     A debug message\n",
+                        "*** Messages from biogeme 3.2.9a [2021-10-26]\n",
+                        "[16:03:12] < Warning >   A test\n",
+                        "[16:03:12] < Warning >   A test\n",
+                        "[16:03:12] < General >   A general message\n",
+                        "[16:03:12] < Warning >   A warning message\n",
+                        "[16:03:12] < Detailed >  A detailed message\n",
+                        "[16:03:12] < Debug >     A debug message\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "print(logger.allMessages())"
             ]
@@ -274,15 +274,15 @@
             "execution_count": 14,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < General >   Log file created: _test.log\n"
+                        "[16:03:12] < General >   Log file created: _test.log\n"
                     ]
                 }
             ],
             "source": [
                 "theFile = logger.createLog(fileName=\"_test\")"
             ]
         },
@@ -291,23 +291,23 @@
             "execution_count": 15,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "*** File created 2021-07-19 10:57:16.322320 ***\n",
-                        "*** Log file from biogeme 3.2.7 [2021-07-19]\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < General >   A general message\n",
-                        "[10:57:16] < Warning >   A warning message\n",
-                        "[10:57:16] < Detailed >  A detailed message\n",
-                        "[10:57:16] < Debug >     A debug message\n",
-                        "[10:57:16] < General >   Log file created: _test.log\n",
+                        "*** File created 2021-10-26 16:03:12.945493 ***\n",
+                        "*** Log file from biogeme 3.2.9a [2021-10-26]\n",
+                        "[16:03:12] < Warning >   A test\n",
+                        "[16:03:12] < Warning >   A test\n",
+                        "[16:03:12] < General >   A general message\n",
+                        "[16:03:12] < Warning >   A warning message\n",
+                        "[16:03:12] < Detailed >  A detailed message\n",
+                        "[16:03:12] < Debug >     A debug message\n",
+                        "[16:03:12] < General >   Log file created: _test.log\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "with open(theFile) as f:\n",
                 "    print(f.read())"
@@ -325,20 +325,20 @@
             "execution_count": 16,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "*** Messages from biogeme 3.2.7 [2021-07-19]\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < General >   A general message\n",
-                        "[10:57:16] < Warning >   A warning message\n",
-                        "[10:57:16] < General >   Log file created: _test.log\n",
+                        "*** Messages from biogeme 3.2.9a [2021-10-26]\n",
+                        "[16:03:12] < Warning >   A test\n",
+                        "[16:03:12] < Warning >   A test\n",
+                        "[16:03:12] < General >   A general message\n",
+                        "[16:03:12] < Warning >   A warning message\n",
+                        "[16:03:12] < General >   Log file created: _test.log\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "print(logger.allMessages(screenLevel=2))"
             ]
@@ -355,15 +355,15 @@
             "execution_count": 17,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "[10:57:16] < General >   Log file created: _test~00.log\n"
+                        "[16:03:12] < General >   Log file created: _test~00.log\n"
                     ]
                 }
             ],
             "source": [
                 "theFile = logger.createLog(fileLevel=2, fileName=\"_test\")"
             ]
         },
@@ -372,22 +372,22 @@
             "execution_count": 18,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "*** File created 2021-07-19 10:57:16.334764 ***\n",
-                        "*** Log file from biogeme 3.2.7 [2021-07-19]\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < Warning >   A test\n",
-                        "[10:57:16] < General >   A general message\n",
-                        "[10:57:16] < Warning >   A warning message\n",
-                        "[10:57:16] < General >   Log file created: _test.log\n",
-                        "[10:57:16] < General >   Log file created: _test~00.log\n",
+                        "*** File created 2021-10-26 16:03:12.957354 ***\n",
+                        "*** Log file from biogeme 3.2.9a [2021-10-26]\n",
+                        "[16:03:12] < Warning >   A test\n",
+                        "[16:03:12] < Warning >   A test\n",
+                        "[16:03:12] < General >   A general message\n",
+                        "[16:03:12] < Warning >   A warning message\n",
+                        "[16:03:12] < General >   Log file created: _test.log\n",
+                        "[16:03:12] < General >   Log file created: _test~00.log\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "with open(theFile) as f:\n",
                 "    print(f.read())"
@@ -405,15 +405,15 @@
             "execution_count": 19,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "*** Messages from biogeme 3.2.7 [2021-07-19]\n",
+                        "*** Messages from biogeme 3.2.9a [2021-10-26]\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "logger.resetMessages()\n",
                 "print(logger.allMessages())"
```

### Comparing `biogeme-3.2.8/examples/notebooks/biogeme.results.ipynb` & `biogeme-3.2.9/examples/notebooks/biogeme.results.ipynb`

 * *Files 20% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9691111462626676%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2022-06-29 19:08:27.263630\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.9b [2022-06-29]\\n')], delete: [0]}}}}, 12: "*

 * *            "{'outputs': {1: {'text': {insert: [(2, 'Output file "*

 * *            "(HTML):\\t\\t\\tsimpleExample~05.html\\n'), (6, 'Init log "*

 * *            "likelihood:\\t\\t-67.5536\\n'), (8, 'Likelihood ratio test "*

 * *            "(init):\\t\\t0.9762237\\n'), (9, 'Rho square (init):\\t\\t\\t0.00723\\n'), (10, 'Rho "*

 * *   […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 11:11:12.386468\n"
+                        "2022-06-29 19:08:27.263630\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.9b [2022-06-29]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -142,36 +142,50 @@
         },
         {
             "cell_type": "code",
             "execution_count": 7,
             "metadata": {},
             "outputs": [
                 {
+                    "name": "stderr",
+                    "output_type": "stream",
+                    "text": [
+                        "100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00<00:00, 433.11it/s]"
+                    ]
+                },
+                {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "\n",
                         "Results for model simpleExample\n",
-                        "Output file (HTML):\t\t\tsimpleExample~14.html\n",
+                        "Output file (HTML):\t\t\tsimpleExample~05.html\n",
                         "Nbr of parameters:\t\t2\n",
                         "Sample size:\t\t\t5\n",
                         "Excluded data:\t\t\t0\n",
-                        "Init log likelihood:\t\t-67.73691\n",
+                        "Init log likelihood:\t\t-67.5536\n",
                         "Final log likelihood:\t\t-67.06549\n",
-                        "Likelihood ratio test (init):\t\t1.342839\n",
-                        "Rho square (init):\t\t\t0.00991\n",
-                        "Rho bar square (init):\t\t\t-0.0196\n",
+                        "Likelihood ratio test (init):\t\t0.9762237\n",
+                        "Rho square (init):\t\t\t0.00723\n",
+                        "Rho bar square (init):\t\t\t-0.0224\n",
                         "Akaike Information Criterion:\t138.131\n",
                         "Bayesian Information Criterion:\t137.3499\n",
-                        "Final gradient norm:\t\t2.887991e-05\n",
-                        "beta1          : -1.27[0.115 -11.1 0][0.0137 -92.8 0][0.0125 -102 0]\n",
-                        "beta2          : 1.25[0.0848 14.7 0][0.0591 21.1 0][0.054 23.1 0]\n",
+                        "Final gradient norm:\t\t0.0001314937\n",
+                        "beta1          : -1.27[0.115 -11.1 0][0.0137 -92.8 0][0.016 -79.5 0]\n",
+                        "beta2          : 1.25[0.0848 14.7 0][0.0591 21.1 0][0.0689 18.1 0]\n",
                         "('beta2', 'beta1'):\t0.00167\t0.171\t19.3\t0\t0.000811\t1\t55.6\t0\n",
                         "\n"
                     ]
+                },
+                {
+                    "name": "stderr",
+                    "output_type": "stream",
+                    "text": [
+                        "\n"
+                    ]
                 }
             ],
             "source": [
                 "myBiogeme = bio.BIOGEME(myData, dictOfExpressions)\n",
                 "myBiogeme.modelName = 'simpleExample'\n",
                 "results = myBiogeme.estimate(bootstrap=10)\n",
                 "print(results)"
@@ -189,21 +203,21 @@
             "execution_count": 8,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "simpleExample~18.pickle\n"
+                        "simpleExample~12.pickle\n"
                     ]
                 }
             ],
             "source": [
-                "f = results.writePickle()\n",
-                "print(f)"
+                "the_pickle_file = results.writePickle()\n",
+                "print(the_pickle_file)"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Results can be imported from a file previously generated"
@@ -216,35 +230,35 @@
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "\n",
                         "Results for model simpleExample\n",
-                        "Output file (HTML):\t\t\tsimpleExample~14.html\n",
+                        "Output file (HTML):\t\t\tsimpleExample~05.html\n",
                         "Nbr of parameters:\t\t2\n",
                         "Sample size:\t\t\t5\n",
                         "Excluded data:\t\t\t0\n",
-                        "Init log likelihood:\t\t-67.73691\n",
+                        "Init log likelihood:\t\t-67.5536\n",
                         "Final log likelihood:\t\t-67.06549\n",
-                        "Likelihood ratio test (init):\t\t1.342839\n",
-                        "Rho square (init):\t\t\t0.00991\n",
-                        "Rho bar square (init):\t\t\t-0.0196\n",
+                        "Likelihood ratio test (init):\t\t0.9762237\n",
+                        "Rho square (init):\t\t\t0.00723\n",
+                        "Rho bar square (init):\t\t\t-0.0224\n",
                         "Akaike Information Criterion:\t138.131\n",
                         "Bayesian Information Criterion:\t137.3499\n",
-                        "Final gradient norm:\t\t2.887991e-05\n",
-                        "beta1          : -1.27[0.115 -11.1 0][0.0137 -92.8 0][0.0125 -102 0]\n",
-                        "beta2          : 1.25[0.0848 14.7 0][0.0591 21.1 0][0.054 23.1 0]\n",
+                        "Final gradient norm:\t\t0.0001314937\n",
+                        "beta1          : -1.27[0.115 -11.1 0][0.0137 -92.8 0][0.016 -79.5 0]\n",
+                        "beta2          : 1.25[0.0848 14.7 0][0.0591 21.1 0][0.0689 18.1 0]\n",
                         "('beta2', 'beta1'):\t0.00167\t0.171\t19.3\t0\t0.000811\t1\t55.6\t0\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
-                "readResults = res.bioResults(pickleFile=f)\n",
+                "readResults = res.bioResults(pickleFile=the_pickle_file)\n",
                 "print(readResults)"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
@@ -253,80 +267,96 @@
         },
         {
             "cell_type": "code",
             "execution_count": 10,
             "metadata": {},
             "outputs": [
                 {
+                    "name": "stderr",
+                    "output_type": "stream",
+                    "text": [
+                        "/Users/michelbierlaire/ToBackupOnGoogleDrive/github/biogeme/biogeme/results.py:735: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n",
+                        "  h += table.to_latex(float_format=formatting)\n"
+                    ]
+                },
+                {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "%% This file is designed to be included into a LaTeX document\n",
                         "%% See http://www.latex-project.org for information about LaTeX\n",
-                        "%% simpleExample - Report from biogeme 3.2.7 [2021-07-19]\n",
-                        "%% biogeme 3.2.7 [2021-07-19]\n",
+                        "%% simpleExample - Report from biogeme 3.2.9b [2022-06-29]\n",
+                        "%% biogeme 3.2.9b [2022-06-29]\n",
                         "%% Version entirely written in Python\n",
                         "%% Home page: http://biogeme.epfl.ch\n",
                         "%% Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "%% Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n",
-                        "%% This file has automatically been generated on 2021-07-19 11:11:13.007730</p>\n",
+                        "%% This file has automatically been generated on 2022-06-29 19:08:27.917313</p>\n",
                         "\n",
                         "%%Database name: test\n",
                         "\n",
                         "%% General statistics\n",
                         "\\section{General statistics}\n",
                         "\\begin{tabular}{ll}\n",
                         "Number of estimated parameters & 2 \\\\\n",
                         "Sample size & 5 \\\\\n",
                         "Excluded observations & 0 \\\\\n",
-                        "Init log likelihood & -67.73691 \\\\\n",
+                        "Init log likelihood & -67.5536 \\\\\n",
                         "Final log likelihood & -67.06549 \\\\\n",
-                        "Likelihood ratio test for the init. model & 1.342839 \\\\\n",
-                        "Rho-square for the init. model & 0.00991 \\\\\n",
-                        "Rho-square-bar for the init. model & -0.0196 \\\\\n",
+                        "Likelihood ratio test for the init. model & 0.9762237 \\\\\n",
+                        "Rho-square for the init. model & 0.00723 \\\\\n",
+                        "Rho-square-bar for the init. model & -0.0224 \\\\\n",
                         "Akaike Information Criterion & 138.131 \\\\\n",
                         "Bayesian Information Criterion & 137.3499 \\\\\n",
-                        "Final gradient norm & 2.8880E-05 \\\\\n",
-                        "Bootstrapping time & 0:00:00.033336 \\\\\n",
+                        "Final gradient norm & 1.3149E-04 \\\\\n",
+                        "Bootstrapping time & 0:00:00.034716 \\\\\n",
                         "Nbr of threads & 16 \\\\\n",
                         "Algorithm & \\verb$Newton with trust region for simple bound constraints$ \\\\\n",
                         "Proportion analytical hessian & \\verb$100.0%$ \\\\\n",
-                        "Relative projected gradient & \\verb$5.401448e-07$ \\\\\n",
-                        "Relative change & \\verb$2.058044e-06$ \\\\\n",
-                        "Number of iterations & \\verb$3$ \\\\\n",
-                        "Number of function evaluations & \\verb$10$ \\\\\n",
-                        "Number of gradient evaluations & \\verb$4$ \\\\\n",
-                        "Number of hessian evaluations & \\verb$4$ \\\\\n",
-                        "Cause of termination & \\verb$Relative change = 2.06e-06 <= 1e-05$ \\\\\n",
-                        "Optimization time & \\verb$0:00:00.003768$ \\\\\n",
+                        "Relative projected gradient & \\verb$2.390418e-06$ \\\\\n",
+                        "Relative change & \\verb$0.001379638$ \\\\\n",
+                        "Number of iterations & \\verb$2$ \\\\\n",
+                        "Number of function evaluations & \\verb$7$ \\\\\n",
+                        "Number of gradient evaluations & \\verb$3$ \\\\\n",
+                        "Number of hessian evaluations & \\verb$3$ \\\\\n",
+                        "Cause of termination & \\verb$Relative gradient = 2.4e-06 <= 6.1e-06$ \\\\\n",
+                        "Optimization time & \\verb$0:00:00.002434$ \\\\\n",
                         "\\end{tabular}\n",
                         "\n",
                         "%%Parameter estimates\n",
                         "\\section{Parameter estimates}\n",
-                        "\\begin{tabular}{lrrrrrrrrrr}\n",
+                        "\\begin{tabular}{lrrrr}\n",
                         "\\toprule\n",
-                        "{} &  Value &  Std err &  t-test &  p-value &  Rob. Std err &  Rob. t-test &  Rob. p-value &  Bootstrap[10] Std err &  Bootstrap t-test &  Bootstrap p-value \\\\\n",
+                        "{} &  Value &  Rob. Std err &  Rob. t-test &  Rob. p-value \\\\\n",
                         "\\midrule\n",
-                        "beta1 &  -1.27 &    0.115 &   -11.1 &      0.0 &        0.0137 &        -92.8 &           0.0 &                 0.0125 &            -102.0 &                0.0 \\\\\n",
-                        "beta2 &   1.25 &   0.0848 &    14.7 &      0.0 &        0.0591 &         21.1 &           0.0 &                  0.054 &              23.1 &                0.0 \\\\\n",
+                        "beta1 &  -1.27 &        0.0137 &        -92.8 &           0.0 \\\\\n",
+                        "beta2 &   1.25 &        0.0591 &         21.1 &           0.0 \\\\\n",
                         "\\bottomrule\n",
                         "\\end{tabular}\n",
                         "\n",
                         "%%Correlation\n",
                         "\\section{Correlation}\n",
                         "\\begin{tabular}{lrrrrrrrrrrrr}\n",
                         "\\toprule\n",
                         "{} &  Covariance &  Correlation &  t-test &  p-value &  Rob. cov. &  Rob. corr. &  Rob. t-test &  Rob. p-value &  Boot. cov. &  Boot. corr. &  Boot. t-test &  Boot. p-value \\\\\n",
                         "\\midrule\n",
-                        "beta2-beta1 &     0.00167 &        0.171 &    19.3 &      0.0 &   0.000811 &         1.0 &         55.6 &           0.0 &    0.000678 &          1.0 &          60.8 &            0.0 \\\\\n",
+                        "beta2-beta1 &     0.00167 &        0.171 &    19.3 &      0.0 &   0.000811 &         1.0 &         55.6 &           0.0 &      0.0011 &          1.0 &          47.7 &            0.0 \\\\\n",
                         "\\bottomrule\n",
                         "\\end{tabular}\n",
                         "\n"
                     ]
+                },
+                {
+                    "name": "stderr",
+                    "output_type": "stream",
+                    "text": [
+                        "/Users/michelbierlaire/ToBackupOnGoogleDrive/github/biogeme/biogeme/results.py:740: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n",
+                        "  h += table.to_latex(float_format=formatting)\n"
+                    ]
                 }
             ],
             "source": [
                 "print(readResults.getLaTeX())"
             ]
         },
         {
@@ -345,17 +375,17 @@
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "<html>\n",
                         "<head>\n",
                         "<script src=\"http://transp-or.epfl.ch/biogeme/sorttable.js\"></script>\n",
                         "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n",
-                        "<title>simpleExample - Report from biogeme 3.2.7 [2021-07-19]</title>\n",
+                        "<title>simpleExample - Report from biogeme 3.2.9b [2022-06-29]</title>\n",
                         "<meta name=\"keywords\" content=\"biogeme, discrete choice, random utility\">\n",
-                        "<meta name=\"description\" content=\"Report from biogeme 3.2.7 [2021-07-19]\">\n",
+                        "<meta name=\"description\" content=\"Report from biogeme 3.2.9b [2022-06-29]\">\n",
                         "<meta name=\"author\" content=\"{bv.author}\">\n",
                         "<style type=text/css>\n",
                         ".biostyle\n",
                         "\t{font-size:10.0pt;\n",
                         "\tfont-weight:400;\n",
                         "\tfont-style:normal;\n",
                         "\tfont-family:Courier;}\n",
@@ -364,64 +394,64 @@
                         "\tfont-weight:400;\n",
                         "\tfont-style:normal;\n",
                         "\tfont-family:Courier;\n",
                         "        color:red}\n",
                         "</style>\n",
                         "</head>\n",
                         "<body bgcolor=\"#ffffff\">\n",
-                        "<p>biogeme 3.2.7 [2021-07-19]</p>\n",
+                        "<p>biogeme 3.2.9b [2022-06-29]</p>\n",
                         "<p><a href=\"https://www.python.org/\" target=\"_blank\">Python</a> package</p>\n",
                         "<p>Home page: <a href=\"http://biogeme.epfl.ch\" target=\"_blank\">http://biogeme.epfl.ch</a></p>\n",
                         "<p>Submit questions to <a href=\"https://groups.google.com/d/forum/biogeme\" target=\"_blank\">https://groups.google.com/d/forum/biogeme</a></p>\n",
                         "<p><a href=\"http://people.epfl.ch/michel.bierlaire\">Michel Bierlaire</a>, <a href=\"http://transp-or.epfl.ch\">Transport and Mobility Laboratory</a>, <a href=\"http://www.epfl.ch\">Ecole Polytechnique F&#233;d&#233;rale de Lausanne (EPFL)</a></p>\n",
-                        "<p>This file has automatically been generated on 2021-07-19 11:11:13.038612</p>\n",
+                        "<p>This file has automatically been generated on 2022-06-29 19:08:28.093081</p>\n",
                         "<table>\n",
-                        "<tr class=biostyle><td align=right><strong>Report file</strong>:\t</td><td>simpleExample~14.html</td></tr>\n",
+                        "<tr class=biostyle><td align=right><strong>Report file</strong>:\t</td><td>simpleExample~05.html</td></tr>\n",
                         "<tr class=biostyle><td align=right><strong>Database name</strong>:\t</td><td>test</td></tr>\n",
                         "</table>\n",
                         "<h1>Estimation report</h1>\n",
                         "<table border=\"0\">\n",
                         "<tr class=biostyle><td align=right ><strong>Number of estimated parameters</strong>: </td> <td>2</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Sample size</strong>: </td> <td>5</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Excluded observations</strong>: </td> <td>0</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Init log likelihood</strong>: </td> <td>-67.73691</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Init log likelihood</strong>: </td> <td>-67.5536</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Final log likelihood</strong>: </td> <td>-67.06549</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Likelihood ratio test for the init. model</strong>: </td> <td>1.342839</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Rho-square for the init. model</strong>: </td> <td>0.00991</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Rho-square-bar for the init. model</strong>: </td> <td>-0.0196</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Likelihood ratio test for the init. model</strong>: </td> <td>0.9762237</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Rho-square for the init. model</strong>: </td> <td>0.00723</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Rho-square-bar for the init. model</strong>: </td> <td>-0.0224</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Akaike Information Criterion</strong>: </td> <td>138.131</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Bayesian Information Criterion</strong>: </td> <td>137.3499</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Final gradient norm</strong>: </td> <td>2.8880E-05</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Bootstrapping time</strong>: </td> <td>0:00:00.033336</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Final gradient norm</strong>: </td> <td>1.3149E-04</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Bootstrapping time</strong>: </td> <td>0:00:00.034716</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Nbr of threads</strong>: </td> <td>16</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Algorithm</strong>: </td> <td>Newton with trust region for simple bound constraints</td></tr>\n",
                         "<tr class=biostyle><td align=right ><strong>Proportion analytical hessian</strong>: </td> <td>100.0%</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Relative projected gradient</strong>: </td> <td>5.401448e-07</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Relative change</strong>: </td> <td>2.0580436087508352e-06</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Number of iterations</strong>: </td> <td>3</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Number of function evaluations</strong>: </td> <td>10</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Number of gradient evaluations</strong>: </td> <td>4</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Number of hessian evaluations</strong>: </td> <td>4</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Cause of termination</strong>: </td> <td>Relative change = 2.06e-06 <= 1e-05</td></tr>\n",
-                        "<tr class=biostyle><td align=right ><strong>Optimization time</strong>: </td> <td>0:00:00.003768</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Relative projected gradient</strong>: </td> <td>2.390418e-06</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Relative change</strong>: </td> <td>0.0013796384032595055</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Number of iterations</strong>: </td> <td>2</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Number of function evaluations</strong>: </td> <td>7</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Number of gradient evaluations</strong>: </td> <td>3</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Number of hessian evaluations</strong>: </td> <td>3</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Cause of termination</strong>: </td> <td>Relative gradient = 2.4e-06 <= 6.1e-06</td></tr>\n",
+                        "<tr class=biostyle><td align=right ><strong>Optimization time</strong>: </td> <td>0:00:00.002434</td></tr>\n",
                         "</table>\n",
                         "<h1>Estimated parameters</h1>\n",
                         "<table border=\"1\">\n",
-                        "<tr class=biostyle><th>Name</th><th>Value</th><th>Std err</th><th>t-test</th><th>p-value</th><th>Rob. Std err</th><th>Rob. t-test</th><th>Rob. p-value</th><th>Bootstrap[10] Std err</th><th>Bootstrap t-test</th><th>Bootstrap p-value</th></tr>\n",
-                        "<tr class=biostyle><td>beta1</td><td>-1.27</td><td>0.115</td><td>-11.1</td><td>0</td><td>0.0137</td><td>-92.8</td><td>0</td><td>0.0125</td><td>-102</td><td>0</td></tr>\n",
-                        "<tr class=biostyle><td>beta2</td><td>1.25</td><td>0.0848</td><td>14.7</td><td>0</td><td>0.0591</td><td>21.1</td><td>0</td><td>0.054</td><td>23.1</td><td>0</td></tr>\n",
+                        "<tr class=biostyle><th>Name</th><th>Value</th><th>Rob. Std err</th><th>Rob. t-test</th><th>Rob. p-value</th></tr>\n",
+                        "<tr class=biostyle><td>beta1</td><td>-1.27</td><td>0.0137</td><td>-92.8</td><td>0</td></tr>\n",
+                        "<tr class=biostyle><td>beta2</td><td>1.25</td><td>0.0591</td><td>21.1</td><td>0</td></tr>\n",
                         "</table>\n",
                         "<h2>Correlation of coefficients</h2>\n",
                         "<table border=\"1\">\n",
                         "<tr class=biostyle><th>Coefficient1</th><th>Coefficient2</th><th>Covariance</th><th>Correlation</th><th>t-test</th><th>p-value</th><th>Rob. cov.</th><th>Rob. corr.</th><th>Rob. t-test</th><th>Rob. p-value</th><th>Boot. cov.</th><th>Boot. corr.</th><th>Boot. t-test</th><th>Boot. p-value</th></tr>\n",
-                        "<tr class=biostyle><td>beta2</td><td>beta1</td><td>0.00167</td><td>0.171</td><td>19.3</td><td>0</td><td>0.000811</td><td>1</td><td>55.6</td><td>0</td><td>0.000678</td><td>1</td><td>60.8</td><td>0</td></tr>\n",
+                        "<tr class=biostyle><td>beta2</td><td>beta1</td><td>0.00167</td><td>0.171</td><td>19.3</td><td>0</td><td>0.000811</td><td>1</td><td>55.6</td><td>0</td><td>0.0011</td><td>1</td><td>47.7</td><td>0</td></tr>\n",
                         "</table>\n",
-                        "<p>Smallest eigenvalue: 73.0541</p>\n",
+                        "<p>Smallest eigenvalue: 73.054</p>\n",
                         "<p>Largest eigenvalue: 147.802</p>\n",
-                        "<p>Condition number: 2.02318</p>\n",
+                        "<p>Condition number: 2.02319</p>\n",
                         "</html>\n"
                     ]
                 }
             ],
             "source": [
                 "print(readResults.getHtml())"
             ]
@@ -440,23 +470,23 @@
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
                             "{'Number of estimated parameters': (2, ''),\n",
                             " 'Sample size': (5, ''),\n",
                             " 'Excluded observations': (0, ''),\n",
-                            " 'Init log likelihood': (-67.73690998796737, '.7g'),\n",
-                            " 'Final log likelihood': (-67.06549047946919, '.7g'),\n",
-                            " 'Likelihood ratio test for the init. model': (1.3428390169963507, '.7g'),\n",
-                            " 'Rho-square for the init. model': (0.009912166182624027, '.3g'),\n",
-                            " 'Rho-square-bar for the init. model': (-0.019613833753825416, '.3g'),\n",
-                            " 'Akaike Information Criterion': (138.13098095893838, '.7g'),\n",
-                            " 'Bayesian Information Criterion': (137.3498567838066, '.7g'),\n",
-                            " 'Final gradient norm': (2.8879908411669447e-05, '.4E'),\n",
-                            " 'Bootstrapping time': (datetime.timedelta(microseconds=33336), ''),\n",
+                            " 'Init log likelihood': (-67.55360233858966, '.7g'),\n",
+                            " 'Final log likelihood': (-67.06549047952232, '.7g'),\n",
+                            " 'Likelihood ratio test for the init. model': (0.976223718134662, '.7g'),\n",
+                            " 'Rho-square for the init. model': (0.0072255489295868225, '.3g'),\n",
+                            " 'Rho-square-bar for the init. model': (-0.022380570222663154, '.3g'),\n",
+                            " 'Akaike Information Criterion': (138.13098095904465, '.7g'),\n",
+                            " 'Bayesian Information Criterion': (137.34985678391286, '.7g'),\n",
+                            " 'Final gradient norm': (0.00013149371433604645, '.4E'),\n",
+                            " 'Bootstrapping time': (datetime.timedelta(microseconds=34716), ''),\n",
                             " 'Nbr of threads': (16, '')}"
                         ]
                     },
                     "execution_count": 12,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
@@ -496,23 +526,23 @@
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
                         "Number of estimated parameters:\t2\n",
                         "Sample size:\t5\n",
                         "Excluded observations:\t0\n",
-                        "Init log likelihood:\t-67.73691\n",
+                        "Init log likelihood:\t-67.5536\n",
                         "Final log likelihood:\t-67.06549\n",
-                        "Likelihood ratio test for the init. model:\t1.342839\n",
-                        "Rho-square for the init. model:\t0.00991\n",
-                        "Rho-square-bar for the init. model:\t-0.0196\n",
+                        "Likelihood ratio test for the init. model:\t0.9762237\n",
+                        "Rho-square for the init. model:\t0.00723\n",
+                        "Rho-square-bar for the init. model:\t-0.0224\n",
                         "Akaike Information Criterion:\t138.131\n",
                         "Bayesian Information Criterion:\t137.3499\n",
-                        "Final gradient norm:\t2.8880E-05\n",
-                        "Bootstrapping time:\t0:00:00.033336\n",
+                        "Final gradient norm:\t1.3149E-04\n",
+                        "Bootstrapping time:\t0:00:00.034716\n",
                         "Nbr of threads:\t16\n",
                         "\n"
                     ]
                 }
             ],
             "source": [
                 "print(results.printGeneralStatistics())"
@@ -548,68 +578,42 @@
                             "    }\n",
                             "</style>\n",
                             "<table border=\"1\" class=\"dataframe\">\n",
                             "  <thead>\n",
                             "    <tr style=\"text-align: right;\">\n",
                             "      <th></th>\n",
                             "      <th>Value</th>\n",
-                            "      <th>Std err</th>\n",
-                            "      <th>t-test</th>\n",
-                            "      <th>p-value</th>\n",
                             "      <th>Rob. Std err</th>\n",
                             "      <th>Rob. t-test</th>\n",
                             "      <th>Rob. p-value</th>\n",
-                            "      <th>Bootstrap[10] Std err</th>\n",
-                            "      <th>Bootstrap t-test</th>\n",
-                            "      <th>Bootstrap p-value</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>beta1</th>\n",
                             "      <td>-1.273264</td>\n",
-                            "      <td>0.115144</td>\n",
-                            "      <td>-11.057995</td>\n",
-                            "      <td>0.0</td>\n",
                             "      <td>0.013724</td>\n",
-                            "      <td>-92.777227</td>\n",
-                            "      <td>0.0</td>\n",
-                            "      <td>0.012541</td>\n",
-                            "      <td>-101.526827</td>\n",
+                            "      <td>-92.776307</td>\n",
                             "      <td>0.0</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>beta2</th>\n",
-                            "      <td>1.248769</td>\n",
-                            "      <td>0.084830</td>\n",
-                            "      <td>14.720837</td>\n",
-                            "      <td>0.0</td>\n",
+                            "      <td>1.248770</td>\n",
                             "      <td>0.059086</td>\n",
-                            "      <td>21.134798</td>\n",
-                            "      <td>0.0</td>\n",
-                            "      <td>0.054043</td>\n",
-                            "      <td>23.106935</td>\n",
+                            "      <td>21.134842</td>\n",
                             "      <td>0.0</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "          Value   Std err     t-test  p-value  Rob. Std err  Rob. t-test  \\\n",
-                            "beta1 -1.273264  0.115144 -11.057995      0.0      0.013724   -92.777227   \n",
-                            "beta2  1.248769  0.084830  14.720837      0.0      0.059086    21.134798   \n",
-                            "\n",
-                            "       Rob. p-value  Bootstrap[10] Std err  Bootstrap t-test  \\\n",
-                            "beta1           0.0               0.012541       -101.526827   \n",
-                            "beta2           0.0               0.054043         23.106935   \n",
-                            "\n",
-                            "       Bootstrap p-value  \n",
-                            "beta1                0.0  \n",
-                            "beta2                0.0  "
+                            "          Value  Rob. Std err  Rob. t-test  Rob. p-value\n",
+                            "beta1 -1.273264      0.013724   -92.776307           0.0\n",
+                            "beta2  1.248770      0.059086    21.134842           0.0"
                         ]
                     },
                     "execution_count": 14,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -665,38 +669,38 @@
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>beta2-beta1</th>\n",
                             "      <td>0.001671</td>\n",
                             "      <td>0.171121</td>\n",
-                            "      <td>19.280038</td>\n",
+                            "      <td>19.28005</td>\n",
                             "      <td>0.0</td>\n",
                             "      <td>0.000811</td>\n",
                             "      <td>1.0</td>\n",
-                            "      <td>55.597868</td>\n",
+                            "      <td>55.598175</td>\n",
                             "      <td>0.0</td>\n",
-                            "      <td>0.000678</td>\n",
-                            "      <td>0.999969</td>\n",
-                            "      <td>60.768382</td>\n",
+                            "      <td>0.001103</td>\n",
+                            "      <td>0.999955</td>\n",
+                            "      <td>47.67909</td>\n",
                             "      <td>0.0</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
-                            "             Covariance  Correlation     t-test  p-value  Rob. cov.  \\\n",
-                            "beta2-beta1    0.001671     0.171121  19.280038      0.0   0.000811   \n",
+                            "             Covariance  Correlation    t-test  p-value  Rob. cov.  \\\n",
+                            "beta2-beta1    0.001671     0.171121  19.28005      0.0   0.000811   \n",
                             "\n",
                             "             Rob. corr.  Rob. t-test  Rob. p-value  Boot. cov.  Boot. corr.  \\\n",
-                            "beta2-beta1         1.0    55.597868           0.0    0.000678     0.999969   \n",
+                            "beta2-beta1         1.0    55.598175           0.0    0.001103     0.999955   \n",
                             "\n",
                             "             Boot. t-test  Boot. p-value  \n",
-                            "beta2-beta1     60.768382            0.0  "
+                            "beta2-beta1      47.67909            0.0  "
                         ]
                     },
                     "execution_count": 15,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -715,15 +719,15 @@
             "cell_type": "code",
             "execution_count": 16,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "{'beta1': -1.2732636016571277, 'beta2': 1.2487688778887986}"
+                            "{'beta1': -1.2732640875536856, 'beta2': 1.248769699775698}"
                         ]
                     },
                     "execution_count": 16,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -735,15 +739,15 @@
             "cell_type": "code",
             "execution_count": 17,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "{'beta2': 1.2487688778887986}"
+                            "{'beta2': 1.248769699775698}"
                         ]
                     },
                     "execution_count": 17,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -921,30 +925,30 @@
                             "      <th>beta1</th>\n",
                             "      <th>beta2</th>\n",
                             "    </tr>\n",
                             "  </thead>\n",
                             "  <tbody>\n",
                             "    <tr>\n",
                             "      <th>beta1</th>\n",
-                            "      <td>0.000157</td>\n",
-                            "      <td>0.000678</td>\n",
+                            "      <td>0.000256</td>\n",
+                            "      <td>0.001103</td>\n",
                             "    </tr>\n",
                             "    <tr>\n",
                             "      <th>beta2</th>\n",
-                            "      <td>0.000678</td>\n",
-                            "      <td>0.002921</td>\n",
+                            "      <td>0.001103</td>\n",
+                            "      <td>0.004748</td>\n",
                             "    </tr>\n",
                             "  </tbody>\n",
                             "</table>\n",
                             "</div>"
                         ],
                         "text/plain": [
                             "          beta1     beta2\n",
-                            "beta1  0.000157  0.000678\n",
-                            "beta2  0.000678  0.002921"
+                            "beta1  0.000256  0.001103\n",
+                            "beta2  0.001103  0.004748"
                         ]
                     },
                     "execution_count": 20,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -963,24 +967,24 @@
             "cell_type": "code",
             "execution_count": 21,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "[{'beta1': -1.277712611634195, 'beta2': 1.2295568140732054},\n",
-                            " {'beta1': -1.277712611634195, 'beta2': 1.2295568140732054},\n",
-                            " {'beta1': -1.2538348107689954, 'beta2': 1.3316123801282882},\n",
-                            " {'beta1': -1.2823937362828728, 'beta2': 1.2091956038603253},\n",
-                            " {'beta1': -1.2573978799535253, 'beta2': 1.3165120810084867},\n",
-                            " {'beta1': -1.2649797742016953, 'beta2': 1.2842631765105148},\n",
-                            " {'beta1': -1.2925578214634943, 'beta2': 1.164322217511046},\n",
-                            " {'beta1': -1.2732636016571277, 'beta2': 1.2487688778887986},\n",
-                            " {'beta1': -1.2611085813021108, 'beta2': 1.300751700209863},\n",
-                            " {'beta1': -1.2823937362828728, 'beta2': 1.2091956038603253}]"
+                            "[{'beta1': -1.2925578214672562, 'beta2': 1.1643222175105554},\n",
+                            " {'beta1': -1.2471072737744642, 'beta2': 1.3600596419340159},\n",
+                            " {'beta1': -1.2777126116343736, 'beta2': 1.229556814073922},\n",
+                            " {'beta1': -1.2732640875536856, 'beta2': 1.248769699775698},\n",
+                            " {'beta1': -1.2690260405244063, 'beta2': 1.2669668838387975},\n",
+                            " {'beta1': -1.2471072737744642, 'beta2': 1.3600596419340159},\n",
+                            " {'beta1': -1.2732640875536856, 'beta2': 1.248769699775698},\n",
+                            " {'beta1': -1.257397879949385, 'beta2': 1.3165120809947877},\n",
+                            " {'beta1': -1.2925578214672562, 'beta2': 1.1643222175105554},\n",
+                            " {'beta1': -1.2690260405244063, 'beta2': 1.2669668838387977}]"
                         ]
                     },
                     "execution_count": 21,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -1000,15 +1004,15 @@
             "cell_type": "code",
             "execution_count": 22,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'                                                                  simpleExample\\nFrom biogeme 3.2.7                                      2021-07-19 11:11:13  \\nEND\\n   0      beta1 F  -1.273263601657e+00 +1.372388079639e-02\\n   0      beta2 F  +1.248768877889e+00 +5.908591637054e-02\\n  -1\\n       5                  0                   0 -6.706549047947e+01\\n   0   0  2021-07-19 11:11:13\\n  99999\\n'"
+                            "'                                                                  simpleExample\\nFrom biogeme 3.2.9b                                     2022-06-29 19:08:28  \\nEND\\n   0      beta1 F  -1.273264087554e+00 +1.372402216626e-02\\n   0      beta2 F  +1.248769699776e+00 +5.908583062960e-02\\n  -1\\n       5                  0                   0 -6.706549047952e+01\\n   0   0  2022-06-29 19:08:28\\n  99999\\n'"
                         ]
                     },
                     "execution_count": 22,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -1023,53 +1027,246 @@
                 "# Miscellaneous functions"
             ]
         },
         {
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Calculation of the $p$-value"
+                "## Likelihood ratio test"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "Let's first estimate a constrained model"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": 23,
             "metadata": {},
             "outputs": [
                 {
+                    "name": "stdout",
+                    "output_type": "stream",
+                    "text": [
+                        "Results for model simpleExampleConstrained\n",
+                        "Nbr of parameters:\t\t1\n",
+                        "Sample size:\t\t\t5\n",
+                        "Excluded data:\t\t\t0\n",
+                        "Final log likelihood:\t\t-114.7702\n",
+                        "Akaike Information Criterion:\t231.5403\n",
+                        "Bayesian Information Criterion:\t231.1498\n",
+                        "\n"
+                    ]
+                }
+            ],
+            "source": [
+                "beta2_constrained = Beta('beta2_constrained', 2.0, -3, 10, 1)\n",
+                "likelihood_constrained = -beta1**2 * Variable1 - exp(beta2_constrained * beta1) * \\\n",
+                "    Variable2 - beta2_constrained**4\n",
+                "myBiogemeConstrained = bio.BIOGEME(myData, likelihood_constrained)\n",
+                "myBiogemeConstrained.modelName = 'simpleExampleConstrained'\n",
+                "results_constrained = myBiogemeConstrained.estimate()\n",
+                "print(results_constrained.shortSummary())"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "We can now perform a likelihood ratio test."
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 24,
+            "metadata": {},
+            "outputs": [
+                {
+                    "data": {
+                        "text/plain": [
+                            "LRTuple(message='H0 can be rejected at level 0.95', statistic=95.4093641320429, threshold=3.841458820694124)"
+                        ]
+                    },
+                    "execution_count": 24,
+                    "metadata": {},
+                    "output_type": "execute_result"
+                }
+            ],
+            "source": [
+                "results.likelihood_ratio_test(results_constrained, 0.95)"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "## Calculation of the $p$-value"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 25,
+            "metadata": {},
+            "outputs": [
+                {
                     "data": {
                         "text/plain": [
                             "0.04999579029644097"
                         ]
                     },
-                    "execution_count": 23,
+                    "execution_count": 25,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "res.calcPValue(1.96)"
             ]
+        },
+        {
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "# Compilation of results"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 26,
+            "metadata": {},
+            "outputs": [],
+            "source": [
+                "dict_of_results = {'Model A': readResults, 'Model B': the_pickle_file}"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 27,
+            "metadata": {},
+            "outputs": [],
+            "source": [
+                "df = res.compileEstimationResults(dict_of_results)"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": 28,
+            "metadata": {},
+            "outputs": [
+                {
+                    "data": {
+                        "text/html": [
+                            "<div>\n",
+                            "<style scoped>\n",
+                            "    .dataframe tbody tr th:only-of-type {\n",
+                            "        vertical-align: middle;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe tbody tr th {\n",
+                            "        vertical-align: top;\n",
+                            "    }\n",
+                            "\n",
+                            "    .dataframe thead th {\n",
+                            "        text-align: right;\n",
+                            "    }\n",
+                            "</style>\n",
+                            "<table border=\"1\" class=\"dataframe\">\n",
+                            "  <thead>\n",
+                            "    <tr style=\"text-align: right;\">\n",
+                            "      <th></th>\n",
+                            "      <th>Model A</th>\n",
+                            "      <th>Model B</th>\n",
+                            "    </tr>\n",
+                            "  </thead>\n",
+                            "  <tbody>\n",
+                            "    <tr>\n",
+                            "      <th>Number of estimated parameters</th>\n",
+                            "      <td>2.000000</td>\n",
+                            "      <td>2.000000</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>Sample size</th>\n",
+                            "      <td>5.000000</td>\n",
+                            "      <td>5.000000</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>Final log likelihood</th>\n",
+                            "      <td>-67.065490</td>\n",
+                            "      <td>-67.065490</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>Akaike Information Criterion</th>\n",
+                            "      <td>138.130981</td>\n",
+                            "      <td>138.130981</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>Bayesian Information Criterion</th>\n",
+                            "      <td>137.349857</td>\n",
+                            "      <td>137.349857</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta1</th>\n",
+                            "      <td>-1.273264</td>\n",
+                            "      <td>-1.273264</td>\n",
+                            "    </tr>\n",
+                            "    <tr>\n",
+                            "      <th>beta2</th>\n",
+                            "      <td>1.248770</td>\n",
+                            "      <td>1.248770</td>\n",
+                            "    </tr>\n",
+                            "  </tbody>\n",
+                            "</table>\n",
+                            "</div>"
+                        ],
+                        "text/plain": [
+                            "                                   Model A     Model B\n",
+                            "Number of estimated parameters    2.000000    2.000000\n",
+                            "Sample size                       5.000000    5.000000\n",
+                            "Final log likelihood            -67.065490  -67.065490\n",
+                            "Akaike Information Criterion    138.130981  138.130981\n",
+                            "Bayesian Information Criterion  137.349857  137.349857\n",
+                            "beta1                            -1.273264   -1.273264\n",
+                            "beta2                             1.248770    1.248770"
+                        ]
+                    },
+                    "execution_count": 28,
+                    "metadata": {},
+                    "output_type": "execute_result"
+                }
+            ],
+            "source": [
+                "df"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": null,
+            "metadata": {},
+            "outputs": [],
+            "source": []
         }
     ],
     "metadata": {
         "kernelspec": {
-            "display_name": "Python 3",
+            "display_name": "Python 3 (ipykernel)",
             "language": "python",
             "name": "python3"
         },
         "language_info": {
             "codemirror_mode": {
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.9.5"
+            "version": "3.10.0"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 2
 }
```

### Comparing `biogeme-3.2.8/examples/notebooks/biogeme.version.ipynb` & `biogeme-3.2.9/examples/notebooks/.ipynb_checkpoints/biogeme.version-checkpoint.ipynb`

 * *Files 8% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9995114087301588%*

 * *Differences: {"'cells'": "{3: {'outputs': {0: {'text': ['2021-08-04 16:40:52.059009\\n']}}}, 4: {'outputs': {0: "*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.8 [2021-08-04]\\n')], delete: [0]}}}}, 6: "*

 * *            '{\'outputs\': {0: {\'data\': {\'text/plain\': ["\'3.2.8\'"]}}}}, 8: {\'outputs\': {0: '*

 * *            "{'text': {insert: [(0, 'biogeme 3.2.8 [2021-08-04]\\n')], delete: [0]}}}}, 10: "*

 * *            "{'outputs': {0: {'text': {insert: [(0, '<p>biogeme 3.2.8 [2021-08-04]</p>\\n')], "*

 * *            "delete: [0]}}} […]*

```diff
@@ -26,15 +26,15 @@
             "execution_count": 1,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "2021-07-19 11:11:42.295725\n"
+                        "2021-08-04 16:40:52.059009\n"
                     ]
                 }
             ],
             "source": [
                 "import datetime\n",
                 "print(datetime.datetime.now())"
             ]
@@ -44,15 +44,15 @@
             "execution_count": 2,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.8 [2021-08-04]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -73,15 +73,15 @@
             "cell_type": "code",
             "execution_count": 3,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/plain": [
-                            "'3.2.7'"
+                            "'3.2.8'"
                         ]
                     },
                     "execution_count": 3,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
@@ -101,15 +101,15 @@
             "execution_count": 4,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "biogeme 3.2.7 [2021-07-19]\n",
+                        "biogeme 3.2.8 [2021-08-04]\n",
                         "Version entirely written in Python\n",
                         "Home page: http://biogeme.epfl.ch\n",
                         "Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -130,15 +130,15 @@
             "execution_count": 5,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "<p>biogeme 3.2.7 [2021-07-19]</p>\n",
+                        "<p>biogeme 3.2.8 [2021-08-04]</p>\n",
                         "<p><a href=\"https://www.python.org/\" target=\"_blank\">Python</a> package</p>\n",
                         "<p>Home page: <a href=\"http://biogeme.epfl.ch\" target=\"_blank\">http://biogeme.epfl.ch</a></p>\n",
                         "<p>Submit questions to <a href=\"https://groups.google.com/d/forum/biogeme\" target=\"_blank\">https://groups.google.com/d/forum/biogeme</a></p>\n",
                         "<p><a href=\"http://people.epfl.ch/michel.bierlaire\">Michel Bierlaire</a>, <a href=\"http://transp-or.epfl.ch\">Transport and Mobility Laboratory</a>, <a href=\"http://www.epfl.ch\">Ecole Polytechnique F&#233;d&#233;rale de Lausanne (EPFL)</a></p>\n",
                         "\n"
                     ]
                 }
@@ -159,15 +159,15 @@
             "execution_count": 6,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "%% biogeme 3.2.7 [2021-07-19]\n",
+                        "%% biogeme 3.2.8 [2021-08-04]\n",
                         "%% Version entirely written in Python\n",
                         "%% Home page: http://biogeme.epfl.ch\n",
                         "%% Submit questions to https://groups.google.com/d/forum/biogeme\n",
                         "%% Michel Bierlaire, Transport and Mobility Laboratory, Ecole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL)\n",
                         "\n"
                     ]
                 }
@@ -188,15 +188,15 @@
             "execution_count": 7,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stdout",
                     "output_type": "stream",
                     "text": [
-                        "3.2.7\n"
+                        "3.2.8\n"
                     ]
                 }
             ],
             "source": [
                 "print(ver.__version__)"
             ]
         }
```

### Comparing `biogeme-3.2.8/examples/notebooks/swissmetro.dat` & `biogeme-3.2.9/examples/notebooks/swissmetro.dat`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/swissmetro/.ipynb_checkpoints/01logit-checkpoint.ipynb` & `biogeme-3.2.9/examples/swissmetro/.ipynb_checkpoints/01logit-checkpoint.ipynb`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/swissmetro/.ipynb_checkpoints/scitas-checkpoint.ipynb` & `biogeme-3.2.9/examples/swissmetro/.ipynb_checkpoints/scitas-checkpoint.ipynb`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/swissmetro/01logit.py` & `biogeme-3.2.9/examples/workingNotToDistribute/01logit.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,19 +7,19 @@
  Three alternatives: Train, Car and Swissmetro
  SP data
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-from biogeme import models
+import biogeme.models as models
 from biogeme.expressions import Beta
 
 # Read the data
-df = pd.read_csv('swissmetro.dat', sep='\t')
+df = pd.read_csv('swissmetro.dat', '\t')
 database = db.Database('swissmetro', df)
 
 # The following statement allows you to use the names of the
 # variable as Python variable.
 globals().update(database.variables)
 
 # Removing some observations
@@ -43,34 +43,41 @@
 TRAIN_COST_SCALED = TRAIN_COST / 100
 SM_TT_SCALED = SM_TT / 100
 SM_COST_SCALED = SM_COST / 100
 CAR_TT_SCALED = CAR_TT / 100
 CAR_CO_SCALED = CAR_CO / 100
 
 # Definition of the utility functions
-V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
-V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+V1 = ASC_TRAIN + \
+     B_TIME * TRAIN_TT_SCALED + \
+     B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + \
+     B_TIME * SM_TT_SCALED + \
+     B_COST * SM_COST_SCALED
+V3 = ASC_CAR + \
+     B_TIME * CAR_TT_SCALED + \
+     B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1, 2: V2, 3: V3}
+V = {1: V1,
+     2: V2,
+     3: V3}
 
 # Associate the availability conditions with the alternatives
-av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP,
+      2: SM_AV,
+      3: CAR_AV_SP}
 
 # Definition of the model. This is the contribution of each
 # observation to the log likelihood function.
 logprob = models.loglogit(V, av, CHOICE)
 
 # Create the Biogeme object
 biogeme = bio.BIOGEME(database, logprob)
 biogeme.modelName = '01logit'
 
-# Calculate the null log likelihood for reporting.
-biogeme.calculateNullLoglikelihood(av)
-
 # Estimate the parameters
 results = biogeme.estimate()
 
 # Get the results in a pandas table
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/01logitBis.py` & `biogeme-3.2.9/examples/workingNotToDistribute/12panel.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,147 +1,132 @@
-"""File 01logitBis.py
+"""File 12panel.py
 
 :author: Michel Bierlaire, EPFL
-:date: Thu Sep  6 15:14:39 2018
-
- Example of a logit model.
-
-Same as 01logit, using bioLinearUtility, and introducing some options
- and features.  Three alternatives: Train, Car and Swissmetro SP data
+:date: Sun Sep  8 18:55:38 2019
 
+ Example of a mixture of logit models, using Monte-Carlo integration.
+ The datafile is organized as panel data.
+ Three alternatives: Train, Car and Swissmetro
+ SP data
 """
-import pandas as pd
 
-import biogeme.biogeme as bio
+import pandas as pd
 import biogeme.database as db
-from biogeme import models
-import biogeme.optimization as opt
+import biogeme.biogeme as bio
+import biogeme.models as models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable, bioLinearUtility
+from biogeme.expressions import Beta, DefineVariable, bioDraws, \
+    PanelLikelihoodTrajectory, MonteCarlo, log
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
+# They are organized as panel data. The variable ID identifies each individual.
+database.panel("ID")
+
 # The Pandas data structure is available as database.data. Use all the
-# Pandas functions to investigate the database. For example:
-# print(database.data.describe())
+# Pandas functions to invesigate the database
+#print(database.data.describe())
 
 # The following statement allows you to use the names of the variable
 # as Python variable.
 globals().update(database.variables)
 
 # Removing some observations can be done directly using pandas.
-# remove = (((database.data.PURPOSE != 1) &
+#remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
-# database.data.drop(database.data[remove].index,inplace=True)
+#database.data.drop(database.data[remove].index,inplace=True)
 
 # Here we use the "biogeme" way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
+
 # Parameters to be estimated
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+# Define a random parameter, normally distributed across individuals,
+# designed to be used for Monte-Carlo simulation
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+
+# It is advised not to use 0 as starting value for the following parameter.
+B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
+B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL_ANTI')
+
+# We do the same for the constants, to address serial correlation.
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_CAR_S = Beta('ASC_CAR_S', 1, None, None, 0)
+ASC_CAR_RND = ASC_CAR + ASC_CAR_S * bioDraws('ASC_CAR_RND', 'NORMAL_ANTI')
+
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
-ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+ASC_TRAIN_S = Beta('ASC_TRAIN_S', 1, None, None, 0)
+ASC_TRAIN_RND = ASC_TRAIN + ASC_TRAIN_S * bioDraws('ASC_TRAIN_RND', 'NORMAL_ANTI')
 
-# We use starting values estimated from a previous run
-B_TIME = Beta('B_TIME', -1.28, None, None, 0)
-B_COST = Beta('B_COST', -1.08, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+ASC_SM_S = Beta('ASC_SM_S', 1, None, None, 0)
+ASC_SM_RND = ASC_SM + ASC_SM_S * bioDraws('ASC_SM_RND', 'NORMAL_ANTI')
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
-# Definition of new variables by adding columns to the database.
-# This is recommended for estimation. And not recommended for simulation.
+# Definition of new variables: adding columns to the database
 CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
 TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
 TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
-)
+TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED', TRAIN_COST / 100, database)
 SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
 SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
 CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
 CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
 
 # Definition of the utility functions
-terms1 = [(B_TIME, TRAIN_TT_SCALED), (B_COST, TRAIN_COST_SCALED)]
-V1 = ASC_TRAIN + bioLinearUtility(terms1)
-
-terms2 = [(B_TIME, SM_TT_SCALED), (B_COST, SM_COST_SCALED)]
-V2 = ASC_SM + bioLinearUtility(terms2)
-
-terms3 = [(B_TIME, CAR_TT_SCALED), (B_COST, CAR_CO_SCALED)]
-V3 = ASC_CAR + bioLinearUtility(terms3)
+V1 = ASC_TRAIN_RND + \
+     B_TIME_RND * TRAIN_TT_SCALED + \
+     B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM_RND + \
+     B_TIME_RND * SM_TT_SCALED + \
+     B_COST * SM_COST_SCALED
+V3 = ASC_CAR_RND + \
+     B_TIME_RND * CAR_TT_SCALED + \
+     B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1, 2: V2, 3: V3}
+V = {1: V1,
+     2: V2,
+     3: V3}
 
 # Associate the availability conditions with the alternatives
-av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP,
+      2: SM_AV,
+      3: CAR_AV_SP}
+
+# Conditional to the random parameters, the likelihood of one observation is
+# given by the logit model (called the kernel)
+obsprob = models.logit(V, av, CHOICE)
+
+# Conditional to the random parameters, the likelihood of all observations for
+# one individual (the trajectory) is the product of the likelihood of
+# each observation.
+condprobIndiv = obsprob
 
-# Definition of the model. This is the contribution of each
-# observation to the log likelihood function.
-logprob = models.loglogit(V, av, CHOICE)
+# We integrate over the random parameters using Monte-Carlo
+logprob = log(MonteCarlo(condprobIndiv))
 
 # Define level of verbosity
 logger = msg.bioMessage()
-# logger.setSilent()
-# logger.setWarning()
-logger.setGeneral()
-# logger.setDetailed()
-
-
-# These notes will be included as such in the report file.
-userNotes = (
-    'Example of a logit model with three alternatives: Train, Car and'
-    ' Swissmetro. Same as 01logit, using bioLinearUtility, and '
-    'introducing some options and features.'
-)
+#logger.setSilent()
+#logger.setWarning()
+#logger.setGeneral()
+logger.setDetailed()
+#logger.setDebug()
 
 # Create the Biogeme object
-biogeme = bio.BIOGEME(
-    database, logprob, numberOfThreads=2, userNotes=userNotes
-)
-
-# As we have used starting values different from 0, the initial model
-# is not the equal probability model. If we want to include the latter
-# in the results, we need to calculate its log likelihood.
-biogeme.calculateNullLoglikelihood(av)
-
-biogeme.modelName = '01logitBis'
-biogeme.saveIterations = False
-
-# Estimate the parameters
-results = biogeme.estimate(
-    bootstrap=100,
-    algorithm=opt.bioNewton,
-    algoParameters={'maxiter': 1000},
-)
-
-biogeme.createLogFile(verbosity=3)
-
-# Get the results in a pandas table
-print('Parameters')
-print('----------')
+biogeme = bio.BIOGEME(database, logprob, numberOfDraws=100000)
+biogeme.modelName = '12panel'
+
+# Estimate the parameters.
+results = biogeme.estimate()
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
-
-# Get general statistics
-print('General statistics')
-print('------------------')
-stats = results.getGeneralStatistics()
-for description, (value, formatting) in stats.items():
-    print(f'{description}: {value:{formatting}}')
-
-# Messages from the optimization algorithm
-print('Optimization algorithm')
-print('----------------------')
-for description, message in results.data.optimizationMessages.items():
-    print(f'{description}:\t{message}')
-
-# Generate the file in Alogit format
-results.writeF12(robustStdErr=True)
-results.writeF12(robustStdErr=False)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/01logit_allAlgos.py` & `biogeme-3.2.9/examples/swissmetro/01logit_allAlgos.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,23 +10,33 @@
 
 import pandas as pd
 import biogeme.biogeme as bio
 import biogeme.optimization as opt
 import biogeme.database as db
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta
+from biogeme.expressions import Beta, Variable
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 
 # Removing some observations
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 # Parameters to be estimated
```

### Comparing `biogeme-3.2.8/examples/swissmetro/01logit_simul.py` & `biogeme-3.2.9/examples/workingNotToDistribute/old.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,38 +3,38 @@
 :author: Michel Bierlaire, EPFL
 :date: Sat Sep  7 18:06:08 2019
 
  Example of simulation with a logit model
  Three alternatives: Train, Car and Swissmetro
  SP data
 """
-
+import datetime
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-from biogeme import models
+import biogeme.models as models
 from biogeme.expressions import Beta, Derive
 
 # Read the data
-df = pd.read_csv('swissmetro.dat', sep='\t')
+df = pd.read_csv('swissmetro.dat', '\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to investigate the database. For example:
-# print(database.data.describe())
+#print(database.data.describe())
 
 # The following statement allows you to use the names of the variable
 # as Python variable.
 globals().update(database.variables)
 
 # Removing some observations can be done directly using pandas.
-# remove = (((database.data.PURPOSE != 1) &
+#remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
-# database.data.drop(database.data[remove].index,inplace=True)
+#database.data.drop(database.data[remove].index,inplace=True)
 
 # Here we use the "biogeme" way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
@@ -43,43 +43,55 @@
 B_TIME = Beta('B_TIME', 0, None, None, 0)
 B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
-# Definition of new variables: in simulation, do not use the
-# DefineVariable operator, as it hides the functional
-# relationships. In particular, derivatives cannot be calculated.
+# Definition of new variables: in simulation, do not use the DefineVariable operator,
+# as it hides the functional relationships. In particular, derivatives cannot be
+# calculated.
 CAR_AV_SP = CAR_AV * (SP != 0)
 TRAIN_AV_SP = TRAIN_AV * (SP != 0)
 TRAIN_TT_SCALED = TRAIN_TT / 100.0
 TRAIN_COST_SCALED = TRAIN_COST / 100
 SM_TT_SCALED = SM_TT / 100.0
 SM_COST_SCALED = SM_COST / 100
 CAR_TT_SCALED = CAR_TT / 100
 CAR_CO_SCALED = CAR_CO / 100
 
 # Definition of the utility functions
-V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
-V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+V1 = ASC_TRAIN + \
+     B_TIME * TRAIN_TT_SCALED + \
+     B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + \
+     B_TIME * SM_TT_SCALED + \
+     B_COST * SM_COST_SCALED
+V3 = ASC_CAR + \
+     B_TIME * CAR_TT_SCALED + \
+     B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1, 2: V2, 3: V3}
+V = {1: V1,
+     2: V2,
+     3: V3}
 
 # Associate the availability conditions with the alternatives
-av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP,
+      2: SM_AV,
+      3: CAR_AV_SP}
 
 # The choice model is a logit, with availability conditions
 prob1 = models.logit(V, av, 1)
 prob2 = models.logit(V, av, 2)
 prob3 = models.logit(V, av, 3)
 
 
+
+
 # Elasticities can be computed. We illustrate below two
 # formulas. Check in the output file that they produce the same
 # result.
 
 # First, the general definition of elasticities. This illustrates the
 # use of the Derive expression, and can be used with any model,
 # however complicated it is. Note the quotes in the Derive opertor.
@@ -90,33 +102,32 @@
 # Second, the elasticity of logit models. See Ben-Akiva and Lerman for
 # the formula
 
 logitelas1 = TRAIN_AV_SP * (1.0 - prob1) * TRAIN_TT_SCALED * B_TIME
 logitelas2 = SM_AV * (1.0 - prob2) * SM_TT_SCALED * B_TIME
 logitelas3 = CAR_AV_SP * (1.0 - prob3) * CAR_TT_SCALED * B_TIME
 
-simulate = {
-    'Prob. train': prob1,
-    'Prob. Swissmetro': prob2,
-    'Prob. car': prob3,
-    'logit elas. 1': logitelas1,
-    'generic elas. 1': genelas1,
-    'logit elas. 2': logitelas2,
-    'generic elas. 2': genelas2,
-    'logit elas. 3': logitelas3,
-    'generic elas. 3': genelas3,
-}
+simulate = {'Prob. train': prob1,
+            'Prob. Swissmetro': prob2,
+            'Prob. car': prob3,
+            'logit elas. 1': logitelas1,
+            'generic elas. 1': genelas1,
+            'logit elas. 2': logitelas2,
+            'generic elas. 2': genelas2,
+            'logit elas. 3': logitelas3,
+            'generic elas. 3': genelas3}
 
 
 biogeme = bio.BIOGEME(database, simulate)
 biogeme.modelName = '01logit_simul'
-betas = {
-    'ASC_TRAIN': -0.701188,
-    'B_TIME': -1.27786,
-    'B_COST': -1.08379,
-    'ASC_SM': 0,
-    'ASC_CAR': -0.154633,
-}
+betas = {'ASC_TRAIN': -0.701188,
+         'B_TIME': -1.27786,
+         'B_COST': -1.08379,
+         'ASC_SM': 0,
+         'ASC_CAR': -0.154633}
+
+begin = datetime.datetime.now()
+for i in range(30):
+    results1 = biogeme.simulate(theBetaValues=betas)
+print(datetime.datetime.now() - begin)
 
 
-results = biogeme.simulate(theBetaValues=betas)
-print(results.describe())
```

### Comparing `biogeme-3.2.8/examples/swissmetro/02weight.py` & `biogeme-3.2.9/examples/swissmetro/02weight.py`

 * *Files 10% similar despite different names*

```diff
@@ -10,27 +10,38 @@
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable
+from biogeme.expressions import Beta, Variable
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to investigate the database. For example:
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
+GROUP = Variable('GROUP')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -46,24 +57,24 @@
 B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
@@ -74,18 +85,19 @@
 
 # Definition of the model. This is the contribution of each
 # observation to the log likelihood function.
 logprob = models.loglogit(V, av, CHOICE)
 
 # Definition of the weight
 weight = 8.890991e-01 * (1.0 * (GROUP == 2) + 1.2 * (GROUP == 3))
+# weight =  (1.0 * (GROUP == 2) + 1.2 * (GROUP == 3))
 
 # Define level of verbosity
-logger = msg.bioMessage()
-logger.setSilent()
+# logger = msg.bioMessage()
+# logger.setSilent()
 # logger.setWarning()
 # logger.setGeneral()
 # logger.setDetailed()
 
 # These notes will be included as such in the report file.
 userNotes = (
     'Example of a logit model with three alternatives: '
```

### Comparing `biogeme-3.2.8/examples/swissmetro/03scale.py` & `biogeme-3.2.9/examples/swissmetro/07discreteMixture.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,37 +1,45 @@
-"""File 03scale.py
+"""File 07discreteMixture.py
 
 :author: Michel Bierlaire, EPFL
-:date: Thu Sep  6 15:14:39 2018
+:date: Sun Sep  8 00:06:20 2019
 
- Illustrates heteroscedastic specification. A different scale is
- associated with different segments of the sample.
+ Example of a discrete mixture of logit (or latent class model)
  Three alternatives: Train, Car and Swissmetro
  SP data
-
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable
+from biogeme.expressions import Beta, Variable, log
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
-# Pandas functions to investigate the database. For example:
+# Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -41,65 +49,70 @@
 
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
 B_TIME = Beta('B_TIME', 0, None, None, 0)
 B_COST = Beta('B_COST', 0, None, None, 0)
-Scale_group3 = Beta('Scale_group3', 1, 0.001, None, 0)
+
+PROB_CLASS1 = Beta('PROB_CLASS1', 0.5, 0, 1, 0)
+PROB_CLASS2 = 1 - PROB_CLASS1
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
-
-# Definition of the utility functions
-V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
-V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
-
-# Scale associated with group 3 is estimated
-scale = (GROUP != 3) + (GROUP == 3) * Scale_group3
-
-# Scale the utility functions, and associate them with the numbering
-# of alternatives
-V = {1: scale * V1, 2: scale * V2, 3: scale * V3}
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+# Definition of the utility functions for latent class 1, where the
+# time coefficient is zero
+V11 = ASC_TRAIN + B_COST * TRAIN_COST_SCALED
+V12 = ASC_SM + B_COST * SM_COST_SCALED
+V13 = ASC_CAR + B_COST * CAR_CO_SCALED
+
+# Associate utility functions with the numbering of alternatives
+V1 = {1: V11, 2: V12, 3: V13}
+
+# Definition of the utility functions for latent class 2, whete the
+# time coefficient is estimated
+V21 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V22 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V23 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+
+# Associate utility functions with the numbering of alternatives
+V2 = {1: V21, 2: V22, 3: V23}
 
 # Associate the availability conditions with the alternatives
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-# Definition of the model. This is the contribution of each
-# observation to the log likelihood function.
-logprob = models.loglogit(V, av, CHOICE)
+
+# The choice model is a discrete mixture of logit, with availability conditions
+prob1 = models.logit(V1, av, CHOICE)
+prob2 = models.logit(V2, av, CHOICE)
+prob = PROB_CLASS1 * prob1 + PROB_CLASS2 * prob2
+logprob = log(prob)
 
 # Define level of verbosity
 logger = msg.bioMessage()
 logger.setSilent()
 # logger.setWarning()
 # logger.setGeneral()
 # logger.setDetailed()
 
-# These notes will be included as such in the report file.
-userNotes = (
-    'Illustrates heteroscedastic specification. A different scale is'
-    ' associated with different segments of the sample.'
-)
-
 # Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob, userNotes=userNotes)
-biogeme.modelName = '03scale'
+biogeme = bio.BIOGEME(database, logprob)
+biogeme.modelName = '07discreteMixture'
 
 # Estimate the parameters
 results = biogeme.estimate()
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/04validation.py` & `biogeme-3.2.9/examples/workingNotToDistribute/threads.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-"""File 04validation.py
+"""File 01logit.py
 
 :author: Michel Bierlaire, EPFL
-:date: Thu Jun  4 17:55:27 2020
+:date: Thu Sep  6 15:14:39 2018
 
- Example of the out-of-sample validation of a logit model.
+ Example of a logit model.
  Three alternatives: Train, Car and Swissmetro
  SP data
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-from biogeme import models
+import biogeme.models as models
 from biogeme.expressions import Beta
 
 # Read the data
-df = pd.read_csv('swissmetro.dat', sep='\t')
+df = pd.read_csv('swissmetro.dat', '\t')
 database = db.Database('swissmetro', df)
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
+# The following statement allows you to use the names of the
+# variable as Python variable.
 globals().update(database.variables)
 
 # Removing some observations
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 # Parameters to be estimated
@@ -35,54 +35,51 @@
 
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 CAR_AV_SP = CAR_AV * (SP != 0)
 TRAIN_AV_SP = TRAIN_AV * (SP != 0)
-TRAIN_TT_SCALED = TRAIN_TT / 100.0
+TRAIN_TT_SCALED = TRAIN_TT / 100
 TRAIN_COST_SCALED = TRAIN_COST / 100
-SM_TT_SCALED = SM_TT / 100.0
+SM_TT_SCALED = SM_TT / 100
 SM_COST_SCALED = SM_COST / 100
 CAR_TT_SCALED = CAR_TT / 100
 CAR_CO_SCALED = CAR_CO / 100
 
 # Definition of the utility functions
-V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
-V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+V1 = ASC_TRAIN + \
+     B_TIME * TRAIN_TT_SCALED + \
+     B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + \
+     B_TIME * SM_TT_SCALED + \
+     B_COST * SM_COST_SCALED
+V3 = ASC_CAR + \
+     B_TIME * CAR_TT_SCALED + \
+     B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1, 2: V2, 3: V3}
+V = {1: V1,
+     2: V2,
+     3: V3}
 
 # Associate the availability conditions with the alternatives
-av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP,
+      2: SM_AV,
+      3: CAR_AV_SP}
 
 # Definition of the model. This is the contribution of each
 # observation to the log likelihood function.
+
 logprob = models.loglogit(V, av, CHOICE)
 
+for t in range(1, 3):
 # Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob)
-biogeme.modelName = '04validation'
+    biogeme = bio.BIOGEME(database, logprob, numberOfThreads=t)
+    biogeme.modelName = f'threads_{t}'
 
-# Estimate the parameters
-results = biogeme.estimate()
+    # Estimate the parameters
+    results = biogeme.estimate()
 
-# The validation consists in organizing the data into several slices
-# of about the same size, randomly defined. Each slice is considered
-# as a validation dataset. The model is then re-estimated using all
-# the data except the slice, and the estimated model is applied on the
-# validation set (i.e. the slice). The value of the log likelihood for
-# each observation in the validation set is reported in a
-# dataframe. As this is done for each slice, the output is a list of
-# dataframes, each corresponding to one of these exercises.
-
-validationData = database.split(slices=5)
-
-validation_results = biogeme.validate(results, validationData)
-
-for slide in validation_results:
-    print(
-        f'Log likelihood for {slide.shape[0]} validation data: '
-        f'{slide["Loglikelihood"].sum()}'
-    )
+    # Get the results in a pandas table
+    pandasResults = results.getEstimatedParameters()
+    print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/05normalMixture.py` & `biogeme-3.2.9/examples/swissmetro/24haltonMixture.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,35 +1,48 @@
-"""File 05normalMixture.py
+"""File 24haltonMixture.py
 
 :author: Michel Bierlaire, EPFL
-:date: Sat Sep  7 18:23:01 2019
+:date: Mon Sep  9 11:02:37 2019
 
- Example of a mixture of logit models, using Monte-Carlo integration.
+ Example of a mixture of logit models, using quasi Monte-Carlo integration with
+ Halton draws (base 5).
+ The mixing distribution is normal.
  Three alternatives: Train, Car and Swissmetro
  SP data
+
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable, bioDraws, log, MonteCarlo
+from biogeme.expressions import Beta, Variable, bioDraws, MonteCarlo, log
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
-# Pandas functions to investigate the database. For example:
+# Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -45,31 +58,33 @@
 
 # Define a random parameter, normally distributed, designed to be used
 # for Monte-Carlo simulation
 B_TIME = Beta('B_TIME', 0, None, None, 0)
 
 # It is advised not to use 0 as starting value for the following parameter.
 B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
-B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL')
+# Define a random parameter with a normal distribution, designed to be used
+# for quasi Monte-Carlo simulation with Halton draws (base 5).
+B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL_HALTON5')
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
@@ -90,20 +105,20 @@
 # logger.setWarning()
 logger.setGeneral()
 # logger.setDetailed()
 
 # These notes will be included as such in the report file.
 userNotes = (
     'Example of a mixture of logit models with three alternatives, '
-    'approximated using Monte-Carlo integration.'
+    'approximated using Monte-Carlo integration with Halton draws.'
 )
 
 # Create the Biogeme object
 biogeme = bio.BIOGEME(
     database, logprob, numberOfDraws=100000, userNotes=userNotes
 )
-biogeme.modelName = '05normalMixture'
+biogeme.modelName = '24haltonMixture'
 
 # Estimate the parameters
 results = biogeme.estimate()
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/05normalMixtureIntegral.py` & `biogeme-3.2.9/examples/swissmetro/06unifMixtureMHLS.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,42 +1,54 @@
-"""File 05normalMixtureIntegral.py
+"""File 06unifMixtureMHLS.py
 
 :author: Michel Bierlaire, EPFL
 :date: Sat Sep  7 18:23:01 2019
 
- Example of a mixture of logit models, using numerical integration.
+ Example of a mixture of logit models, using Monte-Carlo integration.
+ The mixing distribution is uniform.
+ The draws are from the Modified Hypercube Latin Square
  Three alternatives: Train, Car and Swissmetro
  SP data
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.distributions as dist
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
-    RandomVariable,
+    Variable,
+    bioDraws,
+    exp,
     log,
-    Integrate,
+    MonteCarlo,
 )
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to investigate the database. For example:
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -47,62 +59,64 @@
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
 B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Define a random parameter, normally distributed, designed to be used
-# for numerical integration
+# for Monte-Carlo simulation
 B_TIME = Beta('B_TIME', 0, None, None, 0)
+
 # It is advised not to use 0 as starting value for the following parameter.
 B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
-omega = RandomVariable('omega')
-density = dist.normalpdf(omega)
-B_TIME_RND = B_TIME + B_TIME_S * omega
+
+# Define a random parameter, uniformly distributed, designed to be used
+# for Monte-Carlo simulation
+B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL_MLHS')
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
 V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-# Conditional to omega, we have a logit model (called the kernel)
-condprob = models.logit(V, av, CHOICE)
-# We integrate over omega using numerical integration
-logprob = log(Integrate(condprob * density, 'omega'))
+# Conditional to B_TIME_RND, we have a logit model (called the kernel)
+prob = exp(models.loglogit(V, av, CHOICE))
+# We integrate over B_TIME_RND using Monte-Carlo
+logprob = log(MonteCarlo(prob))
 
 # Define level of verbosity
 logger = msg.bioMessage()
 # logger.setSilent()
 # logger.setWarning()
 logger.setGeneral()
 # logger.setDetailed()
 
 # Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob)
-biogeme.modelName = '05normalMixtureIntegral'
+biogeme = bio.BIOGEME(database, logprob, numberOfDraws=100000)
+biogeme.modelName = '06unifMixtureMHLS'
 
 # Estimate the parameters
 results = biogeme.estimate()
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/05normalMixture_allAlgos.py` & `biogeme-3.2.9/examples/swissmetro/05normalMixture_allAlgos.py`

 * *Files 7% similar despite different names*

```diff
@@ -10,27 +10,38 @@
 
 import pandas as pd
 import biogeme.optimization as opt
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable, bioDraws, log, MonteCarlo
+import biogeme.exceptions as excep
+from biogeme.expressions import Beta, Variable, bioDraws, log, MonteCarlo
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to investigate the database. For example:
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -53,24 +64,24 @@
 B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL')
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
@@ -140,22 +151,28 @@
 }
 
 results = {}
 msg = ''
 for name, algo in algos.items():
     biogeme.modelName = f'05normalMixture_allAlgos_{name}'.strip()
     p = algoParameters.get(name)
-    results[name] = biogeme.estimate(algorithm=algo, algoParameters=p)
-    msg += (
-        f'{name}\t{results[name].data.logLike:.2f}\t'
-        f'{results[name].data.gradientNorm:.2g}\t'
-        f'{results[name].data.optimizationMessages["Optimization time"]}'
-        f'\t{results[name].data.optimizationMessages["Cause of termination"]}'
-        f'\n'
-    )
+    try:
+        results[name] = biogeme.estimate(algorithm=algo, algoParameters=p)
+        msg += (
+            f'{name}\t{results[name].data.logLike:.2f}\t'
+            f'{results[name].data.gradientNorm:.2g}\t'
+            f'{results[name].data.optimizationMessages["Optimization time"]}'
+            f'\t{results[name].data.optimizationMessages["Cause of termination"]}'
+            f'\n'
+        )
+    except excep.biogemeError as e:
+        print(e)
+        results[name] = None
+        msg += f'{name}\tFailed to estimate the model'
+
 
 print('Algorithm\t\tloglike\t\tnormg\ttime\t\tdiagnostic')
 print('+++++++++\t\t+++++++\t\t+++++\t++++\t\t++++++++++')
 print(msg)
 
 """
 Here are the results. Note that the draws are identical for all runs. Still, the algorithms
```

### Comparing `biogeme-3.2.8/examples/swissmetro/05normalMixture_simul.py` & `biogeme-3.2.9/examples/swissmetro/05normalMixture_simul.py`

 * *Files 8% similar despite different names*

```diff
@@ -12,28 +12,43 @@
 import sys
 import numpy as np
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.results as res
-from biogeme.expressions import Beta, DefineVariable, bioDraws, MonteCarlo
-import matplotlib.pyplot as plt
+from biogeme.exceptions import biogemeError
+from biogeme.expressions import Beta, Variable, bioDraws, MonteCarlo
+try: 
+    import matplotlib.pyplot as plt
+    plot = True
+except ModuleNotFoundError:
+    plot = False
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to investigate the database. For example:
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -56,24 +71,24 @@
 B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL')
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
@@ -81,15 +96,15 @@
 
 # Associate the availability conditions with the alternatives
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
 # The estimation results are read from the pickle file
 try:
     results = res.bioResults(pickleFile='05normalMixture.pickle')
-except FileNotFoundError:
+except biogemeError:
     print(
         'Run first the script 05normalMixture.py in order to generate the '
         'file 05normalMixture.pickle.'
     )
     sys.exit()
 
 # Conditional to B_TIME_RND, we have a logit model (called the kernel)
@@ -140,15 +155,16 @@
     f'{simresults["right"].sum()}]'
 )
 
 # Post processing to obtain the individual parameters
 simresults['beta'] = simresults['Numerator'] / simresults['Denominator']
 
 # Plot the histogram of individual parameters
-simresults['beta'].plot(kind='hist', density=True, bins=20)
+if plot:
+    simresults['beta'].plot(kind='hist', density=True, bins=20)
 
 # Plot the general distribution of beta
 def normalpdf(v, mu=0.0, s=1.0):
     """
     Calculate the pdf of the normal distribution, for plotting purposes.
 
     """
@@ -159,9 +175,10 @@
     den = s * 2.506628275
     p = num / den
     return p
 
 
 betas = results.getBetaValues(['B_TIME', 'B_TIME_S'])
 x = np.arange(simresults['beta'].min(), simresults['beta'].max(), 0.01)
-plt.plot(x, normalpdf(x, betas['B_TIME'], betas['B_TIME_S']), '-')
-plt.show()
+if plot: 
+    plt.plot(x, normalpdf(x, betas['B_TIME'], betas['B_TIME_S']), '-')
+    plt.show()
```

### Comparing `biogeme-3.2.8/examples/swissmetro/06unifMixture.py` & `biogeme-3.2.9/examples/swissmetro/06unifMixture.py`

 * *Files 10% similar despite different names*

```diff
@@ -12,32 +12,42 @@
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
+    Variable,
     bioDraws,
     exp,
     log,
     MonteCarlo,
 )
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to investigate the database. For example:
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -58,24 +68,24 @@
 B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'UNIFORMSYM')
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
```

### Comparing `biogeme-3.2.8/examples/swissmetro/06unifMixtureIntegral.py` & `biogeme-3.2.9/tests/swissmetro/test_06.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,111 +1,94 @@
-"""File 06unifMixtureIntegral.py
-
-:author: Michel Bierlaire, EPFL
-:date: Sat Sep  7 20:45:18 2019
-
- Example of a mixture of logit models, using numerical integration.
- The mixing distribution is uniform.
- Three alternatives: Train, Car and Swissmetro
- SP data
-"""
-
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
-import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
-    Integrate,
-    RandomVariable,
     exp,
     log,
+    MonteCarlo,
+    bioDraws,
 )
 
-# Read the data
-df = pd.read_csv('swissmetro.dat', sep='\t')
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-# remove = (((database.data.PURPOSE != 1) &
-#           (database.data.PURPOSE != 3)) |
-#          (database.data.CHOICE == 0))
-# database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
+# Here we use the 'biogeme' way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
-# Parameters to be estimated
+
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
-B_COST = Beta('B_COST', 0, None, None, 0)
-
-# Define a random parameter, normally distributed, designed to be used
-# for numerical integration
 B_TIME = Beta('B_TIME', 0, None, None, 0)
 B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
-omega = RandomVariable('omega')
-a = -1
-b = 1
-x = a + (b - a) / (1 + exp(-omega))
-dx = (b - a) * exp(-omega) * (1 + exp(-omega)) ** (-2)
-B_TIME_RND = B_TIME + B_TIME_S * x
+B_COST = Beta('B_COST', 0, None, None, 0)
 
-# Definition of new variables
+# Define a random parameter, normally distirbuted, designed to be used
+# for Monte-Carlo simulation
+B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'UNIFORMSYM')
+
+# Utility functions
+
+# If the person has a GA (season ticket) her incremental cost is actually 0
+# rather than the cost value gathered from the
+# network data.
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
-# Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+# For numerical reasons, it is good practice to scale the data to
+# that the values of the parameters are around 1.0.
+# A previous estimation with the unscaled data has generated
+# parameters around -0.01 for both cost and time. Therefore, time and
+# cost are multipled my 0.01.
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
-# Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
 V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
+
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-# Conditional to omega, we have a logit model (called the kernel)
-condprob = models.logit(V, av, CHOICE)
-# We integrate over omega using numerical integration
-logprob = log(Integrate(condprob * dx / (b - a), 'omega'))
-
-# Define level of verbosity
-logger = msg.bioMessage()
-# logger.setSilent()
-# logger.setWarning()
-logger.setGeneral()
-# logger.setDetailed()
-
-# Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob)
-biogeme.modelName = '06unifMixtureIntegral'
-
-# Estimate the parameters
-results = biogeme.estimate()
-pandasResults = results.getEstimatedParameters()
-print(pandasResults)
+# The choice model is a logit, with availability conditions
+prob = exp(models.loglogit(V, av, CHOICE))
+logprob = log(MonteCarlo(prob))
+
+
+class test_06(unittest.TestCase):
+    def testEstimation(self):
+        biogeme = bio.BIOGEME(database, logprob, seed=10, numberOfDraws=5)
+        biogeme.saveIterations = False
+        biogeme.generateHtml = False
+        biogeme.generatePickle = False
+        results = biogeme.estimate()
+        self.assertAlmostEqual(results.data.logLike, -5313.08427374036, 2)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/examples/swissmetro/06unifMixtureMHLS.py` & `biogeme-3.2.9/examples/swissmetro/05normalMixtureIntegral.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,44 +1,52 @@
-"""File 06unifMixtureMHLS.py
+"""File 05normalMixtureIntegral.py
 
 :author: Michel Bierlaire, EPFL
 :date: Sat Sep  7 18:23:01 2019
 
- Example of a mixture of logit models, using Monte-Carlo integration.
- The mixing distribution is uniform.
- The draws are from the Modified Hypercube Latin Square
+ Example of a mixture of logit models, using numerical integration.
  Three alternatives: Train, Car and Swissmetro
  SP data
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
+import biogeme.distributions as dist
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
-    bioDraws,
-    exp,
+    Variable,
+    RandomVariable,
     log,
-    MonteCarlo,
+    Integrate,
 )
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to investigate the database. For example:
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -49,64 +57,62 @@
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
 B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Define a random parameter, normally distributed, designed to be used
-# for Monte-Carlo simulation
+# for numerical integration
 B_TIME = Beta('B_TIME', 0, None, None, 0)
-
 # It is advised not to use 0 as starting value for the following parameter.
 B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
-
-# Define a random parameter, uniformly distributed, designed to be used
-# for Monte-Carlo simulation
-B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL_MLHS')
+omega = RandomVariable('omega')
+density = dist.normalpdf(omega)
+B_TIME_RND = B_TIME + B_TIME_S * omega
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
 V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-# Conditional to B_TIME_RND, we have a logit model (called the kernel)
-prob = exp(models.loglogit(V, av, CHOICE))
-# We integrate over B_TIME_RND using Monte-Carlo
-logprob = log(MonteCarlo(prob))
+# Conditional to omega, we have a logit model (called the kernel)
+condprob = models.logit(V, av, CHOICE)
+# We integrate over omega using numerical integration
+logprob = log(Integrate(condprob * density, 'omega'))
 
 # Define level of verbosity
 logger = msg.bioMessage()
 # logger.setSilent()
 # logger.setWarning()
 logger.setGeneral()
 # logger.setDetailed()
 
 # Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob, numberOfDraws=100000)
-biogeme.modelName = '06unifMixtureMHLS'
+biogeme = bio.BIOGEME(database, logprob)
+biogeme.modelName = '05normalMixtureIntegral'
 
 # Estimate the parameters
 results = biogeme.estimate()
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/07discreteMixture.py` & `biogeme-3.2.9/examples/swissmetro/01logit_simul.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,35 +1,44 @@
-"""File 07discreteMixture.py
+"""File 01logit_simul.py
 
 :author: Michel Bierlaire, EPFL
-:date: Sun Sep  8 00:06:20 2019
+:date: Sat Sep  7 18:06:08 2019
 
- Example of a discrete mixture of logit (or latent class model)
+ Example of simulation with a logit model
  Three alternatives: Train, Car and Swissmetro
  SP data
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
-import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable, log
+from biogeme.expressions import Beta, Variable, Derive
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
-# Pandas functions to invesigate the database
+# Pandas functions to investigate the database. For example:
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -40,69 +49,84 @@
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
 B_TIME = Beta('B_TIME', 0, None, None, 0)
 B_COST = Beta('B_COST', 0, None, None, 0)
 
-PROB_CLASS1 = Beta('PROB_CLASS1', 0.5, 0, 1, 0)
-PROB_CLASS2 = 1 - PROB_CLASS1
-
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
-# Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
-)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
-
-# Definition of the utility functions for latent class 1, where the
-# time coefficient is zero
-V11 = ASC_TRAIN + B_COST * TRAIN_COST_SCALED
-V12 = ASC_SM + B_COST * SM_COST_SCALED
-V13 = ASC_CAR + B_COST * CAR_CO_SCALED
+# Definition of new variables: in simulation, do not use the
+# DefineVariable operator, as it hides the functional
+# relationships. In particular, derivatives cannot be calculated.
+CAR_AV_SP = CAR_AV * (SP != 0)
+TRAIN_AV_SP = TRAIN_AV * (SP != 0)
+TRAIN_TT_SCALED = TRAIN_TT / 100.0
+TRAIN_COST_SCALED = TRAIN_COST / 100
+SM_TT_SCALED = SM_TT / 100.0
+SM_COST_SCALED = SM_COST / 100
+CAR_TT_SCALED = CAR_TT / 100
+CAR_CO_SCALED = CAR_CO / 100
+
+# Definition of the utility functions
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V1 = {1: V11, 2: V12, 3: V13}
-
-# Definition of the utility functions for latent class 2, whete the
-# time coefficient is estimated
-V21 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
-V22 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
-V23 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
-
-# Associate utility functions with the numbering of alternatives
-V2 = {1: V21, 2: V22, 3: V23}
+V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
+# The choice model is a logit, with availability conditions
+prob1 = models.logit(V, av, 1)
+prob2 = models.logit(V, av, 2)
+prob3 = models.logit(V, av, 3)
+
+
+# Elasticities can be computed. We illustrate below two
+# formulas. Check in the output file that they produce the same
+# result.
+
+# First, the general definition of elasticities. This illustrates the
+# use of the Derive expression, and can be used with any model,
+# however complicated it is. Note the quotes in the Derive opertor.
+genelas1 = Derive(prob1, 'TRAIN_TT') * TRAIN_TT / prob1
+genelas2 = Derive(prob2, 'SM_TT') * SM_TT / prob2
+genelas3 = Derive(prob3, 'CAR_TT') * CAR_TT / prob3
+
+# Second, the elasticity of logit models. See Ben-Akiva and Lerman for
+# the formula
+
+logitelas1 = TRAIN_AV_SP * (1.0 - prob1) * TRAIN_TT_SCALED * B_TIME
+logitelas2 = SM_AV * (1.0 - prob2) * SM_TT_SCALED * B_TIME
+logitelas3 = CAR_AV_SP * (1.0 - prob3) * CAR_TT_SCALED * B_TIME
+
+simulate = {
+    'Prob. train': prob1,
+    'Prob. Swissmetro': prob2,
+    'Prob. car': prob3,
+    'logit elas. 1': logitelas1,
+    'generic elas. 1': genelas1,
+    'logit elas. 2': logitelas2,
+    'generic elas. 2': genelas2,
+    'logit elas. 3': logitelas3,
+    'generic elas. 3': genelas3,
+}
+
+
+biogeme = bio.BIOGEME(database, simulate)
+biogeme.modelName = '01logit_simul'
+betas = {
+    'ASC_TRAIN': -0.701188,
+    'B_TIME': -1.27786,
+    'B_COST': -1.08379,
+    'ASC_SM': 0,
+    'ASC_CAR': -0.154633,
+}
+
 
-# The choice model is a discrete mixture of logit, with availability conditions
-prob1 = models.logit(V1, av, CHOICE)
-prob2 = models.logit(V2, av, CHOICE)
-prob = PROB_CLASS1 * prob1 + PROB_CLASS2 * prob2
-logprob = log(prob)
-
-# Define level of verbosity
-logger = msg.bioMessage()
-logger.setSilent()
-# logger.setWarning()
-# logger.setGeneral()
-# logger.setDetailed()
-
-# Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob)
-biogeme.modelName = '07discreteMixture'
-
-# Estimate the parameters
-results = biogeme.estimate()
-pandasResults = results.getEstimatedParameters()
-print(pandasResults)
+results = biogeme.simulate(theBetaValues=betas)
+print(results.describe())
```

### Comparing `biogeme-3.2.8/examples/swissmetro/08boxcox.py` & `biogeme-3.2.9/tests/swissmetro/test_01simul.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,107 +1,96 @@
-"""File 08boxcox.py
-
-:author: Michel Bierlaire, EPFL
-:date: Sun Sep  8 00:33:03 2019
-
- Example of a logit model, with a Box-Cox transform of variables.
- Three alternatives: Train, Car and Swissmetro
- SP data
-"""
-
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
-import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable
+from biogeme.expressions import Beta, Elem, Derive
 
-# Read the data
-df = pd.read_csv('swissmetro.dat', sep='\t')
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-# remove = (((database.data.PURPOSE != 1) &
-#           (database.data.PURPOSE != 3)) |
-#          (database.data.CHOICE == 0))
-# database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
+# Here we use the 'biogeme' way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
-# Parameters to be estimated
-ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
-ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
-ASC_SM = Beta('ASC_SM', 0, None, None, 1)
-B_TIME = Beta('B_TIME', 0, None, None, 0)
-B_COST = Beta('B_COST', 0, None, None, 0)
-LAMBDA = Beta('LAMBDA', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', -0.701188, None, None, 0)
+B_TIME = Beta('B_TIME', -1.27786, None, None, 0)
+B_COST = Beta('B_COST', -1.08379, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 0)
+ASC_CAR = Beta('ASC_CAR', -0.154633, None, None, 0)
 
-# Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
-# Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
-)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
-
-# Definition of the utility functions
-V1 = (
-    ASC_TRAIN
-    + B_TIME * models.boxcox(TRAIN_TT_SCALED, LAMBDA)
-    + B_COST * TRAIN_COST_SCALED
-)
-V2 = (
-    ASC_SM
-    + B_TIME * models.boxcox(SM_TT_SCALED, LAMBDA)
-    + B_COST * SM_COST_SCALED
-)
-V3 = (
-    ASC_CAR
-    + B_TIME * models.boxcox(CAR_TT_SCALED, LAMBDA)
-    + B_COST * CAR_CO_SCALED
-)
+TRAIN_TT_SCALED = TRAIN_TT / 100.0
+TRAIN_COST_SCALED = TRAIN_COST / 100
+SM_TT_SCALED = SM_TT / 100.0
+SM_COST_SCALED = SM_COST / 100.0
+CAR_TT_SCALED = CAR_TT / 100.0
+CAR_CO_SCALED = CAR_CO / 100.0
+
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
 V = {1: V1, 2: V2, 3: V3}
 
+
 # Associate the availability conditions with the alternatives
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-# Definition of the model. This is the contribution of each
-# observation to the log likelihood function.
-logprob = models.loglogit(V, av, CHOICE)
-
-# Define level of verbosity
-logger = msg.bioMessage()
-# logger.setSilent()
-# logger.setWarning()
-# logger.setGeneral()
-logger.setDetailed()
-
-# Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob)
-biogeme.modelName = '08boxcox'
-
-biogeme.checkDerivatives(verbose=True)
-
-# Estimate the parameters
-results = biogeme.estimate()
-pandasResults = results.getEstimatedParameters()
-print(pandasResults)
+# The choice model is a logit, with availability conditions
+prob1 = Elem({0: 0, 1: models.logit(V, av, 1)}, av[1])
+
+# Elasticities can be computed. We illustrate below two
+# formulas. Check in the output file that they produce the same
+# result.
+
+# First, the general definition of elasticities. This illustrates the
+# use of the Derive expression, and can be used with any model,
+# however complicated it is. Note the quotes in the Derive opertor.
+
+genelas1 = Derive(prob1, 'TRAIN_TT') * TRAIN_TT / prob1
+
+# Second, the elasticity of logit models. See Ben-Akiva and Lerman for
+# the formula
+
+logitelas1 = TRAIN_AV_SP * (1.0 - prob1) * TRAIN_TT_SCALED * B_TIME
+
+simulate = {
+    'P1': prob1,
+    'logit elas. 1': logitelas1,
+    'generic elas. 1': genelas1,
+}
+
+
+class test_01simul(unittest.TestCase):
+    def testSimulation(self):
+        biogeme = bio.BIOGEME(database, simulate)
+        biogeme.saveIterations = False
+        biogeme.generateHtml = False
+        biogeme.generatePickle = False
+        biogeme.modelName = '01logit_simul'
+        results = biogeme.simulate()
+        self.assertAlmostEqual(sum(results['P1']), 907.9992101964821, 2)
+        self.assertAlmostEqual(
+            sum(results['logit elas. 1']), -12673.838605478186, 2
+        )
+        self.assertAlmostEqual(
+            sum(results['generic elas. 1']), -12673.838605478186, 2
+        )
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/examples/swissmetro/09nested.py` & `biogeme-3.2.9/tests/swissmetro/test_15.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,105 +1,110 @@
-"""File 09nested.py
-
-:author: Michel Bierlaire, EPFL
-:date: Sun Sep  8 00:36:04 2019
-
- Example of a nested logit model.
- Three alternatives: Train, Car and Swissmetro
- Train and car are in the same nest.
- SP data
-"""
-
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
-import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable
+from biogeme.expressions import (
+    Beta,
+    log,
+    bioDraws,
+    MonteCarlo,
+    PanelLikelihoodTrajectory,
+)
 
-# Read the data
-df = pd.read_csv('swissmetro.dat', sep='\t')
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
+database.panel('ID')
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-# remove = (((database.data.PURPOSE != 1) &
-#           (database.data.PURPOSE != 3)) |
-#          (database.data.CHOICE == 0))
-# database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
-# Parameters to be estimated
-ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
-ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+
+ASC_CAR = Beta('ASC_CAR', 0.136, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', -1, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
-B_TIME = Beta('B_TIME', 0, None, None, 0)
-B_COST = Beta('B_COST', 0, None, None, 0)
-MU = Beta('MU', 1, 1, 10, 0)
+B_TIME = Beta('B_TIME', -6.3, None, 0, 0)
+B_COST = Beta('B_COST', -3.29, None, 0, 0)
+
+SIGMA_CAR = Beta('SIGMA_CAR', 3.7, None, None, 0)
+SIGMA_SM = Beta('SIGMA_SM', 0.759, None, None, 0)
+SIGMA_TRAIN = Beta('SIGMA_TRAIN', 3.02, None, None, 0)
+
+# Define a random parameter, normally distirbuted, designed to be used
+# for Monte-Carlo simulation
+EC_CAR = SIGMA_CAR * bioDraws('EC_CAR', 'NORMAL')
+EC_SM = SIGMA_SM * bioDraws('EC_SM', 'NORMAL')
+EC_TRAIN = SIGMA_TRAIN * bioDraws('EC_TRAIN', 'NORMAL')
 
-# Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
-# Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
-
-# Definition of the utility functions
-V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
-V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+# For latent class 1, whete the time coefficient is zero
+V11 = ASC_TRAIN + B_COST * TRAIN_COST_SCALED + EC_TRAIN
+V12 = ASC_SM + B_COST * SM_COST_SCALED + EC_SM
+V13 = ASC_CAR + B_COST * CAR_CO_SCALED + EC_CAR
+
+V1 = {1: V11, 2: V12, 3: V13}
+
+# For latent class 2, whete the time coefficient is estimated
+V21 = (
+    ASC_TRAIN
+    + B_TIME * TRAIN_TT_SCALED
+    + B_COST * TRAIN_COST_SCALED
+    + EC_TRAIN
+)
+V22 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED + EC_SM
+V23 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED + EC_CAR
+
+V2 = {1: V21, 2: V22, 3: V23}
 
-# Associate utility functions with the numbering of alternatives
-V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
+
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-# Definition of nests:
-# 1: nests parameter
-# 2: list of alternatives
-existing = MU, [1, 3]
-future = 1.0, [2]
-nests = existing, future
-
-# Definition of the model. This is the contribution of each
-# observation to the log likelihood function.
-# The choice model is a nested logit, with availability conditions
-logprob = models.lognested(V, av, nests, CHOICE)
-
-# Define level of verbosity
-logger = msg.bioMessage()
-# logger.setSilent()
-# logger.setWarning()
-logger.setGeneral()
-# logger.setDetailed()
-
-# Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob)
-biogeme.modelName = "09nested"
-
-# Calculate the null log likelihood for reporting.
-biogeme.calculateNullLoglikelihood(av)
-
-# Estimate the parameters
-results = biogeme.estimate()
-pandasResults = results.getEstimatedParameters()
-print(pandasResults)
+
+# Class membership model
+W_OTHER = Beta('W_OTHER', 0.798, 0, 1, 0)
+probClass1 = 1 - W_OTHER
+probClass2 = W_OTHER
+
+# The choice model is a discrete mixture of logit, with availability conditions
+prob1 = PanelLikelihoodTrajectory(models.logit(V1, av, CHOICE))
+prob2 = PanelLikelihoodTrajectory(models.logit(V2, av, CHOICE))
+probIndiv = probClass1 * prob1 + probClass2 * prob2
+logprob = log(MonteCarlo(probIndiv))
+
+
+class test_15(unittest.TestCase):
+    def testEstimation(self):
+        biogeme = bio.BIOGEME(database, logprob, numberOfDraws=5, seed=10)
+        biogeme.saveIterations = False
+        biogeme.generateHtml = False
+        biogeme.generatePickle = False
+        results = biogeme.estimate()
+        self.assertAlmostEqual(results.data.logLike, -4074.4822049451564, 2)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/examples/swissmetro/09nested_allAlgos.py` & `biogeme-3.2.9/examples/swissmetro/09nested_allAlgos.py`

 * *Files 14% similar despite different names*

```diff
@@ -11,27 +11,37 @@
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 import biogeme.optimization as opt
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable
+from biogeme.expressions import Beta, Variable
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -48,24 +58,24 @@
 MU = Beta('MU', 1, 1, 10, 0)
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
```

### Comparing `biogeme-3.2.8/examples/swissmetro/10nestedBottom.py` & `biogeme-3.2.9/examples/workingNotToDistribute/new.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,107 +1,131 @@
-"""File 10nestedBottom.py
+"""File 01logit_simul.py
 
 :author: Michel Bierlaire, EPFL
-:date: Sun Sep  8 00:36:04 2019
-
- Example of a nested logit model where the normalization is done at
- the bottom level.  Three alternatives: Train, Car and Swissmetro
- Train and car are in the same nest.  SP data
+:date: Sat Sep  7 18:06:08 2019
 
+ Example of simulation with a logit model
+ Three alternatives: Train, Car and Swissmetro
+ SP data
 """
-
+import datetime
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-from biogeme import models
-import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable
+import biogeme.models as models
+from biogeme.expressions import Beta, Derive
 
 # Read the data
-df = pd.read_csv('swissmetro.dat', sep='\t')
+df = pd.read_csv('swissmetro.dat', '\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
-# Pandas functions to invesigate the database
-# print(database.data.describe())
+# Pandas functions to investigate the database. For example:
+#print(database.data.describe())
 
 # The following statement allows you to use the names of the variable
 # as Python variable.
 globals().update(database.variables)
 
 # Removing some observations can be done directly using pandas.
-# remove = (((database.data.PURPOSE != 1) &
+#remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
-# database.data.drop(database.data[remove].index,inplace=True)
+#database.data.drop(database.data[remove].index,inplace=True)
 
 # Here we use the "biogeme" way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
 B_TIME = Beta('B_TIME', 0, None, None, 0)
 B_COST = Beta('B_COST', 0, None, None, 0)
 
-# If the lower bound is set to zero, the model cannot be evaluated.
-# Therefore, we set the lower bound to a small number, strictly larger
-# than zero.
-MU = Beta('MU', 0.5, 0.000001, 1.0, 0)
-
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
-# Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
-)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+# Definition of new variables: in simulation, do not use the DefineVariable operator,
+# as it hides the functional relationships. In particular, derivatives cannot be
+# calculated.
+CAR_AV_SP = CAR_AV * (SP != 0)
+TRAIN_AV_SP = TRAIN_AV * (SP != 0)
+TRAIN_TT_SCALED = TRAIN_TT / 100.0
+TRAIN_COST_SCALED = TRAIN_COST / 100
+SM_TT_SCALED = SM_TT / 100.0
+SM_COST_SCALED = SM_COST / 100
+CAR_TT_SCALED = CAR_TT / 100
+CAR_CO_SCALED = CAR_CO / 100
 
 # Definition of the utility functions
-V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
-V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+V1 = ASC_TRAIN + \
+     B_TIME * TRAIN_TT_SCALED + \
+     B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + \
+     B_TIME * SM_TT_SCALED + \
+     B_COST * SM_COST_SCALED
+V3 = ASC_CAR + \
+     B_TIME * CAR_TT_SCALED + \
+     B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1, 2: V2, 3: V3}
+V = {1: V1,
+     2: V2,
+     3: V3}
 
 # Associate the availability conditions with the alternatives
-av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP,
+      2: SM_AV,
+      3: CAR_AV_SP}
+
+# The choice model is a logit, with availability conditions
+prob1 = models.logit(V, av, 1)
+prob2 = models.logit(V, av, 2)
+prob3 = models.logit(V, av, 3)
+
+
+
 
-# Definition of nests:
-# 1: nests parameter
-# 2: list of alternatives
-existing = 1.0, [1, 3]
-future = 1.0, [2]
-nests = existing, future
-
-# Definition of the model. This is the contribution of each
-# observation to the log likelihood function.
-# The choice model is a nested logit, with availability conditions,
-# where the scale parameter mu is explicitly involved.
-logprob = models.lognestedMevMu(V, av, nests, CHOICE, MU)
-
-# Define level of verbosity
-logger = msg.bioMessage()
-# logger.setSilent()
-# logger.setWarning()
-logger.setGeneral()
-# logger.setDetailed()
-
-# Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob)
-biogeme.modelName = '10nestedBottom'
-
-# Estimate the parameters
-results = biogeme.estimate()
-pandasResults = results.getEstimatedParameters()
-print(pandasResults)
+# Elasticities can be computed. We illustrate below two
+# formulas. Check in the output file that they produce the same
+# result.
+
+# First, the general definition of elasticities. This illustrates the
+# use of the Derive expression, and can be used with any model,
+# however complicated it is. Note the quotes in the Derive opertor.
+genelas1 = Derive(prob1, 'TRAIN_TT') * TRAIN_TT / prob1
+genelas2 = Derive(prob2, 'SM_TT') * SM_TT / prob2
+genelas3 = Derive(prob3, 'CAR_TT') * CAR_TT / prob3
+
+# Second, the elasticity of logit models. See Ben-Akiva and Lerman for
+# the formula
+
+logitelas1 = TRAIN_AV_SP * (1.0 - prob1) * TRAIN_TT_SCALED * B_TIME
+logitelas2 = SM_AV * (1.0 - prob2) * SM_TT_SCALED * B_TIME
+logitelas3 = CAR_AV_SP * (1.0 - prob3) * CAR_TT_SCALED * B_TIME
+
+simulate = {'Prob. train': prob1,
+            'Prob. Swissmetro': prob2,
+            'Prob. car': prob3,
+            'logit elas. 1': logitelas1,
+            'generic elas. 1': genelas1,
+            'logit elas. 2': logitelas2,
+            'generic elas. 2': genelas2,
+            'logit elas. 3': logitelas3,
+            'generic elas. 3': genelas3}
+
+
+biogeme = bio.BIOGEME(database, simulate)
+biogeme.modelName = '01logit_simul'
+betas = {'ASC_TRAIN': -0.701188,
+         'B_TIME': -1.27786,
+         'B_COST': -1.08379,
+         'ASC_SM': 0,
+         'ASC_CAR': -0.154633}
+
+begin = datetime.datetime.now()
+for i in range(30):
+    results = biogeme.newsimulate(theBetaValues=betas)
+print(datetime.datetime.now() - begin)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/11cnl.py` & `biogeme-3.2.9/examples/swissmetro/11cnl_sparse.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,36 +1,47 @@
-"""File 11cnl.py
+"""File 11cnl_sparse.py
 
 :author: Michel Bierlaire, EPFL
-:date: Sun Sep  8 11:10:42 2019
+:date: Thu Apr 30 18:55:02 2020
 
  Example of a cross-nested logit model.
+ Same as 11cnl, where the zero alphas are not included.
  Three alternatives: Train, Car and Swissmetro
  Train and car are in the same nest.
  SP data
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable
+from biogeme.expressions import Beta, Variable
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -51,57 +62,57 @@
 ALPHA_PUBLIC = 1 - ALPHA_EXISTING
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
 V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
 # Definition of nests
 # Nest membership parameters
-alpha_existing = {1: ALPHA_EXISTING, 2: 0.0, 3: 1.0}
+alpha_existing = {1: ALPHA_EXISTING, 3: 1.0}
 
-alpha_public = {1: ALPHA_PUBLIC, 2: 1.0, 3: 0.0}
+alpha_public = {1: ALPHA_PUBLIC, 2: 1.0}
 
 nest_existing = MU_EXISTING, alpha_existing
 nest_public = MU_PUBLIC, alpha_public
 nests = nest_existing, nest_public
 
 # The choice model is a cross-nested logit, with availability conditions
 logprob = models.logcnl_avail(V, av, nests, CHOICE)
 
 # Define level of verbosity
 logger = msg.bioMessage()
-# logger.setSilent()
+logger.setSilent()
 # logger.setWarning()
-logger.setGeneral()
+# logger.setGeneral()
 # logger.setDetailed()
 
 # Create the Biogeme object
 biogeme = bio.BIOGEME(database, logprob)
-biogeme.modelName = '11cnl'
+biogeme.modelName = '11cnl_sparse'
 
 # Estimate the parameters
 results = biogeme.estimate()
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/11cnl_simul.py` & `biogeme-3.2.9/examples/swissmetro/11cnl_simul.py`

 * *Files 16% similar despite different names*

```diff
@@ -10,28 +10,40 @@
 """
 
 import sys
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
+from biogeme.tools import calculate_correlation
 import biogeme.results as res
-from biogeme.expressions import Beta, Derive
+from biogeme.expressions import Beta, Variable, Derive
+import biogeme.exceptions as excep
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -90,23 +102,32 @@
 nest_public = MU_PUBLIC, alpha_public
 nests = nest_existing, nest_public
 
 # Instead of estimating the parameters, read the estimation
 # results from the pickle file.
 try:
     results = res.bioResults(pickleFile='11cnl.pickle')
-except FileNotFoundError:
+except excep.biogemeError:
     print(
         'Run first the script 11cnl.py in order to generate the file '
         '11cnl.pickle.'
     )
     sys.exit()
 
 print('Estimation results: ', results.getEstimatedParameters())
 
+print(
+    'Calculating correlation matrix. '
+    'It may generate numerical warnings from scipy.'
+)
+corr = calculate_correlation(
+    nests, results, alternative_names={1: 'Train', 2: 'Swissmetro', 3: 'Car'}
+)
+print(corr)
+
 # The choice model is a cross-nested logit, with availability conditions
 prob1 = models.cnl_avail(V, av, nests, 1)
 prob2 = models.cnl_avail(V, av, nests, 2)
 prob3 = models.cnl_avail(V, av, nests, 3)
 
 # We calculate elasticities
 genelas1 = Derive(prob1, 'TRAIN_TT') * TRAIN_TT / prob1
```

### Comparing `biogeme-3.2.8/examples/swissmetro/11cnl_sparse.py` & `biogeme-3.2.9/examples/swissmetro/11cnl.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,46 @@
-"""File 11cnl_sparse.py
+"""File 11cnl.py
 
 :author: Michel Bierlaire, EPFL
-:date: Thu Apr 30 18:55:02 2020
+:date: Sun Sep  8 11:10:42 2019
 
  Example of a cross-nested logit model.
- Same as 11cnl, where the zero alphas are not included.
  Three alternatives: Train, Car and Swissmetro
  Train and car are in the same nest.
  SP data
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable
+from biogeme.expressions import Beta, Variable
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -52,57 +61,57 @@
 ALPHA_PUBLIC = 1 - ALPHA_EXISTING
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
 V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
 # Definition of nests
 # Nest membership parameters
-alpha_existing = {1: ALPHA_EXISTING, 3: 1.0}
+alpha_existing = {1: ALPHA_EXISTING, 2: 0.0, 3: 1.0}
 
-alpha_public = {1: ALPHA_PUBLIC, 2: 1.0}
+alpha_public = {1: ALPHA_PUBLIC, 2: 1.0, 3: 0.0}
 
 nest_existing = MU_EXISTING, alpha_existing
 nest_public = MU_PUBLIC, alpha_public
 nests = nest_existing, nest_public
 
 # The choice model is a cross-nested logit, with availability conditions
 logprob = models.logcnl_avail(V, av, nests, CHOICE)
 
 # Define level of verbosity
 logger = msg.bioMessage()
-logger.setSilent()
+# logger.setSilent()
 # logger.setWarning()
-# logger.setGeneral()
+logger.setGeneral()
 # logger.setDetailed()
 
 # Create the Biogeme object
 biogeme = bio.BIOGEME(database, logprob)
-biogeme.modelName = '11cnl_sparse'
+biogeme.modelName = '11cnl'
 
 # Estimate the parameters
 results = biogeme.estimate()
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/12panel.py` & `biogeme-3.2.9/examples/swissmetro/12panel.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,42 +5,55 @@
 
  Example of a mixture of logit models, using Monte-Carlo integration.
  The datafile is organized as panel data.
  Three alternatives: Train, Car and Swissmetro
  SP data
 """
 
+import numpy as np
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
+    Variable,
     bioDraws,
     PanelLikelihoodTrajectory,
     MonteCarlo,
     log,
 )
 
+np.random.seed(seed=90267)
+
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # They are organized as panel data. The variable ID identifies each individual.
 database.panel("ID")
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -76,24 +89,24 @@
 ASC_SM_RND = ASC_SM + ASC_SM_S * bioDraws('ASC_SM_RND', 'NORMAL_ANTI')
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN_RND + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM_RND + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR_RND + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
```

### Comparing `biogeme-3.2.8/examples/swissmetro/13panelNormalized.py` & `biogeme-3.2.9/examples/swissmetro/26triangularPanelMixture.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,104 +1,130 @@
-"""File 13panel.py
+"""File 26triangularPanelMixture.py
 
 :author: Michel Bierlaire, EPFL
-:date: Sun Sep  8 18:55:38 2019
+:date: Mon Sep  9 10:27:40 2019
 
  Example of a mixture of logit models, using Monte-Carlo integration.
- The datafile is organized as panel data.  Same as 12panel, where the
- error component for Swissmetro has been normalized to zero, and it
- corresponds to the lowest variance, according to the estimation
- rresults of 12panel.py. Moreover, the starting values for the
- parameters are close to optimal.  Useful for a faster estimation of
- the model with a large number of draws.  Three alternatives: Train,
- Car and Swissmetro SP data
-
+ THe micing distribution is user-defined (triangular, here).
+ The datafile is organized as panel data.
+ Three alternatives: Train, Car and Swissmetro
+ SP data
 """
-
+import numpy as np
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme.expressions import (
+    Variable,
     Beta,
-    DefineVariable,
     bioDraws,
-    PanelLikelihoodTrajectory,
     MonteCarlo,
+    PanelLikelihoodTrajectory,
     log,
 )
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # They are organized as panel data. The variable ID identifies each individual.
 database.panel("ID")
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
-
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
+
 # Here we use the "biogeme" way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
+def the_triangular_generator(sample_size, number_of_draws):
+    """
+    Provide my own random number generator to the database.
+    See the numpy.random documentation to obtain a list of other distributions.
+    """
+    return np.random.triangular(-1, 0, 1, (sample_size, number_of_draws))
+
+
+myRandomNumberGenerators = {
+    'TRIANGULAR': (
+        the_triangular_generator,
+        'Draws from a triangular distribution',
+    )
+}
+database.setRandomNumberGenerators(myRandomNumberGenerators)
+
 # Parameters to be estimated
-B_COST = Beta('B_COST', -3.32, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Define a random parameter, normally distributed across individuals,
 # designed to be used for Monte-Carlo simulation
-B_TIME = Beta('B_TIME', -5.4, None, None, 0)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
 
 # It is advised not to use 0 as starting value for the following parameter.
-B_TIME_S = Beta('B_TIME_S', 1.55, None, None, 0)
-B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL_ANTI')
+B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
+B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'TRIANGULAR')
 
 # We do the same for the constants, to address serial correlation.
-ASC_CAR = Beta('ASC_CAR', 0.357, None, None, 0)
-ASC_CAR_S = Beta('ASC_CAR_S', 3.37, None, None, 0)
-ASC_CAR_RND = ASC_CAR + ASC_CAR_S * bioDraws('ASC_CAR_RND', 'NORMAL_ANTI')
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_CAR_S = Beta('ASC_CAR_S', 1, None, None, 0)
+ASC_CAR_RND = ASC_CAR + ASC_CAR_S * bioDraws('ASC_CAR_RND', 'TRIANGULAR')
 
-ASC_TRAIN = Beta('ASC_TRAIN', -0.617, None, None, 0)
-ASC_TRAIN_S = Beta('ASC_TRAIN_S', 3.13, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_TRAIN_S = Beta('ASC_TRAIN_S', 1, None, None, 0)
 ASC_TRAIN_RND = ASC_TRAIN + ASC_TRAIN_S * bioDraws(
-    'ASC_TRAIN_RND', 'NORMAL_ANTI'
+    'ASC_TRAIN_RND', 'TRIANGULAR'
 )
 
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+ASC_SM_S = Beta('ASC_SM_S', 1, None, None, 0)
+ASC_SM_RND = ASC_SM + ASC_SM_S * bioDraws('ASC_SM_RND', 'TRIANGULAR')
+
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN_RND + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
-V2 = B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V2 = ASC_SM_RND + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR_RND + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
 V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
@@ -121,13 +147,13 @@
 # logger.setWarning()
 # logger.setGeneral()
 logger.setDetailed()
 # logger.setDebug()
 
 # Create the Biogeme object
 biogeme = bio.BIOGEME(database, logprob, numberOfDraws=100000)
-biogeme.modelName = '13panel'
+biogeme.modelName = '26triangularPanelMixture'
 
 # Estimate the parameters.
 results = biogeme.estimate()
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/14nestedEndogenousSampling.py` & `biogeme-3.2.9/examples/swissmetro/14nestedEndogenousSampling.py`

 * *Files 15% similar despite different names*

```diff
@@ -11,27 +11,37 @@
 
 import numpy as np
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable
+from biogeme.expressions import Beta, Variable
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -58,24 +68,24 @@
 correction = {1: np.log(R_TRAIN), 2: np.log(R_SM), 3: np.log(R_CAR)}
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
```

### Comparing `biogeme-3.2.8/examples/swissmetro/15panelDiscrete.py` & `biogeme-3.2.9/examples/swissmetro/15panelDiscrete.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
+    Variable,
     bioDraws,
     PanelLikelihoodTrajectory,
     MonteCarlo,
     log,
 )
 
 # Read the data
@@ -30,17 +30,27 @@
 # They are organized as panel data. The variable ID identifies each individual.
 database.panel("ID")
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -115,24 +125,24 @@
 PROB_class1 = 1 - PROB_class0
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # In class 0, it is assumed that the time coefficient is zero
 B_TIME_RND[0] = 0
 
 # Utility functions
 V1 = [
     ASC_TRAIN_RND[i]
```

### Comparing `biogeme-3.2.8/examples/swissmetro/15panelDiscreteBis.py` & `biogeme-3.2.9/examples/swissmetro/15panelDiscreteBis.py`

 * *Files 9% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
+    Variable,
     bioDraws,
     PanelLikelihoodTrajectory,
     MonteCarlo,
     log,
 )
 
 # Read the data
@@ -31,17 +31,27 @@
 # They are organized as panel data. The variable ID identifies each individual.
 database.panel("ID")
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -116,24 +126,24 @@
 PROB_class1 = 1 - PROB_class0
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # In class 0, it is assumed that the time coefficient is zero
 B_TIME_RND[0] = 0
 
 # Utility functions
 V1 = [
     ASC_TRAIN_RND[i]
```

### Comparing `biogeme-3.2.8/examples/swissmetro/16panelDiscreteSocioEco.py` & `biogeme-3.2.9/examples/swissmetro/16panelDiscreteSocioEco.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 """File 16panelDiscreteSocioEco.py
 
 :author: Michel Bierlaire, EPFL
-:date: Sun Sep  8 19:30:31 2019
+:date: Mon Feb 14 14:47:54 2022
 
  Example of a discrete mixture of logit models, also called latent class model.
  The class membership model includes socio-economic variables.
  The datafile is organized as panel data.
  Three alternatives: Train, Car and Swissmetro
  SP data
 """
@@ -13,46 +13,76 @@
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
+    Variable,
+    Variable,
     bioDraws,
-    PanelLikelihoodTrajectory,
     MonteCarlo,
     log,
+    exp,
+    bioMultSum,
 )
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # They are organized as panel data. The variable ID identifies each individual.
 database.panel("ID")
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
+INCOME = Variable('INCOME')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
 # Here we use the "biogeme" way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
+# Definition of new variables
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+# Definition of new variables: adding columns to the database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+_ = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+_ = database.DefineVariable('TRAIN_COST_SCALED', TRAIN_COST / 100)
+_ = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+_ = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+_ = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+_ = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+flat_df = database.generateFlatPanelDataframe(identical_columns=None)
+flat_database = db.Database('swissmetro_flat', flat_df)
+
 # Parameters to be estimated. One version for each latent class.
 numberOfClasses = 2
 B_COST = [
     Beta(f'B_COST_class{i}', 0, None, None, 0) for i in range(numberOfClasses)
 ]
 
 # Define a random parameter, normally distributed across individuals,
@@ -111,57 +141,65 @@
     for i in range(numberOfClasses)
 ]
 
 # Parameters for the class membership model
 CLASS_CTE = Beta('CLASS_CTE', 0, None, None, 0)
 CLASS_INC = Beta('CLASS_INC', 0, None, None, 0)
 
-# Definition of new variables
-SM_COST = SM_CO * (GA == 0)
-TRAIN_COST = TRAIN_CO * (GA == 0)
-
-# Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
-)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
 
 # In class 0, it is assumed that the time coefficient is zero
 B_TIME_RND[0] = 0
 
 # Utility functions
 V1 = [
-    ASC_TRAIN_RND[i]
-    + B_TIME_RND[i] * TRAIN_TT_SCALED
-    + B_COST[i] * TRAIN_COST_SCALED
+    [
+        ASC_TRAIN_RND[i]
+        + B_TIME_RND[i] * Variable(f'{t}_TRAIN_TT_SCALED')
+        + B_COST[i] * Variable(f'{t}_TRAIN_COST_SCALED')
+        for t in range(1, 10)
+    ]
     for i in range(numberOfClasses)
 ]
 V2 = [
-    ASC_SM_RND[i] + B_TIME_RND[i] * SM_TT_SCALED + B_COST[i] * SM_COST_SCALED
+    [
+        ASC_SM_RND[i]
+        + B_TIME_RND[i] * Variable(f'{t}_SM_TT_SCALED')
+        + B_COST[i] * Variable(f'{t}_SM_COST_SCALED')
+        for t in range(1, 10)
+    ]
     for i in range(numberOfClasses)
 ]
 V3 = [
-    ASC_CAR_RND[i] + B_TIME_RND[i] * CAR_TT_SCALED + B_COST[i] * CAR_CO_SCALED
+    [
+        ASC_CAR_RND[i]
+        + B_TIME_RND[i] * Variable(f'{t}_CAR_TT_SCALED')
+        + B_COST[i] * Variable(f'{t}_CAR_CO_SCALED')
+        for t in range(1, 10)
+    ]
+    for i in range(numberOfClasses)
+]
+V = [
+    [{1: V1[i][t], 2: V2[i][t], 3: V3[i][t]} for t in range(9)]
     for i in range(numberOfClasses)
 ]
-V = [{1: V1[i], 2: V2[i], 3: V3[i]} for i in range(numberOfClasses)]
 
 # Associate the availability conditions with the alternatives
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
 # The choice model is a discrete mixture of logit, with availability conditions
 # We calculate the conditional probability for each class
 prob = [
-    PanelLikelihoodTrajectory(models.logit(V[i], av, CHOICE))
+    exp(
+        bioMultSum(
+            [
+                models.loglogit(V[i][t], av, Variable(f'{t+1}_CHOICE'))
+                for t in range(9)
+            ]
+        )
+    )
     for i in range(numberOfClasses)
 ]
 
 # Class membership model
 W = CLASS_CTE + CLASS_INC * INCOME
 PROB_class0 = models.logit({0: W, 1: 0}, None, 0)
 PROB_class1 = models.logit({0: W, 1: 0}, None, 1)
@@ -176,14 +214,14 @@
 logger = msg.bioMessage()
 # logger.setSilent()
 # logger.setWarning()
 logger.setGeneral()
 # logger.setDetailed()
 
 # Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob, numberOfDraws=100000)
+biogeme = bio.BIOGEME(flat_database, logprob, numberOfDraws=100000)
 biogeme.modelName = '16panelDiscreteSocioEco'
 
 # Estimate the parameters.
 results = biogeme.estimate()
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/17lognormalMixture.py` & `biogeme-3.2.9/examples/swissmetro/25triangularMixture.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,87 +1,110 @@
-"""File 17lognormalMixture.py
+"""File 25triangularMixture.py
 
 :author: Michel Bierlaire, EPFL
-:date: Sat Sep  7 18:23:01 2019
+:date: Mon Sep  9 10:19:24 2019
 
  Example of a mixture of logit models, using Monte-Carlo integration.
- The mixing distribution is distributed as a log normal.
+ The mixing distirbution is specified by the user. Here, a triangular
+ distribution.
  Three alternatives: Train, Car and Swissmetro
  SP data
+
 """
 
+import numpy as np
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import (
-    Beta,
-    DefineVariable,
-    exp,
-    log,
-    MonteCarlo,
-    bioDraws,
-)
+from biogeme.expressions import Beta, Variable, bioDraws, log, MonteCarlo
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
 # Here we use the "biogeme" way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
-
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
 B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Define a random parameter, normally distributed, designed to be used
 # for Monte-Carlo simulation
 B_TIME = Beta('B_TIME', 0, None, None, 0)
 
 # It is advised not to use 0 as starting value for the following parameter.
 B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
 
-# Define a random parameter, log normally distributed, designed to be used
-# for Monte-Carlo simulation.
-B_TIME_RND = -exp(B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL'))
+
+def theTriangularGenerator(sampleSize, numberOfDraws):
+    """
+    User-defined random number generator to the database.
+    See the numpy.random documentation to obtain a list of other distributions.
+    """
+    return np.random.triangular(-1, 0, 1, (sampleSize, numberOfDraws))
+
+
+myRandomNumberGenerators = {
+    'TRIANGULAR': (
+        theTriangularGenerator,
+        'Draws from a triangular distribution',
+    )
+}
+
+database.setRandomNumberGenerators(myRandomNumberGenerators)
+
+# Define a random parameter with a triangular distribution, designed to be used
+# for Monte-Carlo simulation
+B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'TRIANGULAR')
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
@@ -101,13 +124,13 @@
 # logger.setSilent()
 # logger.setWarning()
 logger.setGeneral()
 # logger.setDetailed()
 
 # Create the Biogeme object
 biogeme = bio.BIOGEME(database, logprob, numberOfDraws=100000)
-biogeme.modelName = '17lognormalMixture'
+biogeme.modelName = '25triangularMixture'
 
 # Estimate the parameters
 results = biogeme.estimate()
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/17lognormalMixtureIntegral.py` & `biogeme-3.2.9/examples/swissmetro/17lognormalMixtureIntegral.py`

 * *Files 21% similar despite different names*

```diff
@@ -13,32 +13,42 @@
 import biogeme.database as db
 import biogeme.biogeme as bio
 import biogeme.distributions as dist
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
+    Variable,
     RandomVariable,
     exp,
     log,
     Integrate,
 )
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -66,24 +76,24 @@
 density = dist.normalpdf(omega)
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
```

### Comparing `biogeme-3.2.8/examples/swissmetro/19individualLevelParameters.py` & `biogeme-3.2.9/examples/swissmetro/19individualLevelParameters.py`

 * *Files 13% similar despite different names*

```diff
@@ -8,23 +8,33 @@
 
 import os
 import pickle
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
-from biogeme.expressions import Beta, DefineVariable, bioDraws, MonteCarlo
+from biogeme.expressions import Beta, Variable, bioDraws, MonteCarlo
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Here we use the "biogeme" way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 # Values of the parameters estimated by the model 05normalMixture
 ASC_CAR = Beta('ASC_CAR', 0.137, None, None, 0)
@@ -41,24 +51,24 @@
 B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL')
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
@@ -75,17 +85,22 @@
 
 simulate = {
     'Numerator': numerator,
     'Denominator': denominator,
     'Choice': CHOICE,
 }
 
-pickleFile = '19individualLevelParameters.pickle'
-if os.path.isfile(pickleFile):
-    with open(pickleFile, 'rb') as f:
+pickle_file = '19individualLevelParameters.pickle'
+if os.path.isfile(pickle_file):
+    with open(pickle_file, 'rb') as f:
         sim = pickle.load(f)
 else:
     biosim = bio.BIOGEME(database, simulate, numberOfDraws=100000)
     sim = biosim.simulate()
     sim['Individual-level parameters'] = sim['Numerator'] / sim['Denominator']
-    with open(pickleFile, 'wb') as f:
+    with open(pickle_file, 'wb') as f:
         pickle.dump(sim, f)
+
+html_file = '19individualLevelParameters.html'
+with open(html_file, 'w') as h:
+    print(sim.to_html(), file=h)
+print(f'Simulated values available in {html_file}')
```

### Comparing `biogeme-3.2.8/examples/swissmetro/21probit.py` & `biogeme-3.2.9/examples/swissmetro/04validation.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,90 +1,98 @@
-"""File 21probit.py
+"""File 04validation.py
 
 :author: Michel Bierlaire, EPFL
-:date: Mon Sep  9 10:14:57 2019
+:date: Thu Jun  4 17:55:27 2020
 
- Example of a binary probit model.
- Two alternatives: Train and Car
+ Example of the out-of-sample validation of a logit model.
+ Three alternatives: Train, Car and Swissmetro
  SP data
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable, bioNormalCdf, Elem, log
+from biogeme import models
+from biogeme.expressions import Beta, Variable
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
-# The Pandas data structure is available as database.data. Use all the
-# Pandas functions to invesigate the database
-# print(database.data.describe())
-
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
-
-# Removing some observations can be done directly using pandas.
-# remove = (((database.data.PURPOSE != 1) &
-#           (database.data.PURPOSE != 3)) |
-#          (database.data.CHOICE == 0))
-# database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility. As we
-# estimate a binary model, we remove observations where Swissmetro was
-# chosen (CHOICE == 2). We also remove observations where one of the
-# two alternatives is not available.
-
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-exclude = (TRAIN_AV_SP == 0) + (CAR_AV_SP == 0) + (CHOICE == 2) + (
-    (PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)
-) > 0
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
+
+# Removing some observations
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
 B_TIME = Beta('B_TIME', 0, None, None, 0)
 B_COST = Beta('B_COST', 0, None, None, 0)
 
+
 # Definition of new variables
+SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
-
-# Definition of new variables by adding columns to the database.
-# This is recommended for estimation. And not recommended for simulation.
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
-)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+CAR_AV_SP = CAR_AV * (SP != 0)
+TRAIN_AV_SP = TRAIN_AV * (SP != 0)
+TRAIN_TT_SCALED = TRAIN_TT / 100.0
+TRAIN_COST_SCALED = TRAIN_COST / 100
+SM_TT_SCALED = SM_TT / 100.0
+SM_COST_SCALED = SM_COST / 100
+CAR_TT_SCALED = CAR_TT / 100
+CAR_CO_SCALED = CAR_CO / 100
 
 # Definition of the utility functions
-# We estimate a binary probit model. There are only two alternatives.
-V1 = B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
-# Associate choice probability with the numbering of alternatives
-P = {1: bioNormalCdf(V1 - V3), 3: bioNormalCdf(V3 - V1)}
+# Associate utility functions with the numbering of alternatives
+V = {1: V1, 2: V2, 3: V3}
+
+# Associate the availability conditions with the alternatives
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
 # Definition of the model. This is the contribution of each
 # observation to the log likelihood function.
-logprob = log(Elem(P, CHOICE))
-
-# Define level of verbosity
-logger = msg.bioMessage()
-logger.setSilent()
-# logger.setWarning()
-# logger.setGeneral()
-# logger.setDetailed()
+logprob = models.loglogit(V, av, CHOICE)
 
 # Create the Biogeme object
 biogeme = bio.BIOGEME(database, logprob)
-biogeme.modelName = '21probit'
+biogeme.modelName = '04validation'
 
 # Estimate the parameters
 results = biogeme.estimate()
-pandasResults = results.getEstimatedParameters()
-print(pandasResults)
+
+# The validation consists in organizing the data into several slices
+# of about the same size, randomly defined. Each slice is considered
+# as a validation dataset. The model is then re-estimated using all
+# the data except the slice, and the estimated model is applied on the
+# validation set (i.e. the slice). The value of the log likelihood for
+# each observation in the validation set is reported in a
+# dataframe. As this is done for each slice, the output is a list of
+# dataframes, each corresponding to one of these exercises.
+
+validationData = database.split(slices=5)
+
+validation_results = biogeme.validate(results, validationData)
+
+for slide in validation_results:
+    print(
+        f'Log likelihood for {slide.shape[0]} validation data: '
+        f'{slide["Loglikelihood"].sum()}'
+    )
```

### Comparing `biogeme-3.2.8/examples/swissmetro/24haltonMixture.py` & `biogeme-3.2.9/examples/workingNotToDistribute/01logit_simul.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,114 +1,141 @@
-"""File 24haltonMixture.py
-
-:author: Michel Bierlaire, EPFL
-:date: Mon Sep  9 11:02:37 2019
-
- Example of a mixture of logit models, using quasi Monte-Carlo integration with
- Halton draws (base 5).
- The mixing distribution is normal.
- Three alternatives: Train, Car and Swissmetro
- SP data
-
-"""
-
-import pandas as pd
-import biogeme.database as db
-import biogeme.biogeme as bio
-from biogeme import models
-import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable, bioDraws, MonteCarlo, log
-
-# Read the data
-df = pd.read_csv('swissmetro.dat', sep='\t')
-database = db.Database('swissmetro', df)
-
-# The Pandas data structure is available as database.data. Use all the
-# Pandas functions to invesigate the database
-# print(database.data.describe())
-
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
-
-# Removing some observations can be done directly using pandas.
-# remove = (((database.data.PURPOSE != 1) &
-#           (database.data.PURPOSE != 3)) |
-#          (database.data.CHOICE == 0))
-# database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
-database.remove(exclude)
-
-# Parameters to be estimated
-ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
-ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
-ASC_SM = Beta('ASC_SM', 0, None, None, 1)
-B_COST = Beta('B_COST', 0, None, None, 0)
-
-# Define a random parameter, normally distributed, designed to be used
-# for Monte-Carlo simulation
-B_TIME = Beta('B_TIME', 0, None, None, 0)
-
-# It is advised not to use 0 as starting value for the following parameter.
-B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
-# Define a random parameter with a normal distribution, designed to be used
-# for quasi Monte-Carlo simulation with Halton draws (base 5).
-B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL_HALTON5')
-
-# Definition of new variables
-SM_COST = SM_CO * (GA == 0)
-TRAIN_COST = TRAIN_CO * (GA == 0)
-
-# Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
-)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
-
-# Definition of the utility functions
-V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
-V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
-
-# Associate utility functions with the numbering of alternatives
-V = {1: V1, 2: V2, 3: V3}
-
-# Associate the availability conditions with the alternatives
-av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
-
-# Conditional to B_TIME_RND, we have a logit model (called the kernel)
-prob = models.logit(V, av, CHOICE)
-
-# We integrate over B_TIME_RND using Monte-Carlo
-logprob = log(MonteCarlo(prob))
-
-# Define level of verbosity
-logger = msg.bioMessage()
-# logger.setSilent()
-# logger.setWarning()
-logger.setGeneral()
-# logger.setDetailed()
-
-# These notes will be included as such in the report file.
-userNotes = (
-    'Example of a mixture of logit models with three alternatives, '
-    'approximated using Monte-Carlo integration with Halton draws.'
-)
-
-# Create the Biogeme object
-biogeme = bio.BIOGEME(
-    database, logprob, numberOfDraws=100000, userNotes=userNotes
-)
-biogeme.modelName = '24haltonMixture'
-
-# Estimate the parameters
-results = biogeme.estimate()
-pandasResults = results.getEstimatedParameters()
-print(pandasResults)
+"""File 01logit_simul.py
+
+:author: Michel Bierlaire, EPFL
+:date: Sat Sep  7 18:06:08 2019
+
+ Example of simulation with a logit model
+ Three alternatives: Train, Car and Swissmetro
+ SP data
+"""
+import time
+import pandas as pd
+import biogeme.database as db
+import biogeme.biogeme as bio
+import biogeme.models as models
+from biogeme.expressions import Beta, Derive
+
+# Read the data
+df = pd.read_csv('swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
+
+# The Pandas data structure is available as database.data. Use all the
+# Pandas functions to investigate the database. For example:
+#print(database.data.describe())
+
+# The following statement allows you to use the names of the variable
+# as Python variable.
+globals().update(database.variables)
+
+# Removing some observations can be done directly using pandas.
+#remove = (((database.data.PURPOSE != 1) &
+#           (database.data.PURPOSE != 3)) |
+#          (database.data.CHOICE == 0))
+#database.data.drop(database.data[remove].index,inplace=True)
+
+# Here we use the "biogeme" way for backward compatibility
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
+database.remove(exclude)
+
+# Parameters to be estimated
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+# Definition of new variables
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+# Definition of new variables: in simulation, do not use the DefineVariable operator,
+# as it hides the functional relationships. In particular, derivatives cannot be
+# calculated.
+CAR_AV_SP = CAR_AV * (SP != 0)
+TRAIN_AV_SP = TRAIN_AV * (SP != 0)
+TRAIN_TT_SCALED = TRAIN_TT / 100.0
+TRAIN_COST_SCALED = TRAIN_COST / 100
+SM_TT_SCALED = SM_TT / 100.0
+SM_COST_SCALED = SM_COST / 100
+CAR_TT_SCALED = CAR_TT / 100
+CAR_CO_SCALED = CAR_CO / 100
+
+# Definition of the utility functions
+V1 = ASC_TRAIN + \
+     B_TIME * TRAIN_TT_SCALED + \
+     B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + \
+     B_TIME * SM_TT_SCALED + \
+     B_COST * SM_COST_SCALED
+V3 = ASC_CAR + \
+     B_TIME * CAR_TT_SCALED + \
+     B_COST * CAR_CO_SCALED
+
+# Associate utility functions with the numbering of alternatives
+V = {1: V1,
+     2: V2,
+     3: V3}
+
+# Associate the availability conditions with the alternatives
+av = {1: TRAIN_AV_SP,
+      2: SM_AV,
+      3: CAR_AV_SP}
+
+# The choice model is a logit, with availability conditions
+prob1 = models.logit(V, av, 1)
+prob2 = models.logit(V, av, 2)
+prob3 = models.logit(V, av, 3)
+
+
+
+
+# Elasticities can be computed. We illustrate below two
+# formulas. Check in the output file that they produce the same
+# result.
+
+# First, the general definition of elasticities. This illustrates the
+# use of the Derive expression, and can be used with any model,
+# however complicated it is. Note the quotes in the Derive opertor.
+genelas1 = Derive(prob1, 'TRAIN_TT') * TRAIN_TT / prob1
+genelas2 = Derive(prob2, 'SM_TT') * SM_TT / prob2
+genelas3 = Derive(prob3, 'CAR_TT') * CAR_TT / prob3
+
+# Second, the elasticity of logit models. See Ben-Akiva and Lerman for
+# the formula
+
+logitelas1 = TRAIN_AV_SP * (1.0 - prob1) * TRAIN_TT_SCALED * B_TIME
+logitelas2 = SM_AV * (1.0 - prob2) * SM_TT_SCALED * B_TIME
+logitelas3 = CAR_AV_SP * (1.0 - prob3) * CAR_TT_SCALED * B_TIME
+
+simulate = {'Prob. train': prob1,
+            'Prob. Swissmetro': prob2,
+            'Prob. car': prob3,
+            'logit elas. 1': logitelas1,
+            'generic elas. 1': genelas1,
+            'logit elas. 2': logitelas2,
+            'generic elas. 2': genelas2,
+            'logit elas. 3': logitelas3,
+            'generic elas. 3': genelas3}
+
+
+biogeme = bio.BIOGEME(database, simulate)
+biogeme.modelName = '01logit_simul'
+betas = {'ASC_TRAIN': -0.701188,
+         'B_TIME': -1.27786,
+         'B_COST': -1.08379,
+         'ASC_SM': 0,
+         'ASC_CAR': -0.154633}
+
+tic = time.perf_counter()
+results1 = biogeme.simulate(theBetaValues=betas)
+toc = time.perf_counter()
+print(results1)
+newtime = toc - tic
+
+tic = time.perf_counter()
+results = biogeme.oldsimulate(theBetaValues=betas)
+toc = time.perf_counter()
+oldtime = toc - tic
+gain = oldtime - newtime
+#print(results.describe())
+print(results)
+print(f'Time gain: {gain:.4f} {100*gain/oldtime:.4f}%')
```

### Comparing `biogeme-3.2.8/examples/swissmetro/25triangularMixture.py` & `biogeme-3.2.9/examples/swissmetro/06unifMixtureIntegral.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,39 +1,53 @@
-"""File 25triangularMixture.py
+"""File 06unifMixtureIntegral.py
 
 :author: Michel Bierlaire, EPFL
-:date: Mon Sep  9 10:19:24 2019
+:date: Sat Sep  7 20:45:18 2019
 
- Example of a mixture of logit models, using Monte-Carlo integration.
- The mixing distirbution is specified by the user. Here, a triangular
- distribution.
+ Example of a mixture of logit models, using numerical integration.
+ The mixing distribution is uniform.
  Three alternatives: Train, Car and Swissmetro
  SP data
-
 """
 
-import numpy as np
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
-from biogeme.expressions import Beta, DefineVariable, bioDraws, log, MonteCarlo
+from biogeme.expressions import (
+    Beta,
+    Variable,
+    Integrate,
+    RandomVariable,
+    exp,
+    log,
+)
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
@@ -44,83 +58,64 @@
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
 B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Define a random parameter, normally distributed, designed to be used
-# for Monte-Carlo simulation
+# for numerical integration
 B_TIME = Beta('B_TIME', 0, None, None, 0)
-
-# It is advised not to use 0 as starting value for the following parameter.
 B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
-
-
-def theTriangularGenerator(sampleSize, numberOfDraws):
-    """
-    User-defined random number generator to the database.
-    See the numpy.random documentation to obtain a list of other distributions.
-    """
-    return np.random.triangular(-1, 0, 1, (sampleSize, numberOfDraws))
-
-
-myRandomNumberGenerators = {
-    'TRIANGULAR': (
-        theTriangularGenerator,
-        'Draws from a triangular distribution',
-    )
-}
-
-database.setRandomNumberGenerators(myRandomNumberGenerators)
-
-# Define a random parameter with a triangular distribution, designed to be used
-# for Monte-Carlo simulation
-B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'TRIANGULAR')
+omega = RandomVariable('omega')
+a = -1
+b = 1
+x = a + (b - a) / (1 + exp(-omega))
+dx = (b - a) * exp(-omega) * (1 + exp(-omega)) ** (-2)
+B_TIME_RND = B_TIME + B_TIME_S * x
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
 V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
 av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-# Conditional to B_TIME_RND, we have a logit model (called the kernel)
-prob = models.logit(V, av, CHOICE)
-
-# We integrate over B_TIME_RND using Monte-Carlo
-logprob = log(MonteCarlo(prob))
+# Conditional to omega, we have a logit model (called the kernel)
+condprob = models.logit(V, av, CHOICE)
+# We integrate over omega using numerical integration
+logprob = log(Integrate(condprob * dx / (b - a), 'omega'))
 
 # Define level of verbosity
 logger = msg.bioMessage()
 # logger.setSilent()
 # logger.setWarning()
 logger.setGeneral()
 # logger.setDetailed()
 
 # Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob, numberOfDraws=100000)
-biogeme.modelName = '25triangularMixture'
+biogeme = bio.BIOGEME(database, logprob)
+biogeme.modelName = '06unifMixtureIntegral'
 
 # Estimate the parameters
 results = biogeme.estimate()
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/swissmetro/26triangularPanelMixture.py` & `biogeme-3.2.9/examples/swissmetro/13panel_simul.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,116 +1,115 @@
-"""File 26triangularPanelMixture.py
+"""File 13panel_simul.py
 
 :author: Michel Bierlaire, EPFL
-:date: Mon Sep  9 10:27:40 2019
+:date: Sun Oct 31 16:25:16 2021
 
  Example of a mixture of logit models, using Monte-Carlo integration.
- THe micing distribution is user-defined (triangular, here).
  The datafile is organized as panel data.
  Three alternatives: Train, Car and Swissmetro
  SP data
 """
-import numpy as np
+
+import sys
+import pickle
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
+import biogeme.exceptions as excep
+import biogeme.results as res
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
-    DefineVariable,
+    Variable,
     bioDraws,
-    MonteCarlo,
     PanelLikelihoodTrajectory,
+    MonteCarlo,
     log,
 )
 
+
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
-# They are organized as panel data. The variable ID identifies each individual.
-database.panel("ID")
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
 # print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
 # remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
 # database.data.drop(database.data[remove].index,inplace=True)
 
 # Here we use the "biogeme" way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
-
-def theTriangularGenerator(sampleSize, numberOfDraws):
-    """
-    Provide my own random number generator to the database.
-    See the numpy.random documentation to obtain a list of other distributions.
-    """
-    return np.random.triangular(-1, 0, 1, (sampleSize, numberOfDraws))
+# They are organized as panel data. The variable ID identifies each individual.
+database.panel("ID")
 
 
-myRandomNumberGenerators = {
-    'TRIANGULAR': (
-        theTriangularGenerator,
-        'Draws from a triangular distribution',
-    )
-}
-database.setRandomNumberGenerators(myRandomNumberGenerators)
-
 # Parameters to be estimated
 B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Define a random parameter, normally distributed across individuals,
 # designed to be used for Monte-Carlo simulation
 B_TIME = Beta('B_TIME', 0, None, None, 0)
 
 # It is advised not to use 0 as starting value for the following parameter.
 B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
-B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'TRIANGULAR')
+B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL_ANTI')
 
 # We do the same for the constants, to address serial correlation.
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_CAR_S = Beta('ASC_CAR_S', 1, None, None, 0)
-ASC_CAR_RND = ASC_CAR + ASC_CAR_S * bioDraws('ASC_CAR_RND', 'TRIANGULAR')
+ASC_CAR_RND = ASC_CAR + ASC_CAR_S * bioDraws('ASC_CAR_RND', 'NORMAL_ANTI')
 
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_TRAIN_S = Beta('ASC_TRAIN_S', 1, None, None, 0)
 ASC_TRAIN_RND = ASC_TRAIN + ASC_TRAIN_S * bioDraws(
-    'ASC_TRAIN_RND', 'TRIANGULAR'
+    'ASC_TRAIN_RND', 'NORMAL_ANTI'
 )
 
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
 ASC_SM_S = Beta('ASC_SM_S', 1, None, None, 0)
-ASC_SM_RND = ASC_SM + ASC_SM_S * bioDraws('ASC_SM_RND', 'TRIANGULAR')
+ASC_SM_RND = ASC_SM + ASC_SM_S * bioDraws('ASC_SM_RND', 'NORMAL_ANTI')
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # Definition of new variables: adding columns to the database
-CAR_AV_SP = DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0), database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0), database)
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0, database)
-TRAIN_COST_SCALED = DefineVariable(
-    'TRAIN_COST_SCALED', TRAIN_COST / 100, database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
 )
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0, database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100, database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100, database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100, database)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
 V1 = ASC_TRAIN_RND + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM_RND + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR_RND + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
@@ -135,15 +134,47 @@
 logger = msg.bioMessage()
 # logger.setSilent()
 # logger.setWarning()
 # logger.setGeneral()
 logger.setDetailed()
 # logger.setDebug()
 
-# Create the Biogeme object
-biogeme = bio.BIOGEME(database, logprob, numberOfDraws=100000)
-biogeme.modelName = '26triangularPanelMixture'
-
 # Estimate the parameters.
-results = biogeme.estimate()
-pandasResults = results.getEstimatedParameters()
-print(pandasResults)
+try:
+    results = res.bioResults(pickleFile='12panel.pickle')
+except excep.biogemeError:
+    sys.exit(
+        'Run first the script 12panel.py '
+        'in order to generate the '
+        'file 12panel.pickle.'
+    )
+
+# Simulate to recalculate the log likelihood
+simulated_loglike = logprob.getValue_c(
+    database=database,
+    betas=results.getBetaValues(),
+    numberOfDraws=100000,
+    aggregation=True,
+    prepareIds=True,
+)
+
+print(f'Simulated log likelihood: {simulated_loglike}')
+
+numerator = MonteCarlo(B_TIME_RND * condprobIndiv)
+denominator = MonteCarlo(condprobIndiv)
+simulate = {
+    'Numerator': numerator,
+    'Denominator': denominator,
+}
+
+biosim = bio.BIOGEME(database, simulate, numberOfDraws=100000, suggestScales=False)
+sim = biosim.simulate()
+
+sim['Individual-level parameters'] = sim['Numerator'] / sim['Denominator']
+pickleFile = '13panel_individual_parameters.pickle'
+with open(pickleFile, 'wb') as f:
+    pickle.dump(sim, f)
+
+htmlFile = '13panel_individual_parameters.html'
+with open(htmlFile, 'w') as h:
+    print(sim.to_html(), file=h)
+print(f'Simulated values available in {htmlFile}')
```

### Comparing `biogeme-3.2.8/examples/swissmetro/swissmetro.dat` & `biogeme-3.2.9/examples/swissmetro/swissmetro.dat`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/swissmetro_panel/01logit_p.py` & `biogeme-3.2.9/examples/swissmetro_panel/01logit_p.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 
 # pylint: disable=invalid-name, undefined-variable
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 from biogeme import models
-from biogeme.expressions import Beta, Variable, DefineVariable, bioMultSum
+from biogeme.expressions import Beta, Variable, bioMultSum
 
 # Read the data
 df = pd.read_csv('swissmetro_panel.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # Number of observations for each individual. The are numbered from 0
 # to 8 in the dat set.
@@ -55,63 +55,63 @@
 
 TRAIN_COST = [
     Variable(f'TRAIN_CO_{q}') * (GA == 0) for q in range(nbrQuestions)
 ]
 
 # Definition of new variables: adding columns to the database
 CAR_AV_SP = [
-    DefineVariable(
-        f'CAR_AV_SP_{q}', Variable(f'CAR_AV_{q}') * (SP != 0), database
+    database.DefineVariable(
+        f'CAR_AV_SP_{q}', Variable(f'CAR_AV_{q}') * (SP != 0)
     )
     for q in range(nbrQuestions)
 ]
 
 TRAIN_AV_SP = [
-    DefineVariable(
-        f'TRAIN_AV_SP_{q}', Variable(f'TRAIN_AV_{q}') * (SP != 0), database
+    database.DefineVariable(
+        f'TRAIN_AV_SP_{q}', Variable(f'TRAIN_AV_{q}') * (SP != 0)
     )
     for q in range(nbrQuestions)
 ]
 
 SM_AV = [Variable(f'SM_AV_{q}') for q in range(nbrQuestions)]
 
 TRAIN_TT_SCALED = [
-    DefineVariable(
-        f'TRAIN_TT_SCALED_{q}', Variable(f'TRAIN_TT_{q}') / 100.0, database
+    database.DefineVariable(
+        f'TRAIN_TT_SCALED_{q}', Variable(f'TRAIN_TT_{q}') / 100.0
     )
     for q in range(nbrQuestions)
 ]
 
 TRAIN_COST_SCALED = [
-    DefineVariable(f'TRAIN_COST_SCALED_{q}', TRAIN_COST[q] / 100, database)
+    database.DefineVariable(f'TRAIN_COST_SCALED_{q}', TRAIN_COST[q] / 100)
     for q in range(nbrQuestions)
 ]
 
 SM_TT_SCALED = [
-    DefineVariable(
-        f'SM_TT_SCALED_{q}', Variable(f'SM_TT_{q}') / 100.0, database
+    database.DefineVariable(
+        f'SM_TT_SCALED_{q}', Variable(f'SM_TT_{q}') / 100.0
     )
     for q in range(nbrQuestions)
 ]
 
 SM_COST_SCALED = [
-    DefineVariable(f'SM_COST_SCALED_{q}', SM_COST[q] / 100, database)
+    database.DefineVariable(f'SM_COST_SCALED_{q}', SM_COST[q] / 100)
     for q in range(nbrQuestions)
 ]
 
 CAR_TT_SCALED = [
-    DefineVariable(
-        f'CAR_TT_SCALED_{q}', Variable(f'CAR_TT_{q}') / 100, database
+    database.DefineVariable(
+        f'CAR_TT_SCALED_{q}', Variable(f'CAR_TT_{q}') / 100
     )
     for q in range(nbrQuestions)
 ]
 
 CAR_CO_SCALED = [
-    DefineVariable(
-        f'CAR_CO_SCALED_{q}', Variable(f'CAR_CO_{q}') / 100, database
+    database.DefineVariable(
+        f'CAR_CO_SCALED_{q}', Variable(f'CAR_CO_{q}') / 100
     )
     for q in range(nbrQuestions)
 ]
 
 # Definition of the utility functions
 V1 = [
     ASC_TRAIN + B_TIME * TRAIN_TT_SCALED[q] + B_COST * TRAIN_COST_SCALED[q]
```

### Comparing `biogeme-3.2.8/examples/swissmetro_panel/12panel_p.py` & `biogeme-3.2.9/examples/swissmetro_panel/12panel_p.py`

 * *Files 7% similar despite different names*

```diff
@@ -19,15 +19,14 @@
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.messaging as msg
 from biogeme.expressions import (
     Beta,
     Variable,
     bioMultSum,
-    DefineVariable,
     bioDraws,
     MonteCarlo,
     log,
     exp,
 )
 
 # Read the data
@@ -65,63 +64,63 @@
 
 TRAIN_COST = [
     Variable(f'TRAIN_CO_{q}') * (GA == 0) for q in range(nbrQuestions)
 ]
 
 # Definition of new variables: adding columns to the database
 CAR_AV_SP = [
-    DefineVariable(
-        f'CAR_AV_SP_{q}', Variable(f'CAR_AV_{q}') * (SP != 0), database
+    database.DefineVariable(
+        f'CAR_AV_SP_{q}', Variable(f'CAR_AV_{q}') * (SP != 0)
     )
     for q in range(nbrQuestions)
 ]
 
 TRAIN_AV_SP = [
-    DefineVariable(
-        f'TRAIN_AV_SP_{q}', Variable(f'TRAIN_AV_{q}') * (SP != 0), database
+    database.DefineVariable(
+        f'TRAIN_AV_SP_{q}', Variable(f'TRAIN_AV_{q}') * (SP != 0)
     )
     for q in range(nbrQuestions)
 ]
 
 SM_AV = [Variable(f'SM_AV_{q}') for q in range(nbrQuestions)]
 
 TRAIN_TT_SCALED = [
-    DefineVariable(
-        f'TRAIN_TT_SCALED_{q}', Variable(f'TRAIN_TT_{q}') / 100.0, database
+    database.DefineVariable(
+        f'TRAIN_TT_SCALED_{q}', Variable(f'TRAIN_TT_{q}') / 100.0
     )
     for q in range(nbrQuestions)
 ]
 
 TRAIN_COST_SCALED = [
-    DefineVariable(f'TRAIN_COST_SCALED_{q}', TRAIN_COST[q] / 100, database)
+    database.DefineVariable(f'TRAIN_COST_SCALED_{q}', TRAIN_COST[q] / 100)
     for q in range(nbrQuestions)
 ]
 
 SM_TT_SCALED = [
-    DefineVariable(
-        f'SM_TT_SCALED_{q}', Variable(f'SM_TT_{q}') / 100.0, database
+    database.DefineVariable(
+        f'SM_TT_SCALED_{q}', Variable(f'SM_TT_{q}') / 100.0
     )
     for q in range(nbrQuestions)
 ]
 
 SM_COST_SCALED = [
-    DefineVariable(f'SM_COST_SCALED_{q}', SM_COST[q] / 100, database)
+    database.DefineVariable(f'SM_COST_SCALED_{q}', SM_COST[q] / 100)
     for q in range(nbrQuestions)
 ]
 
 CAR_TT_SCALED = [
-    DefineVariable(
-        f'CAR_TT_SCALED_{q}', Variable(f'CAR_TT_{q}') / 100, database
+    database.DefineVariable(
+        f'CAR_TT_SCALED_{q}', Variable(f'CAR_TT_{q}') / 100
     )
     for q in range(nbrQuestions)
 ]
 
 CAR_CO_SCALED = [
-    DefineVariable(
-        f'CAR_CO_SCALED_{q}', Variable(f'CAR_CO_{q}') / 100, database
+    database.DefineVariable(
+        f'CAR_CO_SCALED_{q}', Variable(f'CAR_CO_{q}') / 100
     )
     for q in range(nbrQuestions)
 ]
 
 # Definition of the utility functions
 V1 = [
     ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED[q] + B_COST * TRAIN_COST_SCALED[q]
```

### Comparing `biogeme-3.2.8/examples/vns/knapsack.py` & `biogeme-3.2.9/examples/vns/knapsack.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/vns/runknapsack.py` & `biogeme-3.2.9/examples/vns/runknapsack.py`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/workingNotToDistribute/01logit.py` & `biogeme-3.2.9/examples/swissmetro/01logit.py`

 * *Files 19% similar despite different names*

```diff
@@ -7,24 +7,34 @@
  Three alternatives: Train, Car and Swissmetro
  SP data
 """
 
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-from biogeme.expressions import Beta
+from biogeme import models
+from biogeme.expressions import Beta, Variable
 
 # Read the data
-df = pd.read_csv('swissmetro.dat', '\t')
+df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
-# The following statement allows you to use the names of the
-# variable as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
@@ -43,41 +53,34 @@
 TRAIN_COST_SCALED = TRAIN_COST / 100
 SM_TT_SCALED = SM_TT / 100
 SM_COST_SCALED = SM_COST / 100
 CAR_TT_SCALED = CAR_TT / 100
 CAR_CO_SCALED = CAR_CO / 100
 
 # Definition of the utility functions
-V1 = ASC_TRAIN + \
-     B_TIME * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
 # Definition of the model. This is the contribution of each
 # observation to the log likelihood function.
 logprob = models.loglogit(V, av, CHOICE)
 
 # Create the Biogeme object
 biogeme = bio.BIOGEME(database, logprob)
 biogeme.modelName = '01logit'
 
+# Calculate the null log likelihood for reporting.
+biogeme.calculateNullLoglikelihood(av)
+
 # Estimate the parameters
 results = biogeme.estimate()
 
 # Get the results in a pandas table
 pandasResults = results.getEstimatedParameters()
 print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/workingNotToDistribute/01logit_simul.py` & `biogeme-3.2.9/examples/swissmetro/09nested.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,141 +1,121 @@
-"""File 01logit_simul.py
+"""File 09nested.py
 
 :author: Michel Bierlaire, EPFL
-:date: Sat Sep  7 18:06:08 2019
+:date: Sun Sep  8 00:36:04 2019
 
- Example of simulation with a logit model
+ Example of a nested logit model.
  Three alternatives: Train, Car and Swissmetro
+ Train and car are in the same nest.
  SP data
 """
-import time
+
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-from biogeme.expressions import Beta, Derive
+from biogeme import models
+from biogeme.tools import calculate_correlation
+import biogeme.messaging as msg
+from biogeme.expressions import Beta, Variable
 
 # Read the data
 df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
-# Pandas functions to investigate the database. For example:
-#print(database.data.describe())
+# Pandas functions to invesigate the database
+# print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) &
+# remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
+# database.data.drop(database.data[remove].index,inplace=True)
 
 # Here we use the "biogeme" way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
 B_TIME = Beta('B_TIME', 0, None, None, 0)
 B_COST = Beta('B_COST', 0, None, None, 0)
+MU = Beta('MU', 1, 1, 10, 0)
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
-# Definition of new variables: in simulation, do not use the DefineVariable operator,
-# as it hides the functional relationships. In particular, derivatives cannot be
-# calculated.
-CAR_AV_SP = CAR_AV * (SP != 0)
-TRAIN_AV_SP = TRAIN_AV * (SP != 0)
-TRAIN_TT_SCALED = TRAIN_TT / 100.0
-TRAIN_COST_SCALED = TRAIN_COST / 100
-SM_TT_SCALED = SM_TT / 100.0
-SM_COST_SCALED = SM_COST / 100
-CAR_TT_SCALED = CAR_TT / 100
-CAR_CO_SCALED = CAR_CO / 100
+# Definition of new variables: adding columns to the database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
-V1 = ASC_TRAIN + \
-     B_TIME * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-# The choice model is a logit, with availability conditions
-prob1 = models.logit(V, av, 1)
-prob2 = models.logit(V, av, 2)
-prob3 = models.logit(V, av, 3)
-
-
-
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-# Elasticities can be computed. We illustrate below two
-# formulas. Check in the output file that they produce the same
-# result.
-
-# First, the general definition of elasticities. This illustrates the
-# use of the Derive expression, and can be used with any model,
-# however complicated it is. Note the quotes in the Derive opertor.
-genelas1 = Derive(prob1, 'TRAIN_TT') * TRAIN_TT / prob1
-genelas2 = Derive(prob2, 'SM_TT') * SM_TT / prob2
-genelas3 = Derive(prob3, 'CAR_TT') * CAR_TT / prob3
-
-# Second, the elasticity of logit models. See Ben-Akiva and Lerman for
-# the formula
-
-logitelas1 = TRAIN_AV_SP * (1.0 - prob1) * TRAIN_TT_SCALED * B_TIME
-logitelas2 = SM_AV * (1.0 - prob2) * SM_TT_SCALED * B_TIME
-logitelas3 = CAR_AV_SP * (1.0 - prob3) * CAR_TT_SCALED * B_TIME
-
-simulate = {'Prob. train': prob1,
-            'Prob. Swissmetro': prob2,
-            'Prob. car': prob3,
-            'logit elas. 1': logitelas1,
-            'generic elas. 1': genelas1,
-            'logit elas. 2': logitelas2,
-            'generic elas. 2': genelas2,
-            'logit elas. 3': logitelas3,
-            'generic elas. 3': genelas3}
-
-
-biogeme = bio.BIOGEME(database, simulate)
-biogeme.modelName = '01logit_simul'
-betas = {'ASC_TRAIN': -0.701188,
-         'B_TIME': -1.27786,
-         'B_COST': -1.08379,
-         'ASC_SM': 0,
-         'ASC_CAR': -0.154633}
-
-tic = time.perf_counter()
-results1 = biogeme.simulate(theBetaValues=betas)
-toc = time.perf_counter()
-print(results1)
-newtime = toc - tic
-
-tic = time.perf_counter()
-results = biogeme.oldsimulate(theBetaValues=betas)
-toc = time.perf_counter()
-oldtime = toc - tic
-gain = oldtime - newtime
-#print(results.describe())
-print(results)
-print(f'Time gain: {gain:.4f} {100*gain/oldtime:.4f}%')
+# Definition of nests:
+# 1: nests parameter
+# 2: list of alternatives
+existing = MU, [1, 3]
+future = 1.0, [2]
+nests = existing, future
+
+# Definition of the model. This is the contribution of each
+# observation to the log likelihood function.
+# The choice model is a nested logit, with availability conditions
+logprob = models.lognested(V, av, nests, CHOICE)
+
+# Define level of verbosity
+logger = msg.bioMessage()
+# logger.setSilent()
+# logger.setWarning()
+logger.setGeneral()
+# logger.setDetailed()
+
+# Create the Biogeme object
+biogeme = bio.BIOGEME(database, logprob)
+biogeme.modelName = "09nested"
+
+# Calculate the null log likelihood for reporting.
+biogeme.calculateNullLoglikelihood(av)
+
+# Estimate the parameters
+results = biogeme.estimate()
+pandasResults = results.getEstimatedParameters()
+print(pandasResults)
+
+corr = calculate_correlation(
+    nests, results, alternative_names={1: 'Train', 2: 'Swissmetro', 3: 'Car'}
+)
+print(corr)
```

### Comparing `biogeme-3.2.8/examples/workingNotToDistribute/Untitled.ipynb` & `biogeme-3.2.9/examples/workingNotToDistribute/Untitled.ipynb`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/workingNotToDistribute/new.py` & `biogeme-3.2.9/examples/swissmetro/03scale.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,131 +1,116 @@
-"""File 01logit_simul.py
+"""File 03scale.py
 
 :author: Michel Bierlaire, EPFL
-:date: Sat Sep  7 18:06:08 2019
+:date: Thu Sep  6 15:14:39 2018
 
- Example of simulation with a logit model
+ Illustrates heteroscedastic specification. A different scale is
+ associated with different segments of the sample.
  Three alternatives: Train, Car and Swissmetro
  SP data
+
 """
-import datetime
+
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-from biogeme.expressions import Beta, Derive
+from biogeme import models
+import biogeme.messaging as msg
+from biogeme.expressions import Beta, Variable
 
 # Read the data
-df = pd.read_csv('swissmetro.dat', '\t')
+df = pd.read_csv('swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to investigate the database. For example:
-#print(database.data.describe())
+# print(database.data.describe())
 
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
+GROUP = Variable('GROUP')
 
 # Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) &
+# remove = (((database.data.PURPOSE != 1) &
 #           (database.data.PURPOSE != 3)) |
 #          (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
+# database.data.drop(database.data[remove].index,inplace=True)
 
 # Here we use the "biogeme" way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 # Parameters to be estimated
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
 B_TIME = Beta('B_TIME', 0, None, None, 0)
 B_COST = Beta('B_COST', 0, None, None, 0)
+Scale_group3 = Beta('Scale_group3', 1, 0.001, None, 0)
 
 # Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
 
-# Definition of new variables: in simulation, do not use the DefineVariable operator,
-# as it hides the functional relationships. In particular, derivatives cannot be
-# calculated.
-CAR_AV_SP = CAR_AV * (SP != 0)
-TRAIN_AV_SP = TRAIN_AV * (SP != 0)
-TRAIN_TT_SCALED = TRAIN_TT / 100.0
-TRAIN_COST_SCALED = TRAIN_COST / 100
-SM_TT_SCALED = SM_TT / 100.0
-SM_COST_SCALED = SM_COST / 100
-CAR_TT_SCALED = CAR_TT / 100
-CAR_CO_SCALED = CAR_CO / 100
+# Definition of new variables: adding columns to the database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 # Definition of the utility functions
-V1 = ASC_TRAIN + \
-     B_TIME * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
-
-# Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+
+# Scale associated with group 3 is estimated
+scale = (GROUP != 3) + (GROUP == 3) * Scale_group3
+
+# Scale the utility functions, and associate them with the numbering
+# of alternatives
+V = {1: scale * V1, 2: scale * V2, 3: scale * V3}
 
 # Associate the availability conditions with the alternatives
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-# The choice model is a logit, with availability conditions
-prob1 = models.logit(V, av, 1)
-prob2 = models.logit(V, av, 2)
-prob3 = models.logit(V, av, 3)
-
-
-
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-# Elasticities can be computed. We illustrate below two
-# formulas. Check in the output file that they produce the same
-# result.
-
-# First, the general definition of elasticities. This illustrates the
-# use of the Derive expression, and can be used with any model,
-# however complicated it is. Note the quotes in the Derive opertor.
-genelas1 = Derive(prob1, 'TRAIN_TT') * TRAIN_TT / prob1
-genelas2 = Derive(prob2, 'SM_TT') * SM_TT / prob2
-genelas3 = Derive(prob3, 'CAR_TT') * CAR_TT / prob3
-
-# Second, the elasticity of logit models. See Ben-Akiva and Lerman for
-# the formula
-
-logitelas1 = TRAIN_AV_SP * (1.0 - prob1) * TRAIN_TT_SCALED * B_TIME
-logitelas2 = SM_AV * (1.0 - prob2) * SM_TT_SCALED * B_TIME
-logitelas3 = CAR_AV_SP * (1.0 - prob3) * CAR_TT_SCALED * B_TIME
-
-simulate = {'Prob. train': prob1,
-            'Prob. Swissmetro': prob2,
-            'Prob. car': prob3,
-            'logit elas. 1': logitelas1,
-            'generic elas. 1': genelas1,
-            'logit elas. 2': logitelas2,
-            'generic elas. 2': genelas2,
-            'logit elas. 3': logitelas3,
-            'generic elas. 3': genelas3}
-
-
-biogeme = bio.BIOGEME(database, simulate)
-biogeme.modelName = '01logit_simul'
-betas = {'ASC_TRAIN': -0.701188,
-         'B_TIME': -1.27786,
-         'B_COST': -1.08379,
-         'ASC_SM': 0,
-         'ASC_CAR': -0.154633}
-
-begin = datetime.datetime.now()
-for i in range(30):
-    results = biogeme.newsimulate(theBetaValues=betas)
-print(datetime.datetime.now() - begin)
+# Definition of the model. This is the contribution of each
+# observation to the log likelihood function.
+logprob = models.loglogit(V, av, CHOICE)
+
+# Define level of verbosity
+logger = msg.bioMessage()
+logger.setSilent()
+# logger.setWarning()
+# logger.setGeneral()
+# logger.setDetailed()
+
+# These notes will be included as such in the report file.
+userNotes = (
+    'Illustrates heteroscedastic specification. A different scale is'
+    ' associated with different segments of the sample.'
+)
+
+# Create the Biogeme object
+biogeme = bio.BIOGEME(database, logprob, userNotes=userNotes)
+biogeme.modelName = '03scale'
+
+# Estimate the parameters
+results = biogeme.estimate()
+pandasResults = results.getEstimatedParameters()
+print(pandasResults)
```

### Comparing `biogeme-3.2.8/examples/workingNotToDistribute/old.py` & `biogeme-3.2.9/tests/swissmetro/test_25.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,133 +1,100 @@
-"""File 01logit_simul.py
-
-:author: Michel Bierlaire, EPFL
-:date: Sat Sep  7 18:06:08 2019
-
- Example of simulation with a logit model
- Three alternatives: Train, Car and Swissmetro
- SP data
-"""
-import datetime
-import pandas as pd
-import biogeme.database as db
-import biogeme.biogeme as bio
-import biogeme.models as models
-from biogeme.expressions import Beta, Derive
-
-# Read the data
-df = pd.read_csv('swissmetro.dat', '\t')
-database = db.Database('swissmetro', df)
-
-# The Pandas data structure is available as database.data. Use all the
-# Pandas functions to investigate the database. For example:
-#print(database.data.describe())
-
-# The following statement allows you to use the names of the variable
-# as Python variable.
-globals().update(database.variables)
-
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) &
-#           (database.data.PURPOSE != 3)) |
-#          (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
-database.remove(exclude)
-
-# Parameters to be estimated
-ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
-ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
-ASC_SM = Beta('ASC_SM', 0, None, None, 1)
-B_TIME = Beta('B_TIME', 0, None, None, 0)
-B_COST = Beta('B_COST', 0, None, None, 0)
-
-# Definition of new variables
-SM_COST = SM_CO * (GA == 0)
-TRAIN_COST = TRAIN_CO * (GA == 0)
-
-# Definition of new variables: in simulation, do not use the DefineVariable operator,
-# as it hides the functional relationships. In particular, derivatives cannot be
-# calculated.
-CAR_AV_SP = CAR_AV * (SP != 0)
-TRAIN_AV_SP = TRAIN_AV * (SP != 0)
-TRAIN_TT_SCALED = TRAIN_TT / 100.0
-TRAIN_COST_SCALED = TRAIN_COST / 100
-SM_TT_SCALED = SM_TT / 100.0
-SM_COST_SCALED = SM_COST / 100
-CAR_TT_SCALED = CAR_TT / 100
-CAR_CO_SCALED = CAR_CO / 100
-
-# Definition of the utility functions
-V1 = ASC_TRAIN + \
-     B_TIME * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
-
-# Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
-
-# Associate the availability conditions with the alternatives
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-# The choice model is a logit, with availability conditions
-prob1 = models.logit(V, av, 1)
-prob2 = models.logit(V, av, 2)
-prob3 = models.logit(V, av, 3)
-
-
-
-
-# Elasticities can be computed. We illustrate below two
-# formulas. Check in the output file that they produce the same
-# result.
-
-# First, the general definition of elasticities. This illustrates the
-# use of the Derive expression, and can be used with any model,
-# however complicated it is. Note the quotes in the Derive opertor.
-genelas1 = Derive(prob1, 'TRAIN_TT') * TRAIN_TT / prob1
-genelas2 = Derive(prob2, 'SM_TT') * SM_TT / prob2
-genelas3 = Derive(prob3, 'CAR_TT') * CAR_TT / prob3
-
-# Second, the elasticity of logit models. See Ben-Akiva and Lerman for
-# the formula
-
-logitelas1 = TRAIN_AV_SP * (1.0 - prob1) * TRAIN_TT_SCALED * B_TIME
-logitelas2 = SM_AV * (1.0 - prob2) * SM_TT_SCALED * B_TIME
-logitelas3 = CAR_AV_SP * (1.0 - prob3) * CAR_TT_SCALED * B_TIME
-
-simulate = {'Prob. train': prob1,
-            'Prob. Swissmetro': prob2,
-            'Prob. car': prob3,
-            'logit elas. 1': logitelas1,
-            'generic elas. 1': genelas1,
-            'logit elas. 2': logitelas2,
-            'generic elas. 2': genelas2,
-            'logit elas. 3': logitelas3,
-            'generic elas. 3': genelas3}
-
-
-biogeme = bio.BIOGEME(database, simulate)
-biogeme.modelName = '01logit_simul'
-betas = {'ASC_TRAIN': -0.701188,
-         'B_TIME': -1.27786,
-         'B_COST': -1.08379,
-         'ASC_SM': 0,
-         'ASC_CAR': -0.154633}
-
-begin = datetime.datetime.now()
-for i in range(30):
-    results1 = biogeme.simulate(theBetaValues=betas)
-print(datetime.datetime.now() - begin)
-
-
+import os
+import unittest
+import numpy as np
+import pandas as pd
+import biogeme.database as db
+import biogeme.biogeme as bio
+from biogeme import models
+from biogeme.expressions import Beta, bioDraws, log, MonteCarlo
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
+
+# The Pandas data structure is available as database.data. Use all the
+# Pandas functions to invesigate the database
+# print(database.data.describe())
+
+globals().update(database.variables)
+
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
+database.remove(exclude)
+
+
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_TIME_S = Beta('B_TIME_S', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+# Define a random parameter with a triangular distribution, designed to be used
+# for Monte-Carlo simulation
+
+# Provide my own random number generator to the database.
+# See the numpy.random documentation to obtain a list of other distributions.
+def theTriangularGenerator(sampleSize, numberOfDraws):
+    return np.random.triangular(-1, 0, 1, (sampleSize, numberOfDraws))
+
+
+myRandomNumberGenerators = {
+    'TRIANGULAR': (theTriangularGenerator, 'Triangular distribution T(-1,0,1)')
+}
+database.setRandomNumberGenerators(myRandomNumberGenerators)
+
+B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'TRIANGULAR')
+
+# Utility functions
+
+# If the person has a GA (season ticket) her incremental cost is actually 0
+# rather than the cost value gathered from the
+# network data.
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+# For numerical reasons, it is good practice to scale the data to
+# that the values of the parameters are around 1.0.
+# A previous estimation with the unscaled data has generated
+# parameters around -0.01 for both cost and time. Therefore, time and
+# cost are multipled my 0.01.
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+
+# Associate utility functions with the numbering of alternatives
+V = {1: V1, 2: V2, 3: V3}
+
+# Associate the availability conditions with the alternatives
+
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
+
+# The choice model is a logit, with availability conditions
+prob = models.logit(V, av, CHOICE)
+logprob = log(MonteCarlo(prob))
+
+
+class test_25(unittest.TestCase):
+    def testEstimation(self):
+        biogeme = bio.BIOGEME(database, logprob, seed=10, numberOfDraws=5)
+        biogeme.saveIterations = False
+        biogeme.generateHtml = False
+        biogeme.generatePickle = False
+        results = biogeme.estimate()
+        self.assertAlmostEqual(results.data.logLike, -5312.7204284279305, 2)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/examples/workingNotToDistribute/swissmetro.dat` & `biogeme-3.2.9/examples/workingNotToDistribute/swissmetro.dat`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/examples/workingNotToDistribute/threads.py` & `biogeme-3.2.9/tests/swissmetro/test_07.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,85 +1,90 @@
-"""File 01logit.py
-
-:author: Michel Bierlaire, EPFL
-:date: Thu Sep  6 15:14:39 2018
-
- Example of a logit model.
- Three alternatives: Train, Car and Swissmetro
- SP data
-"""
-
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-from biogeme.expressions import Beta
+from biogeme import models
+from biogeme.expressions import Beta, log
 
-# Read the data
-df = pd.read_csv('swissmetro.dat', '\t')
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
 database = db.Database('swissmetro', df)
 
-# The following statement allows you to use the names of the
-# variable as Python variable.
+# The Pandas data structure is available as database.data. Use all the
+# Pandas functions to invesigate the database
+# print(database.data.describe())
+
 globals().update(database.variables)
 
-# Removing some observations
+# Here we use the 'biogeme' way for backward compatibility
 exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
-# Parameters to be estimated
+
 ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
 ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
 ASC_SM = Beta('ASC_SM', 0, None, None, 1)
-B_TIME = Beta('B_TIME', 0, None, None, 0)
-B_COST = Beta('B_COST', 0, None, None, 0)
+B_TIME = Beta('B_TIME', 0, None, 0, 0)
+B_COST = Beta('B_COST', 0, None, 0, 0)
 
 
-# Definition of new variables
 SM_COST = SM_CO * (GA == 0)
 TRAIN_COST = TRAIN_CO * (GA == 0)
-CAR_AV_SP = CAR_AV * (SP != 0)
-TRAIN_AV_SP = TRAIN_AV * (SP != 0)
-TRAIN_TT_SCALED = TRAIN_TT / 100
-TRAIN_COST_SCALED = TRAIN_COST / 100
-SM_TT_SCALED = SM_TT / 100
-SM_COST_SCALED = SM_COST / 100
-CAR_TT_SCALED = CAR_TT / 100
-CAR_CO_SCALED = CAR_CO / 100
-
-# Definition of the utility functions
-V1 = ASC_TRAIN + \
-     B_TIME * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
-
-# Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+# For latent class 1, whete the time coefficient is zero
+V11 = ASC_TRAIN + B_COST * TRAIN_COST_SCALED
+V12 = ASC_SM + B_COST * SM_COST_SCALED
+V13 = ASC_CAR + B_COST * CAR_CO_SCALED
+
+V1 = {1: V11, 2: V12, 3: V13}
+
+# For latent class 2, whete the time coefficient is estimated
+V21 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V22 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V23 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+
+V2 = {1: V21, 2: V22, 3: V23}
+
 
 # Associate the availability conditions with the alternatives
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-# Definition of the model. This is the contribution of each
-# observation to the log likelihood function.
-
-logprob = models.loglogit(V, av, CHOICE)
-
-for t in range(1, 3):
-# Create the Biogeme object
-    biogeme = bio.BIOGEME(database, logprob, numberOfThreads=t)
-    biogeme.modelName = f'threads_{t}'
-
-    # Estimate the parameters
-    results = biogeme.estimate()
-
-    # Get the results in a pandas table
-    pandasResults = results.getEstimatedParameters()
-    print(pandasResults)
+
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
+
+
+# Class membership model
+W_OTHER = Beta('W_OTHER', 0.5, 0, 1, 0)
+probClass1 = 1 - W_OTHER
+probClass2 = W_OTHER
+
+# The choice model is a discrete mixture of logit, with availability conditions
+prob1 = models.logit(V1, av, CHOICE)
+prob2 = models.logit(V2, av, CHOICE)
+prob = probClass1 * prob1 + probClass2 * prob2
+logprob = log(prob)
+
+
+class test_07(unittest.TestCase):
+    def testEstimation(self):
+        biogeme = bio.BIOGEME(database, logprob)
+        biogeme.saveIterations = False
+        biogeme.generateHtml = False
+        biogeme.generatePickle = False
+        results = biogeme.estimate()
+        self.assertAlmostEqual(results.data.logLike, -5208.4980304812725, 2)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/src/#bioExprBoxcox.cc#` & `biogeme-3.2.9/src/bioExprTimes.cc`

 * *Files 17% similar despite different names*

```diff
@@ -1,137 +1,160 @@
 //-*-c++-*------------------------------------------------------------
 //
-// File name : bioExprBoxcox.cc
-// @date   Fri Jun 25 17:23:22 2021
+// File name : bioExprTimes.cc
+// @date   Fri Apr 13 11:39:27 2018
 // @author Michel Bierlaire
 // @version Revision 1.0
 //
 //--------------------------------------------------------------------
 
-#include "bioExprBoxcox.h"
+#include "bioExprTimes.h"
 #include <sstream>
 #include "bioDebug.h"
 #include "bioExceptions.h"
+#include "bioDebug.h"
 
-bioExprBoxcox::bioExprBoxcox(bioExpression* l, bioExpression* r) :
+bioExprTimes::bioExprTimes(bioExpression* l, bioExpression* r) :
   left(l), right(r) {
   listOfChildren.push_back(l) ;
   listOfChildren.push_back(r) ;
 
 }
+bioExprTimes::~bioExprTimes() {
 
-bioExprBoxcox::~bioExprBoxcox() {
 }
-  
-const bioDerivatives* bioExprBoxcox::getValueAndDerivatives(std::vector<bioUInt> literalIds,
-							    bioBoolean gradient,
-							    bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+const bioDerivatives* bioExprTimes::getValueAndDerivatives(std::vector<bioUInt> literalIds,
+						     bioBoolean gradient,
+						     bioBoolean hessian) {
 
 
-  
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
   bioUInt n = literalIds.size() ;
+  theDerivatives.resize(n) ;
+
   const bioDerivatives* leftResult = left->getValueAndDerivatives(literalIds,gradient,hessian) ;
-  const bioDerivatives* rightResult = right->getValueAndDerivatives(literalIds,gradient,hessian) ;
-  if (leftResult == NULL) {
-    throw bioExceptNullPointer(__FILE__,__LINE__,"left result") ;
+  const bioDerivatives* rightResult = NULL ;
+  bioReal rightValue ;
+  if (leftResult->f == 0.0 && !hessian) {
+    // No need to calculate the derivatives of the other term
+    rightValue = right->getValue() ;
   }
-  if (rightResult == NULL) {
-    throw bioExceptNullPointer(__FILE__,__LINE__,"right result") ;
+  else {
+    rightResult = right->getValueAndDerivatives(literalIds,gradient,hessian) ;
+    if (gradient) {
+      if (rightResult->g.size() != literalIds.size()) {
+	std::stringstream str ;
+	str << "Wrong size for the result: " << rightResult->g.size() << " instead of " << literalIds.size() ;
+	throw bioExceptions(__FILE__,__LINE__,str.str()) ;	
+      }
+    }
+    rightValue = rightResult->f ;
   }
 
-  bioReal ell = rightResult->f ;
-  bioReal lnx = log(leftResult->f) ;
-  bioReal x = leftResult->f ;
-  
-  if (std::abs(ell)  <= 1.0-5) {
-    // We use the McLaurin polynomial approximation
-    if (ell == 0.0) {
-      theDerivatives.f = lnx ;
+  if (leftResult->f == 0) {
+    // l = 0
+    if (rightValue == 0) {
+      // l = 0, r = 0
+      theDerivatives.f = 0.0 ;
+      if (gradient) {
+	for (bioUInt i = 0 ; i < n ; ++i) {
+	  theDerivatives.g[i] = 0.0 ;
+	}
+      }
     }
     else {
-      theDerivatives.f = lnx
-	+ lnx * lnx * ell / 2.0
-	+ lnx * lnx * lnx * ell * ell / 6.0
-	+ lnx * lnx * lnx * lnx * ell * ell * ell / 24.0 ;
-    }
-    if (gradient) {
-      for (bioUInt i = 0 ; i < n ; ++i) {
-	// Derivative wrt to x
-	theDerivatives.g[i] = leftResult->g[i] *
-	  (ell * ell * ell * lnx * lnx * lnx / (6 * x) +
-	   ell * ell * lnx * lnx / (2 * x) +
-	   ell * lnx / x +
-	   1 / x) ;
-	// Derivative wrt to ell
-	theDerivatives.g[i] += rightResult->g[i] *
-	  (ell * ell * lnx * lnx * lnx * lnx / 8.0 +
-	   ell * lnx * lnx * lnx / 3.0 +
-	   lnx * lnx / 2.0) ;
-	if (hessian) {
-	  for (bioUInt j = i ; j < n ; ++j) {
-	    theDerivatives.h[i][j] =
-	      theDerivatives.h[j][i] = 
+      // l = 0, r != 0
+      theDerivatives.f = 0.0 ;
+      if (gradient) {
+	for (bioUInt i = 0 ; i < n ; ++i) {
+	  if (leftResult->g[i] == 0.0) {
+	    theDerivatives.g[i] = 0.0 ;
+	  }
+	  else {
+	    theDerivatives.g[i] = leftResult->g[i] * rightValue ;
 	  }
 	}
       }
-      
     }
   }
   else {
-    // We use the original formulation
-  }
-  
-  if (leftResult->f == 0.0) {
-    theDerivatives.f = rightResult->f ;
-  }
-  else if (rightResult->f == 0.0) {
-    theDerivatives.f = leftResult->f ;
-  }
-  else {
-    theDerivatives.f = leftResult->f + rightResult->f ;
-  }
-  if (gradient) {
-    for (bioUInt i = 0 ; i < n ; ++i) {
-      if (leftResult->g[i] == 0.0) {
-	theDerivatives.g[i] = rightResult->g[i] ;
-
-      }
-      else if (rightResult->g[i] == 0.0) {
-	theDerivatives.g[i] = leftResult->g[i] ;
+    // l != 0 
+    if (rightValue == 0) {
+      // l != 0, r = 0
+      theDerivatives.f = 0.0 ;
+      if (rightResult == NULL) {
+	throw bioExceptNullPointer(__FILE__,__LINE__,"Right result of multiplication") ;
       }
-      else {
-	theDerivatives.g[i] = leftResult->g[i] + rightResult->g[i] ;
-      }
-      if (hessian) {
-	for (bioUInt j = 0 ; j < n ; ++j) {
-	  if (leftResult->h[i][j] == 0.0) {
-	    theDerivatives.h[i][j] = rightResult->h[i][j] ;
-	  }
-	  else if (rightResult->h[i][j] == 0.0) {
-	    theDerivatives.h[i][j] = leftResult->h[i][j] ;
-	    
+      
+      if (gradient) {
+	for (bioUInt i = 0 ; i < n ; ++i) {
+	  if (rightResult->g[i] == 0.0) {
+	    theDerivatives.g[i] = 0.0 ;
 	  }
 	  else {
-	    theDerivatives.h[i][j] = leftResult->h[i][j] + rightResult->h[i][j] ;
+	    theDerivatives.g[i] = rightResult->g[i] * leftResult->f ;
 	  }
 	}
       }
     }
+    else {
+      // l != 0, r != 0
+      theDerivatives.f = leftResult->f * rightValue ;
+      if (gradient) {
+	if (rightResult == NULL) {
+	  throw bioExceptNullPointer(__FILE__,__LINE__,"Right result of multiplication") ;
+	}
+	for (bioUInt i = 0 ; i < n ; ++i) {
+	  theDerivatives.g[i] = leftResult->g[i] * rightResult->f + 
+	    rightResult->g[i] * leftResult->f ;
+	}
+      }
+    }
+  }
+
+  if (hessian) {
+    for (bioUInt i = 0 ; i < n ; ++i) {
+      for (bioUInt j = i ; j < n ; ++j) {
+	bioReal v ;
+	if (rightValue != 0.0) {
+	  bioReal lhs = leftResult->h[i][j] ;
+	  v = lhs * rightValue ;
+	}
+	else {
+	  v = 0.0 ;
+	}
+	if (leftResult->f != 0) {
+	  bioReal rhs = rightResult->h[i][j] ;
+	  v += rhs * leftResult->f ;
+	}
+	if (rightResult == NULL) {
+	  throw(bioExceptNullPointer(__FILE__,__LINE__,"rightResult")) ;
+	}
+	if (leftResult->g[i] != 0.0 && rightResult->g[j] != 0.0) {
+	  v += leftResult->g[i] * rightResult->g[j] ;
+	}
+	if (leftResult->g[j] != 0.0 && rightResult->g[i] != 0.0) {
+	  v += leftResult->g[j] * rightResult->g[i] ;
+	}
+	theDerivatives.h[i][j] = theDerivatives.h[j][i] = v ;
+      }
+    }    
   }
-  //  DEBUG_MESSAGE("Plus - Calculated: " << str.length() << " = " << theDerivatives.f) ;
+
+  
   return &theDerivatives ;
 }
 
-bioString bioExprBoxcox::print(bioBoolean hp) const {
+bioString bioExprTimes::print(bioBoolean hp) const {
   std::stringstream str ;
   if (hp) {
-    str << "+(" << left->print(hp) << "," << right->print(hp) << ")" ;
+    str << "*(" << left->print(hp) << "," << right->print(hp) << ")" ;
   }
   else {
-    str << "(" << left->print(hp) << "+" << right->print(hp) << ")" ;
+    str << "(" << left->print(hp) << "*" << right->print(hp) << ")" ;
   }
   return str.str() ;
 }
+
```

### Comparing `biogeme-3.2.8/src/bioCfsqp.cc` & `biogeme-3.2.9/src/bioCfsqp.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioCfsqp.h` & `biogeme-3.2.9/src/bioCfsqp.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioConst.h` & `biogeme-3.2.9/src/bioConst.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioDerivatives.cc` & `biogeme-3.2.9/src/bioExprMin.cc`

 * *Files 22% similar despite different names*

```diff
@@ -1,116 +1,85 @@
 //-*-c++-*------------------------------------------------------------
 //
-// File name : bioDerivatives.h
-// @date   Fri Apr 13 10:31:21 2018
+// File name : bioExprMin.cc
+// @date   Mon Oct 15 15:34:56 2018
 // @author Michel Bierlaire
 // @version Revision 1.0
 //
 //--------------------------------------------------------------------
 
-#include <iostream>
+#include "bioExprMin.h"
+#include <sstream>
 #include "bioDebug.h"
-#include "bioDerivatives.h"
 #include "bioExceptions.h"
 
-// Dealing with exceptions across threads
-static std::exception_ptr theExceptionPtr = nullptr ;
-
-/**
- Constructor .cc
- @param n number of variables
-*/
+bioExprMin::bioExprMin(bioExpression* l, bioExpression* r) :
+  left(l), right(r) {
 
+  listOfChildren.push_back(l) ;
+  listOfChildren.push_back(r) ;
+}
 
-bioDerivatives::bioDerivatives() {
+bioExprMin::~bioExprMin() {
 
 }
 
-void bioDerivatives::resize(bioUInt n) {
-  if (n == getSize()) {
-    return ;
-  }
-  clear() ;
-  try {
-    g.resize(n) ;
-  }
-  catch (std::exception& e) {
-    throw bioExceptions(__FILE__, __LINE__, e.what()) ;
-  }
-  catch (const std::bad_alloc&) {
-    std::stringstream str ;
-    str << "Impossible to allocate memory for vector of size " << n ;  
-    throw bioExceptions(__FILE__, __LINE__, str.str()) ;
-  }
-  try {
-    // **** WARNING ****
-    // Mon Oct  5 11:51:41 2020
-    // Bug with STL.
-    
-    // When n is large, the following statement kills the process (with
-    // a message "bad_alloc") without trigerring an exception.
-    // The only way to deal with it would be to abandon the use of STL vectors.
-    // This would require a significant re-engineering of the code.
-    // This may be considered in the future.
-    
-    h.resize(n, std::vector<bioReal>(n, 0.0)) ;
-  }
-  catch (std::exception& e) {
-    throw bioExceptions(__FILE__, __LINE__, e.what()) ;
+  
+const bioDerivatives* bioExprMin::getValueAndDerivatives(std::vector<bioUInt> literalIds,
+						     bioBoolean gradient,
+						     bioBoolean hessian) {
+
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
+
+  if (gradient) {
+    if (containsLiterals(literalIds)) {
+      std::cout << "Warning: expression " << print()
+		<< " is not differentiable everywhere. " << std::endl ;
+    }
   }
-  catch (const std::bad_alloc&) {
-    std::stringstream str ;
-    str << "Impossible to allocate memory for matrix of size " << n << "x" << n;  
-    throw bioExceptions(__FILE__, __LINE__, str.str()) ;
+
+  if (left == NULL) {
+    throw bioExceptNullPointer(__FILE__,__LINE__,"left") ;
   }
-  catch (...) {
-    std::stringstream str ;
-    str << "Impossible to allocate memory for matrix of size " << n << "x" << n;  
-    throw bioExceptions(__FILE__, __LINE__, str.str()) ;
+  if (right == NULL) {
+    throw bioExceptNullPointer(__FILE__,__LINE__,"right") ;
   }
   
-}
-
-void bioDerivatives::clear() {
-  g.clear() ;
-  h.clear() ;
-}
-
-bioUInt bioDerivatives::getSize() const {
-  return g.size();
-}
-
-void bioDerivatives::setDerivativesToZero() {
-  std::fill(g.begin(),g.end(),0.0) ;
-  std::fill(h.begin(),h.end(),g) ;
-}
-
-void bioDerivatives::setGradientToZero() {
-  std::fill(g.begin(),g.end(),0.0) ;
-}
-
-std::ostream& operator<<(std::ostream &str, const bioDerivatives& x) {
-  str << "f = " << x.f << std::endl ;
-  str << "g = [" ; 
-  for (std::vector<bioReal>::const_iterator i = x.g.begin() ; i != x.g.end() ; ++i) {
-    if (i != x.g.begin()) {
-      str << ", " ;
+  const bioDerivatives* leftResult = left->getValueAndDerivatives(literalIds, gradient, hessian) ;
+  const bioDerivatives* rightResult = right->getValueAndDerivatives(literalIds, gradient, hessian) ;
+  if (leftResult->f <= rightResult->f) {
+    theDerivatives.f = leftResult->f ;
+    if (gradient) {
+      for (std::size_t k = 0 ; k < literalIds.size() ; ++k) {
+	theDerivatives.g[k] = leftResult->g[k] ;
+	if (hessian) {
+	  for (std::size_t l = 0 ; l < literalIds.size() ; ++l) {
+	    theDerivatives.h[k][l] = leftResult->h[k][l] ;
+	  }
+	}
+      }
     }
-    str << *i ;
   }
-  str << "]" << std::endl ;
-  str << "h = [ " ;
-  for (std::vector<std::vector<bioReal> >::const_iterator row = x.h.begin() ; row != x.h.end() ; ++row) {
-    if (row != x.h.begin()) {
-      str << std::endl ;
-    }
-    str << " [ " ;
-    for (std::vector<bioReal>::const_iterator col = row->begin() ; col != row->end() ; ++col) {
-      if (col != row->begin()) {
-	str << ", " ;
+  else { 
+    theDerivatives.f = rightResult->f ;
+    if (gradient) {
+      for (std::size_t k = 0 ; k < literalIds.size() ; ++k) {
+	theDerivatives.g[k] = rightResult->g[k] ;
+	if (hessian) {
+	  for (std::size_t l = 0 ; l < literalIds.size() ; ++l) {
+	    theDerivatives.h[k][l] = rightResult->h[k][l] ;
+	  }
+	}
       }
-      str << *col ;
     }
-    str << " ] " << std::endl ;
   }
-  return str ;
+  return &theDerivatives ;
+}
+
+bioString bioExprMin::print(bioBoolean hp) const {
+  std::stringstream str ;
+  str << "bioMin(" << left->print(hp) << "," << right->print(hp) << ")" ;
+  return str.str() ;
 }
```

### Comparing `biogeme-3.2.8/src/bioDerivatives.h` & `biogeme-3.2.9/src/bioSeveralExpressions.h`

 * *Files 26% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 //-*-c++-*------------------------------------------------------------
 //
-// File name : bioDerivatives.h
-// @date   Fri Apr 13 10:29:32 2018
+// File name : bioSeveralExpressions.h
+// @date   Wed Mar  3 18:03:24 2021
 // @author Michel Bierlaire
 // @version Revision 1.0
 //
 //--------------------------------------------------------------------
 
-
-#ifndef bioDerivatives_h
-#define bioDerivatives_h
+#ifndef bioSeveralExpressions_h
+#define bioSeveralExpressions_h
 
 #include <vector>
-#include "bioTypes.h"
+#include "bioExpression.h"
+#include "bioString.h"
 
-class bioDerivatives {
- public:
-  bioDerivatives() ;
-  void clear() ;
-  void resize(bioUInt n) ;
-  void setDerivativesToZero() ;
-  void setGradientToZero() ;
-  void setHessianToZero() ;
-  bioUInt getSize() const ;
-  bioReal f ;
-  std::vector<bioReal> g ;
-  std::vector<std::vector<bioReal> > h ;
+class bioSeveralExpressions: public bioExpression {
+public:
+  bioSeveralExpressions(std::vector<bioExpression*> exprs) ;
+  ~bioSeveralExpressions() ;
+  virtual bioString print(bioBoolean hp = false) const ;
+  virtual bioReal getValue() ;
+  std::vector<bioReal > getValues() ;
+  const bioDerivatives* getValueAndDerivatives(std::vector<bioUInt> literalIds,
+					       bioBoolean gradient,
+					       bioBoolean hessian) ;
+  std::vector<const bioDerivatives* >
+  getAllValueAndDerivatives(std::vector<bioUInt> literalIds,
+			    bioBoolean gradient,
+			    bioBoolean hessian) ;
+private:
+  std::vector<bioExpression*> theExpressions ;
 };
-
-std::ostream& operator<<(std::ostream &str, const bioDerivatives& x) ;
-
 #endif
```

### Comparing `biogeme-3.2.8/src/bioExceptions.h` & `biogeme-3.2.9/src/bioExceptions.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprAnd.cc` & `biogeme-3.2.9/src/bioExprAnd.cc`

 * *Files 10% similar despite different names*

```diff
@@ -24,30 +24,26 @@
 }
 
   
 const bioDerivatives* bioExprAnd::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 						     bioBoolean gradient,
 						     bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
 
   if (gradient) {
     if (containsLiterals(literalIds)) {
       std::stringstream str ;
       str << "Expression "+print()+" is not differentiable" << std::endl ; 
       throw bioExceptions(__FILE__,__LINE__,str.str()) ;
     }
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
+    theDerivatives.setDerivativesToZero() ;
   }
 
   
   if (left == NULL) {
     throw bioExceptNullPointer(__FILE__,__LINE__,"left") ;
   }
   if (right == NULL) {
```

### Comparing `biogeme-3.2.8/src/bioExprAnd.h` & `biogeme-3.2.9/src/bioExprAnd.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprDerive.cc` & `biogeme-3.2.9/src/bioExprDerive.cc`

 * *Files 11% similar despite different names*

```diff
@@ -24,14 +24,18 @@
 const bioDerivatives* bioExprDerive::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 							  bioBoolean gradient,
 							  bioBoolean hessian) {
 
   if (gradient || hessian) {
     throw bioExceptions(__FILE__,__LINE__,"No derivatives are available for this expression, yet.") ;
   }
+
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+  theDerivatives.resize(literalIds.size()) ;
   
   std::vector<bioUInt> theIds ;
   theIds.push_back(literalId) ;
 
   const bioDerivatives* childResult = child->getValueAndDerivatives(theIds,true,false) ;
   if (childResult == NULL) {
     throw bioExceptNullPointer(__FILE__,__LINE__,"derivatives") ;
```

### Comparing `biogeme-3.2.8/src/bioExprDerive.h` & `biogeme-3.2.9/src/bioExprDerive.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprDivide.cc` & `biogeme-3.2.9/src/bioExprDivide.cc`

 * *Files 2% similar despite different names*

```diff
@@ -27,20 +27,21 @@
 						      bioBoolean gradient,
 						      bioBoolean hessian) {
 
   if (!gradient && hessian) {
     throw bioExceptions(__FILE__,__LINE__,"If the hessian is needed, the gradient must be computed") ;
   }
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
-  
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
 
   bioUInt n = literalIds.size() ;
+  theDerivatives.resize(n) ;
+  
+
   const bioDerivatives* leftResult = left->getValueAndDerivatives(literalIds,gradient,hessian) ;
   const bioDerivatives* rightResult = NULL ;
   bioReal rightValue ;
   if (leftResult->f == 0.0 && !hessian) {
     // No need to calculate the derivatives of the other term
     rightValue = right->getValue() ;
   }
```

### Comparing `biogeme-3.2.8/src/bioExprDivide.h` & `biogeme-3.2.9/src/bioExprDivide.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprDraws.cc` & `biogeme-3.2.9/src/bioExprDraws.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprDraws.h` & `biogeme-3.2.9/src/bioExprDraws.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprElem.cc` & `biogeme-3.2.9/src/bioExprElem.cc`

 * *Files 8% similar despite different names*

```diff
@@ -33,17 +33,18 @@
 
 }
 
 const bioDerivatives* bioExprElem::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 						    bioBoolean gradient,
 				      bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
 
 
   bioUInt k = bioUInt(key->getValue()) ;
 
   std::map<bioUInt,bioExpression*>::const_iterator found = dictOfExpressions.find(k) ;
   if (found == dictOfExpressions.end()) {
     std::stringstream str ;
```

### Comparing `biogeme-3.2.8/src/bioExprElem.h` & `biogeme-3.2.9/src/bioExprElem.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprEqual.cc` & `biogeme-3.2.9/src/bioExprEqual.cc`

 * *Files 6% similar despite different names*

```diff
@@ -19,44 +19,41 @@
   listOfChildren.push_back(r) ;
 }
 
 bioExprEqual::~bioExprEqual() {
 
 }
 
-  
+
 const bioDerivatives* bioExprEqual::getValueAndDerivatives(std::vector<bioUInt> literalIds,
-						     bioBoolean gradient,
-						     bioBoolean hessian) {
+							   bioBoolean gradient,
+							   bioBoolean hessian) {
 
-    if (gradient && theDerivatives.getSize() != literalIds.size()) {
-      theDerivatives.resize(literalIds.size()) ;
-    }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
 
   if (gradient) {
     if (containsLiterals(literalIds)) {
       std::stringstream str ;
-      str << "Expression Equal is not differentiable" << std::endl ; 
+      str << "Expression Equal is not differentiable" << std::endl ;
+      str << "[" << print() << "]" << std::endl ;
       throw(bioExceptions(__FILE__,__LINE__,str.str())) ;
     }
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
+    theDerivatives.setDerivativesToZero() ;
   }
-  
+
   if (left == NULL) {
     throw bioExceptNullPointer(__FILE__,__LINE__,"left") ;
   }
   if (right == NULL) {
     throw bioExceptNullPointer(__FILE__,__LINE__,"right") ;
   }
-  
+
   const bioDerivatives* l = left->getValueAndDerivatives(literalIds,false,false) ;
   const bioDerivatives* r = right->getValueAndDerivatives(literalIds,false,false) ;
   if (l->f == r->f) {
     theDerivatives.f = 1.0 ;
   }
   else {
     theDerivatives.f = 0.0 ;
```

### Comparing `biogeme-3.2.8/src/bioExprEqual.h` & `biogeme-3.2.9/src/bioExprEqual.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprExp.cc` & `biogeme-3.2.9/src/bioExprExp.cc`

 * *Files 5% similar despite different names*

```diff
@@ -23,19 +23,20 @@
 
 }
 
 const bioDerivatives* bioExprExp::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 						   bioBoolean gradient,
 						   bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
 
   bioUInt n = literalIds.size() ;
+  theDerivatives.resize(n) ;
+
   const bioDerivatives* childResult = child->getValueAndDerivatives(literalIds,gradient,hessian) ;
   // if (childResult->f <= -10) {
   //   std::stringstream str ;
   //   str << "Low argument for exp " << childResult->f << "for " << child->print() ;
   //   throw bioExceptions(__FILE__,__LINE__,str.str()) ;
   // }
   if (childResult->f <= bioLogMaxReal::the()) {
```

### Comparing `biogeme-3.2.8/src/bioExprExp.h` & `biogeme-3.2.9/src/bioExprExp.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprFixedParameter.cc` & `biogeme-3.2.9/src/bioExprFixedParameter.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprFixedParameter.h` & `biogeme-3.2.9/src/bioExprFixedParameter.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprFreeParameter.cc` & `biogeme-3.2.9/src/bioExprFreeParameter.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprFreeParameter.h` & `biogeme-3.2.9/src/bioExprFreeParameter.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprGaussHermite.cc` & `biogeme-3.2.9/src/bioExprGaussHermite.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprGaussHermite.h` & `biogeme-3.2.9/src/bioExprGaussHermite.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprGreater.cc` & `biogeme-3.2.9/src/bioExprGreater.cc`

 * *Files 17% similar despite different names*

```diff
@@ -23,32 +23,28 @@
 
 }
 
 const bioDerivatives* bioExprGreater::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 							     bioBoolean gradient,
 							     bioBoolean hessian) {
   
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
 
   if (gradient || hessian) {
     if (containsLiterals(literalIds)) {
       std::stringstream str ;
       str << "Expression Greater is not differentiable" << std::endl ; 
       throw bioExceptions(__FILE__,__LINE__,str.str())  ;
     }
   }
   if (gradient) {
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
+    theDerivatives.setDerivativesToZero() ;
   }
 
   
   if (left->getValue() > right->getValue()) {
     theDerivatives.f = 1.0 ;
   }
   else {
```

### Comparing `biogeme-3.2.8/src/bioExprGreater.h` & `biogeme-3.2.9/src/bioExprGreater.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprGreaterOrEqual.cc` & `biogeme-3.2.9/src/bioExprGreaterOrEqual.cc`

 * *Files 8% similar despite different names*

```diff
@@ -20,33 +20,29 @@
 }
 
 bioExprGreaterOrEqual::~bioExprGreaterOrEqual() {
 
 }
 
 const bioDerivatives* bioExprGreaterOrEqual::getValueAndDerivatives(std::vector<bioUInt> literalIds,
-							      bioBoolean gradient,
-							      bioBoolean hessian) {
+								    bioBoolean gradient,
+								    bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
 
   if (gradient) {
     if (containsLiterals(literalIds)) {
       std::stringstream str ;
       str << "Expression GreaterOrEqual is not differentiable" << std::endl ; 
       throw bioExceptions(__FILE__,__LINE__,str.str()) ;
     }
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
+    theDerivatives.setDerivativesToZero() ;
   }
   
 
   if (left->getValue() >= right->getValue()) {
     theDerivatives.f = 1.0 ;
   }
   else {
```

### Comparing `biogeme-3.2.8/src/bioExprGreaterOrEqual.h` & `biogeme-3.2.9/src/bioExprGreaterOrEqual.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprIntegrate.cc` & `biogeme-3.2.9/src/bioExprIntegrate.cc`

 * *Files 7% similar despite different names*

```diff
@@ -23,17 +23,18 @@
 
 }
 
 const bioDerivatives* bioExprIntegrate::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 							  bioBoolean gradient,
 							  bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
 
   bioExprGaussHermite theGh(child,literalIds,rvId,gradient,hessian) ;   
   bioGaussHermite theGhAlgo(&theGh) ;
   std::vector<bioReal> r = theGhAlgo.integrate() ;
   theDerivatives.f = r[0] ;
   bioUInt n = literalIds.size() ;
   if (gradient) {
```

### Comparing `biogeme-3.2.8/src/bioExprIntegrate.h` & `biogeme-3.2.9/src/bioExprIntegrate.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprLess.cc` & `biogeme-3.2.9/src/bioExprLess.cc`

 * *Files 6% similar despite different names*

```diff
@@ -20,33 +20,29 @@
 }
 
 bioExprLess::~bioExprLess() {
 
 }
 
 const bioDerivatives* bioExprLess::getValueAndDerivatives(std::vector<bioUInt> literalIds,
-						    bioBoolean gradient,
-						    bioBoolean hessian) {
+							  bioBoolean gradient,
+							  bioBoolean hessian) {
   
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
 
   if (gradient) {
     if (containsLiterals(literalIds)) {
       std::stringstream str ;
       str << "Expression Less is not differentiable" << std::endl ; 
       throw(bioExceptions(__FILE__,__LINE__,str.str())) ;
     }
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
+    theDerivatives.setDerivativesToZero() ;
   }
 
   if (left->getValue() < right->getValue()) {
     theDerivatives.f = 1.0 ;
   }
   else {
     theDerivatives.f = 0.0 ;
```

### Comparing `biogeme-3.2.8/src/bioExprLess.h` & `biogeme-3.2.9/src/bioExprLess.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprLessOrEqual.cc` & `biogeme-3.2.9/src/bioExprLessOrEqual.cc`

 * *Files 3% similar despite different names*

```diff
@@ -23,31 +23,26 @@
 
 }
 
 const bioDerivatives* bioExprLessOrEqual::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 							   bioBoolean gradient,
 							   bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
 
+  theDerivatives.resize(literalIds.size()) ;
 
   if (gradient) {
     if (containsLiterals(literalIds)) {
       std::stringstream str ;
       str << "Expression LessOrEqual is not differentiable" << std::endl ; 
       throw bioExceptions(__FILE__,__LINE__,str.str()) ;
     }
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
+    theDerivatives.setDerivativesToZero() ;
   }
   
   if (left->getValue() <= right->getValue()) {
     theDerivatives.f = 1.0 ;
   }
   else {
     theDerivatives.f = 0.0 ;
```

### Comparing `biogeme-3.2.8/src/bioExprLessOrEqual.h` & `biogeme-3.2.9/src/bioExprLessOrEqual.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprLinearUtility.cc` & `biogeme-3.2.9/src/bioExprLinearUtility.cc`

 * *Files 6% similar despite different names*

```diff
@@ -33,35 +33,31 @@
 							bioBoolean gradient,
 							bioBoolean hessian) {
 
   if (!gradient && hessian) {
     throw bioExceptions(__FILE__,__LINE__,"If the hessian is needed, the gradient must be computed") ;
   }
   
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
   
   theDerivatives.f = 0.0 ;
   std::map<bioString,bioReal> values = getAllLiteralValues() ;
   for (std::vector<bioLinearTerm>::iterator i =
 	 listOfTerms.begin() ;
        i != listOfTerms.end() ;
        ++i) {
     if ((values[i->theBetaName] != 0.0) &&  (values[i->theVarName] != 0.0)) {
       theDerivatives.f += values[i->theBetaName] * values[i->theVarName] ;
     }
   }
   if (gradient) {
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
+    theDerivatives.setDerivativesToZero() ;
     for (std::size_t i = 0 ; i < literalIds.size() ; ++i) {
       theDerivatives.g[i] = values[theFriend[i]] ;
     }
   } 
   return &theDerivatives ;
 }
```

### Comparing `biogeme-3.2.8/src/bioExprLinearUtility.h` & `biogeme-3.2.9/src/bioExprLinearUtility.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprLiteral.cc` & `biogeme-3.2.9/src/bioExprLiteral.cc`

 * *Files 9% similar despite different names*

```diff
@@ -23,27 +23,22 @@
 						       bioBoolean gradient,
 						       bioBoolean hessian) {
 
   if (!gradient && hessian) {
     throw bioExceptions(__FILE__,__LINE__,"If the hessian is needed, the gradient must be computed") ;
   }
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
-
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
   
+  theDerivatives.resize(literalIds.size()) ;
+
   
   if (gradient) {
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
+    theDerivatives.setDerivativesToZero() ;
     for (std::size_t i = 0 ; i < literalIds.size() ; ++i) {
       if (literalIds[i] == theLiteralId) {
 	theDerivatives.g[i] = 1.0 ;
       }
       else {
 	theDerivatives.g[i] = 0.0 ;
       }
```

### Comparing `biogeme-3.2.8/src/bioExprLiteral.h` & `biogeme-3.2.9/src/bioExprLiteral.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprLiteral_current.cc` & `biogeme-3.2.9/src/bioExprLiteral_current.cc`

 * *Files 8% similar despite different names*

```diff
@@ -34,14 +34,18 @@
   else {
     if (gradient && theDerivatives->getSize() != literalIds.size()) {
       delete(theDerivatives) ;
       theDerivatives = new bioDerivatives(literalIds.size()) ;
     }
   }
 
+  theDerivatives->with_g = gradient ;
+  theDerivatives->with_h = hessian ;
+
+
   theDerivatives->f = getLiteralValue() ;
   if (gradient) {
     for (std::size_t i = 0 ; i < literalIds.size() ; ++i) {
       if (literalIds[i] == theLiteralId) {
 	theDerivatives->g[i] = 1.0 ;
       }
       else {
```

### Comparing `biogeme-3.2.8/src/bioExprLog.cc` & `biogeme-3.2.9/src/bioExprLog.cc`

 * *Files 9% similar despite different names*

```diff
@@ -23,20 +23,20 @@
 }
 
 const bioDerivatives* bioExprLog::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 						   bioBoolean gradient,
 						   bioBoolean hessian) {
   
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
-
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
 
   bioUInt n = literalIds.size() ;
+  theDerivatives.resize(n) ;
+
   const bioDerivatives* childResult = child->getValueAndDerivatives(literalIds,gradient,hessian) ;
   bioReal cf = childResult->f ;
   if (cf < 0) {
     if (std::abs(cf) < 1.0e-6) {
       cf = 0.0 ;
     }
     else {
```

### Comparing `biogeme-3.2.8/src/bioExprLog.h` & `biogeme-3.2.9/src/bioExprLog.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprLogLogit.cc` & `biogeme-3.2.9/src/bioExprLogLogit.cc`

 * *Files 2% similar despite different names*

```diff
@@ -35,43 +35,39 @@
 }
 
 const bioDerivatives* bioExprLogLogit::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 							bioBoolean gradient,
 							bioBoolean hessian) {
 
   if (!gradient && hessian) {
-    throw bioExceptions(__FILE__,__LINE__,"If the hessian is needed, the gradient must be computed") ;
-  }
-  
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
+    throw bioExceptions(__FILE__,
+			__LINE__,
+			"If the hessian is needed, the gradient must be computed") ;
   }
   
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
   bioUInt n = literalIds.size() ;
+  theDerivatives.resize(n) ;
+  
   bioUInt chosen = bioUInt(choice->getValue()) ;
   std::vector<bioDerivatives> Vs ;
   const bioDerivatives* chosenUtility(NULL) ;
   const bioDerivatives* V;
   bioReal largestUtility(-bioMaxReal) ;
 
   
   for (std::map<bioUInt,bioExpression*>::iterator i = availabilities.begin() ;
        i != availabilities.end() ;
        ++i) {
     bioReal av = i->second->getValue() ;
     if (av == 0.0) {
       if (i->first == chosen) {
-	if (gradient) {
-	  if (hessian) {
-	    theDerivatives.setDerivativesToZero() ;
-	  }
-	  else {
-	    theDerivatives.setGradientToZero() ;
-	  }
-	}
+	theDerivatives.setDerivativesToZero() ;
 	if (std::numeric_limits<bioReal>::has_infinity) {
 	  theDerivatives.f = -std::numeric_limits<bioReal>::infinity() ;
 	}
 	else {
 	  theDerivatives.f = std::numeric_limits<bioReal>::lowest() ;
 	}
 	return &theDerivatives ;
```

### Comparing `biogeme-3.2.8/src/bioExprLogLogit.h` & `biogeme-3.2.9/src/bioExprLogLogit.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprLogLogitFullChoiceSet.cc` & `biogeme-3.2.9/src/bioExprLogLogitFullChoiceSet.cc`

 * *Files 6% similar despite different names*

```diff
@@ -32,19 +32,20 @@
 							bioBoolean hessian) {
 
 
   if (!gradient && hessian) {
     throw bioExceptions(__FILE__,__LINE__,"If the hessian is needed, the gradient must be computed") ;
   }
   
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
-  
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
   bioUInt n = literalIds.size() ;
+  theDerivatives.resize(n) ;
+  
   bioUInt chosen = bioUInt(choice->getValue()) ;
   std::vector<bioDerivatives> Vs ;
   const bioDerivatives* chosenUtility(NULL) ;
   const bioDerivatives* V;
   bioReal largestUtility(-bioMaxReal) ;
   for (std::map<bioUInt,bioExpression*>::iterator theUtil = utilities.begin() ;
        theUtil != utilities.end() ;
```

### Comparing `biogeme-3.2.8/src/bioExprLogLogitFullChoiceSet.h` & `biogeme-3.2.9/src/bioExprLogLogitFullChoiceSet.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprMax.cc` & `biogeme-3.2.9/src/bioExprMax.cc`

 * *Files 3% similar despite different names*

```diff
@@ -24,17 +24,18 @@
 }
 
   
 const bioDerivatives* bioExprMax::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 						     bioBoolean gradient,
 						     bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
 
   if (gradient) {
     if (containsLiterals(literalIds)) {
       std::cout << "Warning: expression " << print()
 		<< " is not differentiable everywhere. " << std::endl ;
     }
   }
```

### Comparing `biogeme-3.2.8/src/bioExprMax.h` & `biogeme-3.2.9/src/bioExprMax.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprMin.cc` & `biogeme-3.2.9/src/bioExprMultSum.cc`

 * *Files 13% similar despite different names*

```diff
@@ -1,84 +1,95 @@
 //-*-c++-*------------------------------------------------------------
 //
-// File name : bioExprMin.cc
-// @date   Mon Oct 15 15:34:56 2018
+// File name : bioExprMultSum.cc
+// @date   Wed Apr 18 11:05:06 2018
 // @author Michel Bierlaire
 // @version Revision 1.0
 //
 //--------------------------------------------------------------------
 
-#include "bioExprMin.h"
 #include <sstream>
 #include "bioDebug.h"
+#include "bioExprMultSum.h"
 #include "bioExceptions.h"
 
-bioExprMin::bioExprMin(bioExpression* l, bioExpression* r) :
-  left(l), right(r) {
-
-  listOfChildren.push_back(l) ;
-  listOfChildren.push_back(r) ;
+bioExprMultSum::bioExprMultSum(std::vector<bioExpression*> e) :
+  expressions(e) {
+  listOfChildren = e ;
 }
 
-bioExprMin::~bioExprMin() {
+bioExprMultSum::~bioExprMultSum() {
 
 }
 
-  
-const bioDerivatives* bioExprMin::getValueAndDerivatives(std::vector<bioUInt> literalIds,
-						     bioBoolean gradient,
-						     bioBoolean hessian) {
+const bioDerivatives* bioExprMultSum::getValueAndDerivatives(std::vector<bioUInt> literalIds,
+							     bioBoolean gradient,
+							     bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
-
-  if (gradient) {
-    if (containsLiterals(literalIds)) {
-      std::cout << "Warning: expression " << print()
-		<< " is not differentiable everywhere. " << std::endl ;
-    }
+  if (!gradient && hessian) {
+    throw bioExceptions(__FILE__,__LINE__,"If the hessian is needed, the gradient must be computed") ;
   }
 
-  if (left == NULL) {
-    throw bioExceptNullPointer(__FILE__,__LINE__,"left") ;
-  }
-  if (right == NULL) {
-    throw bioExceptNullPointer(__FILE__,__LINE__,"right") ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
   
-  const bioDerivatives* leftResult = left->getValueAndDerivatives(literalIds, gradient, hessian) ;
-  const bioDerivatives* rightResult = right->getValueAndDerivatives(literalIds, gradient, hessian) ;
-  if (leftResult->f <= rightResult->f) {
-    theDerivatives.f = leftResult->f ;
+  theDerivatives.resize(literalIds.size()) ;
+
+  theDerivatives.f = 0.0 ;
+  theDerivatives.setDerivativesToZero() ;
+  for (std::vector<bioExpression*>::iterator i = expressions.begin();
+       i != expressions.end() ;
+       ++i) {
+    const bioDerivatives* fgh = (*i)->getValueAndDerivatives(literalIds,gradient,hessian) ;
+    
+    theDerivatives.f += fgh->f ;
     if (gradient) {
       for (std::size_t k = 0 ; k < literalIds.size() ; ++k) {
-	theDerivatives.g[k] = leftResult->g[k] ;
+	theDerivatives.g[k] += fgh->g[k] ;
 	if (hessian) {
-	  for (std::size_t l = 0 ; l < literalIds.size() ; ++l) {
-	    theDerivatives.h[k][l] = leftResult->h[k][l] ;
+	  for (std::size_t l = k ; l < literalIds.size() ; ++l) {
+	    theDerivatives.h[k][l] += fgh->h[k][l] ;
 	  }
 	}
       }
     }
   }
-  else { 
-    theDerivatives.f = rightResult->f ;
-    if (gradient) {
-      for (std::size_t k = 0 ; k < literalIds.size() ; ++k) {
-	theDerivatives.g[k] = rightResult->g[k] ;
-	if (hessian) {
-	  for (std::size_t l = 0 ; l < literalIds.size() ; ++l) {
-	    theDerivatives.h[k][l] = rightResult->h[k][l] ;
-	  }
-	}
+  if (hessian) {
+    // Fill the symmetric part of the matrix
+    for (std::size_t k = 0 ; k < literalIds.size() ; ++k) {
+      for (std::size_t l = k+1 ; l < literalIds.size() ; ++l) {
+	theDerivatives.h[l][k]  = theDerivatives.h[k][l] ;
       }
     }
   }
+  //  DEBUG_MESSAGE("MultiSum calculated " << str.length()) ;
   return &theDerivatives ;
 }
 
-bioString bioExprMin::print(bioBoolean hp) const {
+bioString bioExprMultSum::print(bioBoolean hp) const {
   std::stringstream str ;
-  str << "bioMin(" << left->print(hp) << "," << right->print(hp) << ")" ;
+  if (hp) {
+    str << "MultiSum(" ;
+    for (std::vector<bioExpression*>::const_iterator i = expressions.begin() ;
+	 i != expressions.end() ;
+	 ++i) {
+      if (i != expressions.begin()) {
+	str << " , " ;
+      }
+      str << (*i)->print(hp) ;
+    }
+    str << ")" ;
+  }
+  else {
+    str << "(" ;
+    for (std::vector<bioExpression*>::const_iterator i = expressions.begin() ;
+	 i != expressions.end() ;
+	 ++i) {
+      if (i != expressions.begin()) {
+	str << " + " ;
+      }
+      str << (*i)->print(hp) ;
+    }
+    str << ")" ;
+  }
   return str.str() ;
 }
```

### Comparing `biogeme-3.2.8/src/bioExprMin.h` & `biogeme-3.2.9/src/bioExprMin.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprMinus.cc` & `biogeme-3.2.9/src/bioExprMinus.cc`

 * *Files 9% similar despite different names*

```diff
@@ -23,17 +23,17 @@
 
 }
 
 const bioDerivatives* bioExprMinus::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 						     bioBoolean gradient,
 						     bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+  theDerivatives.resize(literalIds.size()) ;
 
   bioUInt n = literalIds.size() ;
   const bioDerivatives* leftResult = left->getValueAndDerivatives(literalIds,gradient,hessian) ;
   const bioDerivatives* rightResult = right->getValueAndDerivatives(literalIds,gradient,hessian) ;
   theDerivatives.f = leftResult->f - rightResult->f ;
   if (gradient) {
     for (bioUInt i = 0 ; i < n ; ++i) {
```

### Comparing `biogeme-3.2.8/src/bioExprMinus.h` & `biogeme-3.2.9/src/bioExprMinus.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprMontecarlo.cc` & `biogeme-3.2.9/src/bioExprMontecarlo.cc`

 * *Files 3% similar despite different names*

```diff
@@ -20,28 +20,21 @@
 
 }
 
 const bioDerivatives* bioExprMontecarlo::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 							  bioBoolean gradient,
 							  bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
 
-  theDerivatives.f = 0.0 ;
-  if (gradient) {
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
-  }
+  theDerivatives.resize(literalIds.size()) ;
 
+  theDerivatives.setEverythingToZero() ;
+    
   if (numberOfDraws == 0) {
     throw bioExceptions(__FILE__,__LINE__,"Cannot perform Monte-Carlo integration with no draws.") ;
   }
 
   bioUInt n = literalIds.size() ;
   child->setDrawIndex(&drawIndex) ;
   for (drawIndex = 0 ; drawIndex < numberOfDraws ; ++drawIndex) {
```

### Comparing `biogeme-3.2.8/src/bioExprMontecarlo.h` & `biogeme-3.2.9/src/bioExprMontecarlo.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprMultSum.cc` & `biogeme-3.2.9/src/bioExprSum.cc`

 * *Files 24% similar despite different names*

```diff
@@ -1,101 +1,68 @@
 //-*-c++-*------------------------------------------------------------
 //
-// File name : bioExprMultSum.cc
-// @date   Wed Apr 18 11:05:06 2018
+// File name : bioExprSum.cc
+// @date   Fri Apr 13 10:27:14 2018
 // @author Michel Bierlaire
 // @version Revision 1.0
 //
 //--------------------------------------------------------------------
 
-#include <sstream>
+#include "bioExprSum.h"
 #include "bioDebug.h"
-#include "bioExprMultSum.h"
-#include "bioExceptions.h"
-
-bioExprMultSum::bioExprMultSum(std::vector<bioExpression*> e) :
-  expressions(e) {
-  listOfChildren = e ;
-}
+#include <sstream>
 
-bioExprMultSum::~bioExprMultSum() {
+bioExprSum::bioExprSum(bioExpression* c, std::vector< std::vector<bioReal> >* d) :
+  child(c), data(d) {
+  listOfChildren.push_back(c) ;
 
 }
 
-const bioDerivatives* bioExprMultSum::getValueAndDerivatives(std::vector<bioUInt> literalIds,
-						       bioBoolean gradient,
-						       bioBoolean hessian) {
-
-  if (!gradient && hessian) {
-    throw bioExceptions(__FILE__,__LINE__,"If the hessian is needed, the gradient must be computed") ;
-  }
-
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+bioExprSum::~bioExprSum() {
 
-  theDerivatives.f = 0.0 ;
-  if (gradient) {
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
-  }
-  for (std::vector<bioExpression*>::iterator i = expressions.begin();
-       i != expressions.end() ;
-       ++i) {
-    const bioDerivatives* fgh = (*i)->getValueAndDerivatives(literalIds,gradient,hessian) ;
-    
-    theDerivatives.f += fgh->f ;
+}
+  
+const bioDerivatives* bioExprSum::getValueAndDerivatives(std::vector<bioUInt> literalIds,
+						   bioBoolean gradient,
+						   bioBoolean hessian) {
+
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  bioUInt n = literalIds.size() ;
+  theDerivatives.resize(n) ;
+
+  theDerivatives.setToZero() ;
+  for (std::vector< std::vector<bioReal> >::iterator rowIterator = data->begin() ;
+       rowIterator != data->end() ;
+       ++rowIterator) {
+    child->setVariables(&(*rowIterator)) ;
+    const bioDerivatives* childResult = child->getValueAndDerivatives(literalIds,gradient,hessian) ;
+    theDerivatives.f += childResult->f ;
     if (gradient) {
-      for (std::size_t k = 0 ; k < literalIds.size() ; ++k) {
-	theDerivatives.g[k] += fgh->g[k] ;
+      for (bioUInt i = 0 ; i < n ; ++i) {
+	theDerivatives.g[i] += childResult->g[i] ;
 	if (hessian) {
-	  for (std::size_t l = k ; l < literalIds.size() ; ++l) {
-	    theDerivatives.h[k][l] += fgh->h[k][l] ;
+	  for (bioUInt j = i ; j < n ; ++j) {
+	    theDerivatives.h[i][j] += childResult->h[i][j] ;
 	  }
 	}
       }
     }
   }
+  // Fill the symmetric part of the hessian
   if (hessian) {
-    // Fill the symmetric part of the matrix
-    for (std::size_t k = 0 ; k < literalIds.size() ; ++k) {
-      for (std::size_t l = k+1 ; l < literalIds.size() ; ++l) {
-	theDerivatives.h[l][k]  = theDerivatives.h[k][l] ;
+    for (bioUInt i = 0 ; i < n ; ++i) {
+      for (bioUInt j = 0 ; j < i ; ++j) {
+	theDerivatives.h[i][j] = theDerivatives.h[j][i] ;
       }
     }
   }
-  //  DEBUG_MESSAGE("MultiSum calculated " << str.length()) ;
   return &theDerivatives ;
 }
 
-bioString bioExprMultSum::print(bioBoolean hp) const {
+bioString bioExprSum::print(bioBoolean hp) const {
   std::stringstream str ;
-  if (hp) {
-    str << "MultiSum(" ;
-    for (std::vector<bioExpression*>::const_iterator i = expressions.begin() ;
-	 i != expressions.end() ;
-	 ++i) {
-      if (i != expressions.begin()) {
-	str << " , " ;
-      }
-      str << (*i)->print(hp) ;
-    }
-    str << ")" ;
-  }
-  else {
-    str << "(" ;
-    for (std::vector<bioExpression*>::const_iterator i = expressions.begin() ;
-	 i != expressions.end() ;
-	 ++i) {
-      if (i != expressions.begin()) {
-	str << " + " ;
-      }
-      str << (*i)->print(hp) ;
-    }
-    str << ")" ;
-  }
+  str << "Sum(" << child->print(hp) << ")" ;
   return str.str() ;
 }
+
```

### Comparing `biogeme-3.2.8/src/bioExprMultSum.h` & `biogeme-3.2.9/src/bioExprMultSum.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprNormalCdf.cc` & `biogeme-3.2.9/src/bioExprNormalCdf.cc`

 * *Files 8% similar despite different names*

```diff
@@ -20,18 +20,17 @@
 
 }
 
 const bioDerivatives* bioExprNormalCdf::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 							  bioBoolean gradient,
 							  bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
-
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+  theDerivatives.resize(literalIds.size()) ;
 
   const bioDerivatives* childResult = child->getValueAndDerivatives(literalIds,gradient,hessian) ;
   theDerivatives.f = theNormalCdf.compute(childResult->f) ;
 
   if (gradient) {
     bioUInt n = literalIds.size() ;
     bioReal thePdf = invSqrtTwoPi * exp(- childResult->f * childResult->f / 2.0) ;
```

### Comparing `biogeme-3.2.8/src/bioExprNormalCdf.h` & `biogeme-3.2.9/src/bioExprNormalCdf.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprNormalPdf.cc` & `biogeme-3.2.9/src/bioExprNormalPdf.cc`

 * *Files 4% similar despite different names*

```diff
@@ -19,18 +19,17 @@
 
 }
 
 const bioDerivatives* bioExprNormalPdf::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 							  bioBoolean gradient,
 							  bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
-
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+  theDerivatives.resize(literalIds.size()) ;
 
   const bioDerivatives* childResult = child->getValueAndDerivatives(literalIds,gradient,hessian) ;
   bioReal x = - childResult->f * childResult->f / 2.0 ;
   if (x <= bioLogMaxReal::the()) { 
     theDerivatives.f = exp(x) * 0.3989422804 ;
   }
   else {
```

### Comparing `biogeme-3.2.8/src/bioExprNormalPdf.h` & `biogeme-3.2.9/src/bioExprNormalPdf.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprNotEqual.cc` & `biogeme-3.2.9/src/bioExprNotEqual.cc`

 * *Files 5% similar despite different names*

```diff
@@ -23,31 +23,26 @@
 
 }
   
 const bioDerivatives* bioExprNotEqual::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 							bioBoolean gradient,
 							bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
-
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
   
+  theDerivatives.resize(literalIds.size()) ;
+
   if (gradient) {
     if (containsLiterals(literalIds)) {
       std::stringstream str ;
       str << "Expression NotEqual is not differentiable" << std::endl ; 
       throw bioExceptions(__FILE__,__LINE__,str.str()) ;
     }
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
+    theDerivatives.setDerivativesToZero() ;
   }
   
   if (left->getValue() != right->getValue()) {
     theDerivatives. f = 1.0 ;
   }
   else {
     theDerivatives. f = 0.0 ;
```

### Comparing `biogeme-3.2.8/src/bioExprNotEqual.h` & `biogeme-3.2.9/src/bioExprNotEqual.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprNumeric.cc` & `biogeme-3.2.9/src/bioExprNumeric.cc`

 * *Files 17% similar despite different names*

```diff
@@ -15,31 +15,24 @@
 }
 
 bioExprNumeric::~bioExprNumeric() {
 
 }
 
 const bioDerivatives* bioExprNumeric::getValueAndDerivatives(std::vector<bioUInt> literalIds,
-						       bioBoolean gradient,
-						       bioBoolean hessian) {
+							     bioBoolean gradient,
+							     bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
-
-  if (gradient) {
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
+
+  theDerivatives.setDerivativesToZero() ;
   theDerivatives.f = value ;
-  
   return &theDerivatives ;
 }
 
 bioString bioExprNumeric::print(bioBoolean hp) const {
   std::stringstream str ;
   str << value ;
   return str.str() ;
```

### Comparing `biogeme-3.2.8/src/bioExprNumeric.h` & `biogeme-3.2.9/src/bioExprPlus.h`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,31 @@
 //-*-c++-*------------------------------------------------------------
 //
-// File name : bioExprNumeric.h
-// @date   Fri Apr 13 15:11:32 2018
+// File name : bioExprPlus.h
+// @date   Fri Apr 13 10:26:01 2018
 // @author Michel Bierlaire
 // @version Revision 1.0
 //
 //--------------------------------------------------------------------
 
-#ifndef bioExprNumeric_h
-#define bioExprNumeric_h
+#ifndef bioExprPlus_h
+#define bioExprPlus_h
 
 #include "bioExpression.h"
 #include "bioString.h"
 
-class bioExprNumeric: public bioExpression {
+class bioExprPlus: public bioExpression {
  public:
-  bioExprNumeric(bioReal v) ;
-  ~bioExprNumeric() ;
+  bioExprPlus(bioExpression* l, bioExpression* r) ;
+  ~bioExprPlus() ;
   virtual const bioDerivatives* getValueAndDerivatives(std::vector<bioUInt> literalIds,
 						 bioBoolean gradient,
-						bioBoolean hessian) ;
+						 bioBoolean hessian) ;
+
   virtual bioString print(bioBoolean hp = false) const ;
-protected:
-  bioReal value ;
+ protected:
+  bioExpression* left ;
+  bioExpression* right ;
 };
+
+
 #endif
```

### Comparing `biogeme-3.2.8/src/bioExprOr.cc` & `biogeme-3.2.9/src/bioExprOr.cc`

 * *Files 13% similar despite different names*

```diff
@@ -24,30 +24,26 @@
 }
 
   
 const bioDerivatives* bioExprOr::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 						     bioBoolean gradient,
 						     bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
 
   if (gradient) {
     if (containsLiterals(literalIds)) {
       std::stringstream str ;
       str << "Expression "+print()+" is not differentiable" << std::endl ; 
       throw(bioExceptions(__FILE__,__LINE__,str.str())) ;
     }
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
+    theDerivatives.setDerivativesToZero() ;
   }
   
   if (left == NULL) {
     throw bioExceptNullPointer(__FILE__,__LINE__,"left") ;
   }
   if (right == NULL) {
     throw bioExceptNullPointer(__FILE__,__LINE__,"right") ;
```

### Comparing `biogeme-3.2.8/src/bioExprOr.h` & `biogeme-3.2.9/src/bioExprOr.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprPanelTrajectory.cc` & `biogeme-3.2.9/src/bioExprPanelTrajectory.cc`

 * *Files 14% similar despite different names*

```diff
@@ -23,26 +23,22 @@
 }
 
 const bioDerivatives* bioExprPanelTrajectory::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 							  bioBoolean gradient,
 							  bioBoolean hessian) {
 
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
+
+  theDerivatives.resize(literalIds.size()) ;
 
   theDerivatives.f = 0.0 ;
   if (gradient) {
-    if (hessian) {
-      theDerivatives.setDerivativesToZero() ;
-    }
-    else {
-      theDerivatives.setGradientToZero() ;
-    }
+    theDerivatives.setDerivativesToZero() ;
   }
 
   if (dataMap == NULL) {
     throw bioExceptNullPointer(__FILE__,__LINE__,"data map") ;
   }
 
   if (individualIndex == NULL) {
@@ -55,20 +51,15 @@
   }
   bioUInt n = literalIds.size() ;
   child->setRowIndex(&theRowIndex) ;
 
   for (theRowIndex = (*dataMap)[*individualIndex][0]  ; theRowIndex <= (*dataMap)[*individualIndex][1] ; ++theRowIndex) {
     const bioDerivatives* childResult(NULL) ;
     try {
-      childResult = child->getValueAndDerivatives(literalIds,gradient,hessian) ;
-      // if (childResult->f <= 1.0e-6) {
-      // 	std::stringstream str ;
-      // 	str << "Error for data entry " << theRowIndex << ": probability " << childResult->f << "for " << child->print() ;
-      // 	throw bioExceptions(__FILE__,__LINE__,str.str()) ;
-      // }
+      childResult = child->getValueAndDerivatives(literalIds, gradient, hessian) ;
       theDerivatives.f += log(childResult->f) ;
       if (gradient) {
 	for (bioUInt i = 0 ; i < n ; ++i) {
 	  if (childResult->g[i] != 0.0) {
 	    theDerivatives.g[i] += childResult->g[i] / childResult->f ;
 	  }
 	  if (hessian) {
```

### Comparing `biogeme-3.2.8/src/bioExprPanelTrajectory.h` & `biogeme-3.2.9/src/bioExprPanelTrajectory.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprPlus.cc` & `biogeme-3.2.9/src/bioExprPlus.cc`

 * *Files 3% similar despite different names*

```diff
@@ -22,21 +22,20 @@
 bioExprPlus::~bioExprPlus() {
 }
   
 const bioDerivatives* bioExprPlus::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 						    bioBoolean gradient,
 						    bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
-
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
 
-  
   bioUInt n = literalIds.size() ;
+  theDerivatives.resize(n) ;
+
   const bioDerivatives* leftResult = left->getValueAndDerivatives(literalIds,gradient,hessian) ;
   const bioDerivatives* rightResult = right->getValueAndDerivatives(literalIds,gradient,hessian) ;
   if (rightResult == NULL) {
     throw bioExceptNullPointer(__FILE__,__LINE__,"right result") ;
   }
 
   if (leftResult->f == 0.0) {
```

### Comparing `biogeme-3.2.8/src/bioExprPlus.h` & `biogeme-3.2.9/src/bioExprUnaryMinus.h`

 * *Files 14% similar despite different names*

```diff
@@ -1,31 +1,29 @@
 //-*-c++-*------------------------------------------------------------
 //
-// File name : bioExprPlus.h
-// @date   Fri Apr 13 10:26:01 2018
+// File name : bioExprUnaryMinus.h
+// @date   Fri Apr 13 14:53:04 2018
 // @author Michel Bierlaire
 // @version Revision 1.0
 //
 //--------------------------------------------------------------------
 
-#ifndef bioExprPlus_h
-#define bioExprPlus_h
+#ifndef bioExprUnaryMinus_h
+#define bioExprUnaryMinus_h
 
 #include "bioExpression.h"
 #include "bioString.h"
 
-class bioExprPlus: public bioExpression {
+class bioExprUnaryMinus: public bioExpression {
  public:
-  bioExprPlus(bioExpression* l, bioExpression* r) ;
-  ~bioExprPlus() ;
+  bioExprUnaryMinus(bioExpression* c) ;
+  ~bioExprUnaryMinus() ;
   virtual const bioDerivatives* getValueAndDerivatives(std::vector<bioUInt> literalIds,
 						 bioBoolean gradient,
-						 bioBoolean hessian) ;
+						bioBoolean hessian) ;
 
   virtual bioString print(bioBoolean hp = false) const ;
+
  protected:
-  bioExpression* left ;
-  bioExpression* right ;
+  bioExpression* child ;
 };
-
-
 #endif
```

### Comparing `biogeme-3.2.8/src/bioExprPower.cc` & `biogeme-3.2.9/src/bioExprPower.cc`

 * *Files 2% similar despite different names*

```diff
@@ -23,24 +23,24 @@
 
 }
 
 const bioDerivatives* bioExprPower::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 						     bioBoolean gradient,
 						     bioBoolean hessian) {
 
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
-
-  
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
 
   bioUInt n = literalIds.size() ;
+  theDerivatives.resize(n) ;
+
   const bioDerivatives* leftResult = left->getValueAndDerivatives(literalIds,gradient,hessian) ;
+
   const bioDerivatives* rightResult = right->getValueAndDerivatives(literalIds,gradient,hessian) ;
-  
+
   if (rightResult->f == 0.0) {
     theDerivatives.f = 1.0 ;
   }
   else if (rightResult->f == 1.0) {
     theDerivatives.f = leftResult->f ;
   }
   else if (leftResult->f == 0) {
```

### Comparing `biogeme-3.2.8/src/bioExprPower.h` & `biogeme-3.2.9/src/bioExprPower.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprRandomVariable.cc` & `biogeme-3.2.9/src/bioExprRandomVariable.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprRandomVariable.h` & `biogeme-3.2.9/src/bioExprRandomVariable.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprSum.cc` & `biogeme-3.2.9/src/bioExprUnaryMinus.cc`

 * *Files 17% similar despite different names*

```diff
@@ -1,68 +1,54 @@
 //-*-c++-*------------------------------------------------------------
 //
-// File name : bioExprSum.cc
-// @date   Fri Apr 13 10:27:14 2018
+// File name : bioExprUnaryMinus.cc
+// @date   Fri Apr 13 11:38:02 2018
 // @author Michel Bierlaire
 // @version Revision 1.0
 //
 //--------------------------------------------------------------------
 
-#include "bioExprSum.h"
+#include "bioExprUnaryMinus.h"
 #include "bioDebug.h"
-#include <sstream>
+#include <sstream> 
 
-bioExprSum::bioExprSum(bioExpression* c, std::vector< std::vector<bioReal> >* d) :
-  child(c), data(d) {
+bioExprUnaryMinus::bioExprUnaryMinus(bioExpression* c) :
+  child(c) {
   listOfChildren.push_back(c) ;
+}
+bioExprUnaryMinus::~bioExprUnaryMinus() {
 
 }
 
-bioExprSum::~bioExprSum() {
+const bioDerivatives* bioExprUnaryMinus::getValueAndDerivatives(std::vector<bioUInt> literalIds,
+							  bioBoolean gradient,
+							  bioBoolean hessian) {
 
-}
-  
-const bioDerivatives* bioExprSum::getValueAndDerivatives(std::vector<bioUInt> literalIds,
-						   bioBoolean gradient,
-						   bioBoolean hessian) {
-
-  bioString str = print(true) ;
-  if (gradient && theDerivatives.getSize() != literalIds.size()) {
-    theDerivatives.resize(literalIds.size()) ;
-  }
+  theDerivatives.with_g = gradient ;
+  theDerivatives.with_h = hessian ;
 
   bioUInt n = literalIds.size() ;
-  theDerivatives.setToZero() ;
-  for (std::vector< std::vector<bioReal> >::iterator rowIterator = data->begin() ;
-       rowIterator != data->end() ;
-       ++rowIterator) {
-    child->setVariables(&(*rowIterator)) ;
-    const bioDerivatives* childResult = child->getValueAndDerivatives(literalIds,gradient,hessian) ;
-    theDerivatives.f += childResult->f ;
-    if (gradient) {
-      for (bioUInt i = 0 ; i < n ; ++i) {
-	theDerivatives.g[i] += childResult->g[i] ;
-	if (hessian) {
-	  for (bioUInt j = i ; j < n ; ++j) {
-	    theDerivatives.h[i][j] += childResult->h[i][j] ;
-	  }
-	}
-      }
-    }
-  }
-  // Fill the symmetric part of the hessian
-  if (hessian) {
+
+  theDerivatives.resize(n) ;
+
+  const bioDerivatives* childResult = child->getValueAndDerivatives(literalIds,gradient,hessian) ;
+  theDerivatives.f = - childResult->f ;
+  if (gradient) {
     for (bioUInt i = 0 ; i < n ; ++i) {
-      for (bioUInt j = 0 ; j < i ; ++j) {
-	theDerivatives.h[i][j] = theDerivatives.h[j][i] ;
+      theDerivatives.g[i] = - childResult->g[i] ;
+      if (hessian) {
+	for (bioUInt j = 0 ; j < n ; ++j) {
+	  theDerivatives.h[i][j] = - childResult->h[i][j] ;
+	}
       }
     }
   }
   return &theDerivatives ;
 }
 
-bioString bioExprSum::print(bioBoolean hp) const {
-  std::stringstream str ;
-  str << "Sum(" << child->print(hp) << ")" ;
+bioString bioExprUnaryMinus::print(bioBoolean hp) const {
+  std::stringstream str ; 
+  str << "-" << child->print(hp) ;
   return str.str() ;
+
 }
```

### Comparing `biogeme-3.2.8/src/bioExprSum.h` & `biogeme-3.2.9/src/bioExprSum.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprTimes.h` & `biogeme-3.2.9/src/bioExprTimes.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExprVariable.cc` & `biogeme-3.2.9/src/bioExprVariable.cc`

 * *Files 7% similar despite different names*

```diff
@@ -53,15 +53,23 @@
   else {
     if (*rowIndex >= data->size()) {
       std::stringstream str ;
       str << theName << ": " << *rowIndex << " out of range [0," << data->size() - 1 << "]" ;
       throw bioExceptions(__FILE__,__LINE__,str.str()) ;
     }
     if (theVariableId >= (*data)[*rowIndex].size()) {
-      throw bioExceptOutOfRange<bioUInt>(__FILE__,__LINE__,theVariableId,0,(*data)[*rowIndex].size() - 1) ;
+      std::stringstream str ;
+      str << theName
+	  << ": "
+	  << "Value "
+	  << theVariableId
+	  << " out of range [0,"
+	  << (*data)[*rowIndex].size() - 1
+	  <<"]" ;
+      throw bioExceptions(__FILE__,__LINE__,str.str()) ;
     }
     value = (*data)[*rowIndex][theVariableId] ;
   }
   if (value == missingData) {
     std::stringstream str ;
     str << "Variable " << theName << " takes value " << missingData << " at row " << *rowIndex << ". This value is interpreted as a missing value by Biogeme. If it is a genuine value, change the parameter 'missingData' in Biogeme. If not, either remove the observation or change the specification of the model." ;
     throw bioExceptions(__FILE__,__LINE__,str.str()) ;
```

### Comparing `biogeme-3.2.8/src/bioExprVariable.h` & `biogeme-3.2.9/src/bioExprVariable.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioExpression.cc` & `biogeme-3.2.9/src/bioExpression.cc`

 * *Files 0% similar despite different names*

```diff
@@ -92,15 +92,15 @@
        i != listOfChildren.end() ;
        ++i) {
     (*i)->setRandomVariableValuePtr(rvId, v) ;
   }
 }
 
 bioReal bioExpression::getValue() {
-  const bioDerivatives* r = getValueAndDerivatives(std::vector<bioUInt>(),false,false) ;
+  const bioDerivatives* r = getValueAndDerivatives(std::vector<bioUInt>(), false,false) ;
   return r->f ;
 
 }
 
 bioBoolean bioExpression::containsLiterals(std::vector<bioUInt> literalIds) const {
   for (std::vector<bioExpression*>::const_iterator i = listOfChildren.begin() ;
        i != listOfChildren.end() ;
```

### Comparing `biogeme-3.2.8/src/bioExpression.h` & `biogeme-3.2.9/src/bioExpression.h`

 * *Files 1% similar despite different names*

```diff
@@ -33,16 +33,16 @@
   virtual void setDataMap(std::vector< std::vector<bioUInt> >* dm) ;
   virtual void setDraws(std::vector< std::vector< std::vector<bioReal> > >* d) ;
   virtual bioReal getValue() ;
   // Returns true is the expression contains at least one literal in
   // the list. Used to simplify the calculation of the derivatives
   virtual bioBoolean containsLiterals(std::vector<bioUInt> literalIds) const ;
   virtual const bioDerivatives* getValueAndDerivatives(std::vector<bioUInt> literalIds,
-						 bioBoolean gradient,
-						 bioBoolean hessian) = PURE_VIRTUAL ;
+						       bioBoolean gradient,
+						       bioBoolean hessian) = PURE_VIRTUAL ;
   virtual std::map<bioString,bioReal> getAllLiteralValues() ;
  protected:
   std::vector<bioReal>* parameters ;
   std::vector<bioReal>* fixedParameters ;
   bioDerivatives theDerivatives ;
   // Dimensons of the data
   // 1. number of rows
```

### Comparing `biogeme-3.2.8/src/bioFormula.cc` & `biogeme-3.2.9/src/bioFormula.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioFormula.h` & `biogeme-3.2.9/src/bioFormula.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioGaussHermite.cc` & `biogeme-3.2.9/src/bioGaussHermite.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioGaussHermite.h` & `biogeme-3.2.9/src/bioGaussHermite.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioGhFunction.cc` & `biogeme-3.2.9/src/bioGhFunction.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioGhFunction.h` & `biogeme-3.2.9/src/bioGhFunction.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioMemoryManagement.cc` & `biogeme-3.2.9/src/bioMemoryManagement.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioMemoryManagement.h` & `biogeme-3.2.9/src/bioMemoryManagement.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioNormalCdf.cc` & `biogeme-3.2.9/src/bioNormalCdf.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioNormalCdf.h` & `biogeme-3.2.9/src/bioNormalCdf.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioSeveralExpressions.cc` & `biogeme-3.2.9/src/bioSeveralExpressions.cc`

 * *Files 7% similar despite different names*

```diff
@@ -52,15 +52,23 @@
 }
 
 std::vector<bioReal > bioSeveralExpressions::getValues() {
   std::vector<bioReal > results ;
   for (std::vector<bioExpression*>::iterator i = theExpressions.begin() ;
        i != theExpressions.end() ;
        ++i) {
-    results.push_back((*i)->getValue()) ;
+    bioReal res ;
+    try {
+      res = (*i)->getValue() ;
+    }
+    //    catch(bioExceptions& e) {
+    catch(...) {
+      res = std::numeric_limits<bioReal>::quiet_NaN() ;
+    }
+    results.push_back(res) ;
   }
   return results ;
 }
 
 const bioDerivatives* bioSeveralExpressions::getValueAndDerivatives(std::vector<bioUInt> literalIds,
 								    bioBoolean gradient,
 								    bioBoolean hessian) {
```

### Comparing `biogeme-3.2.8/src/bioSeveralFormulas.cc` & `biogeme-3.2.9/src/bioSeveralFormulas.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioSeveralFormulas.h` & `biogeme-3.2.9/src/bioSeveralFormulas.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioString.cc` & `biogeme-3.2.9/src/bioString.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioString.h` & `biogeme-3.2.9/src/bioString.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioThreadMemory.cc` & `biogeme-3.2.9/src/bioThreadMemory.cc`

 * *Files 4% similar despite different names*

```diff
@@ -12,14 +12,15 @@
 #include "bioExceptions.h"
 
 bioThreadMemory::bioThreadMemory() {
   
 }
 
 void bioThreadMemory::resize(bioUInt nThreads, bioUInt dim) {
+  inputStructures.clear() ;
   inputStructures.resize(nThreads) ;
   for (bioUInt i = 0 ; i < numberOfThreads() ; ++i) {
     inputStructures[i].grad.resize(dim) ;
     inputStructures[i].hessian.resize(dim,inputStructures[i].grad) ;
     inputStructures[i].bhhh.resize(dim,inputStructures[i].grad) ;
   }
 }
```

### Comparing `biogeme-3.2.8/src/bioThreadMemory.h` & `biogeme-3.2.9/src/bioThreadMemory.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioThreadMemorySimul.cc` & `biogeme-3.2.9/src/bioThreadMemorySimul.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioThreadMemorySimul.h` & `biogeme-3.2.9/src/bioThreadMemorySimul.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/bioTypes.h` & `biogeme-3.2.9/src/bioTypes.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/biogeme.cc` & `biogeme-3.2.9/src/biogeme.cc`

 * *Files 2% similar despite different names*

```diff
@@ -61,15 +61,14 @@
 }
 
 
 bioReal biogeme::applyTheFormula(  std::vector<bioReal>* g,
 				   std::vector< std::vector<bioReal> >* h,
 				   std::vector< std::vector<bioReal> >* bh) {
 
-
   if ( g != NULL) {
     if (g->size() != theThreadMemory.dimension()) {
       std::stringstream str ;
       str << "Gradient: inconsistent dimensions " << g->size() << " and " << theThreadMemory.dimension() ;
       throw bioExceptions(__FILE__,__LINE__,str.str()) ;
     }
   }
@@ -84,14 +83,15 @@
     if (bh->size() != theThreadMemory.dimension()) {
       std::stringstream str ;
       str << "BHHH: inconsistent dimensions " << bh->size() << " and " << theThreadMemory.dimension() ;
       throw bioExceptions(__FILE__,__LINE__,str.str()) ;
     }
   }
 
+  
   //  std::vector<bioThreadArg*> theInput(nbrOfThreads) ;
   std::vector<pthread_t> theThreads(nbrOfThreads) ;
   for (bioUInt thread = 0 ; thread < nbrOfThreads ; ++thread) {
     if (theInput[thread] == NULL) {
       throw bioExceptNullPointer(__FILE__,__LINE__,"thread") ;
     }
     theInput[thread]->calcGradient = (g != NULL) ;
@@ -142,14 +142,15 @@
       }
     }
   }
 
   if (!std::isfinite(result)) {
     result = -std::numeric_limits<bioReal>::max() ;
   }
+
   if (g != NULL) {
     for (bioUInt i = 0 ; i < g->size() ; ++i) {
       if (!std::isfinite((*g)[i])) {
 	(*g)[i] = -std::numeric_limits<bioReal>::max() ;
       }
       if ( h != NULL) {
 	for (bioUInt j = i ; j < g->size() ; ++j) {
@@ -184,26 +185,26 @@
     }
   }
 
   return result ;
 }
 
 
- bioReal biogeme::calculateLikeAndDerivatives(std::vector<bioReal> betas,
+bioReal biogeme::calculateLikeAndDerivatives(std::vector<bioReal> betas,
  					     std::vector<bioReal> fixedBetas,
  					     std::vector<bioUInt> betaIds,
  					     bioReal* g,
  					     bioReal* h,
  					     bioReal* bh,
  					     bioBoolean hessian,
  					     bioBoolean bhhh) {
-
+  
   int n = betas.size() ;
   
-  ++nbrFctEvaluations ;
+   ++nbrFctEvaluations ;
   literalIds = betaIds ;
   if (forceDataPreparation || (theThreadMemory.dimension() != literalIds.size())) {
     prepareData() ;
     forceDataPreparation = false ;
   }
   calculateHessian = hessian ;
   calculateBhhh = bhhh ;
@@ -277,15 +278,15 @@
 
 // }
 
 
 void biogeme::setExpressions(std::vector<bioString> ll,
 			     std::vector<bioString> w,
 			     bioUInt t) {
-  
+
   theLoglikeString.erase(theLoglikeString.begin(),theLoglikeString.end()) ;
   for (bioUInt i = 0 ; i < ll.size() ; ++i) {
     if (std::find(theLoglikeString.begin(),theLoglikeString.end(),ll[i]) == theLoglikeString.end()) {
       theLoglikeString.push_back(ll[i]) ;
     }
   }
 
@@ -329,16 +330,14 @@
 	  w = input->theWeight.getExpression()->getValue() ;
 	}
       
 	const bioDerivatives* fgh = myLoglike->getValueAndDerivatives(*input->literalIds,
 								      input->calcGradient,
 								      input->calcHessian) ;
       
-      
-
 	if (!input->theWeight.isDefined()) {
 	  input->result += fgh->f ;
 	  for (bioUInt i = 0 ; i < input->grad.size() ; ++i) {
 	    (input->grad)[i] += fgh->g[i] ;
 	    if (input->calcHessian) {
 	      for (bioUInt j = 0 ; j < input->grad.size() ; ++j) {
 		(input->hessian)[i][j] += fgh->h[i][j] ;
@@ -378,24 +377,25 @@
       }
       myLoglike->setIndividualIndex(&row) ;
       myLoglike->setRowIndex(&row) ;
       if (input->theWeight.isDefined()) {
 	input->theWeight.setIndividualIndex(&row) ;
 	input->theWeight.setRowIndex(&row) ;
       }
-      
+
       for (row = input->startData ;
 	   row < input->endData ;
 	   ++row) {
 	
 	try {
 	  if (input->theWeight.isDefined()) {
 	    w = input->theWeight.getExpression()->getValue() ;
 	  }
 
+	  
 	  const bioDerivatives* fgh = myLoglike->getValueAndDerivatives(*input->literalIds,
 						  input->calcGradient,
 						  input->calcHessian) ;
 
 
 	  if (!input->theWeight.isDefined()) {
 	    input->result += fgh->f ;
@@ -453,20 +453,31 @@
   return NULL ;
 }
 
 
 void *simulFunctionForThread(void* fctPtr) {
   try {
     bioThreadArgSimul *input = (bioThreadArgSimul *) fctPtr;
-    
     bioSeveralExpressions* expressions = input->theFormulas.getExpressions() ;
     if (input->panel) {
-      std::stringstream str ;
-      str << "Simulation of panel data is not yet implemented" ;
-      throw bioExceptions(__FILE__,__LINE__,str.str()) ;
+      bioUInt individual ;
+      expressions->setIndividualIndex(&individual) ;
+      for (individual = input->startData ;
+	   individual < input->endData ;
+	   ++individual) {
+	try {
+	  std::vector<bioReal > res = expressions->getValues() ;
+	  input->results.push_back(res) ;
+	}
+	catch(bioExceptions& e) {
+	  std::stringstream str ;
+	  str << "Error in simulating panel data: " << e.what() ;
+	  throw bioExceptions(__FILE__,__LINE__,str.str()) ;
+	}
+      }
     }
     else {
       bioUInt row ;
       if (expressions == NULL) {
 	throw bioExceptNullPointer(__FILE__,__LINE__,"thread memory") ;
       }
       expressions->setIndividualIndex(&row) ;
@@ -498,14 +509,15 @@
 
 void biogeme::prepareMemoryForThreads(bioBoolean force) {
   theThreadMemory.resize(nbrOfThreads,literalIds.size()) ;
   theThreadMemory.setLoglike(theLoglikeString) ;
   if (!theWeightString.empty()) {
     theThreadMemory.setWeight(theWeightString) ;
   }
+  
 }
 
 void biogeme::simulateFormula(std::vector<bioString> formula,
 			      std::vector<bioReal> beta,
 			      std::vector<bioReal> fixedBeta,
 			      std::vector< std::vector<bioReal> > data,
 			      bioReal* results) {
@@ -528,21 +540,62 @@
        row < N ;
        ++row) {
     results[row] = theFormula.getExpression()->getValue() ;
   }
   return ;
 }
 
+bioReal biogeme::simulateSimpleFormula(std::vector<bioString> formula,
+				       std::vector<bioReal> beta,
+				       std::vector<bioReal> fixedBeta,
+				       bioBoolean gradient,
+				       bioBoolean hessian,
+				       bioReal* g,
+				       bioReal* h) {
+
+  bioFormula theFormula ;
+  theFormula.setExpression(formula) ;
+  theFormula.setParameters(&beta) ;
+  theFormula.setFixedParameters(&fixedBeta) ;
+  if (!theDraws.empty()) {
+    theFormula.setDraws(&theDraws) ;
+  }  
+
+  if (!gradient && !hessian) {
+    return theFormula.getExpression()->getValue() ;
+  }
+  int n = beta.size() ;
+  // The ids of th eliterals are from 0 to n-1, corresponding to the free parameters.
+  std::vector<bioUInt> literalIds(n) ;
+  for (int i = 0 ; i < n ; ++i) {
+    literalIds[i] = i ;
+  }
+  const bioDerivatives* results =
+    theFormula.getExpression()->getValueAndDerivatives(literalIds,
+						       gradient,
+						       hessian) ;
+
+  for (int i = 0 ; i < n ; ++i) {
+    g[i] = results->g[i] ;
+    if (hessian) {
+      for (int j = i ; j < n ; j++) {
+	h[i*n+j] = h[j*n+i] = results->h[i][j] ;
+      }
+    }
+  }
+  return results->f ;
+}
+
+
 void biogeme::simulateSeveralFormulas(std::vector<std::vector<bioString> > formulas,
 				      std::vector<bioReal> betas,
 				      std::vector<bioReal> fixedBetas,
 				      bioUInt t,
 				      std::vector< std::vector<bioReal> > data,
 				      bioReal* results) {
-
   nbrOfThreads = t ;
   theThreadMemorySimul.resize(nbrOfThreads) ;
   theThreadMemorySimul.setFormulas(formulas) ;
   prepareDataSimul() ;
   theThreadMemorySimul.setParameters(&betas) ;
   theThreadMemorySimul.setFixedParameters(&fixedBetas) ;
   
@@ -634,14 +687,15 @@
   theData = d ;
   forceDataPreparation = true ;
 }
 
 void biogeme::setDataMap(std::vector< std::vector<bioUInt> >& dm) {
   theDataMap = dm ;
   forceDataPreparation = true ;
+  panel = true ;
 }
 
 void biogeme::setMissingData(bioReal md) {
   missingData = md ;
   forceDataPreparation = true ;
 }
 
@@ -720,14 +774,15 @@
       theInput[thread]->theWeight.setData(theInput[thread]->data) ;
       if (panel) {
 	theInput[thread]->theWeight.setDataMap(theInput[thread]->dataMap) ;
       }
       theInput[thread]->theWeight.setMissingData(theInput[thread]->missingData) ;
     }
   }
+
 }
 
 void biogeme::prepareDataSimul() {
 
   theThreadMemorySimul.setData(&theData) ;
   if (panel) {
     theThreadMemorySimul.setDataMap(&theDataMap) ;
```

### Comparing `biogeme-3.2.8/src/biogeme.cc.tmp` & `biogeme-3.2.9/src/biogeme.cc.tmp`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/biogeme.cc.work` & `biogeme-3.2.9/src/biogeme.cc.work`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/biogeme.h` & `biogeme-3.2.9/src/biogeme.h`

 * *Files 2% similar despite different names*

```diff
@@ -66,14 +66,22 @@
 				      std::vector< std::vector<bioReal> >& h,
 				      std::vector< std::vector<bioReal> >& bh,
 				      bioBoolean hessian,
 				      bioBoolean bhhh) ;
   void setFixedBetas(std::vector<bioReal>& fixedBeta,
 		     std::vector<bioUInt>& betaIds) ;
 
+  bioReal simulateSimpleFormula(std::vector<bioString> formula,
+				std::vector<bioReal> beta,
+				std::vector<bioReal> fixedBeta,
+				bioBoolean gradient,
+				bioBoolean hessian,
+				bioReal* g,
+				bioReal* h) ;
+
   void simulateFormula(std::vector<bioString> formula,
 		       std::vector<bioReal> beta,
 		       std::vector<bioReal> fixedBeta,
 		       std::vector< std::vector<bioReal> > data,
 		       bioReal* results) ;
 
   void simulateSeveralFormulas(std::vector<std::vector<bioString> > formula,
```

### Comparing `biogeme-3.2.8/src/biogeme.h.work` & `biogeme-3.2.9/src/biogeme.h.work`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/biogeme_working.cc` & `biogeme-3.2.9/src/biogeme_working.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/biogeme_working.h` & `biogeme-3.2.9/src/biogeme_working.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/cbiogeme.cpp` & `biogeme-3.2.9/src/cbiogeme.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,48 +1,38 @@
-/* Generated by Cython 0.29.24 */
+/* Generated by Cython 0.29.30 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
-        "define_macros": [
-            [
-                "NPY_NO_DEPRECATED_API",
-                "NPY_1_7_API_VERSION"
-            ]
-        ],
         "depends": [
-            "/Users/michelbierlaire/opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/core/include/numpy/arrayobject.h",
-            "/Users/michelbierlaire/opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/core/include/numpy/arrayscalars.h",
-            "/Users/michelbierlaire/opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/core/include/numpy/ndarrayobject.h",
-            "/Users/michelbierlaire/opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/core/include/numpy/ndarraytypes.h",
-            "/Users/michelbierlaire/opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/core/include/numpy/ufuncobject.h",
+            "/Users/michelbierlaire/opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h",
+            "/Users/michelbierlaire/opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/core/include/numpy/arrayscalars.h",
+            "/Users/michelbierlaire/opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h",
+            "/Users/michelbierlaire/opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h",
+            "/Users/michelbierlaire/opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/core/include/numpy/ufuncobject.h",
             "src/biogeme.h"
         ],
-        "extra_compile_args": [
-            "-std=c++11",
-            "-Wall",
-            "-stdlib=libc++"
-        ],
-        "extra_link_args": [
-            "-lc++"
-        ],
         "include_dirs": [
             "src",
-            "/Users/michelbierlaire/opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/core/include"
+            "src/",
+            "/Users/michelbierlaire/opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/core/include"
         ],
         "language": "c++",
-        "name": "biogeme.cbiogeme",
+        "name": "biogeme",
         "sources": [
             "src/cbiogeme.pyx",
+            "src/cexpressions.pyx",
             "src/biogeme.cc",
+            "src/evaluateExpressions.cc",
             "src/bioMemoryManagement.cc",
             "src/bioNormalCdf.cc",
             "src/bioFormula.cc",
             "src/bioSeveralFormulas.cc",
             "src/bioThreadMemory.cc",
+            "src/bioThreadMemoryOneExpression.cc",
             "src/bioThreadMemorySimul.cc",
             "src/bioString.cc",
             "src/bioExprNormalCdf.cc",
             "src/bioExprIntegrate.cc",
             "src/bioExprGaussHermite.cc",
             "src/bioExprRandomVariable.cc",
             "src/bioExprMontecarlo.cc",
@@ -77,34 +67,35 @@
             "src/bioExprLogLogit.cc",
             "src/bioExprLogLogitFullChoiceSet.cc",
             "src/bioExprLinearUtility.cc",
             "src/bioExpression.cc",
             "src/bioSeveralExpressions.cc",
             "src/bioExceptions.cc",
             "src/bioDerivatives.cc",
+            "src/bioVectorOfDerivatives.cc",
             "src/bioGaussHermite.cc",
             "src/bioGhFunction.cc"
         ]
     },
-    "module_name": "biogeme.cbiogeme"
+    "module_name": "biogeme"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
 #define PY_SSIZE_T_CLEAN
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_24"
-#define CYTHON_HEX_VERSION 0x001D18F0
-#define CYTHON_FUTURE_DIVISION 1
+#define CYTHON_ABI "0_29_30"
+#define CYTHON_HEX_VERSION 0x001D1EF0
+#define CYTHON_FUTURE_DIVISION 0
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
     #define __stdcall
@@ -170,14 +161,17 @@
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC (PYPY_VERSION_HEX >= 0x07030900)
+  #endif
 #elif defined(PYSTON_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_PYSTON 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
@@ -211,14 +205,17 @@
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
+  #endif
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
@@ -242,53 +239,64 @@
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
-  #if PY_VERSION_HEX < 0x030300F0
+  #if PY_VERSION_HEX < 0x030300F0 || PY_VERSION_HEX >= 0x030B00A2
     #undef CYTHON_USE_UNICODE_WRITER
     #define CYTHON_USE_UNICODE_WRITER 0
   #elif !defined(CYTHON_USE_UNICODE_WRITER)
     #define CYTHON_USE_UNICODE_WRITER 1
   #endif
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
-  #ifndef CYTHON_FAST_THREAD_STATE
+  #if PY_VERSION_HEX >= 0x030B00A4
+    #undef CYTHON_FAST_THREAD_STATE
+    #define CYTHON_FAST_THREAD_STATE 0
+  #elif !defined(CYTHON_FAST_THREAD_STATE)
     #define CYTHON_FAST_THREAD_STATE 1
   #endif
   #ifndef CYTHON_FAST_PYCALL
-    #define CYTHON_FAST_PYCALL 1
+    #define CYTHON_FAST_PYCALL (PY_VERSION_HEX < 0x030A0000)
   #endif
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
     #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
   #endif
-  #ifndef CYTHON_USE_EXC_INFO_STACK
+  #if PY_VERSION_HEX >= 0x030B00A4
+    #undef CYTHON_USE_EXC_INFO_STACK
+    #define CYTHON_USE_EXC_INFO_STACK 0
+  #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+  #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
 #if CYTHON_USE_PYLONG_INTERNALS
-  #include "longintrepr.h"
+  #if PY_MAJOR_VERSION < 3
+    #include "longintrepr.h"
+  #endif
   #undef SHIFT
   #undef BASE
   #undef MASK
   #ifdef SIZEOF_VOID_P
     enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
   #endif
 #endif
@@ -411,17 +419,76 @@
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
   #define __Pyx_DefaultClassType PyClass_Type
 #else
   #define __Pyx_BUILTIN_MODULE_NAME "builtins"
-#if PY_VERSION_HEX >= 0x030800A4 && PY_VERSION_HEX < 0x030800B2
-  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
-          PyCode_New(a, 0, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
+  #define __Pyx_DefaultClassType PyType_Type
+#if PY_VERSION_HEX >= 0x030B00A1
+    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int k, int l, int s, int f,
+                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
+                                                    PyObject *fv, PyObject *cell, PyObject* fn,
+                                                    PyObject *name, int fline, PyObject *lnos) {
+        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
+        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *call_result=NULL, *empty=NULL;
+        const char *fn_cstr=NULL;
+        const char *name_cstr=NULL;
+        PyCodeObject* co=NULL;
+        PyObject *type, *value, *traceback;
+        PyErr_Fetch(&type, &value, &traceback);
+        if (!(kwds=PyDict_New())) goto end;
+        if (!(argcount=PyLong_FromLong(a))) goto end;
+        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
+        if (!(posonlyargcount=PyLong_FromLong(0))) goto end;
+        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
+        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
+        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
+        if (!(nlocals=PyLong_FromLong(l))) goto end;
+        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
+        if (!(stacksize=PyLong_FromLong(s))) goto end;
+        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
+        if (!(flags=PyLong_FromLong(f))) goto end;
+        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
+        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
+        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
+        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
+        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
+        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto cleanup_code_too;
+        if (!(empty = PyTuple_New(0))) goto cleanup_code_too; // unfortunately __pyx_empty_tuple isn't available here
+        if (!(call_result = PyObject_Call(replace, empty, kwds))) goto cleanup_code_too;
+        Py_XDECREF((PyObject*)co);
+        co = (PyCodeObject*)call_result;
+        call_result = NULL;
+        if (0) {
+            cleanup_code_too:
+            Py_XDECREF((PyObject*)co);
+            co = NULL;
+        }
+        end:
+        Py_XDECREF(kwds);
+        Py_XDECREF(argcount);
+        Py_XDECREF(posonlyargcount);
+        Py_XDECREF(kwonlyargcount);
+        Py_XDECREF(nlocals);
+        Py_XDECREF(stacksize);
+        Py_XDECREF(replace);
+        Py_XDECREF(call_result);
+        Py_XDECREF(empty);
+        if (type) {
+            PyErr_Restore(type, value, traceback);
+        }
+        return co;
+    }
 #else
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #endif
   #define __Pyx_DefaultClassType PyType_Type
 #endif
 #ifndef Py_TPFLAGS_CHECKTYPES
@@ -651,18 +718,18 @@
   #ifndef PyUnicode_InternFromString
     #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
   #endif
 #endif
 #if PY_VERSION_HEX < 0x030200A4
   typedef long Py_hash_t;
   #define __Pyx_PyInt_FromHash_t PyInt_FromLong
-  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
+  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
 #else
   #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
-  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
+  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
 #else
   #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
 #endif
 #if CYTHON_USE_ASYNC_SLOTS
@@ -679,16 +746,18 @@
     typedef struct {
         unaryfunc am_await;
         unaryfunc am_aiter;
         unaryfunc am_anext;
     } __Pyx_PyAsyncMethodsStruct;
 #endif
 
-#if defined(WIN32) || defined(MS_WINDOWS)
-  #define _USE_MATH_DEFINES
+#if defined(_WIN32) || defined(WIN32) || defined(MS_WINDOWS)
+  #if !defined(_USE_MATH_DEFINES)
+    #define _USE_MATH_DEFINES
+  #endif
 #endif
 #include <math.h>
 #ifdef NAN
 #define __PYX_NAN() ((float) NAN)
 #else
 static CYTHON_INLINE float __PYX_NAN() {
   float value;
@@ -711,16 +780,16 @@
   #ifdef __cplusplus
     #define __PYX_EXTERN_C extern "C"
   #else
     #define __PYX_EXTERN_C extern
   #endif
 #endif
 
-#define __PYX_HAVE__biogeme__cbiogeme
-#define __PYX_HAVE_API__biogeme__cbiogeme
+#define __PYX_HAVE__src__cbiogeme
+#define __PYX_HAVE_API__src__cbiogeme
 /* Early includes */
 #include <string.h>
 #include <stdio.h>
 #include "numpy/arrayobject.h"
 #include "numpy/ndarrayobject.h"
 #include "numpy/ndarraytypes.h"
 #include "numpy/arrayscalars.h"
@@ -830,14 +899,15 @@
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
 #define __Pyx_PySequence_Tuple(obj)\
     (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
 static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject*);
 #if CYTHON_ASSUME_SAFE_MACROS
 #define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
 #else
 #define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
 #endif
 #define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
 #if PY_MAJOR_VERSION >= 3
@@ -964,16 +1034,16 @@
 #if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)
   #undef _Complex_I
   #define _Complex_I 1.0fj
 #endif
 
 
 static const char *__pyx_f[] = {
-  "src/cbiogeme.pyx",
   "stringsource",
+  "src/cbiogeme.pyx",
   "__init__.pxd",
   "type.pxd",
 };
 /* MemviewSliceStruct.proto */
 struct __pyx_memoryview_obj;
 typedef struct {
   struct __pyx_memoryview_obj *memview;
@@ -1078,195 +1148,195 @@
   char enc_type;
   char new_packmode;
   char enc_packmode;
   char is_valid_array;
 } __Pyx_BufFmt_Context;
 
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":690
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":689
  * # in Cython to enable them only on the right systems.
  * 
  * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  */
 typedef npy_int8 __pyx_t_5numpy_int8_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":691
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":690
  * 
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t
  */
 typedef npy_int16 __pyx_t_5numpy_int16_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":692
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":691
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int64      int64_t
  * #ctypedef npy_int96      int96_t
  */
 typedef npy_int32 __pyx_t_5numpy_int32_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":693
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":692
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_int96      int96_t
  * #ctypedef npy_int128     int128_t
  */
 typedef npy_int64 __pyx_t_5numpy_int64_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":697
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":696
  * #ctypedef npy_int128     int128_t
  * 
  * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  */
 typedef npy_uint8 __pyx_t_5numpy_uint8_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":698
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":697
  * 
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t
  */
 typedef npy_uint16 __pyx_t_5numpy_uint16_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":699
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":698
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint64     uint64_t
  * #ctypedef npy_uint96     uint96_t
  */
 typedef npy_uint32 __pyx_t_5numpy_uint32_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":700
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":699
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_uint96     uint96_t
  * #ctypedef npy_uint128    uint128_t
  */
 typedef npy_uint64 __pyx_t_5numpy_uint64_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":704
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":703
  * #ctypedef npy_uint128    uint128_t
  * 
  * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_float64    float64_t
  * #ctypedef npy_float80    float80_t
  */
 typedef npy_float32 __pyx_t_5numpy_float32_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":705
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":704
  * 
  * ctypedef npy_float32    float32_t
  * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_float80    float80_t
  * #ctypedef npy_float128   float128_t
  */
 typedef npy_float64 __pyx_t_5numpy_float64_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":714
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":713
  * # The int types are mapped a bit surprising --
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t
  */
 typedef npy_long __pyx_t_5numpy_int_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":715
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":714
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   longlong_t
  * 
  */
 typedef npy_longlong __pyx_t_5numpy_long_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":716
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":715
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_ulong      uint_t
  */
 typedef npy_longlong __pyx_t_5numpy_longlong_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":718
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":717
  * ctypedef npy_longlong   longlong_t
  * 
  * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t
  */
 typedef npy_ulong __pyx_t_5numpy_uint_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":719
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":718
  * 
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulong_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":720
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":719
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_intp       intp_t
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":722
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":721
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uintp      uintp_t
  * 
  */
 typedef npy_intp __pyx_t_5numpy_intp_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":723
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":722
  * 
  * ctypedef npy_intp       intp_t
  * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_double     float_t
  */
 typedef npy_uintp __pyx_t_5numpy_uintp_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":725
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":724
  * ctypedef npy_uintp      uintp_t
  * 
  * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t
  */
 typedef npy_double __pyx_t_5numpy_float_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":726
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":725
  * 
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longdouble longdouble_t
  * 
  */
 typedef npy_double __pyx_t_5numpy_double_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":727
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":726
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cfloat      cfloat_t
  */
 typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
@@ -1292,48 +1362,48 @@
 #else
     typedef struct { double real, imag; } __pyx_t_double_complex;
 #endif
 static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double, double);
 
 
 /*--- Type declarations ---*/
-struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme;
+struct __pyx_obj_3src_8cbiogeme_pyBiogeme;
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":729
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":728
  * ctypedef npy_longdouble longdouble_t
  * 
  * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t
  */
 typedef npy_cfloat __pyx_t_5numpy_cfloat_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":730
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":729
  * 
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
  * ctypedef npy_clongdouble clongdouble_t
  * 
  */
 typedef npy_cdouble __pyx_t_5numpy_cdouble_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":731
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":730
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cdouble     complex_t
  */
 typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":733
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":732
  * ctypedef npy_clongdouble clongdouble_t
  * 
  * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  */
 typedef npy_cdouble __pyx_t_5numpy_complex_t;
@@ -1341,105 +1411,105 @@
 /* "src/cbiogeme.pyx":10
  * from libcpp cimport bool as bool_t
  * 
  * ctypedef vector[unsigned long] uint_vector             # <<<<<<<<<<<<<<
  * ctypedef vector[uint_vector] uint_matrix
  * ctypedef vector[double] double_vector
  */
-typedef std::vector<unsigned long>  __pyx_t_7biogeme_8cbiogeme_uint_vector;
+typedef std::vector<unsigned long>  __pyx_t_3src_8cbiogeme_uint_vector;
 
 /* "src/cbiogeme.pyx":11
  * 
  * ctypedef vector[unsigned long] uint_vector
  * ctypedef vector[uint_vector] uint_matrix             # <<<<<<<<<<<<<<
  * ctypedef vector[double] double_vector
  * ctypedef vector[double_vector] double_matrix
  */
-typedef std::vector<__pyx_t_7biogeme_8cbiogeme_uint_vector>  __pyx_t_7biogeme_8cbiogeme_uint_matrix;
+typedef std::vector<__pyx_t_3src_8cbiogeme_uint_vector>  __pyx_t_3src_8cbiogeme_uint_matrix;
 
 /* "src/cbiogeme.pyx":12
  * ctypedef vector[unsigned long] uint_vector
  * ctypedef vector[uint_vector] uint_matrix
  * ctypedef vector[double] double_vector             # <<<<<<<<<<<<<<
  * ctypedef vector[double_vector] double_matrix
  * ctypedef vector[double_matrix] double_tensor
  */
-typedef std::vector<double>  __pyx_t_7biogeme_8cbiogeme_double_vector;
+typedef std::vector<double>  __pyx_t_3src_8cbiogeme_double_vector;
 
 /* "src/cbiogeme.pyx":13
  * ctypedef vector[uint_vector] uint_matrix
  * ctypedef vector[double] double_vector
  * ctypedef vector[double_vector] double_matrix             # <<<<<<<<<<<<<<
  * ctypedef vector[double_matrix] double_tensor
  * ctypedef vector[string] string_vector
  */
-typedef std::vector<__pyx_t_7biogeme_8cbiogeme_double_vector>  __pyx_t_7biogeme_8cbiogeme_double_matrix;
+typedef std::vector<__pyx_t_3src_8cbiogeme_double_vector>  __pyx_t_3src_8cbiogeme_double_matrix;
 
 /* "src/cbiogeme.pyx":14
  * ctypedef vector[double] double_vector
  * ctypedef vector[double_vector] double_matrix
  * ctypedef vector[double_matrix] double_tensor             # <<<<<<<<<<<<<<
  * ctypedef vector[string] string_vector
  * 
  */
-typedef std::vector<__pyx_t_7biogeme_8cbiogeme_double_matrix>  __pyx_t_7biogeme_8cbiogeme_double_tensor;
+typedef std::vector<__pyx_t_3src_8cbiogeme_double_matrix>  __pyx_t_3src_8cbiogeme_double_tensor;
 
 /* "src/cbiogeme.pyx":15
  * ctypedef vector[double_vector] double_matrix
  * ctypedef vector[double_matrix] double_tensor
  * ctypedef vector[string] string_vector             # <<<<<<<<<<<<<<
  * 
  * ctypedef int[::1] uint_vector_view
  */
-typedef std::vector<std::string>  __pyx_t_7biogeme_8cbiogeme_string_vector;
+typedef std::vector<std::string>  __pyx_t_3src_8cbiogeme_string_vector;
 
 /* "src/cbiogeme.pyx":17
  * ctypedef vector[string] string_vector
  * 
  * ctypedef int[::1] uint_vector_view             # <<<<<<<<<<<<<<
  * ctypedef int[:, ::1] uint_matrix_view
  * ctypedef double[::1] double_vector_view
  */
-typedef __Pyx_memviewslice __pyx_t_7biogeme_8cbiogeme_uint_vector_view;
+typedef __Pyx_memviewslice __pyx_t_3src_8cbiogeme_uint_vector_view;
 
 /* "src/cbiogeme.pyx":18
  * 
  * ctypedef int[::1] uint_vector_view
  * ctypedef int[:, ::1] uint_matrix_view             # <<<<<<<<<<<<<<
  * ctypedef double[::1] double_vector_view
  * ctypedef double[:, ::1] double_matrix_view
  */
-typedef __Pyx_memviewslice __pyx_t_7biogeme_8cbiogeme_uint_matrix_view;
+typedef __Pyx_memviewslice __pyx_t_3src_8cbiogeme_uint_matrix_view;
 
 /* "src/cbiogeme.pyx":19
  * ctypedef int[::1] uint_vector_view
  * ctypedef int[:, ::1] uint_matrix_view
  * ctypedef double[::1] double_vector_view             # <<<<<<<<<<<<<<
  * ctypedef double[:, ::1] double_matrix_view
  * 
  */
-typedef __Pyx_memviewslice __pyx_t_7biogeme_8cbiogeme_double_vector_view;
+typedef __Pyx_memviewslice __pyx_t_3src_8cbiogeme_double_vector_view;
 
 /* "src/cbiogeme.pyx":20
  * ctypedef int[:, ::1] uint_matrix_view
  * ctypedef double[::1] double_vector_view
  * ctypedef double[:, ::1] double_matrix_view             # <<<<<<<<<<<<<<
  * 
  * 
  */
-typedef __Pyx_memviewslice __pyx_t_7biogeme_8cbiogeme_double_matrix_view;
+typedef __Pyx_memviewslice __pyx_t_3src_8cbiogeme_double_matrix_view;
 
-/* "src/cbiogeme.pyx":70
+/* "src/cbiogeme.pyx":79
  * 
  * 
  * cdef class pyBiogeme:             # <<<<<<<<<<<<<<
  * 	cdef biogeme theBiogeme
  * 
  */
-struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme {
+struct __pyx_obj_3src_8cbiogeme_pyBiogeme {
   PyObject_HEAD
   biogeme theBiogeme;
 };
 
 
 /* "View.MemoryView":105
  * 
@@ -1662,21 +1732,14 @@
     (likely(PyDict_CheckExact(obj)) ?\
      __Pyx_PyDict_GetItem(obj, name) : PyObject_GetItem(obj, name))
 #else
 #define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
 #define __Pyx_PyObject_Dict_GetItem(obj, name)  PyObject_GetItem(obj, name)
 #endif
 
-/* PyObjectCall.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
-#else
-#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
-#endif
-
 /* PyDictVersioning.proto */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 #define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
 #define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
     (version_var) = __PYX_GET_DICT_VERSION(dict);\
     (cache_var) = (value);
@@ -1737,21 +1800,36 @@
 #define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
 #endif
 #define __Pyx_BUILD_ASSERT_EXPR(cond)\
     (sizeof(char [1 - 2*!(cond)]) - 1)
 #ifndef Py_MEMBER_SIZE
 #define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
 #endif
+#if CYTHON_FAST_PYCALL
   static size_t __pyx_pyframe_localsplus_offset = 0;
   #include "frameobject.h"
+#if PY_VERSION_HEX >= 0x030b00a6
+  #ifndef Py_BUILD_CORE
+    #define Py_BUILD_CORE 1
+  #endif
+  #include "internal/pycore_frame.h"
+#endif
   #define __Pxy_PyFrame_Initialize_Offsets()\
     ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
      (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
   #define __Pyx_PyFrame_GetLocalsplus(frame)\
     (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
+#endif // CYTHON_FAST_PYCALL
+#endif
+
+/* PyObjectCall.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
+#else
+#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
 #endif
 
 /* PyObjectCall2Args.proto */
 static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
 
 /* PyObjectCallMethO.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
@@ -1901,15 +1979,15 @@
 /* StrEquals.proto */
 #if PY_MAJOR_VERSION >= 3
 #define __Pyx_PyString_Equals __Pyx_PyUnicode_Equals
 #else
 #define __Pyx_PyString_Equals __Pyx_PyBytes_Equals
 #endif
 
-/* None.proto */
+/* DivInt[Py_ssize_t].proto */
 static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t, Py_ssize_t);
 
 /* UnaryNegOverflows.proto */
 #define UNARY_NEG_WOULD_OVERFLOW(x)\
         (((x) < 0) & ((unsigned long)(x) == 0-(unsigned long)(x)))
 
 static CYTHON_UNUSED int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
@@ -2038,17 +2116,23 @@
 #else
 #define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
 #endif
 
 /* None.proto */
 static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);
 
-/* None.proto */
+/* DivInt[long].proto */
 static CYTHON_INLINE long __Pyx_div_long(long, long);
 
+/* PySequenceContains.proto */
+static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
+    int result = PySequence_Contains(seq, item);
+    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
+}
+
 /* ImportFrom.proto */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
 
 /* HasAttr.proto */
 static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
 
 /* PyObject_GenericGetAttrNoDict.proto */
@@ -2186,14 +2270,21 @@
   catch (...)
   {
     PyErr_SetString(PyExc_RuntimeError, "Unknown exception");
   }
 }
 #endif
 
+/* Print.proto */
+static int __Pyx_Print(PyObject*, PyObject *, int);
+#if CYTHON_COMPILING_IN_PYPY || PY_MAJOR_VERSION >= 3
+static PyObject* __pyx_print = 0;
+static PyObject* __pyx_print_kwargs = 0;
+#endif
+
 /* IsLittleEndian.proto */
 static CYTHON_INLINE int __Pyx_Is_Little_Endian(void);
 
 /* BufferFormatCheck.proto */
 static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts);
 static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
                               __Pyx_BufFmt_StackElem* stack,
@@ -2325,14 +2416,17 @@
 /* MemviewSliceCopyTemplate.proto */
 static __Pyx_memviewslice
 __pyx_memoryview_copy_new_contig(const __Pyx_memviewslice *from_mvs,
                                  const char *mode, int ndim,
                                  size_t sizeof_dtype, int contig_flag,
                                  int dtype_is_object);
 
+/* PrintOne.proto */
+static int __Pyx_PrintOne(PyObject* stream, PyObject *o);
+
 /* CIntFromPy.proto */
 static CYTHON_INLINE unsigned long __Pyx_PyInt_As_unsigned_long(PyObject *);
 
 /* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
 
 /* CIntFromPy.proto */
@@ -2404,16 +2498,16 @@
 
 /* Module declarations from 'libcpp.vector' */
 
 /* Module declarations from 'libcpp.string' */
 
 /* Module declarations from 'libcpp' */
 
-/* Module declarations from 'biogeme.cbiogeme' */
-static PyTypeObject *__pyx_ptype_7biogeme_8cbiogeme_pyBiogeme = 0;
+/* Module declarations from 'src.cbiogeme' */
+static PyTypeObject *__pyx_ptype_3src_8cbiogeme_pyBiogeme = 0;
 static PyTypeObject *__pyx_array_type = 0;
 static PyTypeObject *__pyx_MemviewEnum_type = 0;
 static PyTypeObject *__pyx_memoryview_type = 0;
 static PyTypeObject *__pyx_memoryviewslice_type = 0;
 static PyObject *generic = 0;
 static PyObject *strided = 0;
 static PyObject *indirect = 0;
@@ -2421,18 +2515,18 @@
 static PyObject *indirect_contiguous = 0;
 static int __pyx_memoryview_thread_locks_used;
 static PyThread_type_lock __pyx_memoryview_thread_locks[8];
 static std::vector<double>  __pyx_convert_vector_from_py_double(PyObject *); /*proto*/
 static std::vector<unsigned long>  __pyx_convert_vector_from_py_unsigned_long(PyObject *); /*proto*/
 static std::string __pyx_convert_string_from_py_std__in_string(PyObject *); /*proto*/
 static std::vector<std::string>  __pyx_convert_vector_from_py_std_3a__3a_string(PyObject *); /*proto*/
-static std::vector<__pyx_t_7biogeme_8cbiogeme_double_vector>  __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector(PyObject *); /*proto*/
-static std::vector<__pyx_t_7biogeme_8cbiogeme_string_vector>  __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_string_vector(PyObject *); /*proto*/
-static std::vector<__pyx_t_7biogeme_8cbiogeme_uint_vector>  __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_uint_vector(PyObject *); /*proto*/
-static std::vector<__pyx_t_7biogeme_8cbiogeme_double_matrix>  __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_matrix(PyObject *); /*proto*/
+static std::vector<__pyx_t_3src_8cbiogeme_double_vector>  __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector(PyObject *); /*proto*/
+static std::vector<__pyx_t_3src_8cbiogeme_string_vector>  __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_string_vector(PyObject *); /*proto*/
+static std::vector<__pyx_t_3src_8cbiogeme_uint_vector>  __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_uint_vector(PyObject *); /*proto*/
+static std::vector<__pyx_t_3src_8cbiogeme_double_matrix>  __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_matrix(PyObject *); /*proto*/
 static struct __pyx_array_obj *__pyx_array_new(PyObject *, Py_ssize_t, char *, char *, char *); /*proto*/
 static void *__pyx_align_pointer(void *, size_t); /*proto*/
 static PyObject *__pyx_memoryview_new(PyObject *, int, int, __Pyx_TypeInfo *); /*proto*/
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *); /*proto*/
 static PyObject *_unellipsify(PyObject *, int); /*proto*/
 static PyObject *assert_direct_dimensions(Py_ssize_t *, int); /*proto*/
 static struct __pyx_memoryview_obj *__pyx_memview_slice(struct __pyx_memoryview_obj *, PyObject *); /*proto*/
@@ -2459,20 +2553,19 @@
 static void __pyx_memoryview_refcount_copying(__Pyx_memviewslice *, int, int, int); /*proto*/
 static void __pyx_memoryview_refcount_objects_in_slice_with_gil(char *, Py_ssize_t *, Py_ssize_t *, int, int); /*proto*/
 static void __pyx_memoryview_refcount_objects_in_slice(char *, Py_ssize_t *, Py_ssize_t *, int, int); /*proto*/
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *, int, size_t, void *, int); /*proto*/
 static void __pyx_memoryview__slice_assign_scalar(char *, Py_ssize_t *, Py_ssize_t *, int, size_t, void *); /*proto*/
 static PyObject *__pyx_unpickle_Enum__set_state(struct __pyx_MemviewEnum_obj *, PyObject *); /*proto*/
 static __Pyx_TypeInfo __Pyx_TypeInfo_double = { "double", NULL, sizeof(double), { 0 }, 0, 'R', 0, 0 };
-#define __Pyx_MODULE_NAME "biogeme.cbiogeme"
-extern int __pyx_module_is_main_biogeme__cbiogeme;
-int __pyx_module_is_main_biogeme__cbiogeme = 0;
+#define __Pyx_MODULE_NAME "src.cbiogeme"
+extern int __pyx_module_is_main_src__cbiogeme;
+int __pyx_module_is_main_src__cbiogeme = 0;
 
-/* Implementation of 'biogeme.cbiogeme' */
-static PyObject *__pyx_builtin_print;
+/* Implementation of 'src.cbiogeme' */
 static PyObject *__pyx_builtin_TypeError;
 static PyObject *__pyx_builtin_ImportError;
 static PyObject *__pyx_builtin_ValueError;
 static PyObject *__pyx_builtin_MemoryError;
 static PyObject *__pyx_builtin_enumerate;
 static PyObject *__pyx_builtin_range;
 static PyObject *__pyx_builtin_Ellipsis;
@@ -2481,20 +2574,22 @@
 static const char __pyx_k_O[] = "O";
 static const char __pyx_k_c[] = "c";
 static const char __pyx_k_d[] = "d";
 static const char __pyx_k_id[] = "id";
 static const char __pyx_k_lb[] = "lb";
 static const char __pyx_k_np[] = "np";
 static const char __pyx_k_ub[] = "ub";
+static const char __pyx_k_end[] = "end";
 static const char __pyx_k_new[] = "__new__";
 static const char __pyx_k_obj[] = "obj";
 static const char __pyx_k_base[] = "base";
 static const char __pyx_k_bhhh[] = "bhhh";
 static const char __pyx_k_bmem[] = "bmem";
 static const char __pyx_k_dict[] = "__dict__";
+static const char __pyx_k_file[] = "file";
 static const char __pyx_k_gmem[] = "gmem";
 static const char __pyx_k_hmem[] = "hmem";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_mode[] = "mode";
 static const char __pyx_k_name[] = "name";
 static const char __pyx_k_ndim[] = "ndim";
 static const char __pyx_k_pack[] = "pack";
@@ -2529,14 +2624,15 @@
 static const char __pyx_k_formula[] = "formula";
 static const char __pyx_k_fortran[] = "fortran";
 static const char __pyx_k_hessian[] = "hessian";
 static const char __pyx_k_memview[] = "memview";
 static const char __pyx_k_Ellipsis[] = "Ellipsis";
 static const char __pyx_k_formulas[] = "formulas";
 static const char __pyx_k_getstate[] = "__getstate__";
+static const char __pyx_k_gradient[] = "gradient";
 static const char __pyx_k_itemsize[] = "itemsize";
 static const char __pyx_k_nThreads[] = "nThreads";
 static const char __pyx_k_pyx_type[] = "__pyx_type";
 static const char __pyx_k_setstate[] = "__setstate__";
 static const char __pyx_k_TypeError[] = "TypeError";
 static const char __pyx_k_enumerate[] = "enumerate";
 static const char __pyx_k_pyBiogeme[] = "pyBiogeme";
@@ -2583,34 +2679,34 @@
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
 static const char __pyx_k_numpy_core_multiarray_failed_to[] = "numpy.core.multiarray failed to import";
 static const char __pyx_k_Buffer_view_does_not_expose_stri[] = "Buffer view does not expose strides";
 static const char __pyx_k_Can_only_create_a_buffer_that_is[] = "Can only create a buffer that is contiguous in memory.";
 static const char __pyx_k_Cannot_assign_to_read_only_memor[] = "Cannot assign to read-only memoryview";
 static const char __pyx_k_Cannot_create_writable_memory_vi[] = "Cannot create writable memory view from read-only memoryview";
 static const char __pyx_k_Empty_shape_tuple_for_cython_arr[] = "Empty shape tuple for cython.array";
-static const char __pyx_k_Incompatible_checksums_s_vs_0xb0[] = "Incompatible checksums (%s vs 0xb068931 = (name))";
+static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))";
 static const char __pyx_k_Indirect_dimensions_not_supporte[] = "Indirect dimensions not supported";
 static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got %s";
 static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis %d)";
 static const char __pyx_k_Unable_to_convert_item_to_object[] = "Unable to convert item to object";
 static const char __pyx_k_got_differing_extents_in_dimensi[] = "got differing extents in dimension %d (got %d and %d)";
 static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
 static const char __pyx_k_numpy_core_umath_failed_to_impor[] = "numpy.core.umath failed to import";
 static const char __pyx_k_unable_to_allocate_shape_and_str[] = "unable to allocate shape and strides.";
 static PyObject *__pyx_n_s_ASCII;
 static PyObject *__pyx_kp_s_Buffer_view_does_not_expose_stri;
-static PyObject *__pyx_n_u_C_CONTIGUOUS;
+static PyObject *__pyx_n_s_C_CONTIGUOUS;
 static PyObject *__pyx_kp_s_Can_only_create_a_buffer_that_is;
 static PyObject *__pyx_kp_s_Cannot_assign_to_read_only_memor;
 static PyObject *__pyx_kp_s_Cannot_create_writable_memory_vi;
 static PyObject *__pyx_kp_s_Cannot_index_with_type_s;
 static PyObject *__pyx_n_s_Ellipsis;
 static PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
 static PyObject *__pyx_n_s_ImportError;
-static PyObject *__pyx_kp_s_Incompatible_checksums_s_vs_0xb0;
+static PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
 static PyObject *__pyx_n_s_IndexError;
 static PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
 static PyObject *__pyx_kp_s_Invalid_mode_expected_c_or_fortr;
 static PyObject *__pyx_kp_s_Invalid_shape_in_axis_d_d;
 static PyObject *__pyx_n_s_MemoryError;
 static PyObject *__pyx_kp_s_MemoryView_of_r_at_0x_x;
 static PyObject *__pyx_kp_s_MemoryView_of_r_object;
@@ -2624,43 +2720,46 @@
 static PyObject *__pyx_n_s_allocate_buffer;
 static PyObject *__pyx_n_s_ascontiguousarray;
 static PyObject *__pyx_n_s_base;
 static PyObject *__pyx_n_s_betaIds;
 static PyObject *__pyx_n_s_betas;
 static PyObject *__pyx_n_s_bhhh;
 static PyObject *__pyx_n_s_bmem;
-static PyObject *__pyx_kp_u_bmem_not_contiguous;
+static PyObject *__pyx_kp_s_bmem_not_contiguous;
 static PyObject *__pyx_n_s_c;
 static PyObject *__pyx_n_u_c;
 static PyObject *__pyx_n_s_class;
 static PyObject *__pyx_n_s_cline_in_traceback;
 static PyObject *__pyx_kp_s_contiguous_and_direct;
 static PyObject *__pyx_kp_s_contiguous_and_indirect;
 static PyObject *__pyx_n_s_d;
 static PyObject *__pyx_n_s_dict;
 static PyObject *__pyx_n_s_draws;
 static PyObject *__pyx_n_s_dtype_is_object;
 static PyObject *__pyx_n_s_empty;
 static PyObject *__pyx_n_s_encode;
+static PyObject *__pyx_n_s_end;
 static PyObject *__pyx_n_s_enumerate;
 static PyObject *__pyx_n_s_error;
+static PyObject *__pyx_n_s_file;
 static PyObject *__pyx_n_s_fixedBetas;
 static PyObject *__pyx_n_s_flags;
 static PyObject *__pyx_n_s_format;
 static PyObject *__pyx_n_s_formula;
 static PyObject *__pyx_n_s_formulas;
 static PyObject *__pyx_n_s_fortran;
 static PyObject *__pyx_n_u_fortran;
 static PyObject *__pyx_n_s_getstate;
 static PyObject *__pyx_n_s_gmem;
-static PyObject *__pyx_kp_u_gmem_not_contiguous;
+static PyObject *__pyx_kp_s_gmem_not_contiguous;
 static PyObject *__pyx_kp_s_got_differing_extents_in_dimensi;
+static PyObject *__pyx_n_s_gradient;
 static PyObject *__pyx_n_s_hessian;
 static PyObject *__pyx_n_s_hmem;
-static PyObject *__pyx_kp_u_hmem_not_contiguous;
+static PyObject *__pyx_kp_s_hmem_not_contiguous;
 static PyObject *__pyx_n_s_id;
 static PyObject *__pyx_n_s_import;
 static PyObject *__pyx_n_s_itemsize;
 static PyObject *__pyx_kp_s_itemsize_0_for_cython_array;
 static PyObject *__pyx_n_s_lb;
 static PyObject *__pyx_n_s_loglikeFormulas;
 static PyObject *__pyx_n_s_main;
@@ -2671,31 +2770,31 @@
 static PyObject *__pyx_n_s_name_2;
 static PyObject *__pyx_n_s_nbrOfThreads;
 static PyObject *__pyx_n_s_ndim;
 static PyObject *__pyx_n_s_new;
 static PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
 static PyObject *__pyx_n_s_np;
 static PyObject *__pyx_n_s_numpy;
-static PyObject *__pyx_kp_u_numpy_core_multiarray_failed_to;
-static PyObject *__pyx_kp_u_numpy_core_umath_failed_to_impor;
+static PyObject *__pyx_kp_s_numpy_core_multiarray_failed_to;
+static PyObject *__pyx_kp_s_numpy_core_umath_failed_to_impor;
 static PyObject *__pyx_n_s_obj;
 static PyObject *__pyx_n_s_pack;
 static PyObject *__pyx_n_s_panel;
 static PyObject *__pyx_n_s_pickle;
 static PyObject *__pyx_n_s_print;
 static PyObject *__pyx_n_s_pyBiogeme;
 static PyObject *__pyx_n_s_pyx_PickleError;
 static PyObject *__pyx_n_s_pyx_checksum;
 static PyObject *__pyx_n_s_pyx_getbuffer;
 static PyObject *__pyx_n_s_pyx_result;
 static PyObject *__pyx_n_s_pyx_state;
 static PyObject *__pyx_n_s_pyx_type;
 static PyObject *__pyx_n_s_pyx_unpickle_Enum;
 static PyObject *__pyx_n_s_pyx_vtable;
-static PyObject *__pyx_kp_u_r_not_contiguous;
+static PyObject *__pyx_kp_s_r_not_contiguous;
 static PyObject *__pyx_n_s_range;
 static PyObject *__pyx_n_s_reduce;
 static PyObject *__pyx_n_s_reduce_cython;
 static PyObject *__pyx_n_s_reduce_ex;
 static PyObject *__pyx_n_s_setstate;
 static PyObject *__pyx_n_s_setstate_cython;
 static PyObject *__pyx_n_s_shape;
@@ -2712,28 +2811,29 @@
 static PyObject *__pyx_n_s_ub;
 static PyObject *__pyx_kp_s_unable_to_allocate_array_data;
 static PyObject *__pyx_kp_s_unable_to_allocate_shape_and_str;
 static PyObject *__pyx_n_s_unpack;
 static PyObject *__pyx_n_s_update;
 static PyObject *__pyx_n_s_weightFormulas;
 static PyObject *__pyx_n_s_zeros;
-static int __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme___cinit__(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_2setPanel(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_panel); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_4calculateLikelihoodAndDerivatives(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_betaIds, PyObject *__pyx_v_gmem, PyObject *__pyx_v_hmem, PyObject *__pyx_v_bmem, PyObject *__pyx_v_hessian, PyObject *__pyx_v_bhhh, CYTHON_UNUSED PyObject *__pyx_v_draws); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_6setBounds(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_lb, PyObject *__pyx_v_ub); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_8calculateLikelihood(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_10simulateFormula(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_formula, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_d); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_12simulateSeveralFormulas(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_formulas, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_d, PyObject *__pyx_v_nThreads); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_14setExpressions(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_loglikeFormulas, PyObject *__pyx_v_nbrOfThreads, PyObject *__pyx_v_weightFormulas); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_16setData(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_d); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_18setDataMap(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_m); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_20setMissingData(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_md); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_22setDraws(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_draws); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_24__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_26__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
+static int __pyx_pf_3src_8cbiogeme_9pyBiogeme___cinit__(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_2setPanel(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_panel); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_4calculateLikelihoodAndDerivatives(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_betaIds, PyObject *__pyx_v_gmem, PyObject *__pyx_v_hmem, PyObject *__pyx_v_bmem, PyObject *__pyx_v_hessian, PyObject *__pyx_v_bhhh, CYTHON_UNUSED PyObject *__pyx_v_draws); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_6setBounds(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_lb, PyObject *__pyx_v_ub); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_8calculateLikelihood(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_10simulateSimpleFormula(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_formula, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_gradient, PyObject *__pyx_v_hessian, PyObject *__pyx_v_gmem, PyObject *__pyx_v_hmem); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_12simulateFormula(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_formula, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_d); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_14simulateSeveralFormulas(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_formulas, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_d, PyObject *__pyx_v_nThreads); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_16setExpressions(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_loglikeFormulas, PyObject *__pyx_v_nbrOfThreads, PyObject *__pyx_v_weightFormulas); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_18setData(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_d); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_20setDataMap(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_m); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_22setMissingData(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_md); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_24setDraws(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_draws); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_26__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_28__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView_5array_7memview___get__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_8__getattr__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_attr); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_10__getitem__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_item); /* proto */
@@ -2768,137 +2868,136 @@
 static PyObject *__pyx_pf___pyx_memoryview___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryview_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static void __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView_16_memoryviewslice_4base___get__(struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryviewslice___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryviewslice_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
-static PyObject *__pyx_tp_new_7biogeme_8cbiogeme_pyBiogeme(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static PyObject *__pyx_tp_new_3src_8cbiogeme_pyBiogeme(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_int_0;
 static PyObject *__pyx_int_1;
+static PyObject *__pyx_int_112105877;
+static PyObject *__pyx_int_136983863;
 static PyObject *__pyx_int_184977713;
 static PyObject *__pyx_int_neg_1;
 static PyObject *__pyx_tuple_;
 static PyObject *__pyx_tuple__2;
 static PyObject *__pyx_tuple__3;
 static PyObject *__pyx_tuple__4;
 static PyObject *__pyx_tuple__5;
 static PyObject *__pyx_tuple__6;
 static PyObject *__pyx_tuple__7;
 static PyObject *__pyx_tuple__8;
 static PyObject *__pyx_tuple__9;
-static PyObject *__pyx_slice__23;
+static PyObject *__pyx_slice__19;
 static PyObject *__pyx_tuple__10;
 static PyObject *__pyx_tuple__11;
 static PyObject *__pyx_tuple__12;
 static PyObject *__pyx_tuple__13;
 static PyObject *__pyx_tuple__14;
 static PyObject *__pyx_tuple__15;
 static PyObject *__pyx_tuple__16;
 static PyObject *__pyx_tuple__17;
 static PyObject *__pyx_tuple__18;
-static PyObject *__pyx_tuple__19;
 static PyObject *__pyx_tuple__20;
 static PyObject *__pyx_tuple__21;
 static PyObject *__pyx_tuple__22;
+static PyObject *__pyx_tuple__23;
 static PyObject *__pyx_tuple__24;
 static PyObject *__pyx_tuple__25;
 static PyObject *__pyx_tuple__26;
 static PyObject *__pyx_tuple__27;
 static PyObject *__pyx_tuple__28;
 static PyObject *__pyx_tuple__29;
-static PyObject *__pyx_tuple__30;
-static PyObject *__pyx_tuple__31;
-static PyObject *__pyx_tuple__32;
-static PyObject *__pyx_codeobj__33;
+static PyObject *__pyx_codeobj__30;
 /* Late includes */
 
-/* "src/cbiogeme.pyx":73
+/* "src/cbiogeme.pyx":82
  * 	cdef biogeme theBiogeme
  * 
  * 	def __cinit__(self):             # <<<<<<<<<<<<<<
  * 		self.theBiogeme = biogeme()
  * 
  */
 
 /* Python wrapper */
-static int __pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static int __pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static int __pyx_pw_3src_8cbiogeme_9pyBiogeme_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_3src_8cbiogeme_9pyBiogeme_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
   if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
     __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
   if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme___cinit__(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self));
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme___cinit__(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static int __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme___cinit__(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self) {
+static int __pyx_pf_3src_8cbiogeme_9pyBiogeme___cinit__(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   biogeme __pyx_t_1;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "src/cbiogeme.pyx":74
+  /* "src/cbiogeme.pyx":83
  * 
  * 	def __cinit__(self):
  * 		self.theBiogeme = biogeme()             # <<<<<<<<<<<<<<
  * 
  * 
  */
   try {
     __pyx_t_1 = biogeme();
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 74, __pyx_L1_error)
+    __PYX_ERR(1, 83, __pyx_L1_error)
   }
   __pyx_v_self->theBiogeme = __pyx_t_1;
 
-  /* "src/cbiogeme.pyx":73
+  /* "src/cbiogeme.pyx":82
  * 	cdef biogeme theBiogeme
  * 
  * 	def __cinit__(self):             # <<<<<<<<<<<<<<
  * 		self.theBiogeme = biogeme()
  * 
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "src/cbiogeme.pyx":77
+/* "src/cbiogeme.pyx":86
  * 
  * 
  * 	def setPanel(self,panel=True):             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.setPanel(panel)
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_3setPanel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_2setPanel[] = "pyBiogeme.setPanel(self, panel=True)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_3setPanel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_3setPanel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_2setPanel[] = "pyBiogeme.setPanel(self, panel=True)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_3setPanel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_panel = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("setPanel (wrapper)", 0);
@@ -2920,92 +3019,92 @@
         case  0:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_panel);
           if (value) { values[0] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setPanel") < 0)) __PYX_ERR(0, 77, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setPanel") < 0)) __PYX_ERR(1, 86, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_panel = values[0];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("setPanel", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 77, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("setPanel", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 86, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.setPanel", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.setPanel", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_2setPanel(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_panel);
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_2setPanel(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_panel);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_2setPanel(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_panel) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_2setPanel(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_panel) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   bool __pyx_t_1;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setPanel", 0);
 
-  /* "src/cbiogeme.pyx":78
+  /* "src/cbiogeme.pyx":87
  * 
  * 	def setPanel(self,panel=True):
  * 		self.theBiogeme.setPanel(panel)             # <<<<<<<<<<<<<<
  * 
  * 	def calculateLikelihoodAndDerivatives(self,
  */
-  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_panel); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 78, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_panel); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(1, 87, __pyx_L1_error)
   __pyx_v_self->theBiogeme.setPanel(__pyx_t_1);
 
-  /* "src/cbiogeme.pyx":77
+  /* "src/cbiogeme.pyx":86
  * 
  * 
  * 	def setPanel(self,panel=True):             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.setPanel(panel)
  * 
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.setPanel", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.setPanel", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "src/cbiogeme.pyx":80
+/* "src/cbiogeme.pyx":89
  * 		self.theBiogeme.setPanel(panel)
  * 
  * 	def calculateLikelihoodAndDerivatives(self,             # <<<<<<<<<<<<<<
  * 	                                      betas,
  * 					      fixedBetas,
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_5calculateLikelihoodAndDerivatives(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_4calculateLikelihoodAndDerivatives[] = "pyBiogeme.calculateLikelihoodAndDerivatives(self, betas, fixedBetas, betaIds, gmem, hmem, bmem, hessian, bhhh, draws=None)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_5calculateLikelihoodAndDerivatives(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_5calculateLikelihoodAndDerivatives(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_4calculateLikelihoodAndDerivatives[] = "pyBiogeme.calculateLikelihoodAndDerivatives(self, betas, fixedBetas, betaIds, gmem, hmem, bmem, hessian, bhhh, draws=None)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_5calculateLikelihoodAndDerivatives(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_betas = 0;
   PyObject *__pyx_v_fixedBetas = 0;
   PyObject *__pyx_v_betaIds = 0;
   PyObject *__pyx_v_gmem = 0;
   PyObject *__pyx_v_hmem = 0;
   PyObject *__pyx_v_bmem = 0;
   PyObject *__pyx_v_hessian = 0;
@@ -3017,15 +3116,15 @@
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("calculateLikelihoodAndDerivatives (wrapper)", 0);
   {
     static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_betas,&__pyx_n_s_fixedBetas,&__pyx_n_s_betaIds,&__pyx_n_s_gmem,&__pyx_n_s_hmem,&__pyx_n_s_bmem,&__pyx_n_s_hessian,&__pyx_n_s_bhhh,&__pyx_n_s_draws,0};
     PyObject* values[9] = {0,0,0,0,0,0,0,0,0};
 
-    /* "src/cbiogeme.pyx":89
+    /* "src/cbiogeme.pyx":98
  * 					      hessian,
  * 					      bhhh,
  * 					      draws=None):             # <<<<<<<<<<<<<<
  * 		n = len(betas)
  * 
  */
     values[8] = ((PyObject *)Py_None);
@@ -3059,61 +3158,61 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_betas)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fixedBetas)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 1); __PYX_ERR(0, 80, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 1); __PYX_ERR(1, 89, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_betaIds)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 2); __PYX_ERR(0, 80, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 2); __PYX_ERR(1, 89, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_gmem)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 3); __PYX_ERR(0, 80, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 3); __PYX_ERR(1, 89, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  4:
         if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_hmem)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 4); __PYX_ERR(0, 80, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 4); __PYX_ERR(1, 89, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  5:
         if (likely((values[5] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bmem)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 5); __PYX_ERR(0, 80, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 5); __PYX_ERR(1, 89, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  6:
         if (likely((values[6] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_hessian)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 6); __PYX_ERR(0, 80, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 6); __PYX_ERR(1, 89, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  7:
         if (likely((values[7] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bhhh)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 7); __PYX_ERR(0, 80, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, 7); __PYX_ERR(1, 89, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  8:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_draws);
           if (value) { values[8] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "calculateLikelihoodAndDerivatives") < 0)) __PYX_ERR(0, 80, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "calculateLikelihoodAndDerivatives") < 0)) __PYX_ERR(1, 89, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
         CYTHON_FALLTHROUGH;
         case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
         values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
@@ -3135,54 +3234,54 @@
     __pyx_v_bmem = values[5];
     __pyx_v_hessian = values[6];
     __pyx_v_bhhh = values[7];
     __pyx_v_draws = values[8];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 80, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("calculateLikelihoodAndDerivatives", 0, 8, 9, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 89, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.calculateLikelihoodAndDerivatives", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.calculateLikelihoodAndDerivatives", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_4calculateLikelihoodAndDerivatives(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_betas, __pyx_v_fixedBetas, __pyx_v_betaIds, __pyx_v_gmem, __pyx_v_hmem, __pyx_v_bmem, __pyx_v_hessian, __pyx_v_bhhh, __pyx_v_draws);
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_4calculateLikelihoodAndDerivatives(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_betas, __pyx_v_fixedBetas, __pyx_v_betaIds, __pyx_v_gmem, __pyx_v_hmem, __pyx_v_bmem, __pyx_v_hessian, __pyx_v_bhhh, __pyx_v_draws);
 
-  /* "src/cbiogeme.pyx":80
+  /* "src/cbiogeme.pyx":89
  * 		self.theBiogeme.setPanel(panel)
  * 
  * 	def calculateLikelihoodAndDerivatives(self,             # <<<<<<<<<<<<<<
  * 	                                      betas,
  * 					      fixedBetas,
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_4calculateLikelihoodAndDerivatives(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_betaIds, PyObject *__pyx_v_gmem, PyObject *__pyx_v_hmem, PyObject *__pyx_v_bmem, PyObject *__pyx_v_hessian, PyObject *__pyx_v_bhhh, CYTHON_UNUSED PyObject *__pyx_v_draws) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_4calculateLikelihoodAndDerivatives(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_betaIds, PyObject *__pyx_v_gmem, PyObject *__pyx_v_hmem, PyObject *__pyx_v_bmem, PyObject *__pyx_v_hessian, PyObject *__pyx_v_bhhh, CYTHON_UNUSED PyObject *__pyx_v_draws) {
   CYTHON_UNUSED Py_ssize_t __pyx_v_n;
-  __pyx_t_7biogeme_8cbiogeme_double_vector_view __pyx_v_gmem_view = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __pyx_t_7biogeme_8cbiogeme_double_matrix_view __pyx_v_hmem_view = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __pyx_t_7biogeme_8cbiogeme_double_matrix_view __pyx_v_bmem_view = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __pyx_t_3src_8cbiogeme_double_vector_view __pyx_v_gmem_view = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __pyx_t_3src_8cbiogeme_double_matrix_view __pyx_v_hmem_view = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __pyx_t_3src_8cbiogeme_double_matrix_view __pyx_v_bmem_view = { 0, 0, { 0 }, { 0 }, { 0 } };
   double __pyx_v_f;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
   int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
-  __pyx_t_7biogeme_8cbiogeme_double_vector_view __pyx_t_7 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __pyx_t_7biogeme_8cbiogeme_double_matrix_view __pyx_t_8 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __pyx_t_7biogeme_8cbiogeme_double_vector __pyx_t_9;
-  __pyx_t_7biogeme_8cbiogeme_double_vector __pyx_t_10;
-  __pyx_t_7biogeme_8cbiogeme_uint_vector __pyx_t_11;
+  __pyx_t_3src_8cbiogeme_double_vector_view __pyx_t_7 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __pyx_t_3src_8cbiogeme_double_matrix_view __pyx_t_8 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_9;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_10;
+  __pyx_t_3src_8cbiogeme_uint_vector __pyx_t_11;
   Py_ssize_t __pyx_t_12;
   int __pyx_t_13;
   Py_ssize_t __pyx_t_14;
   Py_ssize_t __pyx_t_15;
   Py_ssize_t __pyx_t_16;
   Py_ssize_t __pyx_t_17;
   bool __pyx_t_18;
@@ -3192,307 +3291,301 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("calculateLikelihoodAndDerivatives", 0);
   __Pyx_INCREF(__pyx_v_gmem);
   __Pyx_INCREF(__pyx_v_hmem);
   __Pyx_INCREF(__pyx_v_bmem);
 
-  /* "src/cbiogeme.pyx":90
+  /* "src/cbiogeme.pyx":99
  * 					      bhhh,
  * 					      draws=None):
  * 		n = len(betas)             # <<<<<<<<<<<<<<
  * 
  * 		if not gmem.flags['C_CONTIGUOUS']:
  */
-  __pyx_t_1 = PyObject_Length(__pyx_v_betas); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 90, __pyx_L1_error)
+  __pyx_t_1 = PyObject_Length(__pyx_v_betas); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(1, 99, __pyx_L1_error)
   __pyx_v_n = __pyx_t_1;
 
-  /* "src/cbiogeme.pyx":92
+  /* "src/cbiogeme.pyx":101
  * 		n = len(betas)
  * 
  * 		if not gmem.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
  * 			print('gmem not contiguous')
  * 			gmem = np.ascontiguousarray(gmem)
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_gmem, __pyx_n_s_flags); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 92, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_gmem, __pyx_n_s_flags); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 101, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_Dict_GetItem(__pyx_t_2, __pyx_n_u_C_CONTIGUOUS); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 92, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Dict_GetItem(__pyx_t_2, __pyx_n_s_C_CONTIGUOUS); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 101, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 92, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 101, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_5 = ((!__pyx_t_4) != 0);
   if (__pyx_t_5) {
 
-    /* "src/cbiogeme.pyx":93
+    /* "src/cbiogeme.pyx":102
  * 
  * 		if not gmem.flags['C_CONTIGUOUS']:
  * 			print('gmem not contiguous')             # <<<<<<<<<<<<<<
  * 			gmem = np.ascontiguousarray(gmem)
  * 		if not hmem.flags['C_CONTIGUOUS']:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_print, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 93, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (__Pyx_PrintOne(0, __pyx_kp_s_gmem_not_contiguous) < 0) __PYX_ERR(1, 102, __pyx_L1_error)
 
-    /* "src/cbiogeme.pyx":94
+    /* "src/cbiogeme.pyx":103
  * 		if not gmem.flags['C_CONTIGUOUS']:
  * 			print('gmem not contiguous')
  * 			gmem = np.ascontiguousarray(gmem)             # <<<<<<<<<<<<<<
  * 		if not hmem.flags['C_CONTIGUOUS']:
  * 			print('hmem not contiguous')
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 94, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 103, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 94, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 103, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_2 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
       __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_6);
       if (likely(__pyx_t_2)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
         __Pyx_INCREF(__pyx_t_2);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_6, function);
       }
     }
     __pyx_t_3 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_2, __pyx_v_gmem) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_gmem);
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 94, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 103, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_DECREF_SET(__pyx_v_gmem, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "src/cbiogeme.pyx":92
+    /* "src/cbiogeme.pyx":101
  * 		n = len(betas)
  * 
  * 		if not gmem.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
  * 			print('gmem not contiguous')
  * 			gmem = np.ascontiguousarray(gmem)
  */
   }
 
-  /* "src/cbiogeme.pyx":95
+  /* "src/cbiogeme.pyx":104
  * 			print('gmem not contiguous')
  * 			gmem = np.ascontiguousarray(gmem)
  * 		if not hmem.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
  * 			print('hmem not contiguous')
  * 			hmem = np.ascontiguousarray(hmem)
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_hmem, __pyx_n_s_flags); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 95, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_hmem, __pyx_n_s_flags); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 104, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_6 = __Pyx_PyObject_Dict_GetItem(__pyx_t_3, __pyx_n_u_C_CONTIGUOUS); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 95, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_Dict_GetItem(__pyx_t_3, __pyx_n_s_C_CONTIGUOUS); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 104, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 95, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(1, 104, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __pyx_t_4 = ((!__pyx_t_5) != 0);
   if (__pyx_t_4) {
 
-    /* "src/cbiogeme.pyx":96
+    /* "src/cbiogeme.pyx":105
  * 			gmem = np.ascontiguousarray(gmem)
  * 		if not hmem.flags['C_CONTIGUOUS']:
  * 			print('hmem not contiguous')             # <<<<<<<<<<<<<<
  * 			hmem = np.ascontiguousarray(hmem)
  * 		if not bmem.flags['C_CONTIGUOUS']:
  */
-    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_print, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 96, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (__Pyx_PrintOne(0, __pyx_kp_s_hmem_not_contiguous) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
 
-    /* "src/cbiogeme.pyx":97
+    /* "src/cbiogeme.pyx":106
  * 		if not hmem.flags['C_CONTIGUOUS']:
  * 			print('hmem not contiguous')
  * 			hmem = np.ascontiguousarray(hmem)             # <<<<<<<<<<<<<<
  * 		if not bmem.flags['C_CONTIGUOUS']:
  * 			print('bmem not contiguous')
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 97, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 106, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 97, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 106, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_3 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
         __Pyx_INCREF(__pyx_t_3);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_2, function);
       }
     }
     __pyx_t_6 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_hmem) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_hmem);
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 97, __pyx_L1_error)
+    if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 106, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF_SET(__pyx_v_hmem, __pyx_t_6);
     __pyx_t_6 = 0;
 
-    /* "src/cbiogeme.pyx":95
+    /* "src/cbiogeme.pyx":104
  * 			print('gmem not contiguous')
  * 			gmem = np.ascontiguousarray(gmem)
  * 		if not hmem.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
  * 			print('hmem not contiguous')
  * 			hmem = np.ascontiguousarray(hmem)
  */
   }
 
-  /* "src/cbiogeme.pyx":98
+  /* "src/cbiogeme.pyx":107
  * 			print('hmem not contiguous')
  * 			hmem = np.ascontiguousarray(hmem)
  * 		if not bmem.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
  * 			print('bmem not contiguous')
  * 			bmem = np.ascontiguousarray(bmem)
  */
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_bmem, __pyx_n_s_flags); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 98, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_bmem, __pyx_n_s_flags); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 107, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_2 = __Pyx_PyObject_Dict_GetItem(__pyx_t_6, __pyx_n_u_C_CONTIGUOUS); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 98, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Dict_GetItem(__pyx_t_6, __pyx_n_s_C_CONTIGUOUS); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 107, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 98, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 107, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_5 = ((!__pyx_t_4) != 0);
   if (__pyx_t_5) {
 
-    /* "src/cbiogeme.pyx":99
+    /* "src/cbiogeme.pyx":108
  * 			hmem = np.ascontiguousarray(hmem)
  * 		if not bmem.flags['C_CONTIGUOUS']:
  * 			print('bmem not contiguous')             # <<<<<<<<<<<<<<
  * 			bmem = np.ascontiguousarray(bmem)
  * 
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_print, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 99, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (__Pyx_PrintOne(0, __pyx_kp_s_bmem_not_contiguous) < 0) __PYX_ERR(1, 108, __pyx_L1_error)
 
-    /* "src/cbiogeme.pyx":100
+    /* "src/cbiogeme.pyx":109
  * 		if not bmem.flags['C_CONTIGUOUS']:
  * 			print('bmem not contiguous')
  * 			bmem = np.ascontiguousarray(bmem)             # <<<<<<<<<<<<<<
  * 
  * 		cdef double_vector_view gmem_view = gmem
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 100, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 109, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 100, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 109, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __pyx_t_6 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_v_bmem) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_bmem);
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 100, __pyx_L1_error)
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 109, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF_SET(__pyx_v_bmem, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "src/cbiogeme.pyx":98
+    /* "src/cbiogeme.pyx":107
  * 			print('hmem not contiguous')
  * 			hmem = np.ascontiguousarray(hmem)
  * 		if not bmem.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
  * 			print('bmem not contiguous')
  * 			bmem = np.ascontiguousarray(bmem)
  */
   }
 
-  /* "src/cbiogeme.pyx":102
+  /* "src/cbiogeme.pyx":111
  * 			bmem = np.ascontiguousarray(bmem)
  * 
  * 		cdef double_vector_view gmem_view = gmem             # <<<<<<<<<<<<<<
  * 		cdef double_matrix_view hmem_view = hmem
  * 		cdef double_matrix_view bmem_view = bmem
  */
-  __pyx_t_7 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_v_gmem, PyBUF_WRITABLE); if (unlikely(!__pyx_t_7.memview)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_v_gmem, PyBUF_WRITABLE); if (unlikely(!__pyx_t_7.memview)) __PYX_ERR(1, 111, __pyx_L1_error)
   __pyx_v_gmem_view = __pyx_t_7;
   __pyx_t_7.memview = NULL;
   __pyx_t_7.data = NULL;
 
-  /* "src/cbiogeme.pyx":103
+  /* "src/cbiogeme.pyx":112
  * 
  * 		cdef double_vector_view gmem_view = gmem
  * 		cdef double_matrix_view hmem_view = hmem             # <<<<<<<<<<<<<<
  * 		cdef double_matrix_view bmem_view = bmem
  * 
  */
-  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_v_hmem, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(0, 103, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_v_hmem, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(1, 112, __pyx_L1_error)
   __pyx_v_hmem_view = __pyx_t_8;
   __pyx_t_8.memview = NULL;
   __pyx_t_8.data = NULL;
 
-  /* "src/cbiogeme.pyx":104
+  /* "src/cbiogeme.pyx":113
  * 		cdef double_vector_view gmem_view = gmem
  * 		cdef double_matrix_view hmem_view = hmem
  * 		cdef double_matrix_view bmem_view = bmem             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_v_bmem, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(0, 104, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_v_bmem, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(1, 113, __pyx_L1_error)
   __pyx_v_bmem_view = __pyx_t_8;
   __pyx_t_8.memview = NULL;
   __pyx_t_8.data = NULL;
 
-  /* "src/cbiogeme.pyx":107
+  /* "src/cbiogeme.pyx":116
  * 
  * 
  * 		f = self.theBiogeme.calculateLikeAndDerivatives(betas,             # <<<<<<<<<<<<<<
  * 			                                        fixedBetas,
  * 								betaIds,
  */
-  __pyx_t_9 = __pyx_convert_vector_from_py_double(__pyx_v_betas); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 107, __pyx_L1_error)
+  __pyx_t_9 = __pyx_convert_vector_from_py_double(__pyx_v_betas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 116, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":108
+  /* "src/cbiogeme.pyx":117
  * 
  * 		f = self.theBiogeme.calculateLikeAndDerivatives(betas,
  * 			                                        fixedBetas,             # <<<<<<<<<<<<<<
  * 								betaIds,
  * 								&gmem_view[0],
  */
-  __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_fixedBetas); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 108, __pyx_L1_error)
+  __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_fixedBetas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 117, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":109
+  /* "src/cbiogeme.pyx":118
  * 		f = self.theBiogeme.calculateLikeAndDerivatives(betas,
  * 			                                        fixedBetas,
  * 								betaIds,             # <<<<<<<<<<<<<<
  * 								&gmem_view[0],
  * 								&hmem_view[0,0],
  */
-  __pyx_t_11 = __pyx_convert_vector_from_py_unsigned_long(__pyx_v_betaIds); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 109, __pyx_L1_error)
+  __pyx_t_11 = __pyx_convert_vector_from_py_unsigned_long(__pyx_v_betaIds); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 118, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":110
+  /* "src/cbiogeme.pyx":119
  * 			                                        fixedBetas,
  * 								betaIds,
  * 								&gmem_view[0],             # <<<<<<<<<<<<<<
  * 								&hmem_view[0,0],
  * 								&bmem_view[0,0],
  */
   __pyx_t_12 = 0;
   __pyx_t_13 = -1;
   if (__pyx_t_12 < 0) {
     __pyx_t_12 += __pyx_v_gmem_view.shape[0];
     if (unlikely(__pyx_t_12 < 0)) __pyx_t_13 = 0;
   } else if (unlikely(__pyx_t_12 >= __pyx_v_gmem_view.shape[0])) __pyx_t_13 = 0;
   if (unlikely(__pyx_t_13 != -1)) {
     __Pyx_RaiseBufferIndexError(__pyx_t_13);
-    __PYX_ERR(0, 110, __pyx_L1_error)
+    __PYX_ERR(1, 119, __pyx_L1_error)
   }
 
-  /* "src/cbiogeme.pyx":111
+  /* "src/cbiogeme.pyx":120
  * 								betaIds,
  * 								&gmem_view[0],
  * 								&hmem_view[0,0],             # <<<<<<<<<<<<<<
  * 								&bmem_view[0,0],
  * 								hessian,
  */
   __pyx_t_14 = 0;
@@ -3504,18 +3597,18 @@
   } else if (unlikely(__pyx_t_14 >= __pyx_v_hmem_view.shape[0])) __pyx_t_13 = 0;
   if (__pyx_t_15 < 0) {
     __pyx_t_15 += __pyx_v_hmem_view.shape[1];
     if (unlikely(__pyx_t_15 < 0)) __pyx_t_13 = 1;
   } else if (unlikely(__pyx_t_15 >= __pyx_v_hmem_view.shape[1])) __pyx_t_13 = 1;
   if (unlikely(__pyx_t_13 != -1)) {
     __Pyx_RaiseBufferIndexError(__pyx_t_13);
-    __PYX_ERR(0, 111, __pyx_L1_error)
+    __PYX_ERR(1, 120, __pyx_L1_error)
   }
 
-  /* "src/cbiogeme.pyx":112
+  /* "src/cbiogeme.pyx":121
  * 								&gmem_view[0],
  * 								&hmem_view[0,0],
  * 								&bmem_view[0,0],             # <<<<<<<<<<<<<<
  * 								hessian,
  * 								bhhh)
  */
   __pyx_t_16 = 0;
@@ -3527,61 +3620,61 @@
   } else if (unlikely(__pyx_t_16 >= __pyx_v_bmem_view.shape[0])) __pyx_t_13 = 0;
   if (__pyx_t_17 < 0) {
     __pyx_t_17 += __pyx_v_bmem_view.shape[1];
     if (unlikely(__pyx_t_17 < 0)) __pyx_t_13 = 1;
   } else if (unlikely(__pyx_t_17 >= __pyx_v_bmem_view.shape[1])) __pyx_t_13 = 1;
   if (unlikely(__pyx_t_13 != -1)) {
     __Pyx_RaiseBufferIndexError(__pyx_t_13);
-    __PYX_ERR(0, 112, __pyx_L1_error)
+    __PYX_ERR(1, 121, __pyx_L1_error)
   }
 
-  /* "src/cbiogeme.pyx":113
+  /* "src/cbiogeme.pyx":122
  * 								&hmem_view[0,0],
  * 								&bmem_view[0,0],
  * 								hessian,             # <<<<<<<<<<<<<<
  * 								bhhh)
  * 		return f, gmem, hmem, bmem
  */
-  __pyx_t_18 = __Pyx_PyObject_IsTrue(__pyx_v_hessian); if (unlikely((__pyx_t_18 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 113, __pyx_L1_error)
+  __pyx_t_18 = __Pyx_PyObject_IsTrue(__pyx_v_hessian); if (unlikely((__pyx_t_18 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(1, 122, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":114
+  /* "src/cbiogeme.pyx":123
  * 								&bmem_view[0,0],
  * 								hessian,
  * 								bhhh)             # <<<<<<<<<<<<<<
  * 		return f, gmem, hmem, bmem
  * 
  */
-  __pyx_t_19 = __Pyx_PyObject_IsTrue(__pyx_v_bhhh); if (unlikely((__pyx_t_19 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 114, __pyx_L1_error)
+  __pyx_t_19 = __Pyx_PyObject_IsTrue(__pyx_v_bhhh); if (unlikely((__pyx_t_19 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(1, 123, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":107
+  /* "src/cbiogeme.pyx":116
  * 
  * 
  * 		f = self.theBiogeme.calculateLikeAndDerivatives(betas,             # <<<<<<<<<<<<<<
  * 			                                        fixedBetas,
  * 								betaIds,
  */
   try {
     __pyx_t_20 = __pyx_v_self->theBiogeme.calculateLikeAndDerivatives(__pyx_t_9, __pyx_t_10, __pyx_t_11, (&(*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_gmem_view.data) + __pyx_t_12)) )))), (&(*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_hmem_view.data + __pyx_t_14 * __pyx_v_hmem_view.strides[0]) )) + __pyx_t_15)) )))), (&(*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_bmem_view.data + __pyx_t_16 * __pyx_v_bmem_view.strides[0]) )) + __pyx_t_17)) )))), __pyx_t_18, __pyx_t_19);
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 107, __pyx_L1_error)
+    __PYX_ERR(1, 116, __pyx_L1_error)
   }
   __pyx_v_f = __pyx_t_20;
 
-  /* "src/cbiogeme.pyx":115
+  /* "src/cbiogeme.pyx":124
  * 								hessian,
  * 								bhhh)
  * 		return f, gmem, hmem, bmem             # <<<<<<<<<<<<<<
  * 
  * 	def setBounds(self,lb,ub):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_f); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 115, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_f); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 124, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 115, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 124, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
   __Pyx_INCREF(__pyx_v_gmem);
   __Pyx_GIVEREF(__pyx_v_gmem);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_gmem);
   __Pyx_INCREF(__pyx_v_hmem);
@@ -3591,55 +3684,55 @@
   __Pyx_GIVEREF(__pyx_v_bmem);
   PyTuple_SET_ITEM(__pyx_t_3, 3, __pyx_v_bmem);
   __pyx_t_2 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "src/cbiogeme.pyx":80
+  /* "src/cbiogeme.pyx":89
  * 		self.theBiogeme.setPanel(panel)
  * 
  * 	def calculateLikelihoodAndDerivatives(self,             # <<<<<<<<<<<<<<
  * 	                                      betas,
  * 					      fixedBetas,
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_6);
   __PYX_XDEC_MEMVIEW(&__pyx_t_7, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_t_8, 1);
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.calculateLikelihoodAndDerivatives", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.calculateLikelihoodAndDerivatives", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_gmem_view, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_hmem_view, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_bmem_view, 1);
   __Pyx_XDECREF(__pyx_v_gmem);
   __Pyx_XDECREF(__pyx_v_hmem);
   __Pyx_XDECREF(__pyx_v_bmem);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "src/cbiogeme.pyx":117
+/* "src/cbiogeme.pyx":126
  * 		return f, gmem, hmem, bmem
  * 
  * 	def setBounds(self,lb,ub):             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.setBounds(lb,ub)
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_7setBounds(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_6setBounds[] = "pyBiogeme.setBounds(self, lb, ub)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_7setBounds(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_7setBounds(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_6setBounds[] = "pyBiogeme.setBounds(self, lb, ub)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_7setBounds(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_lb = 0;
   PyObject *__pyx_v_ub = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -3663,97 +3756,97 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lb)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ub)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("setBounds", 1, 2, 2, 1); __PYX_ERR(0, 117, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("setBounds", 1, 2, 2, 1); __PYX_ERR(1, 126, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setBounds") < 0)) __PYX_ERR(0, 117, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setBounds") < 0)) __PYX_ERR(1, 126, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_lb = values[0];
     __pyx_v_ub = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("setBounds", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 117, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("setBounds", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 126, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.setBounds", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.setBounds", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_6setBounds(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_lb, __pyx_v_ub);
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_6setBounds(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_lb, __pyx_v_ub);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_6setBounds(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_lb, PyObject *__pyx_v_ub) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_6setBounds(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_lb, PyObject *__pyx_v_ub) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  __pyx_t_7biogeme_8cbiogeme_double_vector __pyx_t_1;
-  __pyx_t_7biogeme_8cbiogeme_double_vector __pyx_t_2;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_1;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_2;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setBounds", 0);
 
-  /* "src/cbiogeme.pyx":118
+  /* "src/cbiogeme.pyx":127
  * 
  * 	def setBounds(self,lb,ub):
  * 		self.theBiogeme.setBounds(lb,ub)             # <<<<<<<<<<<<<<
  * 
  * 	def calculateLikelihood(self, betas,fixedBetas):
  */
-  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_lb); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 118, __pyx_L1_error)
-  __pyx_t_2 = __pyx_convert_vector_from_py_double(__pyx_v_ub); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 118, __pyx_L1_error)
+  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_lb); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 127, __pyx_L1_error)
+  __pyx_t_2 = __pyx_convert_vector_from_py_double(__pyx_v_ub); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 127, __pyx_L1_error)
   __pyx_v_self->theBiogeme.setBounds(__pyx_t_1, __pyx_t_2);
 
-  /* "src/cbiogeme.pyx":117
+  /* "src/cbiogeme.pyx":126
  * 		return f, gmem, hmem, bmem
  * 
  * 	def setBounds(self,lb,ub):             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.setBounds(lb,ub)
  * 
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.setBounds", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.setBounds", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "src/cbiogeme.pyx":120
+/* "src/cbiogeme.pyx":129
  * 		self.theBiogeme.setBounds(lb,ub)
  * 
  * 	def calculateLikelihood(self, betas,fixedBetas):             # <<<<<<<<<<<<<<
  * 		r = self.theBiogeme.calculateLikelihood(betas, fixedBetas)
  * 		return r
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_9calculateLikelihood(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_8calculateLikelihood[] = "pyBiogeme.calculateLikelihood(self, betas, fixedBetas)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_9calculateLikelihood(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_9calculateLikelihood(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_8calculateLikelihood[] = "pyBiogeme.calculateLikelihood(self, betas, fixedBetas)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_9calculateLikelihood(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_betas = 0;
   PyObject *__pyx_v_fixedBetas = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -3777,119 +3870,584 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_betas)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fixedBetas)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("calculateLikelihood", 1, 2, 2, 1); __PYX_ERR(0, 120, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("calculateLikelihood", 1, 2, 2, 1); __PYX_ERR(1, 129, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "calculateLikelihood") < 0)) __PYX_ERR(0, 120, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "calculateLikelihood") < 0)) __PYX_ERR(1, 129, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_betas = values[0];
     __pyx_v_fixedBetas = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("calculateLikelihood", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 120, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("calculateLikelihood", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 129, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.calculateLikelihood", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.calculateLikelihood", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_8calculateLikelihood(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_betas, __pyx_v_fixedBetas);
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_8calculateLikelihood(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_betas, __pyx_v_fixedBetas);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_8calculateLikelihood(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_8calculateLikelihood(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas) {
   double __pyx_v_r;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  __pyx_t_7biogeme_8cbiogeme_double_vector __pyx_t_1;
-  __pyx_t_7biogeme_8cbiogeme_double_vector __pyx_t_2;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_1;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_2;
   double __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("calculateLikelihood", 0);
 
-  /* "src/cbiogeme.pyx":121
+  /* "src/cbiogeme.pyx":130
  * 
  * 	def calculateLikelihood(self, betas,fixedBetas):
  * 		r = self.theBiogeme.calculateLikelihood(betas, fixedBetas)             # <<<<<<<<<<<<<<
  * 		return r
  * 
  */
-  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_betas); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 121, __pyx_L1_error)
-  __pyx_t_2 = __pyx_convert_vector_from_py_double(__pyx_v_fixedBetas); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 121, __pyx_L1_error)
+  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_betas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 130, __pyx_L1_error)
+  __pyx_t_2 = __pyx_convert_vector_from_py_double(__pyx_v_fixedBetas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 130, __pyx_L1_error)
   try {
     __pyx_t_3 = __pyx_v_self->theBiogeme.calculateLikelihood(__pyx_t_1, __pyx_t_2);
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 121, __pyx_L1_error)
+    __PYX_ERR(1, 130, __pyx_L1_error)
   }
   __pyx_v_r = __pyx_t_3;
 
-  /* "src/cbiogeme.pyx":122
+  /* "src/cbiogeme.pyx":131
  * 	def calculateLikelihood(self, betas,fixedBetas):
  * 		r = self.theBiogeme.calculateLikelihood(betas, fixedBetas)
  * 		return r             # <<<<<<<<<<<<<<
  * 
- * 	def simulateFormula(self, formula, betas, fixedBetas, d):
+ * 	def simulateSimpleFormula(self,
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_4 = PyFloat_FromDouble(__pyx_v_r); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 122, __pyx_L1_error)
+  __pyx_t_4 = PyFloat_FromDouble(__pyx_v_r); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 131, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_r = __pyx_t_4;
   __pyx_t_4 = 0;
   goto __pyx_L0;
 
-  /* "src/cbiogeme.pyx":120
+  /* "src/cbiogeme.pyx":129
  * 		self.theBiogeme.setBounds(lb,ub)
  * 
  * 	def calculateLikelihood(self, betas,fixedBetas):             # <<<<<<<<<<<<<<
  * 		r = self.theBiogeme.calculateLikelihood(betas, fixedBetas)
  * 		return r
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.calculateLikelihood", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.calculateLikelihood", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "src/cbiogeme.pyx":124
+/* "src/cbiogeme.pyx":133
  * 		return r
  * 
+ * 	def simulateSimpleFormula(self,             # <<<<<<<<<<<<<<
+ *                                   formula,
+ *                                   betas,
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_11simulateSimpleFormula(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_10simulateSimpleFormula[] = "pyBiogeme.simulateSimpleFormula(self, formula, betas, fixedBetas, gradient, hessian, gmem, hmem)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_11simulateSimpleFormula(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_formula = 0;
+  PyObject *__pyx_v_betas = 0;
+  PyObject *__pyx_v_fixedBetas = 0;
+  PyObject *__pyx_v_gradient = 0;
+  PyObject *__pyx_v_hessian = 0;
+  PyObject *__pyx_v_gmem = 0;
+  PyObject *__pyx_v_hmem = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("simulateSimpleFormula (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_formula,&__pyx_n_s_betas,&__pyx_n_s_fixedBetas,&__pyx_n_s_gradient,&__pyx_n_s_hessian,&__pyx_n_s_gmem,&__pyx_n_s_hmem,0};
+    PyObject* values[7] = {0,0,0,0,0,0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
+        CYTHON_FALLTHROUGH;
+        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
+        CYTHON_FALLTHROUGH;
+        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+        CYTHON_FALLTHROUGH;
+        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+        CYTHON_FALLTHROUGH;
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_formula)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_betas)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("simulateSimpleFormula", 1, 7, 7, 1); __PYX_ERR(1, 133, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fixedBetas)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("simulateSimpleFormula", 1, 7, 7, 2); __PYX_ERR(1, 133, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  3:
+        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_gradient)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("simulateSimpleFormula", 1, 7, 7, 3); __PYX_ERR(1, 133, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  4:
+        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_hessian)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("simulateSimpleFormula", 1, 7, 7, 4); __PYX_ERR(1, 133, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  5:
+        if (likely((values[5] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_gmem)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("simulateSimpleFormula", 1, 7, 7, 5); __PYX_ERR(1, 133, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  6:
+        if (likely((values[6] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_hmem)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("simulateSimpleFormula", 1, 7, 7, 6); __PYX_ERR(1, 133, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "simulateSimpleFormula") < 0)) __PYX_ERR(1, 133, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 7) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+      values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+      values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
+      values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
+    }
+    __pyx_v_formula = values[0];
+    __pyx_v_betas = values[1];
+    __pyx_v_fixedBetas = values[2];
+    __pyx_v_gradient = values[3];
+    __pyx_v_hessian = values[4];
+    __pyx_v_gmem = values[5];
+    __pyx_v_hmem = values[6];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("simulateSimpleFormula", 1, 7, 7, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 133, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.simulateSimpleFormula", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_10simulateSimpleFormula(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_formula, __pyx_v_betas, __pyx_v_fixedBetas, __pyx_v_gradient, __pyx_v_hessian, __pyx_v_gmem, __pyx_v_hmem);
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_10simulateSimpleFormula(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_formula, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_gradient, PyObject *__pyx_v_hessian, PyObject *__pyx_v_gmem, PyObject *__pyx_v_hmem) {
+  __pyx_t_3src_8cbiogeme_double_vector_view __pyx_v_gmem_view = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __pyx_t_3src_8cbiogeme_double_matrix_view __pyx_v_hmem_view = { 0, 0, { 0 }, { 0 }, { 0 } };
+  double __pyx_v_r;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_3;
+  int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  __pyx_t_3src_8cbiogeme_double_vector_view __pyx_t_6 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __pyx_t_3src_8cbiogeme_double_matrix_view __pyx_t_7 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  std::vector<std::string>  __pyx_t_8;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_9;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_10;
+  bool __pyx_t_11;
+  bool __pyx_t_12;
+  Py_ssize_t __pyx_t_13;
+  int __pyx_t_14;
+  Py_ssize_t __pyx_t_15;
+  Py_ssize_t __pyx_t_16;
+  double __pyx_t_17;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("simulateSimpleFormula", 0);
+  __Pyx_INCREF(__pyx_v_gmem);
+  __Pyx_INCREF(__pyx_v_hmem);
+
+  /* "src/cbiogeme.pyx":141
+ *                                   gmem,
+ *                                   hmem):
+ * 		if not gmem.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
+ * 			print('gmem not contiguous')
+ * 			gmem = np.ascontiguousarray(gmem)
+ */
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_gmem, __pyx_n_s_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 141, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_Dict_GetItem(__pyx_t_1, __pyx_n_s_C_CONTIGUOUS); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 141, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(1, 141, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_4 = ((!__pyx_t_3) != 0);
+  if (__pyx_t_4) {
+
+    /* "src/cbiogeme.pyx":142
+ *                                   hmem):
+ * 		if not gmem.flags['C_CONTIGUOUS']:
+ * 			print('gmem not contiguous')             # <<<<<<<<<<<<<<
+ * 			gmem = np.ascontiguousarray(gmem)
+ * 		if not hmem.flags['C_CONTIGUOUS']:
+ */
+    if (__Pyx_PrintOne(0, __pyx_kp_s_gmem_not_contiguous) < 0) __PYX_ERR(1, 142, __pyx_L1_error)
+
+    /* "src/cbiogeme.pyx":143
+ * 		if not gmem.flags['C_CONTIGUOUS']:
+ * 			print('gmem not contiguous')
+ * 			gmem = np.ascontiguousarray(gmem)             # <<<<<<<<<<<<<<
+ * 		if not hmem.flags['C_CONTIGUOUS']:
+ * 			print('hmem not contiguous')
+ */
+    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 143, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 143, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_1 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
+      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
+      if (likely(__pyx_t_1)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+        __Pyx_INCREF(__pyx_t_1);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_5, function);
+      }
+    }
+    __pyx_t_2 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_1, __pyx_v_gmem) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_gmem);
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 143, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF_SET(__pyx_v_gmem, __pyx_t_2);
+    __pyx_t_2 = 0;
+
+    /* "src/cbiogeme.pyx":141
+ *                                   gmem,
+ *                                   hmem):
+ * 		if not gmem.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
+ * 			print('gmem not contiguous')
+ * 			gmem = np.ascontiguousarray(gmem)
+ */
+  }
+
+  /* "src/cbiogeme.pyx":144
+ * 			print('gmem not contiguous')
+ * 			gmem = np.ascontiguousarray(gmem)
+ * 		if not hmem.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
+ * 			print('hmem not contiguous')
+ * 			hmem = np.ascontiguousarray(hmem)
+ */
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_hmem, __pyx_n_s_flags); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 144, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_5 = __Pyx_PyObject_Dict_GetItem(__pyx_t_2, __pyx_n_s_C_CONTIGUOUS); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 144, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 144, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_t_3 = ((!__pyx_t_4) != 0);
+  if (__pyx_t_3) {
+
+    /* "src/cbiogeme.pyx":145
+ * 			gmem = np.ascontiguousarray(gmem)
+ * 		if not hmem.flags['C_CONTIGUOUS']:
+ * 			print('hmem not contiguous')             # <<<<<<<<<<<<<<
+ * 			hmem = np.ascontiguousarray(hmem)
+ * 
+ */
+    if (__Pyx_PrintOne(0, __pyx_kp_s_hmem_not_contiguous) < 0) __PYX_ERR(1, 145, __pyx_L1_error)
+
+    /* "src/cbiogeme.pyx":146
+ * 		if not hmem.flags['C_CONTIGUOUS']:
+ * 			print('hmem not contiguous')
+ * 			hmem = np.ascontiguousarray(hmem)             # <<<<<<<<<<<<<<
+ * 
+ * 		cdef double_vector_view gmem_view = gmem
+ */
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 146, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 146, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
+      if (likely(__pyx_t_2)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+        __Pyx_INCREF(__pyx_t_2);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_1, function);
+      }
+    }
+    __pyx_t_5 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_2, __pyx_v_hmem) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_hmem);
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 146, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF_SET(__pyx_v_hmem, __pyx_t_5);
+    __pyx_t_5 = 0;
+
+    /* "src/cbiogeme.pyx":144
+ * 			print('gmem not contiguous')
+ * 			gmem = np.ascontiguousarray(gmem)
+ * 		if not hmem.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
+ * 			print('hmem not contiguous')
+ * 			hmem = np.ascontiguousarray(hmem)
+ */
+  }
+
+  /* "src/cbiogeme.pyx":148
+ * 			hmem = np.ascontiguousarray(hmem)
+ * 
+ * 		cdef double_vector_view gmem_view = gmem             # <<<<<<<<<<<<<<
+ * 		cdef double_matrix_view hmem_view = hmem
+ * 
+ */
+  __pyx_t_6 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_v_gmem, PyBUF_WRITABLE); if (unlikely(!__pyx_t_6.memview)) __PYX_ERR(1, 148, __pyx_L1_error)
+  __pyx_v_gmem_view = __pyx_t_6;
+  __pyx_t_6.memview = NULL;
+  __pyx_t_6.data = NULL;
+
+  /* "src/cbiogeme.pyx":149
+ * 
+ * 		cdef double_vector_view gmem_view = gmem
+ * 		cdef double_matrix_view hmem_view = hmem             # <<<<<<<<<<<<<<
+ * 
+ * 		r = self.theBiogeme.simulateSimpleFormula(formula,
+ */
+  __pyx_t_7 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_v_hmem, PyBUF_WRITABLE); if (unlikely(!__pyx_t_7.memview)) __PYX_ERR(1, 149, __pyx_L1_error)
+  __pyx_v_hmem_view = __pyx_t_7;
+  __pyx_t_7.memview = NULL;
+  __pyx_t_7.data = NULL;
+
+  /* "src/cbiogeme.pyx":151
+ * 		cdef double_matrix_view hmem_view = hmem
+ * 
+ * 		r = self.theBiogeme.simulateSimpleFormula(formula,             # <<<<<<<<<<<<<<
+ * 					                 betas,
+ *    						        fixedBetas,
+ */
+  __pyx_t_8 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_v_formula); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 151, __pyx_L1_error)
+
+  /* "src/cbiogeme.pyx":152
+ * 
+ * 		r = self.theBiogeme.simulateSimpleFormula(formula,
+ * 					                 betas,             # <<<<<<<<<<<<<<
+ *    						        fixedBetas,
+ *                                                            gradient,
+ */
+  __pyx_t_9 = __pyx_convert_vector_from_py_double(__pyx_v_betas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 152, __pyx_L1_error)
+
+  /* "src/cbiogeme.pyx":153
+ * 		r = self.theBiogeme.simulateSimpleFormula(formula,
+ * 					                 betas,
+ *    						        fixedBetas,             # <<<<<<<<<<<<<<
+ *                                                            gradient,
+ *                                                            hessian,
+ */
+  __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_fixedBetas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 153, __pyx_L1_error)
+
+  /* "src/cbiogeme.pyx":154
+ * 					                 betas,
+ *    						        fixedBetas,
+ *                                                            gradient,             # <<<<<<<<<<<<<<
+ *                                                            hessian,
+ *                                                            &gmem_view[0],
+ */
+  __pyx_t_11 = __Pyx_PyObject_IsTrue(__pyx_v_gradient); if (unlikely((__pyx_t_11 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(1, 154, __pyx_L1_error)
+
+  /* "src/cbiogeme.pyx":155
+ *    						        fixedBetas,
+ *                                                            gradient,
+ *                                                            hessian,             # <<<<<<<<<<<<<<
+ *                                                            &gmem_view[0],
+ *                                                            &hmem_view[0,0])
+ */
+  __pyx_t_12 = __Pyx_PyObject_IsTrue(__pyx_v_hessian); if (unlikely((__pyx_t_12 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(1, 155, __pyx_L1_error)
+
+  /* "src/cbiogeme.pyx":156
+ *                                                            gradient,
+ *                                                            hessian,
+ *                                                            &gmem_view[0],             # <<<<<<<<<<<<<<
+ *                                                            &hmem_view[0,0])
+ * 		return r, gmem, hmem
+ */
+  __pyx_t_13 = 0;
+  __pyx_t_14 = -1;
+  if (__pyx_t_13 < 0) {
+    __pyx_t_13 += __pyx_v_gmem_view.shape[0];
+    if (unlikely(__pyx_t_13 < 0)) __pyx_t_14 = 0;
+  } else if (unlikely(__pyx_t_13 >= __pyx_v_gmem_view.shape[0])) __pyx_t_14 = 0;
+  if (unlikely(__pyx_t_14 != -1)) {
+    __Pyx_RaiseBufferIndexError(__pyx_t_14);
+    __PYX_ERR(1, 156, __pyx_L1_error)
+  }
+
+  /* "src/cbiogeme.pyx":157
+ *                                                            hessian,
+ *                                                            &gmem_view[0],
+ *                                                            &hmem_view[0,0])             # <<<<<<<<<<<<<<
+ * 		return r, gmem, hmem
+ * 
+ */
+  __pyx_t_15 = 0;
+  __pyx_t_16 = 0;
+  __pyx_t_14 = -1;
+  if (__pyx_t_15 < 0) {
+    __pyx_t_15 += __pyx_v_hmem_view.shape[0];
+    if (unlikely(__pyx_t_15 < 0)) __pyx_t_14 = 0;
+  } else if (unlikely(__pyx_t_15 >= __pyx_v_hmem_view.shape[0])) __pyx_t_14 = 0;
+  if (__pyx_t_16 < 0) {
+    __pyx_t_16 += __pyx_v_hmem_view.shape[1];
+    if (unlikely(__pyx_t_16 < 0)) __pyx_t_14 = 1;
+  } else if (unlikely(__pyx_t_16 >= __pyx_v_hmem_view.shape[1])) __pyx_t_14 = 1;
+  if (unlikely(__pyx_t_14 != -1)) {
+    __Pyx_RaiseBufferIndexError(__pyx_t_14);
+    __PYX_ERR(1, 157, __pyx_L1_error)
+  }
+
+  /* "src/cbiogeme.pyx":151
+ * 		cdef double_matrix_view hmem_view = hmem
+ * 
+ * 		r = self.theBiogeme.simulateSimpleFormula(formula,             # <<<<<<<<<<<<<<
+ * 					                 betas,
+ *    						        fixedBetas,
+ */
+  try {
+    __pyx_t_17 = __pyx_v_self->theBiogeme.simulateSimpleFormula(__pyx_t_8, __pyx_t_9, __pyx_t_10, __pyx_t_11, __pyx_t_12, (&(*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_gmem_view.data) + __pyx_t_13)) )))), (&(*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_hmem_view.data + __pyx_t_15 * __pyx_v_hmem_view.strides[0]) )) + __pyx_t_16)) )))));
+  } catch(...) {
+    __Pyx_CppExn2PyErr();
+    __PYX_ERR(1, 151, __pyx_L1_error)
+  }
+  __pyx_v_r = __pyx_t_17;
+
+  /* "src/cbiogeme.pyx":158
+ *                                                            &gmem_view[0],
+ *                                                            &hmem_view[0,0])
+ * 		return r, gmem, hmem             # <<<<<<<<<<<<<<
+ * 
+ * 	def simulateFormula(self, formula, betas, fixedBetas, d):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_5 = PyFloat_FromDouble(__pyx_v_r); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 158, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 158, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_5);
+  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_5);
+  __Pyx_INCREF(__pyx_v_gmem);
+  __Pyx_GIVEREF(__pyx_v_gmem);
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_gmem);
+  __Pyx_INCREF(__pyx_v_hmem);
+  __Pyx_GIVEREF(__pyx_v_hmem);
+  PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_hmem);
+  __pyx_t_5 = 0;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "src/cbiogeme.pyx":133
+ * 		return r
+ * 
+ * 	def simulateSimpleFormula(self,             # <<<<<<<<<<<<<<
+ *                                   formula,
+ *                                   betas,
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_5);
+  __PYX_XDEC_MEMVIEW(&__pyx_t_6, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_t_7, 1);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.simulateSimpleFormula", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __PYX_XDEC_MEMVIEW(&__pyx_v_gmem_view, 1);
+  __PYX_XDEC_MEMVIEW(&__pyx_v_hmem_view, 1);
+  __Pyx_XDECREF(__pyx_v_gmem);
+  __Pyx_XDECREF(__pyx_v_hmem);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "src/cbiogeme.pyx":160
+ * 		return r, gmem, hmem
+ * 
  * 	def simulateFormula(self, formula, betas, fixedBetas, d):             # <<<<<<<<<<<<<<
  * 		n = d.shape[0]
  * 		r = np.empty(n)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_11simulateFormula(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_10simulateFormula[] = "pyBiogeme.simulateFormula(self, formula, betas, fixedBetas, d)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_11simulateFormula(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_13simulateFormula(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_12simulateFormula[] = "pyBiogeme.simulateFormula(self, formula, betas, fixedBetas, d)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_13simulateFormula(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_formula = 0;
   PyObject *__pyx_v_betas = 0;
   PyObject *__pyx_v_fixedBetas = 0;
   PyObject *__pyx_v_d = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
@@ -3919,31 +4477,31 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_formula)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_betas)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("simulateFormula", 1, 4, 4, 1); __PYX_ERR(0, 124, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("simulateFormula", 1, 4, 4, 1); __PYX_ERR(1, 160, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fixedBetas)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("simulateFormula", 1, 4, 4, 2); __PYX_ERR(0, 124, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("simulateFormula", 1, 4, 4, 2); __PYX_ERR(1, 160, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("simulateFormula", 1, 4, 4, 3); __PYX_ERR(0, 124, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("simulateFormula", 1, 4, 4, 3); __PYX_ERR(1, 160, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "simulateFormula") < 0)) __PYX_ERR(0, 124, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "simulateFormula") < 0)) __PYX_ERR(1, 160, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
@@ -3952,323 +4510,321 @@
     __pyx_v_formula = values[0];
     __pyx_v_betas = values[1];
     __pyx_v_fixedBetas = values[2];
     __pyx_v_d = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("simulateFormula", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 124, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("simulateFormula", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 160, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.simulateFormula", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.simulateFormula", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_10simulateFormula(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_formula, __pyx_v_betas, __pyx_v_fixedBetas, __pyx_v_d);
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_12simulateFormula(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_formula, __pyx_v_betas, __pyx_v_fixedBetas, __pyx_v_d);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_10simulateFormula(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_formula, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_d) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_12simulateFormula(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_formula, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_d) {
   PyObject *__pyx_v_n = NULL;
   PyObject *__pyx_v_r = NULL;
-  __pyx_t_7biogeme_8cbiogeme_double_vector_view __pyx_v_r_view = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __pyx_t_3src_8cbiogeme_double_vector_view __pyx_v_r_view = { 0, 0, { 0 }, { 0 }, { 0 } };
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
   int __pyx_t_5;
-  __pyx_t_7biogeme_8cbiogeme_double_vector_view __pyx_t_6 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __pyx_t_3src_8cbiogeme_double_vector_view __pyx_t_6 = { 0, 0, { 0 }, { 0 }, { 0 } };
   std::vector<std::string>  __pyx_t_7;
-  __pyx_t_7biogeme_8cbiogeme_double_vector __pyx_t_8;
-  __pyx_t_7biogeme_8cbiogeme_double_vector __pyx_t_9;
-  __pyx_t_7biogeme_8cbiogeme_double_matrix __pyx_t_10;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_8;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_9;
+  __pyx_t_3src_8cbiogeme_double_matrix __pyx_t_10;
   Py_ssize_t __pyx_t_11;
   int __pyx_t_12;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("simulateFormula", 0);
   __Pyx_INCREF(__pyx_v_d);
 
-  /* "src/cbiogeme.pyx":125
+  /* "src/cbiogeme.pyx":161
  * 
  * 	def simulateFormula(self, formula, betas, fixedBetas, d):
  * 		n = d.shape[0]             # <<<<<<<<<<<<<<
  * 		r = np.empty(n)
  * 		if not r.flags['C_CONTIGUOUS']:
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 125, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 161, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 125, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 161, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_n = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "src/cbiogeme.pyx":126
+  /* "src/cbiogeme.pyx":162
  * 	def simulateFormula(self, formula, betas, fixedBetas, d):
  * 		n = d.shape[0]
  * 		r = np.empty(n)             # <<<<<<<<<<<<<<
  * 		if not r.flags['C_CONTIGUOUS']:
  * 			print('r not contiguous')
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 126, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 162, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_empty); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 126, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_empty); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 162, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_1)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_1);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_2 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_1, __pyx_v_n) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_n);
   __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 126, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 162, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_r = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "src/cbiogeme.pyx":127
+  /* "src/cbiogeme.pyx":163
  * 		n = d.shape[0]
  * 		r = np.empty(n)
  * 		if not r.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
  * 			print('r not contiguous')
  * 			r = np.ascontiguousarray(r)
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_r, __pyx_n_s_flags); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 127, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_r, __pyx_n_s_flags); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 163, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_Dict_GetItem(__pyx_t_2, __pyx_n_u_C_CONTIGUOUS); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 127, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Dict_GetItem(__pyx_t_2, __pyx_n_s_C_CONTIGUOUS); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 163, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 127, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 163, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_5 = ((!__pyx_t_4) != 0);
   if (__pyx_t_5) {
 
-    /* "src/cbiogeme.pyx":128
+    /* "src/cbiogeme.pyx":164
  * 		r = np.empty(n)
  * 		if not r.flags['C_CONTIGUOUS']:
  * 			print('r not contiguous')             # <<<<<<<<<<<<<<
  * 			r = np.ascontiguousarray(r)
  * 		d = np.ascontiguousarray(d)
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_print, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 128, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (__Pyx_PrintOne(0, __pyx_kp_s_r_not_contiguous) < 0) __PYX_ERR(1, 164, __pyx_L1_error)
 
-    /* "src/cbiogeme.pyx":129
+    /* "src/cbiogeme.pyx":165
  * 		if not r.flags['C_CONTIGUOUS']:
  * 			print('r not contiguous')
  * 			r = np.ascontiguousarray(r)             # <<<<<<<<<<<<<<
  * 		d = np.ascontiguousarray(d)
  * 
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 129, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 165, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 165, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_2 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
       __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
       if (likely(__pyx_t_2)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
         __Pyx_INCREF(__pyx_t_2);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_1, function);
       }
     }
     __pyx_t_3 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_2, __pyx_v_r) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_r);
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 129, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 165, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF_SET(__pyx_v_r, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "src/cbiogeme.pyx":127
+    /* "src/cbiogeme.pyx":163
  * 		n = d.shape[0]
  * 		r = np.empty(n)
  * 		if not r.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
  * 			print('r not contiguous')
  * 			r = np.ascontiguousarray(r)
  */
   }
 
-  /* "src/cbiogeme.pyx":130
+  /* "src/cbiogeme.pyx":166
  * 			print('r not contiguous')
  * 			r = np.ascontiguousarray(r)
  * 		d = np.ascontiguousarray(d)             # <<<<<<<<<<<<<<
  * 
  * 		cdef double_vector_view r_view = r
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 166, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 130, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 166, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_1)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_1);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_3 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_v_d) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_d);
   __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 130, __pyx_L1_error)
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 166, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF_SET(__pyx_v_d, __pyx_t_3);
   __pyx_t_3 = 0;
 
-  /* "src/cbiogeme.pyx":132
+  /* "src/cbiogeme.pyx":168
  * 		d = np.ascontiguousarray(d)
  * 
  * 		cdef double_vector_view r_view = r             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.simulateFormula(formula,
- * 					        betas,
+ * 					       betas,
  */
-  __pyx_t_6 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_v_r, PyBUF_WRITABLE); if (unlikely(!__pyx_t_6.memview)) __PYX_ERR(0, 132, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_v_r, PyBUF_WRITABLE); if (unlikely(!__pyx_t_6.memview)) __PYX_ERR(1, 168, __pyx_L1_error)
   __pyx_v_r_view = __pyx_t_6;
   __pyx_t_6.memview = NULL;
   __pyx_t_6.data = NULL;
 
-  /* "src/cbiogeme.pyx":133
+  /* "src/cbiogeme.pyx":169
  * 
  * 		cdef double_vector_view r_view = r
  * 		self.theBiogeme.simulateFormula(formula,             # <<<<<<<<<<<<<<
- * 					        betas,
- *    						fixedBetas,
+ * 					       betas,
+ *    					       fixedBetas,
  */
-  __pyx_t_7 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_v_formula); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 133, __pyx_L1_error)
+  __pyx_t_7 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_v_formula); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 169, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":134
+  /* "src/cbiogeme.pyx":170
  * 		cdef double_vector_view r_view = r
  * 		self.theBiogeme.simulateFormula(formula,
- * 					        betas,             # <<<<<<<<<<<<<<
- *    						fixedBetas,
- * 						d,
+ * 					       betas,             # <<<<<<<<<<<<<<
+ *    					       fixedBetas,
+ * 					       d,
  */
-  __pyx_t_8 = __pyx_convert_vector_from_py_double(__pyx_v_betas); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 134, __pyx_L1_error)
+  __pyx_t_8 = __pyx_convert_vector_from_py_double(__pyx_v_betas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 170, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":135
+  /* "src/cbiogeme.pyx":171
  * 		self.theBiogeme.simulateFormula(formula,
- * 					        betas,
- *    						fixedBetas,             # <<<<<<<<<<<<<<
- * 						d,
- * 						&r_view[0])
- */
-  __pyx_t_9 = __pyx_convert_vector_from_py_double(__pyx_v_fixedBetas); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 135, __pyx_L1_error)
-
-  /* "src/cbiogeme.pyx":136
- * 					        betas,
- *    						fixedBetas,
- * 						d,             # <<<<<<<<<<<<<<
- * 						&r_view[0])
+ * 					       betas,
+ *    					       fixedBetas,             # <<<<<<<<<<<<<<
+ * 					       d,
+ * 					       &r_view[0])
+ */
+  __pyx_t_9 = __pyx_convert_vector_from_py_double(__pyx_v_fixedBetas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 171, __pyx_L1_error)
+
+  /* "src/cbiogeme.pyx":172
+ * 					       betas,
+ *    					       fixedBetas,
+ * 					       d,             # <<<<<<<<<<<<<<
+ * 					       &r_view[0])
  * 		return r
  */
-  __pyx_t_10 = __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector(__pyx_v_d); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 136, __pyx_L1_error)
+  __pyx_t_10 = __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector(__pyx_v_d); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 172, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":137
- *    						fixedBetas,
- * 						d,
- * 						&r_view[0])             # <<<<<<<<<<<<<<
+  /* "src/cbiogeme.pyx":173
+ *    					       fixedBetas,
+ * 					       d,
+ * 					       &r_view[0])             # <<<<<<<<<<<<<<
  * 		return r
  * 
  */
   __pyx_t_11 = 0;
   __pyx_t_12 = -1;
   if (__pyx_t_11 < 0) {
     __pyx_t_11 += __pyx_v_r_view.shape[0];
     if (unlikely(__pyx_t_11 < 0)) __pyx_t_12 = 0;
   } else if (unlikely(__pyx_t_11 >= __pyx_v_r_view.shape[0])) __pyx_t_12 = 0;
   if (unlikely(__pyx_t_12 != -1)) {
     __Pyx_RaiseBufferIndexError(__pyx_t_12);
-    __PYX_ERR(0, 137, __pyx_L1_error)
+    __PYX_ERR(1, 173, __pyx_L1_error)
   }
 
-  /* "src/cbiogeme.pyx":133
+  /* "src/cbiogeme.pyx":169
  * 
  * 		cdef double_vector_view r_view = r
  * 		self.theBiogeme.simulateFormula(formula,             # <<<<<<<<<<<<<<
- * 					        betas,
- *    						fixedBetas,
+ * 					       betas,
+ *    					       fixedBetas,
  */
   try {
     __pyx_v_self->theBiogeme.simulateFormula(__pyx_t_7, __pyx_t_8, __pyx_t_9, __pyx_t_10, (&(*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_r_view.data) + __pyx_t_11)) )))));
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 133, __pyx_L1_error)
+    __PYX_ERR(1, 169, __pyx_L1_error)
   }
 
-  /* "src/cbiogeme.pyx":138
- * 						d,
- * 						&r_view[0])
+  /* "src/cbiogeme.pyx":174
+ * 					       d,
+ * 					       &r_view[0])
  * 		return r             # <<<<<<<<<<<<<<
  * 
  * 	def simulateSeveralFormulas(self, formulas, betas, fixedBetas, d, nThreads):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_r);
   __pyx_r = __pyx_v_r;
   goto __pyx_L0;
 
-  /* "src/cbiogeme.pyx":124
- * 		return r
+  /* "src/cbiogeme.pyx":160
+ * 		return r, gmem, hmem
  * 
  * 	def simulateFormula(self, formula, betas, fixedBetas, d):             # <<<<<<<<<<<<<<
  * 		n = d.shape[0]
  * 		r = np.empty(n)
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __PYX_XDEC_MEMVIEW(&__pyx_t_6, 1);
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.simulateFormula", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.simulateFormula", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_n);
   __Pyx_XDECREF(__pyx_v_r);
   __PYX_XDEC_MEMVIEW(&__pyx_v_r_view, 1);
   __Pyx_XDECREF(__pyx_v_d);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "src/cbiogeme.pyx":140
+/* "src/cbiogeme.pyx":176
  * 		return r
  * 
  * 	def simulateSeveralFormulas(self, formulas, betas, fixedBetas, d, nThreads):             # <<<<<<<<<<<<<<
  * 		n = d.shape[0]
  * 		nf = len(formulas)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_13simulateSeveralFormulas(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_12simulateSeveralFormulas[] = "pyBiogeme.simulateSeveralFormulas(self, formulas, betas, fixedBetas, d, nThreads)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_13simulateSeveralFormulas(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_15simulateSeveralFormulas(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_14simulateSeveralFormulas[] = "pyBiogeme.simulateSeveralFormulas(self, formulas, betas, fixedBetas, d, nThreads)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_15simulateSeveralFormulas(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_formulas = 0;
   PyObject *__pyx_v_betas = 0;
   PyObject *__pyx_v_fixedBetas = 0;
   PyObject *__pyx_v_d = 0;
   PyObject *__pyx_v_nThreads = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
@@ -4301,37 +4857,37 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_formulas)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_betas)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("simulateSeveralFormulas", 1, 5, 5, 1); __PYX_ERR(0, 140, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("simulateSeveralFormulas", 1, 5, 5, 1); __PYX_ERR(1, 176, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fixedBetas)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("simulateSeveralFormulas", 1, 5, 5, 2); __PYX_ERR(0, 140, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("simulateSeveralFormulas", 1, 5, 5, 2); __PYX_ERR(1, 176, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("simulateSeveralFormulas", 1, 5, 5, 3); __PYX_ERR(0, 140, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("simulateSeveralFormulas", 1, 5, 5, 3); __PYX_ERR(1, 176, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  4:
         if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nThreads)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("simulateSeveralFormulas", 1, 5, 5, 4); __PYX_ERR(0, 140, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("simulateSeveralFormulas", 1, 5, 5, 4); __PYX_ERR(1, 176, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "simulateSeveralFormulas") < 0)) __PYX_ERR(0, 140, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "simulateSeveralFormulas") < 0)) __PYX_ERR(1, 176, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 5) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
@@ -4342,96 +4898,96 @@
     __pyx_v_betas = values[1];
     __pyx_v_fixedBetas = values[2];
     __pyx_v_d = values[3];
     __pyx_v_nThreads = values[4];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("simulateSeveralFormulas", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 140, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("simulateSeveralFormulas", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 176, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.simulateSeveralFormulas", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.simulateSeveralFormulas", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_12simulateSeveralFormulas(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_formulas, __pyx_v_betas, __pyx_v_fixedBetas, __pyx_v_d, __pyx_v_nThreads);
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_14simulateSeveralFormulas(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_formulas, __pyx_v_betas, __pyx_v_fixedBetas, __pyx_v_d, __pyx_v_nThreads);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_12simulateSeveralFormulas(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_formulas, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_d, PyObject *__pyx_v_nThreads) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_14simulateSeveralFormulas(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_formulas, PyObject *__pyx_v_betas, PyObject *__pyx_v_fixedBetas, PyObject *__pyx_v_d, PyObject *__pyx_v_nThreads) {
   PyObject *__pyx_v_n = NULL;
   Py_ssize_t __pyx_v_nf;
   PyObject *__pyx_v_r = NULL;
-  __pyx_t_7biogeme_8cbiogeme_double_matrix_view __pyx_v_r_view = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __pyx_t_3src_8cbiogeme_double_matrix_view __pyx_v_r_view = { 0, 0, { 0 }, { 0 }, { 0 } };
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   Py_ssize_t __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_t_6;
   int __pyx_t_7;
-  __pyx_t_7biogeme_8cbiogeme_double_matrix_view __pyx_t_8 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  std::vector<__pyx_t_7biogeme_8cbiogeme_string_vector>  __pyx_t_9;
-  __pyx_t_7biogeme_8cbiogeme_double_vector __pyx_t_10;
-  __pyx_t_7biogeme_8cbiogeme_double_vector __pyx_t_11;
+  __pyx_t_3src_8cbiogeme_double_matrix_view __pyx_t_8 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  std::vector<__pyx_t_3src_8cbiogeme_string_vector>  __pyx_t_9;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_10;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_11;
   unsigned long __pyx_t_12;
-  __pyx_t_7biogeme_8cbiogeme_double_matrix __pyx_t_13;
+  __pyx_t_3src_8cbiogeme_double_matrix __pyx_t_13;
   Py_ssize_t __pyx_t_14;
   Py_ssize_t __pyx_t_15;
   int __pyx_t_16;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("simulateSeveralFormulas", 0);
   __Pyx_INCREF(__pyx_v_d);
 
-  /* "src/cbiogeme.pyx":141
+  /* "src/cbiogeme.pyx":177
  * 
  * 	def simulateSeveralFormulas(self, formulas, betas, fixedBetas, d, nThreads):
  * 		n = d.shape[0]             # <<<<<<<<<<<<<<
  * 		nf = len(formulas)
  * 		r = np.zeros([nf, n])
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 141, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 177, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 141, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 177, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_n = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "src/cbiogeme.pyx":142
+  /* "src/cbiogeme.pyx":178
  * 	def simulateSeveralFormulas(self, formulas, betas, fixedBetas, d, nThreads):
  * 		n = d.shape[0]
  * 		nf = len(formulas)             # <<<<<<<<<<<<<<
  * 		r = np.zeros([nf, n])
  * 		if not r.flags['C_CONTIGUOUS']:
  */
-  __pyx_t_3 = PyObject_Length(__pyx_v_formulas); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 142, __pyx_L1_error)
+  __pyx_t_3 = PyObject_Length(__pyx_v_formulas); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(1, 178, __pyx_L1_error)
   __pyx_v_nf = __pyx_t_3;
 
-  /* "src/cbiogeme.pyx":143
+  /* "src/cbiogeme.pyx":179
  * 		n = d.shape[0]
  * 		nf = len(formulas)
  * 		r = np.zeros([nf, n])             # <<<<<<<<<<<<<<
  * 		if not r.flags['C_CONTIGUOUS']:
  * 			print('r not contiguous')
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 143, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 179, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_zeros); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 143, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_zeros); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 179, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_nf); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 143, __pyx_L1_error)
+  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_nf); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 179, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = PyList_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 143, __pyx_L1_error)
+  __pyx_t_5 = PyList_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 179, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_GIVEREF(__pyx_t_1);
   PyList_SET_ITEM(__pyx_t_5, 0, __pyx_t_1);
   __Pyx_INCREF(__pyx_v_n);
   __Pyx_GIVEREF(__pyx_v_n);
   PyList_SET_ITEM(__pyx_t_5, 1, __pyx_v_n);
   __pyx_t_1 = 0;
@@ -4444,175 +5000,173 @@
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_2 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_1, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5);
   __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 143, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 179, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_v_r = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "src/cbiogeme.pyx":144
+  /* "src/cbiogeme.pyx":180
  * 		nf = len(formulas)
  * 		r = np.zeros([nf, n])
  * 		if not r.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
  * 			print('r not contiguous')
  * 			r = np.ascontiguousarray(r)
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_r, __pyx_n_s_flags); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 144, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_r, __pyx_n_s_flags); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 180, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = __Pyx_PyObject_Dict_GetItem(__pyx_t_2, __pyx_n_u_C_CONTIGUOUS); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 144, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Dict_GetItem(__pyx_t_2, __pyx_n_s_C_CONTIGUOUS); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 180, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 144, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 180, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_7 = ((!__pyx_t_6) != 0);
   if (__pyx_t_7) {
 
-    /* "src/cbiogeme.pyx":145
+    /* "src/cbiogeme.pyx":181
  * 		r = np.zeros([nf, n])
  * 		if not r.flags['C_CONTIGUOUS']:
  * 			print('r not contiguous')             # <<<<<<<<<<<<<<
  * 			r = np.ascontiguousarray(r)
  * 		d = np.ascontiguousarray(d)
  */
-    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_print, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 145, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (__Pyx_PrintOne(0, __pyx_kp_s_r_not_contiguous) < 0) __PYX_ERR(1, 181, __pyx_L1_error)
 
-    /* "src/cbiogeme.pyx":146
+    /* "src/cbiogeme.pyx":182
  * 		if not r.flags['C_CONTIGUOUS']:
  * 			print('r not contiguous')
  * 			r = np.ascontiguousarray(r)             # <<<<<<<<<<<<<<
  * 		d = np.ascontiguousarray(d)
  * 
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 146, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 182, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 146, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 182, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_2 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_2)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_2);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_4 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_2, __pyx_v_r) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_r);
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 146, __pyx_L1_error)
+    if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 182, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_r, __pyx_t_4);
     __pyx_t_4 = 0;
 
-    /* "src/cbiogeme.pyx":144
+    /* "src/cbiogeme.pyx":180
  * 		nf = len(formulas)
  * 		r = np.zeros([nf, n])
  * 		if not r.flags['C_CONTIGUOUS']:             # <<<<<<<<<<<<<<
  * 			print('r not contiguous')
  * 			r = np.ascontiguousarray(r)
  */
   }
 
-  /* "src/cbiogeme.pyx":147
+  /* "src/cbiogeme.pyx":183
  * 			print('r not contiguous')
  * 			r = np.ascontiguousarray(r)
  * 		d = np.ascontiguousarray(d)             # <<<<<<<<<<<<<<
  * 
  * 		cdef double_matrix_view r_view = r
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 147, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 183, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 147, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 183, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_t_5 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_v_d) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_d);
   __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 147, __pyx_L1_error)
+  if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 183, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF_SET(__pyx_v_d, __pyx_t_4);
   __pyx_t_4 = 0;
 
-  /* "src/cbiogeme.pyx":149
+  /* "src/cbiogeme.pyx":185
  * 		d = np.ascontiguousarray(d)
  * 
  * 		cdef double_matrix_view r_view = r             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.simulateSeveralFormulas(formulas,
- * 					        	      betas,
+ * 				        	      betas,
  */
-  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_v_r, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(0, 149, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_v_r, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(1, 185, __pyx_L1_error)
   __pyx_v_r_view = __pyx_t_8;
   __pyx_t_8.memview = NULL;
   __pyx_t_8.data = NULL;
 
-  /* "src/cbiogeme.pyx":150
+  /* "src/cbiogeme.pyx":186
  * 
  * 		cdef double_matrix_view r_view = r
  * 		self.theBiogeme.simulateSeveralFormulas(formulas,             # <<<<<<<<<<<<<<
- * 					        	      betas,
+ * 				        	      betas,
  *    						      fixedBetas,
  */
-  __pyx_t_9 = __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_string_vector(__pyx_v_formulas); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 150, __pyx_L1_error)
+  __pyx_t_9 = __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_string_vector(__pyx_v_formulas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 186, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":151
+  /* "src/cbiogeme.pyx":187
  * 		cdef double_matrix_view r_view = r
  * 		self.theBiogeme.simulateSeveralFormulas(formulas,
- * 					        	      betas,             # <<<<<<<<<<<<<<
+ * 				        	      betas,             # <<<<<<<<<<<<<<
  *    						      fixedBetas,
  *  						      nThreads,
  */
-  __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_betas); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 151, __pyx_L1_error)
+  __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_betas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 187, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":152
+  /* "src/cbiogeme.pyx":188
  * 		self.theBiogeme.simulateSeveralFormulas(formulas,
- * 					        	      betas,
+ * 				        	      betas,
  *    						      fixedBetas,             # <<<<<<<<<<<<<<
  *  						      nThreads,
  * 						      d,
  */
-  __pyx_t_11 = __pyx_convert_vector_from_py_double(__pyx_v_fixedBetas); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 152, __pyx_L1_error)
+  __pyx_t_11 = __pyx_convert_vector_from_py_double(__pyx_v_fixedBetas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 188, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":153
- * 					        	      betas,
+  /* "src/cbiogeme.pyx":189
+ * 				        	      betas,
  *    						      fixedBetas,
  *  						      nThreads,             # <<<<<<<<<<<<<<
  * 						      d,
  * 						      &r_view[0,0])
  */
-  __pyx_t_12 = __Pyx_PyInt_As_unsigned_long(__pyx_v_nThreads); if (unlikely((__pyx_t_12 == (unsigned long)-1) && PyErr_Occurred())) __PYX_ERR(0, 153, __pyx_L1_error)
+  __pyx_t_12 = __Pyx_PyInt_As_unsigned_long(__pyx_v_nThreads); if (unlikely((__pyx_t_12 == (unsigned long)-1) && PyErr_Occurred())) __PYX_ERR(1, 189, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":154
+  /* "src/cbiogeme.pyx":190
  *    						      fixedBetas,
  *  						      nThreads,
  * 						      d,             # <<<<<<<<<<<<<<
  * 						      &r_view[0,0])
  * 		return r
  */
-  __pyx_t_13 = __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector(__pyx_v_d); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 154, __pyx_L1_error)
+  __pyx_t_13 = __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector(__pyx_v_d); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 190, __pyx_L1_error)
 
-  /* "src/cbiogeme.pyx":155
+  /* "src/cbiogeme.pyx":191
  *  						      nThreads,
  * 						      d,
  * 						      &r_view[0,0])             # <<<<<<<<<<<<<<
  * 		return r
  * 
  */
   __pyx_t_14 = 0;
@@ -4624,82 +5178,82 @@
   } else if (unlikely(__pyx_t_14 >= __pyx_v_r_view.shape[0])) __pyx_t_16 = 0;
   if (__pyx_t_15 < 0) {
     __pyx_t_15 += __pyx_v_r_view.shape[1];
     if (unlikely(__pyx_t_15 < 0)) __pyx_t_16 = 1;
   } else if (unlikely(__pyx_t_15 >= __pyx_v_r_view.shape[1])) __pyx_t_16 = 1;
   if (unlikely(__pyx_t_16 != -1)) {
     __Pyx_RaiseBufferIndexError(__pyx_t_16);
-    __PYX_ERR(0, 155, __pyx_L1_error)
+    __PYX_ERR(1, 191, __pyx_L1_error)
   }
 
-  /* "src/cbiogeme.pyx":150
+  /* "src/cbiogeme.pyx":186
  * 
  * 		cdef double_matrix_view r_view = r
  * 		self.theBiogeme.simulateSeveralFormulas(formulas,             # <<<<<<<<<<<<<<
- * 					        	      betas,
+ * 				        	      betas,
  *    						      fixedBetas,
  */
   try {
     __pyx_v_self->theBiogeme.simulateSeveralFormulas(__pyx_t_9, __pyx_t_10, __pyx_t_11, __pyx_t_12, __pyx_t_13, (&(*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_r_view.data + __pyx_t_14 * __pyx_v_r_view.strides[0]) )) + __pyx_t_15)) )))));
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    __PYX_ERR(0, 150, __pyx_L1_error)
+    __PYX_ERR(1, 186, __pyx_L1_error)
   }
 
-  /* "src/cbiogeme.pyx":156
+  /* "src/cbiogeme.pyx":192
  * 						      d,
  * 						      &r_view[0,0])
  * 		return r             # <<<<<<<<<<<<<<
  * 
  * 	def setExpressions(self,loglikeFormulas,nbrOfThreads,weightFormulas=None):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_r);
   __pyx_r = __pyx_v_r;
   goto __pyx_L0;
 
-  /* "src/cbiogeme.pyx":140
+  /* "src/cbiogeme.pyx":176
  * 		return r
  * 
  * 	def simulateSeveralFormulas(self, formulas, betas, fixedBetas, d, nThreads):             # <<<<<<<<<<<<<<
  * 		n = d.shape[0]
  * 		nf = len(formulas)
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __PYX_XDEC_MEMVIEW(&__pyx_t_8, 1);
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.simulateSeveralFormulas", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.simulateSeveralFormulas", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_n);
   __Pyx_XDECREF(__pyx_v_r);
   __PYX_XDEC_MEMVIEW(&__pyx_v_r_view, 1);
   __Pyx_XDECREF(__pyx_v_d);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "src/cbiogeme.pyx":158
+/* "src/cbiogeme.pyx":194
  * 		return r
  * 
  * 	def setExpressions(self,loglikeFormulas,nbrOfThreads,weightFormulas=None):             # <<<<<<<<<<<<<<
  * 		cdef vector[string] w
  * 		if (weightFormulas is not None):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_15setExpressions(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_14setExpressions[] = "pyBiogeme.setExpressions(self, loglikeFormulas, nbrOfThreads, weightFormulas=None)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_15setExpressions(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_17setExpressions(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_16setExpressions[] = "pyBiogeme.setExpressions(self, loglikeFormulas, nbrOfThreads, weightFormulas=None)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_17setExpressions(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_loglikeFormulas = 0;
   PyObject *__pyx_v_nbrOfThreads = 0;
   PyObject *__pyx_v_weightFormulas = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
@@ -4727,25 +5281,25 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_loglikeFormulas)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nbrOfThreads)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("setExpressions", 0, 2, 3, 1); __PYX_ERR(0, 158, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("setExpressions", 0, 2, 3, 1); __PYX_ERR(1, 194, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_weightFormulas);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setExpressions") < 0)) __PYX_ERR(0, 158, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setExpressions") < 0)) __PYX_ERR(1, 194, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
@@ -4755,451 +5309,451 @@
     }
     __pyx_v_loglikeFormulas = values[0];
     __pyx_v_nbrOfThreads = values[1];
     __pyx_v_weightFormulas = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("setExpressions", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 158, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("setExpressions", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 194, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.setExpressions", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.setExpressions", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_14setExpressions(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_loglikeFormulas, __pyx_v_nbrOfThreads, __pyx_v_weightFormulas);
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_16setExpressions(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), __pyx_v_loglikeFormulas, __pyx_v_nbrOfThreads, __pyx_v_weightFormulas);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_14setExpressions(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_loglikeFormulas, PyObject *__pyx_v_nbrOfThreads, PyObject *__pyx_v_weightFormulas) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_16setExpressions(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_loglikeFormulas, PyObject *__pyx_v_nbrOfThreads, PyObject *__pyx_v_weightFormulas) {
   std::vector<std::string>  __pyx_v_w;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   std::vector<std::string>  __pyx_t_3;
   unsigned long __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setExpressions", 0);
 
-  /* "src/cbiogeme.pyx":160
+  /* "src/cbiogeme.pyx":196
  * 	def setExpressions(self,loglikeFormulas,nbrOfThreads,weightFormulas=None):
  * 		cdef vector[string] w
  * 		if (weightFormulas is not None):             # <<<<<<<<<<<<<<
  * 			w = weightFormulas
  * 		self.theBiogeme.setExpressions(loglikeFormulas,w,nbrOfThreads)
  */
   __pyx_t_1 = (__pyx_v_weightFormulas != Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "src/cbiogeme.pyx":161
+    /* "src/cbiogeme.pyx":197
  * 		cdef vector[string] w
  * 		if (weightFormulas is not None):
  * 			w = weightFormulas             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.setExpressions(loglikeFormulas,w,nbrOfThreads)
  * 
  */
-    __pyx_t_3 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_v_weightFormulas); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 161, __pyx_L1_error)
+    __pyx_t_3 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_v_weightFormulas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 197, __pyx_L1_error)
     __pyx_v_w = __pyx_t_3;
 
-    /* "src/cbiogeme.pyx":160
+    /* "src/cbiogeme.pyx":196
  * 	def setExpressions(self,loglikeFormulas,nbrOfThreads,weightFormulas=None):
  * 		cdef vector[string] w
  * 		if (weightFormulas is not None):             # <<<<<<<<<<<<<<
  * 			w = weightFormulas
  * 		self.theBiogeme.setExpressions(loglikeFormulas,w,nbrOfThreads)
  */
   }
 
-  /* "src/cbiogeme.pyx":162
+  /* "src/cbiogeme.pyx":198
  * 		if (weightFormulas is not None):
  * 			w = weightFormulas
  * 		self.theBiogeme.setExpressions(loglikeFormulas,w,nbrOfThreads)             # <<<<<<<<<<<<<<
  * 
  * 	def setData(self, d):
  */
-  __pyx_t_3 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_v_loglikeFormulas); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 162, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyInt_As_unsigned_long(__pyx_v_nbrOfThreads); if (unlikely((__pyx_t_4 == (unsigned long)-1) && PyErr_Occurred())) __PYX_ERR(0, 162, __pyx_L1_error)
+  __pyx_t_3 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_v_loglikeFormulas); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 198, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_As_unsigned_long(__pyx_v_nbrOfThreads); if (unlikely((__pyx_t_4 == (unsigned long)-1) && PyErr_Occurred())) __PYX_ERR(1, 198, __pyx_L1_error)
   __pyx_v_self->theBiogeme.setExpressions(__pyx_t_3, __pyx_v_w, __pyx_t_4);
 
-  /* "src/cbiogeme.pyx":158
+  /* "src/cbiogeme.pyx":194
  * 		return r
  * 
  * 	def setExpressions(self,loglikeFormulas,nbrOfThreads,weightFormulas=None):             # <<<<<<<<<<<<<<
  * 		cdef vector[string] w
  * 		if (weightFormulas is not None):
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.setExpressions", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.setExpressions", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "src/cbiogeme.pyx":164
+/* "src/cbiogeme.pyx":200
  * 		self.theBiogeme.setExpressions(loglikeFormulas,w,nbrOfThreads)
  * 
  * 	def setData(self, d):             # <<<<<<<<<<<<<<
  * 		d = np.ascontiguousarray(d)
  * 		self.theBiogeme.setData(d)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_17setData(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_16setData[] = "pyBiogeme.setData(self, d)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_17setData(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_19setData(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_18setData[] = "pyBiogeme.setData(self, d)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_19setData(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("setData (wrapper)", 0);
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_16setData(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), ((PyObject *)__pyx_v_d));
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_18setData(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), ((PyObject *)__pyx_v_d));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_16setData(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_d) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_18setData(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
-  __pyx_t_7biogeme_8cbiogeme_double_matrix __pyx_t_4;
+  __pyx_t_3src_8cbiogeme_double_matrix __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setData", 0);
   __Pyx_INCREF(__pyx_v_d);
 
-  /* "src/cbiogeme.pyx":165
+  /* "src/cbiogeme.pyx":201
  * 
  * 	def setData(self, d):
  * 		d = np.ascontiguousarray(d)             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.setData(d)
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 165, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 201, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 165, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 201, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_d) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_d);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 165, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 201, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_d, __pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "src/cbiogeme.pyx":166
+  /* "src/cbiogeme.pyx":202
  * 	def setData(self, d):
  * 		d = np.ascontiguousarray(d)
  * 		self.theBiogeme.setData(d)             # <<<<<<<<<<<<<<
  * 
  * 	def setDataMap(self, m):
  */
-  __pyx_t_4 = __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector(__pyx_v_d); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 166, __pyx_L1_error)
+  __pyx_t_4 = __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector(__pyx_v_d); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 202, __pyx_L1_error)
   __pyx_v_self->theBiogeme.setData(__pyx_t_4);
 
-  /* "src/cbiogeme.pyx":164
+  /* "src/cbiogeme.pyx":200
  * 		self.theBiogeme.setExpressions(loglikeFormulas,w,nbrOfThreads)
  * 
  * 	def setData(self, d):             # <<<<<<<<<<<<<<
  * 		d = np.ascontiguousarray(d)
  * 		self.theBiogeme.setData(d)
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.setData", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.setData", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_d);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "src/cbiogeme.pyx":168
+/* "src/cbiogeme.pyx":204
  * 		self.theBiogeme.setData(d)
  * 
  * 	def setDataMap(self, m):             # <<<<<<<<<<<<<<
  * 		m = np.ascontiguousarray(m)
  * 		self.theBiogeme.setDataMap(m)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_19setDataMap(PyObject *__pyx_v_self, PyObject *__pyx_v_m); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_18setDataMap[] = "pyBiogeme.setDataMap(self, m)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_19setDataMap(PyObject *__pyx_v_self, PyObject *__pyx_v_m) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_21setDataMap(PyObject *__pyx_v_self, PyObject *__pyx_v_m); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_20setDataMap[] = "pyBiogeme.setDataMap(self, m)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_21setDataMap(PyObject *__pyx_v_self, PyObject *__pyx_v_m) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("setDataMap (wrapper)", 0);
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_18setDataMap(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), ((PyObject *)__pyx_v_m));
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_20setDataMap(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), ((PyObject *)__pyx_v_m));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_18setDataMap(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_m) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_20setDataMap(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_m) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
-  __pyx_t_7biogeme_8cbiogeme_uint_matrix __pyx_t_4;
+  __pyx_t_3src_8cbiogeme_uint_matrix __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setDataMap", 0);
   __Pyx_INCREF(__pyx_v_m);
 
-  /* "src/cbiogeme.pyx":169
+  /* "src/cbiogeme.pyx":205
  * 
  * 	def setDataMap(self, m):
  * 		m = np.ascontiguousarray(m)             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.setDataMap(m)
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 169, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 205, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 169, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 205, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_m) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_m);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 169, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 205, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_m, __pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "src/cbiogeme.pyx":170
+  /* "src/cbiogeme.pyx":206
  * 	def setDataMap(self, m):
  * 		m = np.ascontiguousarray(m)
  * 		self.theBiogeme.setDataMap(m)             # <<<<<<<<<<<<<<
  * 
  * 	def setMissingData(self, md):
  */
-  __pyx_t_4 = __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_uint_vector(__pyx_v_m); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 170, __pyx_L1_error)
+  __pyx_t_4 = __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_uint_vector(__pyx_v_m); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 206, __pyx_L1_error)
   __pyx_v_self->theBiogeme.setDataMap(__pyx_t_4);
 
-  /* "src/cbiogeme.pyx":168
+  /* "src/cbiogeme.pyx":204
  * 		self.theBiogeme.setData(d)
  * 
  * 	def setDataMap(self, m):             # <<<<<<<<<<<<<<
  * 		m = np.ascontiguousarray(m)
  * 		self.theBiogeme.setDataMap(m)
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.setDataMap", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.setDataMap", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_m);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "src/cbiogeme.pyx":172
+/* "src/cbiogeme.pyx":208
  * 		self.theBiogeme.setDataMap(m)
  * 
  * 	def setMissingData(self, md):             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.setMissingData(md)
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_21setMissingData(PyObject *__pyx_v_self, PyObject *__pyx_v_md); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_20setMissingData[] = "pyBiogeme.setMissingData(self, md)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_21setMissingData(PyObject *__pyx_v_self, PyObject *__pyx_v_md) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_23setMissingData(PyObject *__pyx_v_self, PyObject *__pyx_v_md); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_22setMissingData[] = "pyBiogeme.setMissingData(self, md)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_23setMissingData(PyObject *__pyx_v_self, PyObject *__pyx_v_md) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("setMissingData (wrapper)", 0);
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_20setMissingData(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), ((PyObject *)__pyx_v_md));
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_22setMissingData(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), ((PyObject *)__pyx_v_md));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_20setMissingData(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_md) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_22setMissingData(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_md) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   double __pyx_t_1;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setMissingData", 0);
 
-  /* "src/cbiogeme.pyx":173
+  /* "src/cbiogeme.pyx":209
  * 
  * 	def setMissingData(self, md):
  * 		self.theBiogeme.setMissingData(md)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __pyx_PyFloat_AsDouble(__pyx_v_md); if (unlikely((__pyx_t_1 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 173, __pyx_L1_error)
+  __pyx_t_1 = __pyx_PyFloat_AsDouble(__pyx_v_md); if (unlikely((__pyx_t_1 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 209, __pyx_L1_error)
   __pyx_v_self->theBiogeme.setMissingData(__pyx_t_1);
 
-  /* "src/cbiogeme.pyx":172
+  /* "src/cbiogeme.pyx":208
  * 		self.theBiogeme.setDataMap(m)
  * 
  * 	def setMissingData(self, md):             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.setMissingData(md)
  * 
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.setMissingData", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.setMissingData", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "src/cbiogeme.pyx":176
+/* "src/cbiogeme.pyx":212
  * 
  * 
  * 	def setDraws(self, draws):             # <<<<<<<<<<<<<<
  * 		draws = np.ascontiguousarray(draws)
  * 		self.theBiogeme.setDraws(draws)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_23setDraws(PyObject *__pyx_v_self, PyObject *__pyx_v_draws); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_22setDraws[] = "pyBiogeme.setDraws(self, draws)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_23setDraws(PyObject *__pyx_v_self, PyObject *__pyx_v_draws) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_25setDraws(PyObject *__pyx_v_self, PyObject *__pyx_v_draws); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_24setDraws[] = "pyBiogeme.setDraws(self, draws)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_25setDraws(PyObject *__pyx_v_self, PyObject *__pyx_v_draws) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("setDraws (wrapper)", 0);
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_22setDraws(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), ((PyObject *)__pyx_v_draws));
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_24setDraws(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), ((PyObject *)__pyx_v_draws));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_22setDraws(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_draws) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_24setDraws(struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, PyObject *__pyx_v_draws) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
-  __pyx_t_7biogeme_8cbiogeme_double_tensor __pyx_t_4;
+  __pyx_t_3src_8cbiogeme_double_tensor __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setDraws", 0);
   __Pyx_INCREF(__pyx_v_draws);
 
-  /* "src/cbiogeme.pyx":177
+  /* "src/cbiogeme.pyx":213
  * 
  * 	def setDraws(self, draws):
  * 		draws = np.ascontiguousarray(draws)             # <<<<<<<<<<<<<<
  * 		self.theBiogeme.setDraws(draws)
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 177, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 213, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 177, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 213, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_draws) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_draws);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 177, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 213, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_draws, __pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "src/cbiogeme.pyx":178
+  /* "src/cbiogeme.pyx":214
  * 	def setDraws(self, draws):
  * 		draws = np.ascontiguousarray(draws)
  * 		self.theBiogeme.setDraws(draws)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_4 = __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_matrix(__pyx_v_draws); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 178, __pyx_L1_error)
+  __pyx_t_4 = __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_matrix(__pyx_v_draws); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 214, __pyx_L1_error)
   __pyx_v_self->theBiogeme.setDraws(__pyx_t_4);
 
-  /* "src/cbiogeme.pyx":176
+  /* "src/cbiogeme.pyx":212
  * 
  * 
  * 	def setDraws(self, draws):             # <<<<<<<<<<<<<<
  * 		draws = np.ascontiguousarray(draws)
  * 		self.theBiogeme.setDraws(draws)
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.setDraws", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.setDraws", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_draws);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
@@ -5207,123 +5761,123 @@
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_25__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_24__reduce_cython__[] = "pyBiogeme.__reduce_cython__(self)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_25__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_27__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_26__reduce_cython__[] = "pyBiogeme.__reduce_cython__(self)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_27__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_24__reduce_cython__(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self));
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_26__reduce_cython__(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_24__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_26__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 2, __pyx_L1_error)
+  __PYX_ERR(0, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":3
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_27__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
-static char __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_26__setstate_cython__[] = "pyBiogeme.__setstate_cython__(self, __pyx_state)";
-static PyObject *__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_27__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_29__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static char __pyx_doc_3src_8cbiogeme_9pyBiogeme_28__setstate_cython__[] = "pyBiogeme.__setstate_cython__(self, __pyx_state)";
+static PyObject *__pyx_pw_3src_8cbiogeme_9pyBiogeme_29__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_26__setstate_cython__(((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
+  __pyx_r = __pyx_pf_3src_8cbiogeme_9pyBiogeme_28__setstate_cython__(((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_7biogeme_8cbiogeme_9pyBiogeme_26__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
+static PyObject *__pyx_pf_3src_8cbiogeme_9pyBiogeme_28__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_3src_8cbiogeme_pyBiogeme *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 4, __pyx_L1_error)
+  __PYX_ERR(0, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("biogeme.cbiogeme.pyBiogeme.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("src.cbiogeme.pyBiogeme.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":735
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":734
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
@@ -5332,29 +5886,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":736
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":735
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 736, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 735, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":735
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":734
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
@@ -5365,15 +5919,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":738
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":737
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
@@ -5382,29 +5936,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":739
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":738
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 739, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 738, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":738
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":737
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
@@ -5415,15 +5969,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":741
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":740
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
@@ -5432,29 +5986,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":742
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":741
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 742, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 741, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":741
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":740
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
@@ -5465,15 +6019,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":744
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":743
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
@@ -5482,29 +6036,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":745
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":744
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 745, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 744, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":744
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":743
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
@@ -5515,15 +6069,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":747
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":746
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
@@ -5532,29 +6086,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":748
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":747
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 748, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 747, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":747
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":746
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
@@ -5565,212 +6119,212 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":750
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":749
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyDataType_SHAPE(PyArray_Descr *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("PyDataType_SHAPE", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":751
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":750
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   __pyx_t_1 = (PyDataType_HASSUBARRAY(__pyx_v_d) != 0);
   if (__pyx_t_1) {
 
-    /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":752
+    /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":751
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape             # <<<<<<<<<<<<<<
  *     else:
  *         return ()
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject*)__pyx_v_d->subarray->shape));
     __pyx_r = ((PyObject*)__pyx_v_d->subarray->shape);
     goto __pyx_L0;
 
-    /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":751
+    /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":750
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   }
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":754
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":753
  *         return <tuple>d.subarray.shape
  *     else:
  *         return ()             # <<<<<<<<<<<<<<
  * 
  * 
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_empty_tuple);
     __pyx_r = __pyx_empty_tuple;
     goto __pyx_L0;
   }
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":750
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":749
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":931
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":928
  *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
 static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("set_array_base", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":932
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":929
  * 
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!             # <<<<<<<<<<<<<<
  *     PyArray_SetBaseObject(arr, base)
  * 
  */
   Py_INCREF(__pyx_v_base);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":933
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":930
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object get_array_base(ndarray arr):
  */
   (void)(PyArray_SetBaseObject(__pyx_v_arr, __pyx_v_base));
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":931
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":928
  *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":935
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":932
  *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
   PyObject *__pyx_v_base;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("get_array_base", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":936
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":933
  * 
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)             # <<<<<<<<<<<<<<
  *     if base is NULL:
  *         return None
  */
   __pyx_v_base = PyArray_BASE(__pyx_v_arr);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":937
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":934
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
   __pyx_t_1 = ((__pyx_v_base == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":938
+    /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":935
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  *         return None             # <<<<<<<<<<<<<<
  *     return <object>base
  * 
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":937
+    /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":934
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
   }
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":939
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":936
  *     if base is NULL:
  *         return None
  *     return <object>base             # <<<<<<<<<<<<<<
  * 
  * # Versions of the import_* functions which are more suitable for
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_base));
   __pyx_r = ((PyObject *)__pyx_v_base);
   goto __pyx_L0;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":935
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":932
  *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":943
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":940
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -5786,15 +6340,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_array", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":944
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
   {
@@ -5802,84 +6356,84 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":945
+      /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":942
  * cdef inline int import_array() except -1:
  *     try:
  *         __pyx_import_array()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")
  */
-      __pyx_t_4 = _import_array(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 945, __pyx_L3_error)
+      __pyx_t_4 = _import_array(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 942, __pyx_L3_error)
 
-      /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":944
+      /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":946
+    /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":943
  *     try:
  *         __pyx_import_array()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 946, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 943, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":947
+      /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":944
  *         __pyx_import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_umath() except -1:
  */
-      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 947, __pyx_L5_except_error)
+      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 944, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __PYX_ERR(2, 947, __pyx_L5_except_error)
+      __PYX_ERR(2, 944, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":944
+    /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":943
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":940
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -5894,15 +6448,15 @@
   __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":949
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":946
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -5918,15 +6472,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_umath", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":950
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":947
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -5934,84 +6488,84 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":951
+      /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":948
  * cdef inline int import_umath() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
-      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 951, __pyx_L3_error)
+      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 948, __pyx_L3_error)
 
-      /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":950
+      /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":947
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":952
+    /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":949
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 952, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 949, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":953
+      /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":950
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_ufunc() except -1:
  */
-      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 953, __pyx_L5_except_error)
+      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 950, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __PYX_ERR(2, 953, __pyx_L5_except_error)
+      __PYX_ERR(2, 950, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":950
+    /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":947
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":949
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":946
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -6026,15 +6580,15 @@
   __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":955
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":952
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -6050,15 +6604,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_ufunc", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":956
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":953
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -6066,84 +6620,84 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":957
+      /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":954
  * cdef inline int import_ufunc() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
-      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 957, __pyx_L3_error)
+      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 954, __pyx_L3_error)
 
-      /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":956
+      /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":953
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":958
+    /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":955
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 958, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 955, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":959
+      /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":956
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef extern from *:
  */
-      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 959, __pyx_L5_except_error)
+      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 956, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __PYX_ERR(2, 959, __pyx_L5_except_error)
+      __PYX_ERR(2, 956, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":956
+    /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":953
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":955
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":952
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -6158,176 +6712,176 @@
   __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":969
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":966
  * 
  * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_timedelta64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_timedelta64_object", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":981
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":978
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyTimedeltaArrType_Type)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyTimedeltaArrType_Type));
   goto __pyx_L0;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":969
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":966
  * 
  * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":984
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":981
  * 
  * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_datetime64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_datetime64_object", 0);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":996
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":993
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyDatetimeArrType_Type)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyDatetimeArrType_Type));
   goto __pyx_L0;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":984
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":981
  * 
  * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":999
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":996
  * 
  * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
 static CYTHON_INLINE npy_datetime __pyx_f_5numpy_get_datetime64_value(PyObject *__pyx_v_obj) {
   npy_datetime __pyx_r;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":1006
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":1003
  *     also needed.  That can be found using `get_datetime64_unit`.
  *     """
  *     return (<PyDatetimeScalarObject*>obj).obval             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((PyDatetimeScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":999
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":996
  * 
  * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":1009
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":1006
  * 
  * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
 static CYTHON_INLINE npy_timedelta __pyx_f_5numpy_get_timedelta64_value(PyObject *__pyx_v_obj) {
   npy_timedelta __pyx_r;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":1013
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":1010
  *     returns the int64 value underlying scalar numpy timedelta64 object
  *     """
  *     return (<PyTimedeltaScalarObject*>obj).obval             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((PyTimedeltaScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":1009
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":1006
  * 
  * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":1016
+/* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":1013
  * 
  * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
 static CYTHON_INLINE NPY_DATETIMEUNIT __pyx_f_5numpy_get_datetime64_unit(PyObject *__pyx_v_obj) {
   NPY_DATETIMEUNIT __pyx_r;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":1020
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":1017
  *     returns the unit part of the dtype for a numpy datetime64 object.
  *     """
  *     return <NPY_DATETIMEUNIT>(<PyDatetimeScalarObject*>obj).obmeta.base             # <<<<<<<<<<<<<<
  */
   __pyx_r = ((NPY_DATETIMEUNIT)((PyDatetimeScalarObject *)__pyx_v_obj)->obmeta.base);
   goto __pyx_L0;
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":1016
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":1013
  * 
  * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
@@ -6366,44 +6920,44 @@
  *         v.push_back(<X>item)
  *     return v
  */
   if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
     __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
     __pyx_t_3 = NULL;
   } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 47, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 47, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_3)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       } else {
         if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       }
     } else {
       __pyx_t_4 = __pyx_t_3(__pyx_t_1);
       if (unlikely(!__pyx_t_4)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 47, __pyx_L1_error)
+          else __PYX_ERR(0, 47, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_4);
     }
     __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
     __pyx_t_4 = 0;
@@ -6411,15 +6965,15 @@
     /* "vector.from_py":48
  *     cdef vector[X] v
  *     for item in o:
  *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
  *     return v
  * 
  */
-    __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_v_item); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
+    __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_v_item); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L1_error)
     __pyx_v_v.push_back(((double)__pyx_t_5));
 
     /* "vector.from_py":47
  * cdef vector[X] __pyx_convert_vector_from_py_double(object o) except *:
  *     cdef vector[X] v
  *     for item in o:             # <<<<<<<<<<<<<<
  *         v.push_back(<X>item)
@@ -6480,44 +7034,44 @@
  *         v.push_back(<X>item)
  *     return v
  */
   if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
     __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
     __pyx_t_3 = NULL;
   } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 47, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 47, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_3)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       } else {
         if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       }
     } else {
       __pyx_t_4 = __pyx_t_3(__pyx_t_1);
       if (unlikely(!__pyx_t_4)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 47, __pyx_L1_error)
+          else __PYX_ERR(0, 47, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_4);
     }
     __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
     __pyx_t_4 = 0;
@@ -6525,15 +7079,15 @@
     /* "vector.from_py":48
  *     cdef vector[X] v
  *     for item in o:
  *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
  *     return v
  * 
  */
-    __pyx_t_5 = __Pyx_PyInt_As_unsigned_long(__pyx_v_item); if (unlikely((__pyx_t_5 == (unsigned long)-1) && PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyInt_As_unsigned_long(__pyx_v_item); if (unlikely((__pyx_t_5 == (unsigned long)-1) && PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L1_error)
     __pyx_v_v.push_back(((unsigned long)__pyx_t_5));
 
     /* "vector.from_py":47
  * cdef vector[X] __pyx_convert_vector_from_py_unsigned_long(object o) except *:
  *     cdef vector[X] v
  *     for item in o:             # <<<<<<<<<<<<<<
  *         v.push_back(<X>item)
@@ -6603,15 +7157,15 @@
   /* "string.from_py":15
  * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
  *     cdef Py_ssize_t length = 0
  *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
  *     return string(data, length)
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == ((char const *)NULL))) __PYX_ERR(1, 15, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == ((char const *)NULL))) __PYX_ERR(0, 15, __pyx_L1_error)
   __pyx_v_data = __pyx_t_1;
 
   /* "string.from_py":16
  *     cdef Py_ssize_t length = 0
  *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
  *     return string(data, length)             # <<<<<<<<<<<<<<
  * 
@@ -6667,44 +7221,44 @@
  *         v.push_back(<X>item)
  *     return v
  */
   if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
     __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
     __pyx_t_3 = NULL;
   } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 47, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 47, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_3)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       } else {
         if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       }
     } else {
       __pyx_t_4 = __pyx_t_3(__pyx_t_1);
       if (unlikely(!__pyx_t_4)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 47, __pyx_L1_error)
+          else __PYX_ERR(0, 47, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_4);
     }
     __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
     __pyx_t_4 = 0;
@@ -6712,15 +7266,15 @@
     /* "vector.from_py":48
  *     cdef vector[X] v
  *     for item in o:
  *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
  *     return v
  * 
  */
-    __pyx_t_5 = __pyx_convert_string_from_py_std__in_string(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
+    __pyx_t_5 = __pyx_convert_string_from_py_std__in_string(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L1_error)
     __pyx_v_v.push_back(((std::string)__pyx_t_5));
 
     /* "vector.from_py":47
  * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:
  *     cdef vector[X] v
  *     for item in o:             # <<<<<<<<<<<<<<
  *         v.push_back(<X>item)
@@ -6755,70 +7309,70 @@
   __Pyx_pretend_to_initialize(&__pyx_r);
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_item);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static std::vector<__pyx_t_7biogeme_8cbiogeme_double_vector>  __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector(PyObject *__pyx_v_o) {
-  std::vector<__pyx_t_7biogeme_8cbiogeme_double_vector>  __pyx_v_v;
+static std::vector<__pyx_t_3src_8cbiogeme_double_vector>  __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector(PyObject *__pyx_v_o) {
+  std::vector<__pyx_t_3src_8cbiogeme_double_vector>  __pyx_v_v;
   PyObject *__pyx_v_item = NULL;
-  std::vector<__pyx_t_7biogeme_8cbiogeme_double_vector>  __pyx_r;
+  std::vector<__pyx_t_3src_8cbiogeme_double_vector>  __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t __pyx_t_2;
   PyObject *(*__pyx_t_3)(PyObject *);
   PyObject *__pyx_t_4 = NULL;
-  __pyx_t_7biogeme_8cbiogeme_double_vector __pyx_t_5;
+  __pyx_t_3src_8cbiogeme_double_vector __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector", 0);
+  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector", 0);
 
   /* "vector.from_py":47
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector(object o) except *:
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector(object o) except *:
  *     cdef vector[X] v
  *     for item in o:             # <<<<<<<<<<<<<<
  *         v.push_back(<X>item)
  *     return v
  */
   if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
     __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
     __pyx_t_3 = NULL;
   } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 47, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 47, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_3)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       } else {
         if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       }
     } else {
       __pyx_t_4 = __pyx_t_3(__pyx_t_1);
       if (unlikely(!__pyx_t_4)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 47, __pyx_L1_error)
+          else __PYX_ERR(0, 47, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_4);
     }
     __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
     __pyx_t_4 = 0;
@@ -6826,19 +7380,19 @@
     /* "vector.from_py":48
  *     cdef vector[X] v
  *     for item in o:
  *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
  *     return v
  * 
  */
-    __pyx_t_5 = __pyx_convert_vector_from_py_double(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
-    __pyx_v_v.push_back(((__pyx_t_7biogeme_8cbiogeme_double_vector)__pyx_t_5));
+    __pyx_t_5 = __pyx_convert_vector_from_py_double(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L1_error)
+    __pyx_v_v.push_back(((__pyx_t_3src_8cbiogeme_double_vector)__pyx_t_5));
 
     /* "vector.from_py":47
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector(object o) except *:
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector(object o) except *:
  *     cdef vector[X] v
  *     for item in o:             # <<<<<<<<<<<<<<
  *         v.push_back(<X>item)
  *     return v
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
@@ -6851,88 +7405,88 @@
  * 
  */
   __pyx_r = __pyx_v_v;
   goto __pyx_L0;
 
   /* "vector.from_py":45
  * 
- * @cname("__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector")
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector(object o) except *:             # <<<<<<<<<<<<<<
+ * @cname("__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector")
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector(object o) except *:             # <<<<<<<<<<<<<<
  *     cdef vector[X] v
  *     for item in o:
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_pretend_to_initialize(&__pyx_r);
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_item);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static std::vector<__pyx_t_7biogeme_8cbiogeme_string_vector>  __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_string_vector(PyObject *__pyx_v_o) {
-  std::vector<__pyx_t_7biogeme_8cbiogeme_string_vector>  __pyx_v_v;
+static std::vector<__pyx_t_3src_8cbiogeme_string_vector>  __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_string_vector(PyObject *__pyx_v_o) {
+  std::vector<__pyx_t_3src_8cbiogeme_string_vector>  __pyx_v_v;
   PyObject *__pyx_v_item = NULL;
-  std::vector<__pyx_t_7biogeme_8cbiogeme_string_vector>  __pyx_r;
+  std::vector<__pyx_t_3src_8cbiogeme_string_vector>  __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t __pyx_t_2;
   PyObject *(*__pyx_t_3)(PyObject *);
   PyObject *__pyx_t_4 = NULL;
-  __pyx_t_7biogeme_8cbiogeme_string_vector __pyx_t_5;
+  __pyx_t_3src_8cbiogeme_string_vector __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_string_vector", 0);
+  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_string_vector", 0);
 
   /* "vector.from_py":47
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_string_vector(object o) except *:
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_string_vector(object o) except *:
  *     cdef vector[X] v
  *     for item in o:             # <<<<<<<<<<<<<<
  *         v.push_back(<X>item)
  *     return v
  */
   if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
     __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
     __pyx_t_3 = NULL;
   } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 47, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 47, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_3)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       } else {
         if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       }
     } else {
       __pyx_t_4 = __pyx_t_3(__pyx_t_1);
       if (unlikely(!__pyx_t_4)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 47, __pyx_L1_error)
+          else __PYX_ERR(0, 47, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_4);
     }
     __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
     __pyx_t_4 = 0;
@@ -6940,19 +7494,19 @@
     /* "vector.from_py":48
  *     cdef vector[X] v
  *     for item in o:
  *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
  *     return v
  * 
  */
-    __pyx_t_5 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
-    __pyx_v_v.push_back(((__pyx_t_7biogeme_8cbiogeme_string_vector)__pyx_t_5));
+    __pyx_t_5 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L1_error)
+    __pyx_v_v.push_back(((__pyx_t_3src_8cbiogeme_string_vector)__pyx_t_5));
 
     /* "vector.from_py":47
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_string_vector(object o) except *:
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_string_vector(object o) except *:
  *     cdef vector[X] v
  *     for item in o:             # <<<<<<<<<<<<<<
  *         v.push_back(<X>item)
  *     return v
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
@@ -6965,88 +7519,88 @@
  * 
  */
   __pyx_r = __pyx_v_v;
   goto __pyx_L0;
 
   /* "vector.from_py":45
  * 
- * @cname("__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_string_vector")
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_string_vector(object o) except *:             # <<<<<<<<<<<<<<
+ * @cname("__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_string_vector")
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_string_vector(object o) except *:             # <<<<<<<<<<<<<<
  *     cdef vector[X] v
  *     for item in o:
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_string_vector", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_string_vector", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_pretend_to_initialize(&__pyx_r);
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_item);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static std::vector<__pyx_t_7biogeme_8cbiogeme_uint_vector>  __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_uint_vector(PyObject *__pyx_v_o) {
-  std::vector<__pyx_t_7biogeme_8cbiogeme_uint_vector>  __pyx_v_v;
+static std::vector<__pyx_t_3src_8cbiogeme_uint_vector>  __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_uint_vector(PyObject *__pyx_v_o) {
+  std::vector<__pyx_t_3src_8cbiogeme_uint_vector>  __pyx_v_v;
   PyObject *__pyx_v_item = NULL;
-  std::vector<__pyx_t_7biogeme_8cbiogeme_uint_vector>  __pyx_r;
+  std::vector<__pyx_t_3src_8cbiogeme_uint_vector>  __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t __pyx_t_2;
   PyObject *(*__pyx_t_3)(PyObject *);
   PyObject *__pyx_t_4 = NULL;
-  __pyx_t_7biogeme_8cbiogeme_uint_vector __pyx_t_5;
+  __pyx_t_3src_8cbiogeme_uint_vector __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_uint_vector", 0);
+  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_uint_vector", 0);
 
   /* "vector.from_py":47
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_uint_vector(object o) except *:
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_uint_vector(object o) except *:
  *     cdef vector[X] v
  *     for item in o:             # <<<<<<<<<<<<<<
  *         v.push_back(<X>item)
  *     return v
  */
   if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
     __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
     __pyx_t_3 = NULL;
   } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 47, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 47, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_3)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       } else {
         if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       }
     } else {
       __pyx_t_4 = __pyx_t_3(__pyx_t_1);
       if (unlikely(!__pyx_t_4)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 47, __pyx_L1_error)
+          else __PYX_ERR(0, 47, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_4);
     }
     __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
     __pyx_t_4 = 0;
@@ -7054,19 +7608,19 @@
     /* "vector.from_py":48
  *     cdef vector[X] v
  *     for item in o:
  *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
  *     return v
  * 
  */
-    __pyx_t_5 = __pyx_convert_vector_from_py_unsigned_long(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
-    __pyx_v_v.push_back(((__pyx_t_7biogeme_8cbiogeme_uint_vector)__pyx_t_5));
+    __pyx_t_5 = __pyx_convert_vector_from_py_unsigned_long(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L1_error)
+    __pyx_v_v.push_back(((__pyx_t_3src_8cbiogeme_uint_vector)__pyx_t_5));
 
     /* "vector.from_py":47
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_uint_vector(object o) except *:
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_uint_vector(object o) except *:
  *     cdef vector[X] v
  *     for item in o:             # <<<<<<<<<<<<<<
  *         v.push_back(<X>item)
  *     return v
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
@@ -7079,88 +7633,88 @@
  * 
  */
   __pyx_r = __pyx_v_v;
   goto __pyx_L0;
 
   /* "vector.from_py":45
  * 
- * @cname("__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_uint_vector")
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_uint_vector(object o) except *:             # <<<<<<<<<<<<<<
+ * @cname("__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_uint_vector")
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_uint_vector(object o) except *:             # <<<<<<<<<<<<<<
  *     cdef vector[X] v
  *     for item in o:
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_uint_vector", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_uint_vector", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_pretend_to_initialize(&__pyx_r);
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_item);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static std::vector<__pyx_t_7biogeme_8cbiogeme_double_matrix>  __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_matrix(PyObject *__pyx_v_o) {
-  std::vector<__pyx_t_7biogeme_8cbiogeme_double_matrix>  __pyx_v_v;
+static std::vector<__pyx_t_3src_8cbiogeme_double_matrix>  __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_matrix(PyObject *__pyx_v_o) {
+  std::vector<__pyx_t_3src_8cbiogeme_double_matrix>  __pyx_v_v;
   PyObject *__pyx_v_item = NULL;
-  std::vector<__pyx_t_7biogeme_8cbiogeme_double_matrix>  __pyx_r;
+  std::vector<__pyx_t_3src_8cbiogeme_double_matrix>  __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t __pyx_t_2;
   PyObject *(*__pyx_t_3)(PyObject *);
   PyObject *__pyx_t_4 = NULL;
-  __pyx_t_7biogeme_8cbiogeme_double_matrix __pyx_t_5;
+  __pyx_t_3src_8cbiogeme_double_matrix __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_matrix", 0);
+  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_matrix", 0);
 
   /* "vector.from_py":47
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_matrix(object o) except *:
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_matrix(object o) except *:
  *     cdef vector[X] v
  *     for item in o:             # <<<<<<<<<<<<<<
  *         v.push_back(<X>item)
  *     return v
  */
   if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
     __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
     __pyx_t_3 = NULL;
   } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 47, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 47, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_3)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       } else {
         if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       }
     } else {
       __pyx_t_4 = __pyx_t_3(__pyx_t_1);
       if (unlikely(!__pyx_t_4)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 47, __pyx_L1_error)
+          else __PYX_ERR(0, 47, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_4);
     }
     __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
     __pyx_t_4 = 0;
@@ -7168,19 +7722,19 @@
     /* "vector.from_py":48
  *     cdef vector[X] v
  *     for item in o:
  *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
  *     return v
  * 
  */
-    __pyx_t_5 = __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_vector(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
-    __pyx_v_v.push_back(((__pyx_t_7biogeme_8cbiogeme_double_matrix)__pyx_t_5));
+    __pyx_t_5 = __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_vector(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L1_error)
+    __pyx_v_v.push_back(((__pyx_t_3src_8cbiogeme_double_matrix)__pyx_t_5));
 
     /* "vector.from_py":47
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_matrix(object o) except *:
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_matrix(object o) except *:
  *     cdef vector[X] v
  *     for item in o:             # <<<<<<<<<<<<<<
  *         v.push_back(<X>item)
  *     return v
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
@@ -7193,25 +7747,25 @@
  * 
  */
   __pyx_r = __pyx_v_v;
   goto __pyx_L0;
 
   /* "vector.from_py":45
  * 
- * @cname("__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_matrix")
- * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_matrix(object o) except *:             # <<<<<<<<<<<<<<
+ * @cname("__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_matrix")
+ * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_matrix(object o) except *:             # <<<<<<<<<<<<<<
  *     cdef vector[X] v
  *     for item in o:
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py___pyx_t_7biogeme_8cbiogeme_double_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py___pyx_t_3src_8cbiogeme_double_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_pretend_to_initialize(&__pyx_r);
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_item);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -7263,21 +7817,21 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_shape)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_itemsize)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(1, 122, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(0, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_format)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(1, 122, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(0, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
           if (value) { values[3] = value; kw_args--; }
         }
@@ -7285,15 +7839,15 @@
         case  4:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allocate_buffer);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 122, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 122, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -7301,42 +7855,42 @@
         values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_shape = ((PyObject*)values[0]);
-    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 122, __pyx_L3_error)
+    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 122, __pyx_L3_error)
     __pyx_v_format = values[2];
     __pyx_v_mode = values[3];
     if (values[4]) {
-      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 123, __pyx_L3_error)
+      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 123, __pyx_L3_error)
     } else {
 
       /* "View.MemoryView":123
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,
  *                   mode="c", bint allocate_buffer=True):             # <<<<<<<<<<<<<<
  * 
  *         cdef int idx
  */
       __pyx_v_allocate_buffer = ((int)1);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 122, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 122, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.array.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(1, 122, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(0, 122, __pyx_L1_error)
   if (unlikely(((PyObject *)__pyx_v_format) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(1, 122, __pyx_L1_error)
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(0, 122, __pyx_L1_error)
   }
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(((struct __pyx_array_obj *)__pyx_v_self), __pyx_v_shape, __pyx_v_itemsize, __pyx_v_format, __pyx_v_mode, __pyx_v_allocate_buffer);
 
   /* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
@@ -7383,17 +7937,17 @@
  * 
  *         self.ndim = <int> len(shape)             # <<<<<<<<<<<<<<
  *         self.itemsize = itemsize
  * 
  */
   if (unlikely(__pyx_v_shape == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
-    __PYX_ERR(1, 129, __pyx_L1_error)
+    __PYX_ERR(0, 129, __pyx_L1_error)
   }
-  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(1, 129, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 129, __pyx_L1_error)
   __pyx_v_self->ndim = ((int)__pyx_t_1);
 
   /* "View.MemoryView":130
  * 
  *         self.ndim = <int> len(shape)
  *         self.itemsize = itemsize             # <<<<<<<<<<<<<<
  * 
@@ -7414,19 +7968,19 @@
     /* "View.MemoryView":133
  * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 133, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 133, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 133, __pyx_L1_error)
+    __PYX_ERR(0, 133, __pyx_L1_error)
 
     /* "View.MemoryView":132
  *         self.itemsize = itemsize
  * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
@@ -7446,19 +8000,19 @@
     /* "View.MemoryView":136
  * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 136, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 136, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 136, __pyx_L1_error)
+    __PYX_ERR(0, 136, __pyx_L1_error)
 
     /* "View.MemoryView":135
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
@@ -7479,29 +8033,29 @@
     /* "View.MemoryView":139
  * 
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')             # <<<<<<<<<<<<<<
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 139, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 139, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_6 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_n_s_ASCII) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_n_s_ASCII);
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 139, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 139, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_format, __pyx_t_3);
     __pyx_t_3 = 0;
 
     /* "View.MemoryView":138
  *             raise ValueError("itemsize <= 0 for cython.array")
@@ -7515,15 +8069,15 @@
   /* "View.MemoryView":140
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string             # <<<<<<<<<<<<<<
  *         self.format = self._format
  * 
  */
-  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_format)->tp_name), 0))) __PYX_ERR(1, 140, __pyx_L1_error)
+  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_format)->tp_name), 0))) __PYX_ERR(0, 140, __pyx_L1_error)
   __pyx_t_3 = __pyx_v_format;
   __Pyx_INCREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_3);
   __Pyx_GOTREF(__pyx_v_self->_format);
   __Pyx_DECREF(__pyx_v_self->_format);
   __pyx_v_self->_format = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
@@ -7533,17 +8087,17 @@
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format             # <<<<<<<<<<<<<<
  * 
  * 
  */
   if (unlikely(__pyx_v_self->_format == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
-    __PYX_ERR(1, 141, __pyx_L1_error)
+    __PYX_ERR(0, 141, __pyx_L1_error)
   }
-  __pyx_t_7 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(1, 141, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(0, 141, __pyx_L1_error)
   __pyx_v_self->format = __pyx_t_7;
 
   /* "View.MemoryView":144
  * 
  * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)             # <<<<<<<<<<<<<<
  *         self._strides = self._shape + self.ndim
@@ -7573,19 +8127,19 @@
     /* "View.MemoryView":148
  * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 148, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 148, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 148, __pyx_L1_error)
+    __PYX_ERR(0, 148, __pyx_L1_error)
 
     /* "View.MemoryView":147
  *         self._strides = self._shape + self.ndim
  * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
  *             raise MemoryError("unable to allocate shape and strides.")
  * 
@@ -7600,20 +8154,20 @@
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
   __pyx_t_8 = 0;
   __pyx_t_3 = __pyx_v_shape; __Pyx_INCREF(__pyx_t_3); __pyx_t_1 = 0;
   for (;;) {
     if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_5); __pyx_t_1++; if (unlikely(0 < 0)) __PYX_ERR(1, 151, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_5); __pyx_t_1++; if (unlikely(0 < 0)) __PYX_ERR(0, 151, __pyx_L1_error)
     #else
-    __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 151, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 151, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
-    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 151, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 151, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_9;
     __pyx_v_idx = __pyx_t_8;
     __pyx_t_8 = (__pyx_t_8 + 1);
 
     /* "View.MemoryView":152
  * 
@@ -7628,35 +8182,35 @@
       /* "View.MemoryView":153
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))             # <<<<<<<<<<<<<<
  *             self._shape[idx] = dim
  * 
  */
-      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 153, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 153, __pyx_L1_error)
+      __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
-      __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 153, __pyx_L1_error)
+      __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_GIVEREF(__pyx_t_5);
       PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_5);
       __Pyx_GIVEREF(__pyx_t_6);
       PyTuple_SET_ITEM(__pyx_t_10, 1, __pyx_t_6);
       __pyx_t_5 = 0;
       __pyx_t_6 = 0;
-      __pyx_t_6 = __Pyx_PyString_Format(__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 153, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyString_Format(__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 153, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_Raise(__pyx_t_10, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __PYX_ERR(1, 153, __pyx_L1_error)
+      __PYX_ERR(0, 153, __pyx_L1_error)
 
       /* "View.MemoryView":152
  * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
@@ -7685,15 +8239,15 @@
   /* "View.MemoryView":157
  * 
  *         cdef char order
  *         if mode == 'fortran':             # <<<<<<<<<<<<<<
  *             order = b'F'
  *             self.mode = u'fortran'
  */
-  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 157, __pyx_L1_error)
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 157, __pyx_L1_error)
   if (__pyx_t_4) {
 
     /* "View.MemoryView":158
  *         cdef char order
  *         if mode == 'fortran':
  *             order = b'F'             # <<<<<<<<<<<<<<
  *             self.mode = u'fortran'
@@ -7727,15 +8281,15 @@
   /* "View.MemoryView":160
  *             order = b'F'
  *             self.mode = u'fortran'
  *         elif mode == 'c':             # <<<<<<<<<<<<<<
  *             order = b'C'
  *             self.mode = u'c'
  */
-  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(1, 160, __pyx_L1_error)
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 160, __pyx_L1_error)
   if (likely(__pyx_t_4)) {
 
     /* "View.MemoryView":161
  *             self.mode = u'fortran'
  *         elif mode == 'c':
  *             order = b'C'             # <<<<<<<<<<<<<<
  *             self.mode = u'c'
@@ -7770,22 +8324,22 @@
  *             self.mode = u'c'
  *         else:
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)             # <<<<<<<<<<<<<<
  * 
  *         self.len = fill_contig_strides_array(self._shape, self._strides,
  */
   /*else*/ {
-    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_v_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 164, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_v_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 164, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 164, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 164, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_10, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    __PYX_ERR(1, 164, __pyx_L1_error)
+    __PYX_ERR(0, 164, __pyx_L1_error)
   }
   __pyx_L10:;
 
   /* "View.MemoryView":166
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
  * 
  *         self.len = fill_contig_strides_array(self._shape, self._strides,             # <<<<<<<<<<<<<<
@@ -7806,16 +8360,16 @@
   /* "View.MemoryView":170
  * 
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'             # <<<<<<<<<<<<<<
  *         if allocate_buffer:
  * 
  */
-  __pyx_t_10 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 170, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 170, __pyx_L1_error)
+  __pyx_t_10 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 170, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 170, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
   __pyx_v_self->dtype_is_object = __pyx_t_4;
 
   /* "View.MemoryView":171
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
@@ -7847,19 +8401,19 @@
       /* "View.MemoryView":176
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
  * 
  *             if self.dtype_is_object:
  */
-      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(1, 176, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 176, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_Raise(__pyx_t_10, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __PYX_ERR(1, 176, __pyx_L1_error)
+      __PYX_ERR(0, 176, __pyx_L1_error)
 
       /* "View.MemoryView":175
  * 
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:             # <<<<<<<<<<<<<<
  *                 raise MemoryError("unable to allocate array data.")
  * 
@@ -7890,19 +8444,19 @@
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):             # <<<<<<<<<<<<<<
  *                     p[i] = Py_None
  *                     Py_INCREF(Py_None)
  */
       if (unlikely(__pyx_v_itemsize == 0)) {
         PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-        __PYX_ERR(1, 180, __pyx_L1_error)
+        __PYX_ERR(0, 180, __pyx_L1_error)
       }
       else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_self->len))) {
         PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-        __PYX_ERR(1, 180, __pyx_L1_error)
+        __PYX_ERR(0, 180, __pyx_L1_error)
       }
       __pyx_t_1 = __Pyx_div_Py_ssize_t(__pyx_v_self->len, __pyx_v_itemsize);
       __pyx_t_9 = __pyx_t_1;
       for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_9; __pyx_t_11+=1) {
         __pyx_v_i = __pyx_t_11;
 
         /* "View.MemoryView":181
@@ -8021,15 +8575,15 @@
   /* "View.MemoryView":187
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1
  *         if self.mode == u"c":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":
  */
-  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 187, __pyx_L1_error)
+  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 187, __pyx_L1_error)
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
     /* "View.MemoryView":188
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
@@ -8051,15 +8605,15 @@
   /* "View.MemoryView":189
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  */
-  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 189, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 189, __pyx_L1_error)
   __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
     /* "View.MemoryView":190
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
@@ -8091,19 +8645,19 @@
     /* "View.MemoryView":192
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 192, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 192, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 192, __pyx_L1_error)
+    __PYX_ERR(0, 192, __pyx_L1_error)
 
     /* "View.MemoryView":191
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):             # <<<<<<<<<<<<<<
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
@@ -8438,15 +8992,15 @@
  *     @property
  *     def memview(self):
  *         return self.get_memview()             # <<<<<<<<<<<<<<
  * 
  *     @cname('get_memview')
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 223, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 223, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":222
  * 
@@ -8500,30 +9054,30 @@
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 228, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 228, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 228, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 228, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":226
@@ -8632,17 +9186,17 @@
  * 
  *     def __getattr__(self, attr):
  *         return getattr(self.memview, attr)             # <<<<<<<<<<<<<<
  * 
  *     def __getitem__(self, item):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 234, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 234, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":233
@@ -8700,17 +9254,17 @@
  * 
  *     def __getitem__(self, item):
  *         return self.memview[item]             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(self, item, value):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 237, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 237, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":236
@@ -8766,17 +9320,17 @@
   /* "View.MemoryView":240
  * 
  *     def __setitem__(self, item, value):
  *         self.memview[item] = value             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 240, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 240, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (unlikely(PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0)) __PYX_ERR(1, 240, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0)) __PYX_ERR(0, 240, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "View.MemoryView":239
  *         return self.memview[item]
  * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
@@ -8825,19 +9379,19 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 2, __pyx_L1_error)
+  __PYX_ERR(0, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
@@ -8881,19 +9435,19 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 4, __pyx_L1_error)
+  __PYX_ERR(0, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
@@ -8943,35 +9497,35 @@
     /* "View.MemoryView":249
  * 
  *     if buf == NULL:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))             # <<<<<<<<<<<<<<
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  */
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 249, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 249, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 249, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 249, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_shape);
     __Pyx_GIVEREF(__pyx_t_2);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_4);
     __pyx_t_2 = 0;
     __pyx_t_3 = 0;
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 249, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_4);
     __pyx_t_4 = 0;
 
     /* "View.MemoryView":248
  *     cdef array result
@@ -8987,21 +9541,21 @@
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
  *                        allocate_buffer=False)
  *         result.data = buf
  */
   /*else*/ {
-    __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
     PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_shape);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_5);
@@ -9015,26 +9569,26 @@
     /* "View.MemoryView":252
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  *                        allocate_buffer=False)             # <<<<<<<<<<<<<<
  *         result.data = buf
  * 
  */
-    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 252, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 252, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(1, 252, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(0, 252, __pyx_L1_error)
 
     /* "View.MemoryView":251
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
  *                        allocate_buffer=False)
  *         result.data = buf
  */
-    __pyx_t_5 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 251, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_5);
     __pyx_t_5 = 0;
 
     /* "View.MemoryView":253
@@ -9116,26 +9670,26 @@
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(1, 281, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 281, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_name = values[0];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 281, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 281, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.Enum.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum___init__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self), __pyx_v_name);
 
@@ -9267,30 +9821,30 @@
   /* "(tree fragment)":5
  *     cdef object _dict
  *     cdef bint use_setstate
  *     state = (self.name,)             # <<<<<<<<<<<<<<
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  */
-  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_v_self->name);
   __Pyx_GIVEREF(__pyx_v_self->name);
   PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_self->name);
   __pyx_v_state = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "(tree fragment)":6
  *     cdef bint use_setstate
  *     state = (self.name,)
  *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<
  *     if _dict is not None:
  *         state += (_dict,)
  */
-  __pyx_t_1 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 6, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v__dict = __pyx_t_1;
   __pyx_t_1 = 0;
 
   /* "(tree fragment)":7
  *     state = (self.name,)
  *     _dict = getattr(self, '__dict__', None)
@@ -9305,20 +9859,20 @@
     /* "(tree fragment)":8
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  *         state += (_dict,)             # <<<<<<<<<<<<<<
  *         use_setstate = True
  *     else:
  */
-    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_v__dict);
     __Pyx_GIVEREF(__pyx_v__dict);
     PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v__dict);
-    __pyx_t_4 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 8, __pyx_L1_error)
+    __pyx_t_4 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 8, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_4));
     __pyx_t_4 = 0;
 
     /* "(tree fragment)":9
  *     if _dict is not None:
@@ -9366,28 +9920,28 @@
  *         use_setstate = self.name is not None
  *     if use_setstate:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state             # <<<<<<<<<<<<<<
  *     else:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 13, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 13, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_INCREF(__pyx_int_184977713);
     __Pyx_GIVEREF(__pyx_int_184977713);
     PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_184977713);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
     PyTuple_SET_ITEM(__pyx_t_1, 2, Py_None);
-    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 13, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 13, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
@@ -9412,28 +9966,28 @@
  *     else:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 15, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 15, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_INCREF(__pyx_int_184977713);
     __Pyx_GIVEREF(__pyx_int_184977713);
     PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_184977713);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
     PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_state);
-    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 15, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 15, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1);
     __pyx_t_5 = 0;
     __pyx_t_1 = 0;
@@ -9493,16 +10047,16 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":17
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<
  */
-  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
-  __pyx_t_1 = __pyx_unpickle_Enum__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)
+  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(0, 17, __pyx_L1_error)
+  __pyx_t_1 = __pyx_unpickle_Enum__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":16
  *     else:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
@@ -9646,47 +10200,47 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_flags)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(1, 345, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(0, 345, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype_is_object);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(1, 345, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 345, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_obj = values[0];
-    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 345, __pyx_L3_error)
+    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 345, __pyx_L3_error)
     if (values[2]) {
-      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 345, __pyx_L3_error)
+      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 345, __pyx_L3_error)
     } else {
       __pyx_v_dtype_is_object = ((int)0);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 345, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 345, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.memoryview.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview___cinit__(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_obj, __pyx_v_flags, __pyx_v_dtype_is_object);
 
@@ -9752,15 +10306,15 @@
     /* "View.MemoryView":349
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)             # <<<<<<<<<<<<<<
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  */
-    __pyx_t_4 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 349, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 349, __pyx_L1_error)
 
     /* "View.MemoryView":350
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:             # <<<<<<<<<<<<<<
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)
@@ -9873,15 +10427,15 @@
       /* "View.MemoryView":361
  *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
  *                 raise MemoryError             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
-      PyErr_NoMemory(); __PYX_ERR(1, 361, __pyx_L1_error)
+      PyErr_NoMemory(); __PYX_ERR(0, 361, __pyx_L1_error)
 
       /* "View.MemoryView":360
  *         if self.lock is NULL:
  *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  * 
@@ -10258,44 +10812,44 @@
  * 
  */
   __pyx_t_1 = 0;
   if (likely(PyList_CheckExact(__pyx_v_index)) || PyTuple_CheckExact(__pyx_v_index)) {
     __pyx_t_2 = __pyx_v_index; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
     __pyx_t_4 = NULL;
   } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 397, __pyx_L1_error)
+    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 397, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 397, __pyx_L1_error)
+    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 397, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_4)) {
       if (likely(PyList_CheckExact(__pyx_t_2))) {
         if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 397, __pyx_L1_error)
+        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 397, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 397, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 397, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       } else {
         if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(1, 397, __pyx_L1_error)
+        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 397, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 397, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 397, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       }
     } else {
       __pyx_t_5 = __pyx_t_4(__pyx_t_2);
       if (unlikely(!__pyx_t_5)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 397, __pyx_L1_error)
+          else __PYX_ERR(0, 397, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_5);
     }
     __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_5);
     __pyx_t_5 = 0;
@@ -10305,16 +10859,16 @@
     /* "View.MemoryView":398
  * 
  *         for dim, idx in enumerate(index):
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)             # <<<<<<<<<<<<<<
  * 
  *         return itemp
  */
-    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 398, __pyx_L1_error)
-    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(1, 398, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(0, 398, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_7;
 
     /* "View.MemoryView":397
  *         cdef char *itemp = <char *> self.view.buf
  * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
@@ -10426,63 +10980,63 @@
   /* "View.MemoryView":407
  *             return self
  * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         cdef char *itemp
  */
-  __pyx_t_3 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 407, __pyx_L1_error)
+  __pyx_t_3 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 407, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   if (likely(__pyx_t_3 != Py_None)) {
     PyObject* sequence = __pyx_t_3;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(1, 407, __pyx_L1_error)
+      __PYX_ERR(0, 407, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
     __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 407, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 407, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 407, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 407, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 407, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(0, 407, __pyx_L1_error)
   }
   __pyx_v_have_slices = __pyx_t_4;
   __pyx_t_4 = 0;
   __pyx_v_indices = __pyx_t_5;
   __pyx_t_5 = 0;
 
   /* "View.MemoryView":410
  * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(1, 410, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 410, __pyx_L1_error)
   if (__pyx_t_2) {
 
     /* "View.MemoryView":411
  *         cdef char *itemp
  *         if have_slices:
  *             return memview_slice(self, indices)             # <<<<<<<<<<<<<<
  *         else:
  *             itemp = self.get_item_pointer(indices)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 411, __pyx_L1_error)
+    __pyx_t_3 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 411, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
     /* "View.MemoryView":410
  * 
@@ -10497,26 +11051,26 @@
  *             return memview_slice(self, indices)
  *         else:
  *             itemp = self.get_item_pointer(indices)             # <<<<<<<<<<<<<<
  *             return self.convert_item_to_object(itemp)
  * 
  */
   /*else*/ {
-    __pyx_t_6 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(1, 413, __pyx_L1_error)
+    __pyx_t_6 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(0, 413, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_6;
 
     /* "View.MemoryView":414
  *         else:
  *             itemp = self.get_item_pointer(indices)
  *             return self.convert_item_to_object(itemp)             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(memoryview self, object index, object value):
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 414, __pyx_L1_error)
+    __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 414, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
   /* "View.MemoryView":403
@@ -10591,19 +11145,19 @@
     /* "View.MemoryView":418
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 418, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 418, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(1, 418, __pyx_L1_error)
+    __PYX_ERR(0, 418, __pyx_L1_error)
 
     /* "View.MemoryView":417
  * 
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise TypeError("Cannot assign to read-only memoryview")
  * 
@@ -10613,86 +11167,86 @@
   /* "View.MemoryView":420
  *             raise TypeError("Cannot assign to read-only memoryview")
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         if have_slices:
  */
-  __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 420, __pyx_L1_error)
+  __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 420, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   if (likely(__pyx_t_2 != Py_None)) {
     PyObject* sequence = __pyx_t_2;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(1, 420, __pyx_L1_error)
+      __PYX_ERR(0, 420, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
     __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_4);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 420, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 420, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 420, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 420, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     #endif
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 420, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(0, 420, __pyx_L1_error)
   }
   __pyx_v_have_slices = __pyx_t_3;
   __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_index, __pyx_t_4);
   __pyx_t_4 = 0;
 
   /* "View.MemoryView":422
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
-  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 422, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 422, __pyx_L1_error)
   if (__pyx_t_1) {
 
     /* "View.MemoryView":423
  * 
  *         if have_slices:
  *             obj = self.is_slice(value)             # <<<<<<<<<<<<<<
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)
  */
-    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 423, __pyx_L1_error)
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 423, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_v_obj = __pyx_t_2;
     __pyx_t_2 = 0;
 
     /* "View.MemoryView":424
  *         if have_slices:
  *             obj = self.is_slice(value)
  *             if obj:             # <<<<<<<<<<<<<<
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  */
-    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 424, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 424, __pyx_L1_error)
     if (__pyx_t_1) {
 
       /* "View.MemoryView":425
  *             obj = self.is_slice(value)
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)             # <<<<<<<<<<<<<<
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)
  */
-      __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 425, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 425, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_4 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_2, __pyx_v_obj); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 425, __pyx_L1_error)
+      __pyx_t_4 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_2, __pyx_v_obj); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 425, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
       /* "View.MemoryView":424
  *         if have_slices:
  *             obj = self.is_slice(value)
@@ -10707,18 +11261,18 @@
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)             # <<<<<<<<<<<<<<
  *         else:
  *             self.setitem_indexed(index, value)
  */
     /*else*/ {
-      __pyx_t_4 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 427, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 427, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_memoryview_type))))) __PYX_ERR(1, 427, __pyx_L1_error)
-      __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_4), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 427, __pyx_L1_error)
+      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_memoryview_type))))) __PYX_ERR(0, 427, __pyx_L1_error)
+      __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_4), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 427, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
     __pyx_L5:;
 
     /* "View.MemoryView":422
@@ -10735,15 +11289,15 @@
  *                 self.setitem_slice_assign_scalar(self[index], value)
  *         else:
  *             self.setitem_indexed(index, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef is_slice(self, obj):
  */
   /*else*/ {
-    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 429, __pyx_L1_error)
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 429, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
   __pyx_L4:;
 
   /* "View.MemoryView":416
  *             return self.convert_item_to_object(itemp)
@@ -10826,46 +11380,46 @@
         /* "View.MemoryView":434
  *         if not isinstance(obj, memoryview):
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_6 = __Pyx_PyInt_From_int(((__pyx_v_self->flags & (~PyBUF_WRITABLE)) | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 434, __pyx_L4_error)
+        __pyx_t_6 = __Pyx_PyInt_From_int(((__pyx_v_self->flags & (~PyBUF_WRITABLE)) | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_6);
 
         /* "View.MemoryView":435
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)             # <<<<<<<<<<<<<<
  *             except TypeError:
  *                 return None
  */
-        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 435, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 435, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
 
         /* "View.MemoryView":434
  *         if not isinstance(obj, memoryview):
  *             try:
  *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 434, __pyx_L4_error)
+        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_INCREF(__pyx_v_obj);
         __Pyx_GIVEREF(__pyx_v_obj);
         PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_v_obj);
         __Pyx_GIVEREF(__pyx_t_6);
         PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_6);
         __Pyx_GIVEREF(__pyx_t_7);
         PyTuple_SET_ITEM(__pyx_t_8, 2, __pyx_t_7);
         __pyx_t_6 = 0;
         __pyx_t_7 = 0;
-        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 434, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 434, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         __Pyx_DECREF_SET(__pyx_v_obj, __pyx_t_7);
         __pyx_t_7 = 0;
 
         /* "View.MemoryView":433
  *     cdef is_slice(self, obj):
@@ -10890,15 +11444,15 @@
  *             except TypeError:             # <<<<<<<<<<<<<<
  *                 return None
  * 
  */
       __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_TypeError);
       if (__pyx_t_9) {
         __Pyx_AddTraceback("View.MemoryView.memoryview.is_slice", __pyx_clineno, __pyx_lineno, __pyx_filename);
-        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(1, 436, __pyx_L6_except_error)
+        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(0, 436, __pyx_L6_except_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_GOTREF(__pyx_t_6);
 
         /* "View.MemoryView":437
  *                                  self.dtype_is_object)
  *             except TypeError:
@@ -11007,51 +11561,51 @@
   /* "View.MemoryView":445
  *         cdef __Pyx_memviewslice src_slice
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
-  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(1, 445, __pyx_L1_error)
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 445, __pyx_L1_error)
+  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(0, 445, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(0, 445, __pyx_L1_error)
 
   /* "View.MemoryView":446
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
  *                                  get_slice_from_memview(dst, &dst_slice)[0],             # <<<<<<<<<<<<<<
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  */
-  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(1, 446, __pyx_L1_error)
-  __pyx_t_2 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice)); if (unlikely(__pyx_t_2 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 446, __pyx_L1_error)
+  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(0, 446, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice)); if (unlikely(__pyx_t_2 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(0, 446, __pyx_L1_error)
 
   /* "View.MemoryView":447
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 447, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 447, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 447, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 447, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 447, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 447, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 447, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 447, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "View.MemoryView":445
  *         cdef __Pyx_memviewslice src_slice
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
-  __pyx_t_6 = __pyx_memoryview_copy_contents((__pyx_t_1[0]), (__pyx_t_2[0]), __pyx_t_4, __pyx_t_5, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 445, __pyx_L1_error)
+  __pyx_t_6 = __pyx_memoryview_copy_contents((__pyx_t_1[0]), (__pyx_t_2[0]), __pyx_t_4, __pyx_t_5, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(0, 445, __pyx_L1_error)
 
   /* "View.MemoryView":441
  *         return obj
  * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
@@ -11115,15 +11669,15 @@
   /* "View.MemoryView":456
  *         cdef __Pyx_memviewslice *dst_slice
  *         cdef __Pyx_memviewslice tmp_slice
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)             # <<<<<<<<<<<<<<
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 456, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(0, 456, __pyx_L1_error)
   __pyx_v_dst_slice = __pyx_t_1;
 
   /* "View.MemoryView":458
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
@@ -11154,15 +11708,15 @@
       /* "View.MemoryView":461
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  *                 raise MemoryError             # <<<<<<<<<<<<<<
  *             item = tmp
  *         else:
  */
-      PyErr_NoMemory(); __PYX_ERR(1, 461, __pyx_L1_error)
+      PyErr_NoMemory(); __PYX_ERR(0, 461, __pyx_L1_error)
 
       /* "View.MemoryView":460
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  *             item = tmp
@@ -11242,15 +11796,15 @@
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)             # <<<<<<<<<<<<<<
  * 
  * 
  */
     /*else*/ {
-      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 470, __pyx_L6_error)
+      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 470, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     }
     __pyx_L8:;
 
     /* "View.MemoryView":474
  * 
@@ -11265,15 +11819,15 @@
       /* "View.MemoryView":475
  * 
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)             # <<<<<<<<<<<<<<
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  *                                 item, self.dtype_is_object)
  */
-      __pyx_t_3 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 475, __pyx_L6_error)
+      __pyx_t_3 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 475, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
       /* "View.MemoryView":474
  * 
  * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
@@ -11382,25 +11936,25 @@
   /* "View.MemoryView":482
  * 
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)             # <<<<<<<<<<<<<<
  *         self.assign_item_from_object(itemp, value)
  * 
  */
-  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(1, 482, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(0, 482, __pyx_L1_error)
   __pyx_v_itemp = __pyx_t_1;
 
   /* "View.MemoryView":483
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
-  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 483, __pyx_L1_error)
+  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 483, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "View.MemoryView":481
  *             PyMem_Free(tmp)
  * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
@@ -11454,27 +12008,27 @@
   /* "View.MemoryView":488
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef bytes bytesitem
  * 
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 488, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 488, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":491
  *         cdef bytes bytesitem
  * 
  *         bytesitem = itemp[:self.view.itemsize]             # <<<<<<<<<<<<<<
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  */
-  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 491, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 491, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_bytesitem = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
@@ -11494,17 +12048,17 @@
       /* "View.MemoryView":493
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)             # <<<<<<<<<<<<<<
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 493, __pyx_L3_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 493, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 493, __pyx_L3_error)
+      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 493, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_6);
       __pyx_t_7 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_7)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -11513,42 +12067,42 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
-        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 493, __pyx_L3_error)
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
-        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 493, __pyx_L3_error)
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       } else
       #endif
       {
-        __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 493, __pyx_L3_error)
+        __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 493, __pyx_L3_error)
         __Pyx_GOTREF(__pyx_t_9);
         if (__pyx_t_7) {
           __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
         }
         __Pyx_GIVEREF(__pyx_t_6);
         PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_t_6);
         __Pyx_INCREF(__pyx_v_bytesitem);
         __Pyx_GIVEREF(__pyx_v_bytesitem);
         PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_v_bytesitem);
         __pyx_t_6 = 0;
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 493, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 493, __pyx_L3_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_v_result = __pyx_t_1;
       __pyx_t_1 = 0;
 
@@ -11577,15 +12131,15 @@
  *         else:
  *             if len(self.view.format) == 1:
  *                 return result[0]             # <<<<<<<<<<<<<<
  *             return result
  * 
  */
         __Pyx_XDECREF(__pyx_r);
-        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 498, __pyx_L5_except_error)
+        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 498, __pyx_L5_except_error)
         __Pyx_GOTREF(__pyx_t_1);
         __pyx_r = __pyx_t_1;
         __pyx_t_1 = 0;
         goto __pyx_L6_except_return;
 
         /* "View.MemoryView":497
  *             raise ValueError("Unable to convert item to object")
@@ -11619,39 +12173,39 @@
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:             # <<<<<<<<<<<<<<
  *             raise ValueError("Unable to convert item to object")
  *         else:
  */
     __Pyx_ErrFetch(&__pyx_t_1, &__pyx_t_5, &__pyx_t_9);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 494, __pyx_L5_except_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 494, __pyx_L5_except_error)
     __Pyx_GOTREF(__pyx_t_6);
     __pyx_t_8 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_1, __pyx_t_6);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_ErrRestore(__pyx_t_1, __pyx_t_5, __pyx_t_9);
     __pyx_t_1 = 0; __pyx_t_5 = 0; __pyx_t_9 = 0;
     if (__pyx_t_8) {
       __Pyx_AddTraceback("View.MemoryView.memoryview.convert_item_to_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_5, &__pyx_t_1) < 0) __PYX_ERR(1, 494, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_5, &__pyx_t_1) < 0) __PYX_ERR(0, 494, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_9);
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_1);
 
       /* "View.MemoryView":495
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 495, __pyx_L5_except_error)
+      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 495, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_Raise(__pyx_t_6, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __PYX_ERR(1, 495, __pyx_L5_except_error)
+      __PYX_ERR(0, 495, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
     /* "View.MemoryView":492
  * 
  *         bytesitem = itemp[:self.view.itemsize]
@@ -11735,15 +12289,15 @@
   /* "View.MemoryView":504
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef char c
  *         cdef bytes bytesvalue
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 504, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 504, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":509
  *         cdef Py_ssize_t i
  * 
@@ -11758,34 +12312,34 @@
     /* "View.MemoryView":510
  * 
  *         if isinstance(value, tuple):
  *             bytesvalue = struct.pack(self.view.format, *value)             # <<<<<<<<<<<<<<
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)
  */
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = PyNumber_Add(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __pyx_t_6 = PyNumber_Add(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 510, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 510, __pyx_L1_error)
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(0, 510, __pyx_L1_error)
     __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
     __pyx_t_4 = 0;
 
     /* "View.MemoryView":509
  *         cdef Py_ssize_t i
  * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
@@ -11799,17 +12353,17 @@
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)             # <<<<<<<<<<<<<<
  * 
  *         for i, c in enumerate(bytesvalue):
  */
   /*else*/ {
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 512, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 512, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 512, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_5 = NULL;
     __pyx_t_7 = 0;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
@@ -11818,47 +12372,47 @@
         __Pyx_DECREF_SET(__pyx_t_6, function);
         __pyx_t_7 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_6)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
-      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 512, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
-      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 512, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     } else
     #endif
     {
-      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 512, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_8);
       if (__pyx_t_5) {
         __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5); __pyx_t_5 = NULL;
       }
       __Pyx_GIVEREF(__pyx_t_1);
       PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_1);
       __Pyx_INCREF(__pyx_v_value);
       __Pyx_GIVEREF(__pyx_v_value);
       PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_v_value);
       __pyx_t_1 = 0;
-      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 512, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 512, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(1, 512, __pyx_L1_error)
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(0, 512, __pyx_L1_error)
     __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
     __pyx_t_4 = 0;
   }
   __pyx_L3:;
 
   /* "View.MemoryView":514
  *             bytesvalue = struct.pack(self.view.format, value)
@@ -11866,15 +12420,15 @@
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
  * 
  */
   __pyx_t_9 = 0;
   if (unlikely(__pyx_v_bytesvalue == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' is not iterable");
-    __PYX_ERR(1, 514, __pyx_L1_error)
+    __PYX_ERR(0, 514, __pyx_L1_error)
   }
   __Pyx_INCREF(__pyx_v_bytesvalue);
   __pyx_t_10 = __pyx_v_bytesvalue;
   __pyx_t_12 = PyBytes_AS_STRING(__pyx_t_10);
   __pyx_t_13 = (__pyx_t_12 + PyBytes_GET_SIZE(__pyx_t_10));
   for (__pyx_t_14 = __pyx_t_12; __pyx_t_14 < __pyx_t_13; __pyx_t_14++) {
     __pyx_t_11 = __pyx_t_14;
@@ -12001,19 +12555,19 @@
     /* "View.MemoryView":520
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_ND:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 520, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 520, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 520, __pyx_L1_error)
+    __PYX_ERR(0, 520, __pyx_L1_error)
 
     /* "View.MemoryView":519
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  * 
@@ -12316,28 +12870,28 @@
   /* "View.MemoryView":554
  *     @property
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&result.from_slice)
  *         return result
  */
-  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 554, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 554, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(1, 554, __pyx_L1_error)
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(0, 554, __pyx_L1_error)
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":555
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)             # <<<<<<<<<<<<<<
  *         return result
  * 
  */
-  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 555, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(0, 555, __pyx_L1_error)
 
   /* "View.MemoryView":556
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  *         return result             # <<<<<<<<<<<<<<
  * 
  *     @property
@@ -12459,26 +13013,26 @@
  *     @property
  *     def shape(self):
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 564, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 564, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_3 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
   for (__pyx_t_4 = __pyx_v_self->view.shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
     __pyx_t_2 = __pyx_t_4;
     __pyx_v_length = (__pyx_t_2[0]);
-    __pyx_t_5 = PyInt_FromSsize_t(__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 564, __pyx_L1_error)
+    __pyx_t_5 = PyInt_FromSsize_t(__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 564, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(1, 564, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 564, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
-  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 564, __pyx_L1_error)
+  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 564, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":563
@@ -12550,19 +13104,19 @@
     /* "View.MemoryView":570
  *         if self.view.strides == NULL:
  * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 570, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 570, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(1, 570, __pyx_L1_error)
+    __PYX_ERR(0, 570, __pyx_L1_error)
 
     /* "View.MemoryView":568
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
  * 
  *             raise ValueError("Buffer view does not expose strides")
@@ -12573,26 +13127,26 @@
  *             raise ValueError("Buffer view does not expose strides")
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 572, __pyx_L1_error)
+  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 572, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = (__pyx_v_self->view.strides + __pyx_v_self->view.ndim);
   for (__pyx_t_5 = __pyx_v_self->view.strides; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
     __pyx_t_3 = __pyx_t_5;
     __pyx_v_stride = (__pyx_t_3[0]);
-    __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 572, __pyx_L1_error)
+    __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 572, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(1, 572, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(0, 572, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
-  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 572, __pyx_L1_error)
+  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 572, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_6;
   __pyx_t_6 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":567
@@ -12665,17 +13219,17 @@
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 577, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 577, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__20, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 577, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__16, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 577, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
     /* "View.MemoryView":576
@@ -12691,26 +13245,26 @@
  *             return (-1,) * self.view.ndim
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 579, __pyx_L1_error)
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 579, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_5 = (__pyx_v_self->view.suboffsets + __pyx_v_self->view.ndim);
   for (__pyx_t_6 = __pyx_v_self->view.suboffsets; __pyx_t_6 < __pyx_t_5; __pyx_t_6++) {
     __pyx_t_4 = __pyx_t_6;
     __pyx_v_suboffset = (__pyx_t_4[0]);
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_suboffset); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_suboffset); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 579, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_2))) __PYX_ERR(1, 579, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_2))) __PYX_ERR(0, 579, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
-  __pyx_t_2 = PyList_AsTuple(((PyObject*)__pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
+  __pyx_t_2 = PyList_AsTuple(((PyObject*)__pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 579, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":575
@@ -12767,15 +13321,15 @@
  *     @property
  *     def ndim(self):
  *         return self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 583, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 583, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":582
  * 
@@ -12830,15 +13384,15 @@
  *     @property
  *     def itemsize(self):
  *         return self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 587, __pyx_L1_error)
+  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 587, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":586
  * 
@@ -12895,19 +13449,19 @@
  *     @property
  *     def nbytes(self):
  *         return self.size * self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 591, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 591, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 591, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
@@ -12996,27 +13550,27 @@
  *             for length in self.view.shape[:self.view.ndim]:             # <<<<<<<<<<<<<<
  *                 result *= length
  * 
  */
     __pyx_t_4 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
     for (__pyx_t_5 = __pyx_v_self->view.shape; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
       __pyx_t_3 = __pyx_t_5;
-      __pyx_t_6 = PyInt_FromSsize_t((__pyx_t_3[0])); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 598, __pyx_L1_error)
+      __pyx_t_6 = PyInt_FromSsize_t((__pyx_t_3[0])); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 598, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_6);
       __pyx_t_6 = 0;
 
       /* "View.MemoryView":599
  * 
  *             for length in self.view.shape[:self.view.ndim]:
  *                 result *= length             # <<<<<<<<<<<<<<
  * 
  *             self._size = result
  */
-      __pyx_t_6 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 599, __pyx_L1_error)
+      __pyx_t_6 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 599, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_6);
       __pyx_t_6 = 0;
     }
 
     /* "View.MemoryView":601
  *                 result *= length
@@ -13189,49 +13743,49 @@
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 612, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 612, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 612, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "View.MemoryView":613
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))             # <<<<<<<<<<<<<<
  * 
  *     def __str__(self):
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 613, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 613, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
   /* "View.MemoryView":612
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 612, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 612, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":611
@@ -13290,28 +13844,28 @@
  * 
  *     def __str__(self):
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 616, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 616, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 616, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":615
@@ -13370,26 +13924,26 @@
   /* "View.MemoryView":622
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 622, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(0, 622, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
   /* "View.MemoryView":623
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def is_f_contig(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 623, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 623, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":619
  * 
@@ -13446,26 +14000,26 @@
   /* "View.MemoryView":628
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  */
-  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(1, 628, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp)); if (unlikely(__pyx_t_1 == ((__Pyx_memviewslice *)NULL))) __PYX_ERR(0, 628, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
   /* "View.MemoryView":629
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def copy(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 629, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 629, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":625
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
@@ -13540,26 +14094,26 @@
   /* "View.MemoryView":636
  * 
  *         slice_copy(self, &mslice)
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                    self.view.itemsize,
  *                                    flags|PyBUF_C_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 636, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 636, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
   /* "View.MemoryView":641
  *                                    self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &mslice)             # <<<<<<<<<<<<<<
  * 
  *     def copy_fortran(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 641, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":631
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
@@ -13635,26 +14189,26 @@
   /* "View.MemoryView":648
  * 
  *         slice_copy(self, &src)
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                 self.view.itemsize,
  *                                 flags|PyBUF_F_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 648, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 648, __pyx_L1_error)
   __pyx_v_dst = __pyx_t_1;
 
   /* "View.MemoryView":653
  *                                 self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &dst)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 653, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 653, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":643
  *         return memoryview_copy_from_slice(self, &mslice)
@@ -13705,19 +14259,19 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 2, __pyx_L1_error)
+  __PYX_ERR(0, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
@@ -13761,19 +14315,19 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 4, __pyx_L1_error)
+  __PYX_ERR(0, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
@@ -13811,30 +14365,30 @@
   /* "View.MemoryView":658
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)             # <<<<<<<<<<<<<<
  *     result.typeinfo = typeinfo
  *     return result
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 658, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 658, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(__pyx_v_o);
   __Pyx_GIVEREF(__pyx_v_o);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_o);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 658, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryview_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
   /* "View.MemoryView":659
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
@@ -13966,15 +14520,15 @@
     /* "View.MemoryView":672
  *     """
  *     if not isinstance(index, tuple):
  *         tup = (index,)             # <<<<<<<<<<<<<<
  *     else:
  *         tup = index
  */
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 672, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 672, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_index);
     __Pyx_GIVEREF(__pyx_v_index);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_index);
     __pyx_v_tup = __pyx_t_3;
     __pyx_t_3 = 0;
 
@@ -14004,15 +14558,15 @@
   /* "View.MemoryView":676
  *         tup = index
  * 
  *     result = []             # <<<<<<<<<<<<<<
  *     have_slices = False
  *     seen_ellipsis = False
  */
-  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 676, __pyx_L1_error)
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 676, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_v_result = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
 
   /* "View.MemoryView":677
  * 
  *     result = []
@@ -14040,54 +14594,54 @@
  */
   __Pyx_INCREF(__pyx_int_0);
   __pyx_t_3 = __pyx_int_0;
   if (likely(PyList_CheckExact(__pyx_v_tup)) || PyTuple_CheckExact(__pyx_v_tup)) {
     __pyx_t_4 = __pyx_v_tup; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
     __pyx_t_6 = NULL;
   } else {
-    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_tup); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 679, __pyx_L1_error)
+    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_tup); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 679, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 679, __pyx_L1_error)
+    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 679, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_6)) {
       if (likely(PyList_CheckExact(__pyx_t_4))) {
         if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 679, __pyx_L1_error)
+        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 679, __pyx_L1_error)
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 679, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       } else {
         if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(1, 679, __pyx_L1_error)
+        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 679, __pyx_L1_error)
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 679, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       }
     } else {
       __pyx_t_7 = __pyx_t_6(__pyx_t_4);
       if (unlikely(!__pyx_t_7)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 679, __pyx_L1_error)
+          else __PYX_ERR(0, 679, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_7);
     }
     __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_7);
     __pyx_t_7 = 0;
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_3);
-    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_3, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 679, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_3, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 679, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_3);
     __pyx_t_3 = __pyx_t_7;
     __pyx_t_7 = 0;
 
     /* "View.MemoryView":680
  *     seen_ellipsis = False
@@ -14113,25 +14667,25 @@
         /* "View.MemoryView":682
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
  *                 seen_ellipsis = True
  *             else:
  */
-        __pyx_t_8 = PyObject_Length(__pyx_v_tup); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(1, 682, __pyx_L1_error)
-        __pyx_t_7 = PyList_New(1 * ((((__pyx_v_ndim - __pyx_t_8) + 1)<0) ? 0:((__pyx_v_ndim - __pyx_t_8) + 1))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 682, __pyx_L1_error)
+        __pyx_t_8 = PyObject_Length(__pyx_v_tup); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 682, __pyx_L1_error)
+        __pyx_t_7 = PyList_New(1 * ((((__pyx_v_ndim - __pyx_t_8) + 1)<0) ? 0:((__pyx_v_ndim - __pyx_t_8) + 1))); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 682, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         { Py_ssize_t __pyx_temp;
           for (__pyx_temp=0; __pyx_temp < ((__pyx_v_ndim - __pyx_t_8) + 1); __pyx_temp++) {
-            __Pyx_INCREF(__pyx_slice__23);
-            __Pyx_GIVEREF(__pyx_slice__23);
-            PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_slice__23);
+            __Pyx_INCREF(__pyx_slice__19);
+            __Pyx_GIVEREF(__pyx_slice__19);
+            PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_slice__19);
           }
         }
-        __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_7); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 682, __pyx_L1_error)
+        __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_7); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 682, __pyx_L1_error)
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
         /* "View.MemoryView":683
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True             # <<<<<<<<<<<<<<
  *             else:
@@ -14153,15 +14707,15 @@
  *                 seen_ellipsis = True
  *             else:
  *                 result.append(slice(None))             # <<<<<<<<<<<<<<
  *             have_slices = True
  *         else:
  */
       /*else*/ {
-        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__23); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 685, __pyx_L1_error)
+        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__19); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 685, __pyx_L1_error)
       }
       __pyx_L7:;
 
       /* "View.MemoryView":686
  *             else:
  *                 result.append(slice(None))
  *             have_slices = True             # <<<<<<<<<<<<<<
@@ -14203,22 +14757,22 @@
         /* "View.MemoryView":689
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):
  *                 raise TypeError("Cannot index with type '%s'" % type(item))             # <<<<<<<<<<<<<<
  * 
  *             have_slices = have_slices or isinstance(item, slice)
  */
-        __pyx_t_7 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Cannot_index_with_type_s, ((PyObject *)Py_TYPE(__pyx_v_item))); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 689, __pyx_L1_error)
+        __pyx_t_7 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Cannot_index_with_type_s, ((PyObject *)Py_TYPE(__pyx_v_item))); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 689, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
-        __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 689, __pyx_L1_error)
+        __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 689, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_11);
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_Raise(__pyx_t_11, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        __PYX_ERR(1, 689, __pyx_L1_error)
+        __PYX_ERR(0, 689, __pyx_L1_error)
 
         /* "View.MemoryView":688
  *             have_slices = True
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
  * 
@@ -14247,15 +14801,15 @@
       /* "View.MemoryView":692
  * 
  *             have_slices = have_slices or isinstance(item, slice)
  *             result.append(item)             # <<<<<<<<<<<<<<
  * 
  *     nslices = ndim - len(result)
  */
-      __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_v_item); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 692, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_v_item); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 692, __pyx_L1_error)
     }
     __pyx_L6:;
 
     /* "View.MemoryView":679
  *     have_slices = False
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):             # <<<<<<<<<<<<<<
@@ -14269,15 +14823,15 @@
   /* "View.MemoryView":694
  *             result.append(item)
  * 
  *     nslices = ndim - len(result)             # <<<<<<<<<<<<<<
  *     if nslices:
  *         result.extend([slice(None)] * nslices)
  */
-  __pyx_t_5 = PyList_GET_SIZE(__pyx_v_result); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(1, 694, __pyx_L1_error)
+  __pyx_t_5 = PyList_GET_SIZE(__pyx_v_result); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 694, __pyx_L1_error)
   __pyx_v_nslices = (__pyx_v_ndim - __pyx_t_5);
 
   /* "View.MemoryView":695
  * 
  *     nslices = ndim - len(result)
  *     if nslices:             # <<<<<<<<<<<<<<
  *         result.extend([slice(None)] * nslices)
@@ -14289,24 +14843,24 @@
     /* "View.MemoryView":696
  *     nslices = ndim - len(result)
  *     if nslices:
  *         result.extend([slice(None)] * nslices)             # <<<<<<<<<<<<<<
  * 
  *     return have_slices or nslices, tuple(result)
  */
-    __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 696, __pyx_L1_error)
+    __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 696, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     { Py_ssize_t __pyx_temp;
       for (__pyx_temp=0; __pyx_temp < __pyx_v_nslices; __pyx_temp++) {
-        __Pyx_INCREF(__pyx_slice__23);
-        __Pyx_GIVEREF(__pyx_slice__23);
-        PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__23);
+        __Pyx_INCREF(__pyx_slice__19);
+        __Pyx_GIVEREF(__pyx_slice__19);
+        PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__19);
       }
     }
-    __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 696, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 696, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
     /* "View.MemoryView":695
  * 
  *     nslices = ndim - len(result)
  *     if nslices:             # <<<<<<<<<<<<<<
  *         result.extend([slice(None)] * nslices)
@@ -14320,28 +14874,28 @@
  *     return have_slices or nslices, tuple(result)             # <<<<<<<<<<<<<<
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  */
   __Pyx_XDECREF(__pyx_r);
   if (!__pyx_v_have_slices) {
   } else {
-    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 698, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_3 = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L14_bool_binop_done;
   }
-  __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
+  __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 698, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_3 = __pyx_t_4;
   __pyx_t_4 = 0;
   __pyx_L14_bool_binop_done:;
-  __pyx_t_4 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 698, __pyx_L1_error)
+  __pyx_t_4 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 698, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_11 = PyTuple_New(2); if (unlikely(!__pyx_t_11)) __PYX_ERR(1, 698, __pyx_L1_error)
+  __pyx_t_11 = PyTuple_New(2); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 698, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_4);
   PyTuple_SET_ITEM(__pyx_t_11, 1, __pyx_t_4);
   __pyx_t_3 = 0;
   __pyx_t_4 = 0;
@@ -14422,19 +14976,19 @@
       /* "View.MemoryView":703
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 703, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 703, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(1, 703, __pyx_L1_error)
+      __PYX_ERR(0, 703, __pyx_L1_error)
 
       /* "View.MemoryView":702
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("Indirect dimensions not supported")
  * 
@@ -14533,15 +15087,15 @@
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!((__pyx_v_memview->view.ndim > 0) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(1, 722, __pyx_L1_error)
+      __PYX_ERR(0, 722, __pyx_L1_error)
     }
   }
   #endif
 
   /* "View.MemoryView":724
  *     assert memview.view.ndim > 0
  * 
@@ -14556,15 +15110,15 @@
     /* "View.MemoryView":725
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview             # <<<<<<<<<<<<<<
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  */
-    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 725, __pyx_L1_error)
+    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(0, 725, __pyx_L1_error)
     __pyx_t_3 = ((PyObject *)__pyx_v_memview);
     __Pyx_INCREF(__pyx_t_3);
     __pyx_v_memviewsliceobj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
 
     /* "View.MemoryView":726
  *     if isinstance(memview, _memoryviewslice):
@@ -14652,44 +15206,44 @@
  *             slice_memviewslice(
  */
   __pyx_t_6 = 0;
   if (likely(PyList_CheckExact(__pyx_v_indices)) || PyTuple_CheckExact(__pyx_v_indices)) {
     __pyx_t_3 = __pyx_v_indices; __Pyx_INCREF(__pyx_t_3); __pyx_t_7 = 0;
     __pyx_t_8 = NULL;
   } else {
-    __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 746, __pyx_L1_error)
+    __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 746, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 746, __pyx_L1_error)
+    __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 746, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_8)) {
       if (likely(PyList_CheckExact(__pyx_t_3))) {
         if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_9 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 746, __pyx_L1_error)
+        __pyx_t_9 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 746, __pyx_L1_error)
         #else
-        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 746, __pyx_L1_error)
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 746, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_9);
         #endif
       } else {
         if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_9 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(1, 746, __pyx_L1_error)
+        __pyx_t_9 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 746, __pyx_L1_error)
         #else
-        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 746, __pyx_L1_error)
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 746, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_9);
         #endif
       }
     } else {
       __pyx_t_9 = __pyx_t_8(__pyx_t_3);
       if (unlikely(!__pyx_t_9)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(1, 746, __pyx_L1_error)
+          else __PYX_ERR(0, 746, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_9);
     }
     __Pyx_XDECREF_SET(__pyx_v_index, __pyx_t_9);
     __pyx_t_9 = 0;
@@ -14709,24 +15263,24 @@
       /* "View.MemoryView":751
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  *                 index, 0, 0, # start, stop, step             # <<<<<<<<<<<<<<
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  */
-      __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 751, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 751, __pyx_L1_error)
 
       /* "View.MemoryView":748
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_t_10, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 748, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_t_10, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(0, 748, __pyx_L1_error)
 
       /* "View.MemoryView":747
  * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
  *             slice_memviewslice(
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
@@ -14795,21 +15349,21 @@
  *             new_ndim += 1
  *         else:
  *             start = index.start or 0             # <<<<<<<<<<<<<<
  *             stop = index.stop or 0
  *             step = index.step or 0
  */
     /*else*/ {
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 760, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 760, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 760, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 760, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 760, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 760, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L7_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L7_bool_binop_done:;
       __pyx_v_start = __pyx_t_10;
@@ -14817,21 +15371,21 @@
       /* "View.MemoryView":761
  *         else:
  *             start = index.start or 0
  *             stop = index.stop or 0             # <<<<<<<<<<<<<<
  *             step = index.step or 0
  * 
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 761, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 761, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 761, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 761, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 761, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 761, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L9_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L9_bool_binop_done:;
       __pyx_v_stop = __pyx_t_10;
@@ -14839,21 +15393,21 @@
       /* "View.MemoryView":762
  *             start = index.start or 0
  *             stop = index.stop or 0
  *             step = index.step or 0             # <<<<<<<<<<<<<<
  * 
  *             have_start = index.start is not None
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 762, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 762, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(1, 762, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 762, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 762, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 762, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L11_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L11_bool_binop_done:;
       __pyx_v_step = __pyx_t_10;
@@ -14861,54 +15415,54 @@
       /* "View.MemoryView":764
  *             step = index.step or 0
  * 
  *             have_start = index.start is not None             # <<<<<<<<<<<<<<
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 764, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 764, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_start = __pyx_t_1;
 
       /* "View.MemoryView":765
  * 
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None             # <<<<<<<<<<<<<<
  *             have_step = index.step is not None
  * 
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 765, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 765, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_stop = __pyx_t_1;
 
       /* "View.MemoryView":766
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None             # <<<<<<<<<<<<<<
  * 
  *             slice_memviewslice(
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(1, 766, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 766, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_step = __pyx_t_1;
 
       /* "View.MemoryView":768
  *             have_step = index.step is not None
  * 
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(1, 768, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(0, 768, __pyx_L1_error)
 
       /* "View.MemoryView":774
  *                 have_start, have_stop, have_step,
  *                 True)
  *             new_ndim += 1             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
@@ -14950,35 +15504,35 @@
     /* "View.MemoryView":778
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_dtype_func,
  *                                     memview.dtype_is_object)
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 778, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(0, 778, __pyx_L1_error) }
 
     /* "View.MemoryView":779
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  *     else:
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(1, 779, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(0, 779, __pyx_L1_error) }
 
     /* "View.MemoryView":777
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
-    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 777, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 777, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 777, __pyx_L1_error)
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(0, 777, __pyx_L1_error)
     __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
     /* "View.MemoryView":776
  *             new_ndim += 1
  * 
@@ -15001,25 +15555,25 @@
     /* "View.MemoryView":783
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,
  *                                     memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 782, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 782, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
 
     /* "View.MemoryView":782
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  * 
  */
-    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(1, 782, __pyx_L1_error)
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(0, 782, __pyx_L1_error)
     __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
   /* "View.MemoryView":710
  * 
@@ -15117,15 +15671,15 @@
       /* "View.MemoryView":832
  *             start += shape
  *         if not 0 <= start < shape:
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)             # <<<<<<<<<<<<<<
  *     else:
  * 
  */
-      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"Index out of bounds (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 832, __pyx_L1_error)
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"Index out of bounds (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 832, __pyx_L1_error)
 
       /* "View.MemoryView":831
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
@@ -15182,15 +15736,15 @@
       /* "View.MemoryView":838
  * 
  *         if have_step and step == 0:
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Step may not be zero (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 838, __pyx_L1_error)
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Step may not be zero (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 838, __pyx_L1_error)
 
       /* "View.MemoryView":837
  *         negative_step = have_step != 0 and step < 0
  * 
  *         if have_step and step == 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
  * 
@@ -15754,15 +16308,15 @@
         /* "View.MemoryView":900
  *             else:
  *                 _err_dim(IndexError, "All dimensions preceding dimension %d "
  *                                      "must be indexed and not sliced", dim)             # <<<<<<<<<<<<<<
  *         else:
  *             suboffset_dim[0] = new_ndim
  */
-        __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"All dimensions preceding dimension %d must be indexed and not sliced"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 899, __pyx_L1_error)
+        __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"All dimensions preceding dimension %d must be indexed and not sliced"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 899, __pyx_L1_error)
       }
       __pyx_L26:;
 
       /* "View.MemoryView":895
  * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
@@ -15886,19 +16440,19 @@
  *     if view.ndim == 0:
  *         shape = view.len / itemsize             # <<<<<<<<<<<<<<
  *         stride = itemsize
  *     else:
  */
     if (unlikely(__pyx_v_itemsize == 0)) {
       PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-      __PYX_ERR(1, 917, __pyx_L1_error)
+      __PYX_ERR(0, 917, __pyx_L1_error)
     }
     else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_view->len))) {
       PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-      __PYX_ERR(1, 917, __pyx_L1_error)
+      __PYX_ERR(0, 917, __pyx_L1_error)
     }
     __pyx_v_shape = __Pyx_div_Py_ssize_t(__pyx_v_view->len, __pyx_v_itemsize);
 
     /* "View.MemoryView":918
  *     if view.ndim == 0:
  *         shape = view.len / itemsize
  *         stride = itemsize             # <<<<<<<<<<<<<<
@@ -15998,25 +16552,25 @@
       /* "View.MemoryView":928
  *         index += view.shape[dim]
  *         if index < 0:
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     if index >= shape:
  */
-      __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 928, __pyx_L1_error)
+      __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 928, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 928, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 928, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 928, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 928, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(1, 928, __pyx_L1_error)
+      __PYX_ERR(0, 928, __pyx_L1_error)
 
       /* "View.MemoryView":927
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
@@ -16045,25 +16599,25 @@
     /* "View.MemoryView":931
  * 
  *     if index >= shape:
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     resultp = bufp + index * stride
  */
-    __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 931, __pyx_L1_error)
+    __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 931, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 931, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 931, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 931, __pyx_L1_error)
+    __PYX_ERR(0, 931, __pyx_L1_error)
 
     /* "View.MemoryView":930
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
@@ -16260,15 +16814,15 @@
       /* "View.MemoryView":957
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")             # <<<<<<<<<<<<<<
  * 
  *     return 1
  */
-      __pyx_t_9 = __pyx_memoryview_err(__pyx_builtin_ValueError, ((char *)"Cannot transpose memoryview with indirect dimensions")); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(1, 957, __pyx_L1_error)
+      __pyx_t_9 = __pyx_memoryview_err(__pyx_builtin_ValueError, ((char *)"Cannot transpose memoryview with indirect dimensions")); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 957, __pyx_L1_error)
 
       /* "View.MemoryView":956
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
@@ -16386,15 +16940,15 @@
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)             # <<<<<<<<<<<<<<
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 981, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 981, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
 
     /* "View.MemoryView":980
  * 
@@ -16410,15 +16964,15 @@
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)             # <<<<<<<<<<<<<<
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 983, __pyx_L1_error)
+    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 983, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
   /* "View.MemoryView":979
@@ -16472,15 +17026,15 @@
     /* "View.MemoryView":987
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)             # <<<<<<<<<<<<<<
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)
  */
-    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(1, 987, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(0, 987, __pyx_L1_error)
 
     /* "View.MemoryView":986
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
@@ -16492,15 +17046,15 @@
  *             self.to_dtype_func(itemp, value)
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   /*else*/ {
-    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 989, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 989, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __pyx_L3:;
 
   /* "View.MemoryView":985
  *             return memoryview.convert_item_to_object(self, itemp)
@@ -16606,19 +17160,19 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 2, __pyx_L1_error)
+  __PYX_ERR(0, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
@@ -16662,19 +17216,19 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 4, __pyx_L1_error)
+  __PYX_ERR(0, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
@@ -16750,28 +17304,28 @@
   /* "View.MemoryView":1013
  * 
  * 
  *     result = _memoryviewslice(None, 0, dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     result.from_slice = memviewslice
  */
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1013, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(Py_None);
   PyTuple_SET_ITEM(__pyx_t_3, 0, Py_None);
   __Pyx_INCREF(__pyx_int_0);
   __Pyx_GIVEREF(__pyx_int_0);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_0);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1013, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1013, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
   /* "View.MemoryView":1015
  *     result = _memoryviewslice(None, 0, dtype_is_object)
@@ -16794,15 +17348,15 @@
   /* "View.MemoryView":1018
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
  * 
  *     result.from_object = (<memoryview> memviewslice.memview).base             # <<<<<<<<<<<<<<
  *     result.typeinfo = memviewslice.memview.typeinfo
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_memviewslice.memview), __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1018, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_memviewslice.memview), __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1018, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __Pyx_GOTREF(__pyx_v_result->from_object);
   __Pyx_DECREF(__pyx_v_result->from_object);
   __pyx_v_result->from_object = __pyx_t_2;
   __pyx_t_2 = 0;
 
@@ -16997,32 +17551,32 @@
  *     for length in result.view.shape[:ndim]:             # <<<<<<<<<<<<<<
  *         result.view.len *= length
  * 
  */
   __pyx_t_7 = (__pyx_v_result->__pyx_base.view.shape + __pyx_v_ndim);
   for (__pyx_t_8 = __pyx_v_result->__pyx_base.view.shape; __pyx_t_8 < __pyx_t_7; __pyx_t_8++) {
     __pyx_t_6 = __pyx_t_8;
-    __pyx_t_2 = PyInt_FromSsize_t((__pyx_t_6[0])); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1043, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t((__pyx_t_6[0])); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1043, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_2);
     __pyx_t_2 = 0;
 
     /* "View.MemoryView":1044
  *     result.view.len = result.view.itemsize
  *     for length in result.view.shape[:ndim]:
  *         result.view.len *= length             # <<<<<<<<<<<<<<
  * 
  *     result.to_object_func = to_object_func
  */
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_result->__pyx_base.view.len); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1044, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_result->__pyx_base.view.len); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1044, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PyNumber_InPlaceMultiply(__pyx_t_2, __pyx_v_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1044, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_InPlaceMultiply(__pyx_t_2, __pyx_v_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1044, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_3); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 1044, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_3); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 1044, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_result->__pyx_base.view.len = __pyx_t_9;
   }
 
   /* "View.MemoryView":1046
  *         result.view.len *= length
  * 
@@ -17109,15 +17663,15 @@
     /* "View.MemoryView":1056
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview             # <<<<<<<<<<<<<<
  *         return &obj.from_slice
  *     else:
  */
-    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(1, 1056, __pyx_L1_error)
+    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(0, 1056, __pyx_L1_error)
     __pyx_t_3 = ((PyObject *)__pyx_v_memview);
     __Pyx_INCREF(__pyx_t_3);
     __pyx_v_obj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
 
     /* "View.MemoryView":1057
  *     if isinstance(memview, _memoryviewslice):
@@ -17335,15 +17889,15 @@
  *     cdef __Pyx_memviewslice memviewslice
  *     slice_copy(memview, &memviewslice)
  *     return memoryview_copy_from_slice(memview, &memviewslice)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_memoryview_copy_object_from_slice(__pyx_v_memview, (&__pyx_v_memviewslice)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1084, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_object_from_slice(__pyx_v_memview, (&__pyx_v_memviewslice)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1084, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":1080
  * 
@@ -17461,15 +18015,15 @@
   /* "View.MemoryView":1103
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,
  *                                 to_object_func, to_dtype_func,
  *                                 memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_5 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 1101, __pyx_L1_error)
+  __pyx_t_5 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1101, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
   /* "View.MemoryView":1087
  * 
@@ -18272,15 +18826,15 @@
     /* "View.MemoryView":1224
  *     result = malloc(size)
  *     if not result:
  *         _err(MemoryError, NULL)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __pyx_memoryview_err(__pyx_builtin_MemoryError, NULL); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 1224, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_err(__pyx_builtin_MemoryError, NULL); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 1224, __pyx_L1_error)
 
     /* "View.MemoryView":1223
  * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
  *         _err(MemoryError, NULL)
  * 
@@ -18488,21 +19042,21 @@
   /* "View.MemoryView":1254
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  *                                                         (i, extent1, extent2))             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err_dim')
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1254, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_extent1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1254, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_extent1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_extent2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1254, __pyx_L1_error)
+  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_extent2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1254, __pyx_L1_error)
+  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);
@@ -18513,23 +19067,23 @@
   /* "View.MemoryView":1253
  * cdef int _err_extents(int i, Py_ssize_t extent1,
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %             # <<<<<<<<<<<<<<
  *                                                         (i, extent1, extent2))
  * 
  */
-  __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1253, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1253, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1253, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1253, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_Raise(__pyx_t_4, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __PYX_ERR(1, 1253, __pyx_L1_error)
+  __PYX_ERR(0, 1253, __pyx_L1_error)
 
   /* "View.MemoryView":1251
  * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
@@ -18577,19 +19131,19 @@
   /* "View.MemoryView":1258
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:
  *     raise error(msg.decode('ascii') % dim)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err')
  */
-  __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1258, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1258, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyUnicode_Format(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 1258, __pyx_L1_error)
+  __pyx_t_4 = PyUnicode_Format(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_INCREF(__pyx_v_error);
   __pyx_t_3 = __pyx_v_error; __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
@@ -18599,20 +19153,20 @@
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1258, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1258, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 1258, __pyx_L1_error)
+  __PYX_ERR(0, 1258, __pyx_L1_error)
 
   /* "View.MemoryView":1257
  * 
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
  *     raise error(msg.decode('ascii') % dim)
  * 
@@ -18672,15 +19226,15 @@
     /* "View.MemoryView":1263
  * cdef int _err(object error, char *msg) except -1 with gil:
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))             # <<<<<<<<<<<<<<
  *     else:
  *         raise error
  */
-    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 1263, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1263, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_error);
     __pyx_t_4 = __pyx_v_error; __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
@@ -18688,20 +19242,20 @@
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1263, __pyx_L1_error)
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1263, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(1, 1263, __pyx_L1_error)
+    __PYX_ERR(0, 1263, __pyx_L1_error)
 
     /* "View.MemoryView":1262
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:
  *     if msg != NULL:             # <<<<<<<<<<<<<<
  *         raise error(msg.decode('ascii'))
  *     else:
@@ -18713,15 +19267,15 @@
  *     else:
  *         raise error             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_contents')
  */
   /*else*/ {
     __Pyx_Raise(__pyx_v_error, 0, 0, 0);
-    __PYX_ERR(1, 1265, __pyx_L1_error)
+    __PYX_ERR(0, 1265, __pyx_L1_error)
   }
 
   /* "View.MemoryView":1261
  * 
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
  *     if msg != NULL:
@@ -18958,15 +19512,15 @@
  *                 src.strides[i] = 0
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])             # <<<<<<<<<<<<<<
  * 
  *         if src.suboffsets[i] >= 0:
  */
       /*else*/ {
-        __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1297, __pyx_L1_error)
+        __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(0, 1297, __pyx_L1_error)
       }
       __pyx_L7:;
 
       /* "View.MemoryView":1292
  * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
@@ -18988,15 +19542,15 @@
       /* "View.MemoryView":1300
  * 
  *         if src.suboffsets[i] >= 0:
  *             _err_dim(ValueError, "Dimension %d is not direct", i)             # <<<<<<<<<<<<<<
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  */
-      __pyx_t_6 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Dimension %d is not direct"), __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(1, 1300, __pyx_L1_error)
+      __pyx_t_6 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Dimension %d is not direct"), __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(0, 1300, __pyx_L1_error)
 
       /* "View.MemoryView":1299
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
@@ -19045,15 +19599,15 @@
     /* "View.MemoryView":1307
  *             order = get_best_order(&dst, ndim)
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)             # <<<<<<<<<<<<<<
  *         src = tmp
  * 
  */
-    __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(1, 1307, __pyx_L1_error)
+    __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(0, 1307, __pyx_L1_error)
     __pyx_v_tmpdata = __pyx_t_7;
 
     /* "View.MemoryView":1308
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  *         src = tmp             # <<<<<<<<<<<<<<
  * 
@@ -19229,24 +19783,24 @@
     /* "View.MemoryView":1329
  * 
  * 
  *         transpose_memslice(&src)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&dst)
  * 
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1329, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(0, 1329, __pyx_L1_error)
 
     /* "View.MemoryView":1330
  * 
  *         transpose_memslice(&src)
  *         transpose_memslice(&dst)             # <<<<<<<<<<<<<<
  * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(1, 1330, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(0, 1330, __pyx_L1_error)
 
     /* "View.MemoryView":1326
  *             return 0
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
  * 
  * 
@@ -19876,40 +20430,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, 1); __PYX_ERR(1, 1, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, 1); __PYX_ERR(0, 1, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, 2); __PYX_ERR(1, 1, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, 2); __PYX_ERR(0, 1, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__pyx_unpickle_Enum") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__pyx_unpickle_Enum") < 0)) __PYX_ERR(0, 1, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v___pyx_type = values[0];
-    __pyx_v___pyx_checksum = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v___pyx_checksum == (long)-1) && PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)
+    __pyx_v___pyx_checksum = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v___pyx_checksum == (long)-1) && PyErr_Occurred())) __PYX_ERR(0, 1, __pyx_L3_error)
     __pyx_v___pyx_state = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 1, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(__pyx_self, __pyx_v___pyx_type, __pyx_v___pyx_checksum, __pyx_v___pyx_state);
 
@@ -19919,151 +20473,155 @@
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_v___pyx_PickleError = 0;
   PyObject *__pyx_v___pyx_result = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  int __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
+  PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum", 0);
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
  */
-  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0xb068931) != 0);
-  if (__pyx_t_1) {
+  __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_tuple__23, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_3 = (__pyx_t_2 != 0);
+  if (__pyx_t_3) {
 
     /* "(tree fragment)":5
  *     cdef object __pyx_result
- *     if __pyx_checksum != 0xb068931:
+ *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):
  *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<
- *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  */
-    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_n_s_PickleError);
     __Pyx_GIVEREF(__pyx_n_s_PickleError);
-    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);
-    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_INCREF(__pyx_t_2);
-    __pyx_v___pyx_PickleError = __pyx_t_2;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_PickleError);
+    __pyx_t_4 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_1, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_INCREF(__pyx_t_1);
+    __pyx_v___pyx_PickleError = __pyx_t_1;
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
     /* "(tree fragment)":6
- *     if __pyx_checksum != 0xb068931:
+ *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)             # <<<<<<<<<<<<<<
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)             # <<<<<<<<<<<<<<
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  */
-    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_1 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_INCREF(__pyx_v___pyx_PickleError);
-    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;
-    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_5)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_5);
+    __pyx_t_1 = __pyx_v___pyx_PickleError; __pyx_t_6 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
+      if (likely(__pyx_t_6)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+        __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __Pyx_DECREF_SET(__pyx_t_1, function);
       }
     }
-    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_5);
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 6, __pyx_L1_error)
+    __PYX_ERR(0, 6, __pyx_L1_error)
 
     /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
- *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
+ *     if __pyx_checksum not in (0xb068931, 0x82a3537, 0x6ae9995):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
  */
   }
 
   /* "(tree fragment)":7
  *         from pickle import PickleError as __pyx_PickleError
- *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)             # <<<<<<<<<<<<<<
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_4);
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_5 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
+    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
+    if (likely(__pyx_t_5)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+      __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __Pyx_DECREF_SET(__pyx_t_1, function);
     }
   }
-  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);
-  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v___pyx_result = __pyx_t_3;
-  __pyx_t_3 = 0;
+  __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_5, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v___pyx_type);
+  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v___pyx_result = __pyx_t_4;
+  __pyx_t_4 = 0;
 
   /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
-  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);
-  __pyx_t_6 = (__pyx_t_1 != 0);
-  if (__pyx_t_6) {
+  __pyx_t_3 = (__pyx_v___pyx_state != Py_None);
+  __pyx_t_2 = (__pyx_t_3 != 0);
+  if (__pyx_t_2) {
 
     /* "(tree fragment)":9
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<
  *     return __pyx_result
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  */
-    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
-    __pyx_t_3 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(0, 9, __pyx_L1_error)
+    __pyx_t_4 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 9, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
     /* "(tree fragment)":8
- *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
+ *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   }
 
@@ -20083,18 +20641,18 @@
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v___pyx_PickleError);
   __Pyx_XDECREF(__pyx_v___pyx_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
@@ -20130,17 +20688,17 @@
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  *     __pyx_result.name = __pyx_state[0]             # <<<<<<<<<<<<<<
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
  *         __pyx_result.__dict__.update(__pyx_state[1])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-    __PYX_ERR(1, 12, __pyx_L1_error)
+    __PYX_ERR(0, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v___pyx_result->name);
   __Pyx_DECREF(__pyx_v___pyx_result->name);
   __pyx_v___pyx_result->name = __pyx_t_1;
   __pyx_t_1 = 0;
 
@@ -20148,59 +20706,59 @@
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
  *         __pyx_result.__dict__.update(__pyx_state[1])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
-    __PYX_ERR(1, 13, __pyx_L1_error)
+    __PYX_ERR(0, 13, __pyx_L1_error)
   }
-  __pyx_t_3 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 13, __pyx_L1_error)
   __pyx_t_4 = ((__pyx_t_3 > 1) != 0);
   if (__pyx_t_4) {
   } else {
     __pyx_t_2 = __pyx_t_4;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_4 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 13, __pyx_L1_error)
   __pyx_t_5 = (__pyx_t_4 != 0);
   __pyx_t_2 = __pyx_t_5;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_2) {
 
     /* "(tree fragment)":14
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
  *         __pyx_result.__dict__.update(__pyx_state[1])             # <<<<<<<<<<<<<<
  */
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_update); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_update); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     if (unlikely(__pyx_v___pyx_state == Py_None)) {
       PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-      __PYX_ERR(1, 14, __pyx_L1_error)
+      __PYX_ERR(0, 14, __pyx_L1_error)
     }
-    __pyx_t_6 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __pyx_t_8 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
       __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
       if (likely(__pyx_t_8)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
         __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_7, function);
       }
     }
     __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);
     __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
     /* "(tree fragment)":13
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  *     __pyx_result.name = __pyx_state[0]
@@ -20229,66 +20787,67 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_tp_new_7biogeme_8cbiogeme_pyBiogeme(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
-  struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *p;
+static PyObject *__pyx_tp_new_3src_8cbiogeme_pyBiogeme(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
+  struct __pyx_obj_3src_8cbiogeme_pyBiogeme *p;
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
   } else {
     o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
   }
   if (unlikely(!o)) return 0;
-  p = ((struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)o);
+  p = ((struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)o);
   new((void*)&(p->theBiogeme)) biogeme();
-  if (unlikely(__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) goto bad;
+  if (unlikely(__pyx_pw_3src_8cbiogeme_9pyBiogeme_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) goto bad;
   return o;
   bad:
   Py_DECREF(o); o = 0;
   return NULL;
 }
 
-static void __pyx_tp_dealloc_7biogeme_8cbiogeme_pyBiogeme(PyObject *o) {
-  struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *p = (struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme *)o;
+static void __pyx_tp_dealloc_3src_8cbiogeme_pyBiogeme(PyObject *o) {
+  struct __pyx_obj_3src_8cbiogeme_pyBiogeme *p = (struct __pyx_obj_3src_8cbiogeme_pyBiogeme *)o;
   #if CYTHON_USE_TP_FINALIZE
   if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   __Pyx_call_destructor(p->theBiogeme);
   (*Py_TYPE(o)->tp_free)(o);
 }
 
-static PyMethodDef __pyx_methods_7biogeme_8cbiogeme_pyBiogeme[] = {
-  {"setPanel", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_3setPanel, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_2setPanel},
-  {"calculateLikelihoodAndDerivatives", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_5calculateLikelihoodAndDerivatives, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_4calculateLikelihoodAndDerivatives},
-  {"setBounds", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_7setBounds, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_6setBounds},
-  {"calculateLikelihood", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_9calculateLikelihood, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_8calculateLikelihood},
-  {"simulateFormula", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_11simulateFormula, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_10simulateFormula},
-  {"simulateSeveralFormulas", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_13simulateSeveralFormulas, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_12simulateSeveralFormulas},
-  {"setExpressions", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_15setExpressions, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_14setExpressions},
-  {"setData", (PyCFunction)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_17setData, METH_O, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_16setData},
-  {"setDataMap", (PyCFunction)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_19setDataMap, METH_O, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_18setDataMap},
-  {"setMissingData", (PyCFunction)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_21setMissingData, METH_O, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_20setMissingData},
-  {"setDraws", (PyCFunction)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_23setDraws, METH_O, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_22setDraws},
-  {"__reduce_cython__", (PyCFunction)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_25__reduce_cython__, METH_NOARGS, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_24__reduce_cython__},
-  {"__setstate_cython__", (PyCFunction)__pyx_pw_7biogeme_8cbiogeme_9pyBiogeme_27__setstate_cython__, METH_O, __pyx_doc_7biogeme_8cbiogeme_9pyBiogeme_26__setstate_cython__},
+static PyMethodDef __pyx_methods_3src_8cbiogeme_pyBiogeme[] = {
+  {"setPanel", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3src_8cbiogeme_9pyBiogeme_3setPanel, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3src_8cbiogeme_9pyBiogeme_2setPanel},
+  {"calculateLikelihoodAndDerivatives", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3src_8cbiogeme_9pyBiogeme_5calculateLikelihoodAndDerivatives, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3src_8cbiogeme_9pyBiogeme_4calculateLikelihoodAndDerivatives},
+  {"setBounds", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3src_8cbiogeme_9pyBiogeme_7setBounds, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3src_8cbiogeme_9pyBiogeme_6setBounds},
+  {"calculateLikelihood", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3src_8cbiogeme_9pyBiogeme_9calculateLikelihood, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3src_8cbiogeme_9pyBiogeme_8calculateLikelihood},
+  {"simulateSimpleFormula", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3src_8cbiogeme_9pyBiogeme_11simulateSimpleFormula, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3src_8cbiogeme_9pyBiogeme_10simulateSimpleFormula},
+  {"simulateFormula", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3src_8cbiogeme_9pyBiogeme_13simulateFormula, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3src_8cbiogeme_9pyBiogeme_12simulateFormula},
+  {"simulateSeveralFormulas", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3src_8cbiogeme_9pyBiogeme_15simulateSeveralFormulas, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3src_8cbiogeme_9pyBiogeme_14simulateSeveralFormulas},
+  {"setExpressions", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_3src_8cbiogeme_9pyBiogeme_17setExpressions, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3src_8cbiogeme_9pyBiogeme_16setExpressions},
+  {"setData", (PyCFunction)__pyx_pw_3src_8cbiogeme_9pyBiogeme_19setData, METH_O, __pyx_doc_3src_8cbiogeme_9pyBiogeme_18setData},
+  {"setDataMap", (PyCFunction)__pyx_pw_3src_8cbiogeme_9pyBiogeme_21setDataMap, METH_O, __pyx_doc_3src_8cbiogeme_9pyBiogeme_20setDataMap},
+  {"setMissingData", (PyCFunction)__pyx_pw_3src_8cbiogeme_9pyBiogeme_23setMissingData, METH_O, __pyx_doc_3src_8cbiogeme_9pyBiogeme_22setMissingData},
+  {"setDraws", (PyCFunction)__pyx_pw_3src_8cbiogeme_9pyBiogeme_25setDraws, METH_O, __pyx_doc_3src_8cbiogeme_9pyBiogeme_24setDraws},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw_3src_8cbiogeme_9pyBiogeme_27__reduce_cython__, METH_NOARGS, __pyx_doc_3src_8cbiogeme_9pyBiogeme_26__reduce_cython__},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw_3src_8cbiogeme_9pyBiogeme_29__setstate_cython__, METH_O, __pyx_doc_3src_8cbiogeme_9pyBiogeme_28__setstate_cython__},
   {0, 0, 0, 0}
 };
 
-static PyTypeObject __pyx_type_7biogeme_8cbiogeme_pyBiogeme = {
+static PyTypeObject __pyx_type_3src_8cbiogeme_pyBiogeme = {
   PyVarObject_HEAD_INIT(0, 0)
-  "biogeme.cbiogeme.pyBiogeme", /*tp_name*/
-  sizeof(struct __pyx_obj_7biogeme_8cbiogeme_pyBiogeme), /*tp_basicsize*/
+  "src.cbiogeme.pyBiogeme", /*tp_name*/
+  sizeof(struct __pyx_obj_3src_8cbiogeme_pyBiogeme), /*tp_basicsize*/
   0, /*tp_itemsize*/
-  __pyx_tp_dealloc_7biogeme_8cbiogeme_pyBiogeme, /*tp_dealloc*/
+  __pyx_tp_dealloc_3src_8cbiogeme_pyBiogeme, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
   0, /*tp_vectorcall_offset*/
   #endif
   0, /*tp_getattr*/
@@ -20313,43 +20872,46 @@
   0, /*tp_doc*/
   0, /*tp_traverse*/
   0, /*tp_clear*/
   0, /*tp_richcompare*/
   0, /*tp_weaklistoffset*/
   0, /*tp_iter*/
   0, /*tp_iternext*/
-  __pyx_methods_7biogeme_8cbiogeme_pyBiogeme, /*tp_methods*/
+  __pyx_methods_3src_8cbiogeme_pyBiogeme, /*tp_methods*/
   0, /*tp_members*/
   0, /*tp_getset*/
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
   0, /*tp_dictoffset*/
   0, /*tp_init*/
   0, /*tp_alloc*/
-  __pyx_tp_new_7biogeme_8cbiogeme_pyBiogeme, /*tp_new*/
+  __pyx_tp_new_3src_8cbiogeme_pyBiogeme, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  0, /*tp_pypy_flags*/
+  #endif
 };
 static struct __pyx_vtabstruct_array __pyx_vtable_array;
 
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_array_obj *p;
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
@@ -20466,15 +21028,15 @@
   #endif
   __pyx_array_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_array = {
   PyVarObject_HEAD_INIT(0, 0)
-  "biogeme.cbiogeme.array", /*tp_name*/
+  "src.cbiogeme.array", /*tp_name*/
   sizeof(struct __pyx_array_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_array, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -20525,20 +21087,23 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  0, /*tp_pypy_flags*/
+  #endif
 };
 
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_MemviewEnum_obj *p;
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
     o = (*t->tp_alloc)(t, 0);
@@ -20585,15 +21150,15 @@
   {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_1__reduce_cython__, METH_NOARGS, 0},
   {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_3__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type___pyx_MemviewEnum = {
   PyVarObject_HEAD_INIT(0, 0)
-  "biogeme.cbiogeme.Enum", /*tp_name*/
+  "src.cbiogeme.Enum", /*tp_name*/
   sizeof(struct __pyx_MemviewEnum_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_Enum, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -20644,20 +21209,23 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  0, /*tp_pypy_flags*/
+  #endif
 };
 static struct __pyx_vtabstruct_memoryview __pyx_vtable_memoryview;
 
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryview_obj *p;
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
@@ -20846,15 +21414,15 @@
   #endif
   __pyx_memoryview_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_memoryview = {
   PyVarObject_HEAD_INIT(0, 0)
-  "biogeme.cbiogeme.memoryview", /*tp_name*/
+  "src.cbiogeme.memoryview", /*tp_name*/
   sizeof(struct __pyx_memoryview_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_memoryview, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -20905,20 +21473,23 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  0, /*tp_pypy_flags*/
+  #endif
 };
 static struct __pyx_vtabstruct__memoryviewslice __pyx_vtable__memoryviewslice;
 
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryviewslice_obj *p;
   PyObject *o = __pyx_tp_new_memoryview(t, a, k);
   if (unlikely(!o)) return 0;
@@ -20984,15 +21555,15 @@
 static struct PyGetSetDef __pyx_getsets__memoryviewslice[] = {
   {(char *)"base", __pyx_getprop___pyx_memoryviewslice_base, 0, (char *)0, 0},
   {0, 0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type___pyx_memoryviewslice = {
   PyVarObject_HEAD_INIT(0, 0)
-  "biogeme.cbiogeme._memoryviewslice", /*tp_name*/
+  "src.cbiogeme._memoryviewslice", /*tp_name*/
   sizeof(struct __pyx_memoryviewslice_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc__memoryviewslice, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -21051,20 +21622,23 @@
   0, /*tp_subclasses*/
   0, /*tp_weaklist*/
   0, /*tp_del*/
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
-  #if PY_VERSION_HEX >= 0x030800b1
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  0, /*tp_pypy_flags*/
+  #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
 
 #if PY_MAJOR_VERSION >= 3
@@ -21107,23 +21681,23 @@
     #define CYTHON_SMALL_CODE
 #endif
 #endif
 
 static __Pyx_StringTabEntry __pyx_string_tab[] = {
   {&__pyx_n_s_ASCII, __pyx_k_ASCII, sizeof(__pyx_k_ASCII), 0, 0, 1, 1},
   {&__pyx_kp_s_Buffer_view_does_not_expose_stri, __pyx_k_Buffer_view_does_not_expose_stri, sizeof(__pyx_k_Buffer_view_does_not_expose_stri), 0, 0, 1, 0},
-  {&__pyx_n_u_C_CONTIGUOUS, __pyx_k_C_CONTIGUOUS, sizeof(__pyx_k_C_CONTIGUOUS), 0, 1, 0, 1},
+  {&__pyx_n_s_C_CONTIGUOUS, __pyx_k_C_CONTIGUOUS, sizeof(__pyx_k_C_CONTIGUOUS), 0, 0, 1, 1},
   {&__pyx_kp_s_Can_only_create_a_buffer_that_is, __pyx_k_Can_only_create_a_buffer_that_is, sizeof(__pyx_k_Can_only_create_a_buffer_that_is), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_assign_to_read_only_memor, __pyx_k_Cannot_assign_to_read_only_memor, sizeof(__pyx_k_Cannot_assign_to_read_only_memor), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_create_writable_memory_vi, __pyx_k_Cannot_create_writable_memory_vi, sizeof(__pyx_k_Cannot_create_writable_memory_vi), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_index_with_type_s, __pyx_k_Cannot_index_with_type_s, sizeof(__pyx_k_Cannot_index_with_type_s), 0, 0, 1, 0},
   {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
   {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
   {&__pyx_n_s_ImportError, __pyx_k_ImportError, sizeof(__pyx_k_ImportError), 0, 0, 1, 1},
-  {&__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_k_Incompatible_checksums_s_vs_0xb0, sizeof(__pyx_k_Incompatible_checksums_s_vs_0xb0), 0, 0, 1, 0},
+  {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
   {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
   {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
   {&__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_k_Invalid_mode_expected_c_or_fortr, sizeof(__pyx_k_Invalid_mode_expected_c_or_fortr), 0, 0, 1, 0},
   {&__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_k_Invalid_shape_in_axis_d_d, sizeof(__pyx_k_Invalid_shape_in_axis_d_d), 0, 0, 1, 0},
   {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
   {&__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_k_MemoryView_of_r_at_0x_x, sizeof(__pyx_k_MemoryView_of_r_at_0x_x), 0, 0, 1, 0},
   {&__pyx_kp_s_MemoryView_of_r_object, __pyx_k_MemoryView_of_r_object, sizeof(__pyx_k_MemoryView_of_r_object), 0, 0, 1, 0},
@@ -21137,43 +21711,46 @@
   {&__pyx_n_s_allocate_buffer, __pyx_k_allocate_buffer, sizeof(__pyx_k_allocate_buffer), 0, 0, 1, 1},
   {&__pyx_n_s_ascontiguousarray, __pyx_k_ascontiguousarray, sizeof(__pyx_k_ascontiguousarray), 0, 0, 1, 1},
   {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
   {&__pyx_n_s_betaIds, __pyx_k_betaIds, sizeof(__pyx_k_betaIds), 0, 0, 1, 1},
   {&__pyx_n_s_betas, __pyx_k_betas, sizeof(__pyx_k_betas), 0, 0, 1, 1},
   {&__pyx_n_s_bhhh, __pyx_k_bhhh, sizeof(__pyx_k_bhhh), 0, 0, 1, 1},
   {&__pyx_n_s_bmem, __pyx_k_bmem, sizeof(__pyx_k_bmem), 0, 0, 1, 1},
-  {&__pyx_kp_u_bmem_not_contiguous, __pyx_k_bmem_not_contiguous, sizeof(__pyx_k_bmem_not_contiguous), 0, 1, 0, 0},
+  {&__pyx_kp_s_bmem_not_contiguous, __pyx_k_bmem_not_contiguous, sizeof(__pyx_k_bmem_not_contiguous), 0, 0, 1, 0},
   {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
   {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
   {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
   {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
   {&__pyx_kp_s_contiguous_and_direct, __pyx_k_contiguous_and_direct, sizeof(__pyx_k_contiguous_and_direct), 0, 0, 1, 0},
   {&__pyx_kp_s_contiguous_and_indirect, __pyx_k_contiguous_and_indirect, sizeof(__pyx_k_contiguous_and_indirect), 0, 0, 1, 0},
   {&__pyx_n_s_d, __pyx_k_d, sizeof(__pyx_k_d), 0, 0, 1, 1},
   {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
   {&__pyx_n_s_draws, __pyx_k_draws, sizeof(__pyx_k_draws), 0, 0, 1, 1},
   {&__pyx_n_s_dtype_is_object, __pyx_k_dtype_is_object, sizeof(__pyx_k_dtype_is_object), 0, 0, 1, 1},
   {&__pyx_n_s_empty, __pyx_k_empty, sizeof(__pyx_k_empty), 0, 0, 1, 1},
   {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
+  {&__pyx_n_s_end, __pyx_k_end, sizeof(__pyx_k_end), 0, 0, 1, 1},
   {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
   {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
+  {&__pyx_n_s_file, __pyx_k_file, sizeof(__pyx_k_file), 0, 0, 1, 1},
   {&__pyx_n_s_fixedBetas, __pyx_k_fixedBetas, sizeof(__pyx_k_fixedBetas), 0, 0, 1, 1},
   {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
   {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
   {&__pyx_n_s_formula, __pyx_k_formula, sizeof(__pyx_k_formula), 0, 0, 1, 1},
   {&__pyx_n_s_formulas, __pyx_k_formulas, sizeof(__pyx_k_formulas), 0, 0, 1, 1},
   {&__pyx_n_s_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 0, 1, 1},
   {&__pyx_n_u_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 1, 0, 1},
   {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
   {&__pyx_n_s_gmem, __pyx_k_gmem, sizeof(__pyx_k_gmem), 0, 0, 1, 1},
-  {&__pyx_kp_u_gmem_not_contiguous, __pyx_k_gmem_not_contiguous, sizeof(__pyx_k_gmem_not_contiguous), 0, 1, 0, 0},
+  {&__pyx_kp_s_gmem_not_contiguous, __pyx_k_gmem_not_contiguous, sizeof(__pyx_k_gmem_not_contiguous), 0, 0, 1, 0},
   {&__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_k_got_differing_extents_in_dimensi, sizeof(__pyx_k_got_differing_extents_in_dimensi), 0, 0, 1, 0},
+  {&__pyx_n_s_gradient, __pyx_k_gradient, sizeof(__pyx_k_gradient), 0, 0, 1, 1},
   {&__pyx_n_s_hessian, __pyx_k_hessian, sizeof(__pyx_k_hessian), 0, 0, 1, 1},
   {&__pyx_n_s_hmem, __pyx_k_hmem, sizeof(__pyx_k_hmem), 0, 0, 1, 1},
-  {&__pyx_kp_u_hmem_not_contiguous, __pyx_k_hmem_not_contiguous, sizeof(__pyx_k_hmem_not_contiguous), 0, 1, 0, 0},
+  {&__pyx_kp_s_hmem_not_contiguous, __pyx_k_hmem_not_contiguous, sizeof(__pyx_k_hmem_not_contiguous), 0, 0, 1, 0},
   {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
   {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
   {&__pyx_n_s_itemsize, __pyx_k_itemsize, sizeof(__pyx_k_itemsize), 0, 0, 1, 1},
   {&__pyx_kp_s_itemsize_0_for_cython_array, __pyx_k_itemsize_0_for_cython_array, sizeof(__pyx_k_itemsize_0_for_cython_array), 0, 0, 1, 0},
   {&__pyx_n_s_lb, __pyx_k_lb, sizeof(__pyx_k_lb), 0, 0, 1, 1},
   {&__pyx_n_s_loglikeFormulas, __pyx_k_loglikeFormulas, sizeof(__pyx_k_loglikeFormulas), 0, 0, 1, 1},
   {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
@@ -21184,31 +21761,31 @@
   {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
   {&__pyx_n_s_nbrOfThreads, __pyx_k_nbrOfThreads, sizeof(__pyx_k_nbrOfThreads), 0, 0, 1, 1},
   {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
   {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
   {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
   {&__pyx_n_s_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 0, 1, 1},
   {&__pyx_n_s_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 0, 1, 1},
-  {&__pyx_kp_u_numpy_core_multiarray_failed_to, __pyx_k_numpy_core_multiarray_failed_to, sizeof(__pyx_k_numpy_core_multiarray_failed_to), 0, 1, 0, 0},
-  {&__pyx_kp_u_numpy_core_umath_failed_to_impor, __pyx_k_numpy_core_umath_failed_to_impor, sizeof(__pyx_k_numpy_core_umath_failed_to_impor), 0, 1, 0, 0},
+  {&__pyx_kp_s_numpy_core_multiarray_failed_to, __pyx_k_numpy_core_multiarray_failed_to, sizeof(__pyx_k_numpy_core_multiarray_failed_to), 0, 0, 1, 0},
+  {&__pyx_kp_s_numpy_core_umath_failed_to_impor, __pyx_k_numpy_core_umath_failed_to_impor, sizeof(__pyx_k_numpy_core_umath_failed_to_impor), 0, 0, 1, 0},
   {&__pyx_n_s_obj, __pyx_k_obj, sizeof(__pyx_k_obj), 0, 0, 1, 1},
   {&__pyx_n_s_pack, __pyx_k_pack, sizeof(__pyx_k_pack), 0, 0, 1, 1},
   {&__pyx_n_s_panel, __pyx_k_panel, sizeof(__pyx_k_panel), 0, 0, 1, 1},
   {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
   {&__pyx_n_s_print, __pyx_k_print, sizeof(__pyx_k_print), 0, 0, 1, 1},
   {&__pyx_n_s_pyBiogeme, __pyx_k_pyBiogeme, sizeof(__pyx_k_pyBiogeme), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_PickleError, __pyx_k_pyx_PickleError, sizeof(__pyx_k_pyx_PickleError), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_checksum, __pyx_k_pyx_checksum, sizeof(__pyx_k_pyx_checksum), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_getbuffer, __pyx_k_pyx_getbuffer, sizeof(__pyx_k_pyx_getbuffer), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_result, __pyx_k_pyx_result, sizeof(__pyx_k_pyx_result), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_unpickle_Enum, __pyx_k_pyx_unpickle_Enum, sizeof(__pyx_k_pyx_unpickle_Enum), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
-  {&__pyx_kp_u_r_not_contiguous, __pyx_k_r_not_contiguous, sizeof(__pyx_k_r_not_contiguous), 0, 1, 0, 0},
+  {&__pyx_kp_s_r_not_contiguous, __pyx_k_r_not_contiguous, sizeof(__pyx_k_r_not_contiguous), 0, 0, 1, 0},
   {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
   {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
   {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
   {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
   {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
@@ -21228,387 +21805,347 @@
   {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
   {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
   {&__pyx_n_s_weightFormulas, __pyx_k_weightFormulas, sizeof(__pyx_k_weightFormulas), 0, 0, 1, 1},
   {&__pyx_n_s_zeros, __pyx_k_zeros, sizeof(__pyx_k_zeros), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_print = __Pyx_GetBuiltinName(__pyx_n_s_print); if (!__pyx_builtin_print) __PYX_ERR(0, 93, __pyx_L1_error)
-  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
-  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(2, 947, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 133, __pyx_L1_error)
-  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(1, 148, __pyx_L1_error)
-  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 151, __pyx_L1_error)
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(1, 180, __pyx_L1_error)
-  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 404, __pyx_L1_error)
-  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 613, __pyx_L1_error)
-  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 832, __pyx_L1_error)
+  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(0, 2, __pyx_L1_error)
+  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(2, 944, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 133, __pyx_L1_error)
+  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 148, __pyx_L1_error)
+  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(0, 151, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 180, __pyx_L1_error)
+  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(0, 404, __pyx_L1_error)
+  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(0, 613, __pyx_L1_error)
+  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(0, 832, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "src/cbiogeme.pyx":93
- * 
- * 		if not gmem.flags['C_CONTIGUOUS']:
- * 			print('gmem not contiguous')             # <<<<<<<<<<<<<<
- * 			gmem = np.ascontiguousarray(gmem)
- * 		if not hmem.flags['C_CONTIGUOUS']:
- */
-  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_gmem_not_contiguous); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 93, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple_);
-  __Pyx_GIVEREF(__pyx_tuple_);
-
-  /* "src/cbiogeme.pyx":96
- * 			gmem = np.ascontiguousarray(gmem)
- * 		if not hmem.flags['C_CONTIGUOUS']:
- * 			print('hmem not contiguous')             # <<<<<<<<<<<<<<
- * 			hmem = np.ascontiguousarray(hmem)
- * 		if not bmem.flags['C_CONTIGUOUS']:
- */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_hmem_not_contiguous); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 96, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__2);
-  __Pyx_GIVEREF(__pyx_tuple__2);
-
-  /* "src/cbiogeme.pyx":99
- * 			hmem = np.ascontiguousarray(hmem)
- * 		if not bmem.flags['C_CONTIGUOUS']:
- * 			print('bmem not contiguous')             # <<<<<<<<<<<<<<
- * 			bmem = np.ascontiguousarray(bmem)
- * 
- */
-  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_u_bmem_not_contiguous); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 99, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__3);
-  __Pyx_GIVEREF(__pyx_tuple__3);
-
-  /* "src/cbiogeme.pyx":128
- * 		r = np.empty(n)
- * 		if not r.flags['C_CONTIGUOUS']:
- * 			print('r not contiguous')             # <<<<<<<<<<<<<<
- * 			r = np.ascontiguousarray(r)
- * 		d = np.ascontiguousarray(d)
- */
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_r_not_contiguous); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 128, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__4);
-  __Pyx_GIVEREF(__pyx_tuple__4);
-
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__5);
-  __Pyx_GIVEREF(__pyx_tuple__5);
+  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple_);
+  __Pyx_GIVEREF(__pyx_tuple_);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__6);
-  __Pyx_GIVEREF(__pyx_tuple__6);
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__2);
+  __Pyx_GIVEREF(__pyx_tuple__2);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":947
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":944
  *         __pyx_import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_umath() except -1:
  */
-  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_u_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(2, 947, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__7);
-  __Pyx_GIVEREF(__pyx_tuple__7);
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(2, 944, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__3);
+  __Pyx_GIVEREF(__pyx_tuple__3);
 
-  /* "../../../opt/anaconda3/envs/python38/lib/python3.8/site-packages/numpy/__init__.pxd":953
+  /* "../../../opt/anaconda3/envs/python310/lib/python3.10/site-packages/numpy/__init__.pxd":950
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_ufunc() except -1:
  */
-  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_u_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(2, 953, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__8);
-  __Pyx_GIVEREF(__pyx_tuple__8);
+  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(2, 950, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__4);
+  __Pyx_GIVEREF(__pyx_tuple__4);
 
   /* "View.MemoryView":133
  * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 133, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__9);
-  __Pyx_GIVEREF(__pyx_tuple__9);
+  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 133, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__5);
+  __Pyx_GIVEREF(__pyx_tuple__5);
 
   /* "View.MemoryView":136
  * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(1, 136, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__10);
-  __Pyx_GIVEREF(__pyx_tuple__10);
+  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 136, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__6);
+  __Pyx_GIVEREF(__pyx_tuple__6);
 
   /* "View.MemoryView":148
  * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 148, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__11);
-  __Pyx_GIVEREF(__pyx_tuple__11);
+  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(0, 148, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__7);
+  __Pyx_GIVEREF(__pyx_tuple__7);
 
   /* "View.MemoryView":176
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
  * 
  *             if self.dtype_is_object:
  */
-  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 176, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__12);
-  __Pyx_GIVEREF(__pyx_tuple__12);
+  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 176, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__8);
+  __Pyx_GIVEREF(__pyx_tuple__8);
 
   /* "View.MemoryView":192
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 192, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__13);
-  __Pyx_GIVEREF(__pyx_tuple__13);
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__9);
+  __Pyx_GIVEREF(__pyx_tuple__9);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__14);
-  __Pyx_GIVEREF(__pyx_tuple__14);
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__10);
+  __Pyx_GIVEREF(__pyx_tuple__10);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__15);
-  __Pyx_GIVEREF(__pyx_tuple__15);
+  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__11);
+  __Pyx_GIVEREF(__pyx_tuple__11);
 
   /* "View.MemoryView":418
  *     def __setitem__(memoryview self, object index, object value):
  *         if self.view.readonly:
  *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  */
-  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(1, 418, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__16);
-  __Pyx_GIVEREF(__pyx_tuple__16);
+  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 418, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__12);
+  __Pyx_GIVEREF(__pyx_tuple__12);
 
   /* "View.MemoryView":495
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 495, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__17);
-  __Pyx_GIVEREF(__pyx_tuple__17);
+  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 495, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__13);
+  __Pyx_GIVEREF(__pyx_tuple__13);
 
   /* "View.MemoryView":520
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         if flags & PyBUF_WRITABLE and self.view.readonly:
  *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_ND:
  */
-  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 520, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__18);
-  __Pyx_GIVEREF(__pyx_tuple__18);
+  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 520, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__14);
+  __Pyx_GIVEREF(__pyx_tuple__14);
 
   /* "View.MemoryView":570
  *         if self.view.strides == NULL:
  * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 570, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__19);
-  __Pyx_GIVEREF(__pyx_tuple__19);
+  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(0, 570, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__15);
+  __Pyx_GIVEREF(__pyx_tuple__15);
 
   /* "View.MemoryView":577
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
-  __pyx_tuple__20 = PyTuple_New(1); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(1, 577, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__20);
+  __pyx_tuple__16 = PyTuple_New(1); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 577, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__16);
   __Pyx_INCREF(__pyx_int_neg_1);
   __Pyx_GIVEREF(__pyx_int_neg_1);
-  PyTuple_SET_ITEM(__pyx_tuple__20, 0, __pyx_int_neg_1);
-  __Pyx_GIVEREF(__pyx_tuple__20);
+  PyTuple_SET_ITEM(__pyx_tuple__16, 0, __pyx_int_neg_1);
+  __Pyx_GIVEREF(__pyx_tuple__16);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__21);
-  __Pyx_GIVEREF(__pyx_tuple__21);
+  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(0, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__17);
+  __Pyx_GIVEREF(__pyx_tuple__17);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__22);
-  __Pyx_GIVEREF(__pyx_tuple__22);
+  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__18);
+  __Pyx_GIVEREF(__pyx_tuple__18);
 
   /* "View.MemoryView":682
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
  *                 seen_ellipsis = True
  *             else:
  */
-  __pyx_slice__23 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__23)) __PYX_ERR(1, 682, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice__23);
-  __Pyx_GIVEREF(__pyx_slice__23);
+  __pyx_slice__19 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__19)) __PYX_ERR(0, 682, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_slice__19);
+  __Pyx_GIVEREF(__pyx_slice__19);
 
   /* "View.MemoryView":703
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(1, 703, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__24);
-  __Pyx_GIVEREF(__pyx_tuple__24);
+  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__20);
+  __Pyx_GIVEREF(__pyx_tuple__20);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__25);
-  __Pyx_GIVEREF(__pyx_tuple__25);
+  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__21);
+  __Pyx_GIVEREF(__pyx_tuple__21);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(1, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__26);
-  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__22);
+  __Pyx_GIVEREF(__pyx_tuple__22);
+  __pyx_tuple__23 = PyTuple_Pack(3, __pyx_int_184977713, __pyx_int_136983863, __pyx_int_112105877); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(0, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__23);
+  __Pyx_GIVEREF(__pyx_tuple__23);
 
   /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(1, 286, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__27);
-  __Pyx_GIVEREF(__pyx_tuple__27);
+  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__24);
+  __Pyx_GIVEREF(__pyx_tuple__24);
 
   /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(1, 287, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__28);
-  __Pyx_GIVEREF(__pyx_tuple__28);
+  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 287, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__25);
+  __Pyx_GIVEREF(__pyx_tuple__25);
 
   /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(1, 288, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__29);
-  __Pyx_GIVEREF(__pyx_tuple__29);
+  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(0, 288, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__26);
+  __Pyx_GIVEREF(__pyx_tuple__26);
 
   /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(1, 291, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__30);
-  __Pyx_GIVEREF(__pyx_tuple__30);
+  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 291, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__27);
+  __Pyx_GIVEREF(__pyx_tuple__27);
 
   /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__31 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(1, 292, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__31);
-  __Pyx_GIVEREF(__pyx_tuple__31);
+  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__28);
+  __Pyx_GIVEREF(__pyx_tuple__28);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_tuple__32 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__32);
-  __Pyx_GIVEREF(__pyx_tuple__32);
-  __pyx_codeobj__33 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__32, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__33)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_tuple__29 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__29);
+  __Pyx_GIVEREF(__pyx_tuple__29);
+  __pyx_codeobj__30 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__30)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
-  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
-  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_184977713 = PyInt_FromLong(184977713L); if (unlikely(!__pyx_int_184977713)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(1, 1, __pyx_L1_error);
+  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_int_112105877 = PyInt_FromLong(112105877L); if (unlikely(!__pyx_int_112105877)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_int_136983863 = PyInt_FromLong(136983863L); if (unlikely(!__pyx_int_136983863)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_int_184977713 = PyInt_FromLong(184977713L); if (unlikely(!__pyx_int_184977713)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(1, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
@@ -21650,74 +22187,74 @@
 static int __Pyx_modinit_type_init_code(void) {
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
-  if (PyType_Ready(&__pyx_type_7biogeme_8cbiogeme_pyBiogeme) < 0) __PYX_ERR(0, 70, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_3src_8cbiogeme_pyBiogeme) < 0) __PYX_ERR(1, 79, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
-  __pyx_type_7biogeme_8cbiogeme_pyBiogeme.tp_print = 0;
+  __pyx_type_3src_8cbiogeme_pyBiogeme.tp_print = 0;
   #endif
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_7biogeme_8cbiogeme_pyBiogeme.tp_dictoffset && __pyx_type_7biogeme_8cbiogeme_pyBiogeme.tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_type_7biogeme_8cbiogeme_pyBiogeme.tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_3src_8cbiogeme_pyBiogeme.tp_dictoffset && __pyx_type_3src_8cbiogeme_pyBiogeme.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type_3src_8cbiogeme_pyBiogeme.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_pyBiogeme, (PyObject *)&__pyx_type_7biogeme_8cbiogeme_pyBiogeme) < 0) __PYX_ERR(0, 70, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_7biogeme_8cbiogeme_pyBiogeme) < 0) __PYX_ERR(0, 70, __pyx_L1_error)
-  __pyx_ptype_7biogeme_8cbiogeme_pyBiogeme = &__pyx_type_7biogeme_8cbiogeme_pyBiogeme;
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_pyBiogeme, (PyObject *)&__pyx_type_3src_8cbiogeme_pyBiogeme) < 0) __PYX_ERR(1, 79, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_3src_8cbiogeme_pyBiogeme) < 0) __PYX_ERR(1, 79, __pyx_L1_error)
+  __pyx_ptype_3src_8cbiogeme_pyBiogeme = &__pyx_type_3src_8cbiogeme_pyBiogeme;
   __pyx_vtabptr_array = &__pyx_vtable_array;
   __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
-  if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_array.tp_print = 0;
   #endif
-  if (__Pyx_SetVtable(__pyx_type___pyx_array.tp_dict, __pyx_vtabptr_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 105, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type___pyx_array.tp_dict, __pyx_vtabptr_array) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_array) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __pyx_array_type = &__pyx_type___pyx_array;
-  if (PyType_Ready(&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 279, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(0, 279, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_MemviewEnum.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_MemviewEnum.tp_dictoffset && __pyx_type___pyx_MemviewEnum.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type___pyx_MemviewEnum.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(1, 279, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(0, 279, __pyx_L1_error)
   __pyx_MemviewEnum_type = &__pyx_type___pyx_MemviewEnum;
   __pyx_vtabptr_memoryview = &__pyx_vtable_memoryview;
   __pyx_vtable_memoryview.get_item_pointer = (char *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_get_item_pointer;
   __pyx_vtable_memoryview.is_slice = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_is_slice;
   __pyx_vtable_memoryview.setitem_slice_assignment = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_slice_assignment;
   __pyx_vtable_memoryview.setitem_slice_assign_scalar = (PyObject *(*)(struct __pyx_memoryview_obj *, struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_setitem_slice_assign_scalar;
   __pyx_vtable_memoryview.setitem_indexed = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_indexed;
   __pyx_vtable_memoryview.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryview_convert_item_to_object;
   __pyx_vtable_memoryview.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryview_assign_item_from_object;
-  if (PyType_Ready(&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(0, 330, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_memoryview.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryview.tp_dictoffset && __pyx_type___pyx_memoryview.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type___pyx_memoryview.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type___pyx_memoryview.tp_dict, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(1, 330, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryview.tp_dict, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(0, 330, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(0, 330, __pyx_L1_error)
   __pyx_memoryview_type = &__pyx_type___pyx_memoryview;
   __pyx_vtabptr__memoryviewslice = &__pyx_vtable__memoryviewslice;
   __pyx_vtable__memoryviewslice.__pyx_base = *__pyx_vtabptr_memoryview;
   __pyx_vtable__memoryviewslice.__pyx_base.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryviewslice_convert_item_to_object;
   __pyx_vtable__memoryviewslice.__pyx_base.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryviewslice_assign_item_from_object;
   __pyx_type___pyx_memoryviewslice.tp_base = __pyx_memoryview_type;
-  if (PyType_Ready(&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(0, 965, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_memoryviewslice.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryviewslice.tp_dictoffset && __pyx_type___pyx_memoryviewslice.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type___pyx_memoryviewslice.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type___pyx_memoryviewslice.tp_dict, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(1, 965, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryviewslice.tp_dict, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(0, 965, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(0, 965, __pyx_L1_error)
   __pyx_memoryviewslice_type = &__pyx_type___pyx_memoryviewslice;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
@@ -21737,46 +22274,46 @@
   sizeof(PyTypeObject),
   #else
   sizeof(PyHeapTypeObject),
   #endif
   __Pyx_ImportType_CheckSize_Warn);
    if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(3, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyImport_ImportModule("numpy"); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 200, __pyx_L1_error)
+  __pyx_t_1 = PyImport_ImportModule("numpy"); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 199, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_ptype_5numpy_dtype = __Pyx_ImportType(__pyx_t_1, "numpy", "dtype", sizeof(PyArray_Descr), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(2, 200, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(2, 199, __pyx_L1_error)
   __pyx_ptype_5numpy_flatiter = __Pyx_ImportType(__pyx_t_1, "numpy", "flatiter", sizeof(PyArrayIterObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(2, 223, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(2, 222, __pyx_L1_error)
   __pyx_ptype_5numpy_broadcast = __Pyx_ImportType(__pyx_t_1, "numpy", "broadcast", sizeof(PyArrayMultiIterObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(2, 227, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(2, 226, __pyx_L1_error)
   __pyx_ptype_5numpy_ndarray = __Pyx_ImportType(__pyx_t_1, "numpy", "ndarray", sizeof(PyArrayObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(2, 239, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(2, 238, __pyx_L1_error)
   __pyx_ptype_5numpy_generic = __Pyx_ImportType(__pyx_t_1, "numpy", "generic", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_generic) __PYX_ERR(2, 771, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_generic) __PYX_ERR(2, 770, __pyx_L1_error)
   __pyx_ptype_5numpy_number = __Pyx_ImportType(__pyx_t_1, "numpy", "number", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_number) __PYX_ERR(2, 773, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_number) __PYX_ERR(2, 772, __pyx_L1_error)
   __pyx_ptype_5numpy_integer = __Pyx_ImportType(__pyx_t_1, "numpy", "integer", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_integer) __PYX_ERR(2, 775, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_integer) __PYX_ERR(2, 774, __pyx_L1_error)
   __pyx_ptype_5numpy_signedinteger = __Pyx_ImportType(__pyx_t_1, "numpy", "signedinteger", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_signedinteger) __PYX_ERR(2, 777, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_signedinteger) __PYX_ERR(2, 776, __pyx_L1_error)
   __pyx_ptype_5numpy_unsignedinteger = __Pyx_ImportType(__pyx_t_1, "numpy", "unsignedinteger", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_unsignedinteger) __PYX_ERR(2, 779, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_unsignedinteger) __PYX_ERR(2, 778, __pyx_L1_error)
   __pyx_ptype_5numpy_inexact = __Pyx_ImportType(__pyx_t_1, "numpy", "inexact", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_inexact) __PYX_ERR(2, 781, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_inexact) __PYX_ERR(2, 780, __pyx_L1_error)
   __pyx_ptype_5numpy_floating = __Pyx_ImportType(__pyx_t_1, "numpy", "floating", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_floating) __PYX_ERR(2, 783, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_floating) __PYX_ERR(2, 782, __pyx_L1_error)
   __pyx_ptype_5numpy_complexfloating = __Pyx_ImportType(__pyx_t_1, "numpy", "complexfloating", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_complexfloating) __PYX_ERR(2, 785, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_complexfloating) __PYX_ERR(2, 784, __pyx_L1_error)
   __pyx_ptype_5numpy_flexible = __Pyx_ImportType(__pyx_t_1, "numpy", "flexible", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_flexible) __PYX_ERR(2, 787, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_flexible) __PYX_ERR(2, 786, __pyx_L1_error)
   __pyx_ptype_5numpy_character = __Pyx_ImportType(__pyx_t_1, "numpy", "character", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_character) __PYX_ERR(2, 789, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_character) __PYX_ERR(2, 788, __pyx_L1_error)
   __pyx_ptype_5numpy_ufunc = __Pyx_ImportType(__pyx_t_1, "numpy", "ufunc", sizeof(PyUFuncObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(2, 827, __pyx_L1_error)
+   if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(2, 826, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -21913,38 +22450,38 @@
   PyErr_Clear();
   __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
   if (!__Pyx_RefNanny)
       Py_FatalError("failed to import 'refnanny' module");
 }
 #endif
   __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_cbiogeme(void)", 0);
-  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__Pyx_check_binary_version() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   #ifdef __Pxy_PyFrame_Initialize_Offsets
   __Pxy_PyFrame_Initialize_Offsets();
   #endif
-  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(1, 1, __pyx_L1_error)
   #ifdef __Pyx_CyFunction_USED
-  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_CyFunction_init() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_FusedFunction_USED
-  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_Coroutine_USED
-  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_Coroutine_init() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_Generator_USED
-  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_Generator_init() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_AsyncGen_USED
-  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_StopAsyncIteration_USED
-  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   #endif
   /*--- Library function declarations ---*/
   /*--- Threads initialization code ---*/
   #if defined(WITH_THREAD) && PY_VERSION_HEX < 0x030700F0 && defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
   PyEval_InitThreads();
   #endif
   /*--- Module creation code ---*/
@@ -21953,155 +22490,155 @@
   Py_INCREF(__pyx_m);
   #else
   #if PY_MAJOR_VERSION < 3
   __pyx_m = Py_InitModule4("cbiogeme", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
   #else
   __pyx_m = PyModule_Create(&__pyx_moduledef);
   #endif
-  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (unlikely(!__pyx_m)) __PYX_ERR(1, 1, __pyx_L1_error)
   #endif
-  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(1, 1, __pyx_L1_error)
   Py_INCREF(__pyx_d);
-  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(1, 1, __pyx_L1_error)
   Py_INCREF(__pyx_b);
-  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(1, 1, __pyx_L1_error)
   Py_INCREF(__pyx_cython_runtime);
-  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
+  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(1, 1, __pyx_L1_error);
   /*--- Initialize various global constants etc. ---*/
-  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__Pyx_InitGlobals() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
-  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   #endif
-  if (__pyx_module_is_main_biogeme__cbiogeme) {
-    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name_2, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__pyx_module_is_main_src__cbiogeme) {
+    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name_2, __pyx_n_s_main) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   }
   #if PY_MAJOR_VERSION >= 3
   {
-    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
-    if (!PyDict_GetItemString(modules, "biogeme.cbiogeme")) {
-      if (unlikely(PyDict_SetItemString(modules, "biogeme.cbiogeme", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
+    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(1, 1, __pyx_L1_error)
+    if (!PyDict_GetItemString(modules, "src.cbiogeme")) {
+      if (unlikely(PyDict_SetItemString(modules, "src.cbiogeme", __pyx_m) < 0)) __PYX_ERR(1, 1, __pyx_L1_error)
     }
   }
   #endif
   /*--- Builtin init code ---*/
-  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   /*--- Constants init code ---*/
-  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   /*--- Global type/function init code ---*/
   (void)__Pyx_modinit_global_init_code();
   (void)__Pyx_modinit_variable_export_code();
   (void)__Pyx_modinit_function_export_code();
-  if (unlikely(__Pyx_modinit_type_init_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
-  if (unlikely(__Pyx_modinit_type_import_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (unlikely(__Pyx_modinit_type_init_code() < 0)) __PYX_ERR(1, 1, __pyx_L1_error)
+  if (unlikely(__Pyx_modinit_type_import_code() < 0)) __PYX_ERR(1, 1, __pyx_L1_error)
   (void)__Pyx_modinit_variable_import_code();
   (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
-  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (__Pyx_patch_abc() < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   #endif
 
   /* "src/cbiogeme.pyx":5
  * 
  * cimport numpy as np
  * import numpy as np             # <<<<<<<<<<<<<<
  * from libcpp.vector cimport vector
  * from libcpp.string cimport string
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_numpy, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_numpy, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_1) < 0) __PYX_ERR(0, 5, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_1) < 0) __PYX_ERR(1, 5, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "src/cbiogeme.pyx":1
  * # distutils: language=c++             # <<<<<<<<<<<<<<
  * # cython: embedsignature=True
  * 
  */
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "View.MemoryView":209
  *         info.obj = self
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(array self):
  */
-  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 209, __pyx_L1_error)
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 209, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 209, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(0, 209, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_array_type);
 
   /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 286, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 286, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(generic);
   __Pyx_DECREF_SET(generic, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 287, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 287, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(strided);
   __Pyx_DECREF_SET(strided, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__29, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 288, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 288, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect);
   __Pyx_DECREF_SET(indirect, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__30, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 291, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(contiguous);
   __Pyx_DECREF_SET(contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__31, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 292, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 292, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect_contiguous);
   __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":316
@@ -22133,41 +22670,41 @@
   /* "View.MemoryView":549
  *         info.obj = self
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 549, __pyx_L1_error)
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 549, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 549, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(0, 549, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_memoryview_type);
 
   /* "View.MemoryView":995
  *         return self.from_object
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 995, __pyx_L1_error)
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 995, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(1, 995, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(0, 995, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_memoryviewslice_type);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_1) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":11
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_result.name = __pyx_state[0]
@@ -22177,19 +22714,19 @@
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   if (__pyx_m) {
     if (__pyx_d) {
-      __Pyx_AddTraceback("init biogeme.cbiogeme", __pyx_clineno, __pyx_lineno, __pyx_filename);
+      __Pyx_AddTraceback("init src.cbiogeme", __pyx_clineno, __pyx_lineno, __pyx_filename);
     }
     Py_CLEAR(__pyx_m);
   } else if (!PyErr_Occurred()) {
-    PyErr_SetString(PyExc_ImportError, "init biogeme.cbiogeme");
+    PyErr_SetString(PyExc_ImportError, "init src.cbiogeme");
   }
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   return (__pyx_m != NULL) ? 0 : -1;
   #elif PY_MAJOR_VERSION >= 3
   return __pyx_m;
@@ -22446,34 +22983,14 @@
         return NULL;
     }
     Py_INCREF(value);
     return value;
 }
 #endif
 
-/* PyObjectCall */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
-    PyObject *result;
-    ternaryfunc call = Py_TYPE(func)->tp_call;
-    if (unlikely(!call))
-        return PyObject_Call(func, arg, kw);
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
-        return NULL;
-    result = (*call)(func, arg, kw);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
-    }
-    return result;
-}
-#endif
-
 /* PyDictVersioning */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
     PyObject *dict = Py_TYPE(obj)->tp_dict;
     return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
 }
 static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
@@ -22669,14 +23186,34 @@
 done:
     Py_LeaveRecursiveCall();
     return result;
 }
 #endif
 #endif
 
+/* PyObjectCall */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+    PyObject *result;
+    ternaryfunc call = Py_TYPE(func)->tp_call;
+    if (unlikely(!call))
+        return PyObject_Call(func, arg, kw);
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    result = (*call)(func, arg, kw);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
+    }
+    return result;
+}
+#endif
+
 /* PyObjectCall2Args */
 static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
     PyObject *args, *result = NULL;
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(function)) {
         PyObject *args[2] = {arg1, arg2};
         return __Pyx_PyFunction_FastCall(function, args, 2);
@@ -23362,15 +23899,15 @@
         ps2 = PyBytes_AS_STRING(s2);
         if (ps1[0] != ps2[0]) {
             return (equals == Py_NE);
         } else if (length == 1) {
             return (equals == Py_EQ);
         } else {
             int result;
-#if CYTHON_USE_UNICODE_INTERNALS
+#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
             Py_hash_t hash1, hash2;
             hash1 = ((PyBytesObject*)s1)->ob_shash;
             hash2 = ((PyBytesObject*)s2)->ob_shash;
             if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
                 return (equals == Py_NE);
             }
 #endif
@@ -23491,15 +24028,15 @@
     #if PY_MAJOR_VERSION < 3
     Py_XDECREF(owned_ref);
     #endif
     return (equals == Py_NE);
 #endif
 }
 
-/* None */
+/* DivInt[Py_ssize_t] */
 static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t a, Py_ssize_t b) {
     Py_ssize_t q = a / b;
     Py_ssize_t r = a - q*b;
     q -= ((r != 0) & ((r ^ b) < 0));
     return q;
 }
 
@@ -23949,15 +24486,15 @@
 #endif
 
 /* None */
 static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
     PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
 }
 
-/* None */
+/* DivInt[long] */
 static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
     long q = a / b;
     long r = a - q*b;
     q -= ((r != 0) & ((r ^ b) < 0));
     return q;
 }
 
@@ -24081,25 +24618,43 @@
   }
   Py_XDECREF(name_attr);
   return ret;
 }
 static int __Pyx_setup_reduce(PyObject* type_obj) {
     int ret = 0;
     PyObject *object_reduce = NULL;
+    PyObject *object_getstate = NULL;
     PyObject *object_reduce_ex = NULL;
     PyObject *reduce = NULL;
     PyObject *reduce_ex = NULL;
     PyObject *reduce_cython = NULL;
     PyObject *setstate = NULL;
     PyObject *setstate_cython = NULL;
+    PyObject *getstate = NULL;
+#if CYTHON_USE_PYTYPE_LOOKUP
+    getstate = _PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate);
+#else
+    getstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_getstate);
+    if (!getstate && PyErr_Occurred()) {
+        goto __PYX_BAD;
+    }
+#endif
+    if (getstate) {
 #if CYTHON_USE_PYTYPE_LOOKUP
-    if (_PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
+        object_getstate = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_getstate);
 #else
-    if (PyObject_HasAttr(type_obj, __pyx_n_s_getstate)) goto __PYX_GOOD;
+        object_getstate = __Pyx_PyObject_GetAttrStrNoError((PyObject*)&PyBaseObject_Type, __pyx_n_s_getstate);
+        if (!object_getstate && PyErr_Occurred()) {
+            goto __PYX_BAD;
+        }
 #endif
+        if (object_getstate != getstate) {
+            goto __PYX_GOOD;
+        }
+    }
 #if CYTHON_USE_PYTYPE_LOOKUP
     object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #else
     object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #endif
     reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto __PYX_BAD;
     if (reduce_ex == object_reduce_ex) {
@@ -24136,14 +24691,16 @@
     if (!PyErr_Occurred())
         PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
     ret = -1;
 __PYX_GOOD:
 #if !CYTHON_USE_PYTYPE_LOOKUP
     Py_XDECREF(object_reduce);
     Py_XDECREF(object_reduce_ex);
+    Py_XDECREF(object_getstate);
+    Py_XDECREF(getstate);
 #endif
     Py_XDECREF(reduce);
     Py_XDECREF(reduce_ex);
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
@@ -24256,15 +24813,15 @@
       } else {
         PyErr_Clear();
         use_cline = NULL;
       }
     }
     if (!use_cline) {
         c_line = 0;
-        PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
+        (void) PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
     }
     else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
         c_line = 0;
     }
     __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
     return c_line;
 }
@@ -24350,41 +24907,48 @@
     Py_INCREF(code_object);
 }
 
 /* AddTraceback */
 #include "compile.h"
 #include "frameobject.h"
 #include "traceback.h"
+#if PY_VERSION_HEX >= 0x030b00a6
+  #ifndef Py_BUILD_CORE
+    #define Py_BUILD_CORE 1
+  #endif
+  #include "internal/pycore_frame.h"
+#endif
 static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
             const char *funcname, int c_line,
             int py_line, const char *filename) {
-    PyCodeObject *py_code = 0;
-    PyObject *py_srcfile = 0;
-    PyObject *py_funcname = 0;
+    PyCodeObject *py_code = NULL;
+    PyObject *py_funcname = NULL;
     #if PY_MAJOR_VERSION < 3
+    PyObject *py_srcfile = NULL;
     py_srcfile = PyString_FromString(filename);
-    #else
-    py_srcfile = PyUnicode_FromString(filename);
-    #endif
     if (!py_srcfile) goto bad;
+    #endif
     if (c_line) {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        if (!py_funcname) goto bad;
         #else
         py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
+        if (!py_funcname) goto bad;
+        funcname = PyUnicode_AsUTF8(py_funcname);
+        if (!funcname) goto bad;
         #endif
     }
     else {
         #if PY_MAJOR_VERSION < 3
         py_funcname = PyString_FromString(funcname);
-        #else
-        py_funcname = PyUnicode_FromString(funcname);
+        if (!py_funcname) goto bad;
         #endif
     }
-    if (!py_funcname) goto bad;
+    #if PY_MAJOR_VERSION < 3
     py_code = __Pyx_PyCode_New(
         0,
         0,
         0,
         0,
         0,
         __pyx_empty_bytes, /*PyObject *code,*/
@@ -24395,34 +24959,49 @@
         __pyx_empty_tuple, /*PyObject *cellvars,*/
         py_srcfile,   /*PyObject *filename,*/
         py_funcname,  /*PyObject *name,*/
         py_line,
         __pyx_empty_bytes  /*PyObject *lnotab*/
     );
     Py_DECREF(py_srcfile);
-    Py_DECREF(py_funcname);
+    #else
+    py_code = PyCode_NewEmpty(filename, funcname, py_line);
+    #endif
+    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
     return py_code;
 bad:
-    Py_XDECREF(py_srcfile);
     Py_XDECREF(py_funcname);
+    #if PY_MAJOR_VERSION < 3
+    Py_XDECREF(py_srcfile);
+    #endif
     return NULL;
 }
 static void __Pyx_AddTraceback(const char *funcname, int c_line,
                                int py_line, const char *filename) {
     PyCodeObject *py_code = 0;
     PyFrameObject *py_frame = 0;
     PyThreadState *tstate = __Pyx_PyThreadState_Current;
+    PyObject *ptype, *pvalue, *ptraceback;
     if (c_line) {
         c_line = __Pyx_CLineForTraceback(tstate, c_line);
     }
     py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
     if (!py_code) {
+        __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
         py_code = __Pyx_CreateCodeObjectForTraceback(
             funcname, c_line, py_line, filename);
-        if (!py_code) goto bad;
+        if (!py_code) {
+            /* If the code object creation fails, then we should clear the
+               fetched exception references and propagate the new exception */
+            Py_XDECREF(ptype);
+            Py_XDECREF(pvalue);
+            Py_XDECREF(ptraceback);
+            goto bad;
+        }
+        __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
         __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
     }
     py_frame = PyFrame_New(
         tstate,            /*PyThreadState *tstate,*/
         py_code,           /*PyCodeObject *code,*/
         __pyx_d,    /*PyObject *globals,*/
         0                  /*PyObject *locals*/
@@ -24524,14 +25103,120 @@
     cobj = PyCapsule_New(p, sig, NULL);
 #else
     cobj = PyCObject_FromVoidPtr(p, NULL);
 #endif
     return cobj;
 }
 
+/* Print */
+#if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION < 3
+static PyObject *__Pyx_GetStdout(void) {
+    PyObject *f = PySys_GetObject((char *)"stdout");
+    if (!f) {
+        PyErr_SetString(PyExc_RuntimeError, "lost sys.stdout");
+    }
+    return f;
+}
+static int __Pyx_Print(PyObject* f, PyObject *arg_tuple, int newline) {
+    int i;
+    if (!f) {
+        if (!(f = __Pyx_GetStdout()))
+            return -1;
+    }
+    Py_INCREF(f);
+    for (i=0; i < PyTuple_GET_SIZE(arg_tuple); i++) {
+        PyObject* v;
+        if (PyFile_SoftSpace(f, 1)) {
+            if (PyFile_WriteString(" ", f) < 0)
+                goto error;
+        }
+        v = PyTuple_GET_ITEM(arg_tuple, i);
+        if (PyFile_WriteObject(v, f, Py_PRINT_RAW) < 0)
+            goto error;
+        if (PyString_Check(v)) {
+            char *s = PyString_AsString(v);
+            Py_ssize_t len = PyString_Size(v);
+            if (len > 0) {
+                switch (s[len-1]) {
+                    case ' ': break;
+                    case '\f': case '\r': case '\n': case '\t': case '\v':
+                        PyFile_SoftSpace(f, 0);
+                        break;
+                    default:  break;
+                }
+            }
+        }
+    }
+    if (newline) {
+        if (PyFile_WriteString("\n", f) < 0)
+            goto error;
+        PyFile_SoftSpace(f, 0);
+    }
+    Py_DECREF(f);
+    return 0;
+error:
+    Py_DECREF(f);
+    return -1;
+}
+#else
+static int __Pyx_Print(PyObject* stream, PyObject *arg_tuple, int newline) {
+    PyObject* kwargs = 0;
+    PyObject* result = 0;
+    PyObject* end_string;
+    if (unlikely(!__pyx_print)) {
+        __pyx_print = PyObject_GetAttr(__pyx_b, __pyx_n_s_print);
+        if (!__pyx_print)
+            return -1;
+    }
+    if (stream) {
+        kwargs = PyDict_New();
+        if (unlikely(!kwargs))
+            return -1;
+        if (unlikely(PyDict_SetItem(kwargs, __pyx_n_s_file, stream) < 0))
+            goto bad;
+        if (!newline) {
+            end_string = PyUnicode_FromStringAndSize(" ", 1);
+            if (unlikely(!end_string))
+                goto bad;
+            if (PyDict_SetItem(kwargs, __pyx_n_s_end, end_string) < 0) {
+                Py_DECREF(end_string);
+                goto bad;
+            }
+            Py_DECREF(end_string);
+        }
+    } else if (!newline) {
+        if (unlikely(!__pyx_print_kwargs)) {
+            __pyx_print_kwargs = PyDict_New();
+            if (unlikely(!__pyx_print_kwargs))
+                return -1;
+            end_string = PyUnicode_FromStringAndSize(" ", 1);
+            if (unlikely(!end_string))
+                return -1;
+            if (PyDict_SetItem(__pyx_print_kwargs, __pyx_n_s_end, end_string) < 0) {
+                Py_DECREF(end_string);
+                return -1;
+            }
+            Py_DECREF(end_string);
+        }
+        kwargs = __pyx_print_kwargs;
+    }
+    result = PyObject_Call(__pyx_print, arg_tuple, kwargs);
+    if (unlikely(kwargs) && (kwargs != __pyx_print_kwargs))
+        Py_DECREF(kwargs);
+    if (!result)
+        return -1;
+    Py_DECREF(result);
+    return 0;
+bad:
+    if (kwargs != __pyx_print_kwargs)
+        Py_XDECREF(kwargs);
+    return -1;
+}
+#endif
+
 /* IsLittleEndian */
 static CYTHON_INLINE int __Pyx_Is_Little_Endian(void)
 {
   union {
     uint32_t u32;
     uint8_t u8[4];
   } S;
@@ -25702,14 +26387,51 @@
     __Pyx_XDECREF(shape_tuple);
     __Pyx_XDECREF(temp_int);
     __Pyx_XDECREF(array_obj);
     __Pyx_RefNannyFinishContext();
     return new_mvs;
 }
 
+/* PrintOne */
+  #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION < 3
+static int __Pyx_PrintOne(PyObject* f, PyObject *o) {
+    if (!f) {
+        if (!(f = __Pyx_GetStdout()))
+            return -1;
+    }
+    Py_INCREF(f);
+    if (PyFile_SoftSpace(f, 0)) {
+        if (PyFile_WriteString(" ", f) < 0)
+            goto error;
+    }
+    if (PyFile_WriteObject(o, f, Py_PRINT_RAW) < 0)
+        goto error;
+    if (PyFile_WriteString("\n", f) < 0)
+        goto error;
+    Py_DECREF(f);
+    return 0;
+error:
+    Py_DECREF(f);
+    return -1;
+    /* the line below is just to avoid C compiler
+     * warnings about unused functions */
+    return __Pyx_Print(f, NULL, 0);
+}
+#else
+static int __Pyx_PrintOne(PyObject* stream, PyObject *o) {
+    int res;
+    PyObject* arg_tuple = PyTuple_Pack(1, o);
+    if (unlikely(!arg_tuple))
+        return -1;
+    res = __Pyx_Print(stream, arg_tuple, 1);
+    Py_DECREF(arg_tuple);
+    return res;
+}
+#endif
+
 /* CIntFromPy */
   static CYTHON_INLINE unsigned long __Pyx_PyInt_As_unsigned_long(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const unsigned long neg_one = (unsigned long) -1, const_zero = (unsigned long) 0;
@@ -26564,19 +27286,41 @@
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to char");
     return (char) -1;
 }
 
 /* CheckBinaryVersion */
   static int __Pyx_check_binary_version(void) {
-    char ctversion[4], rtversion[4];
-    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
-    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
-    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
+    char ctversion[5];
+    int same=1, i, found_dot;
+    const char* rt_from_call = Py_GetVersion();
+    PyOS_snprintf(ctversion, 5, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
+    found_dot = 0;
+    for (i = 0; i < 4; i++) {
+        if (!ctversion[i]) {
+            same = (rt_from_call[i] < '0' || rt_from_call[i] > '9');
+            break;
+        }
+        if (rt_from_call[i] != ctversion[i]) {
+            same = 0;
+            break;
+        }
+    }
+    if (!same) {
+        char rtversion[5] = {'\0'};
         char message[200];
+        for (i=0; i<4; ++i) {
+            if (rt_from_call[i] == '.') {
+                if (found_dot) break;
+                found_dot = 1;
+            } else if (rt_from_call[i] < '0' || rt_from_call[i] > '9') {
+                break;
+            }
+            rtversion[i] = rt_from_call[i];
+        }
         PyOS_snprintf(message, sizeof(message),
                       "compiletime version %s of module '%.100s' "
                       "does not match runtime version %s",
                       ctversion, __Pyx_MODULE_NAME, rtversion);
         return PyErr_WarnEx(NULL, message, 1);
     }
     return 0;
@@ -26826,14 +27570,31 @@
   }
   x = PyNumber_Index(b);
   if (!x) return -1;
   ival = PyInt_AsSsize_t(x);
   Py_DECREF(x);
   return ival;
 }
+static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject* o) {
+  if (sizeof(Py_hash_t) == sizeof(Py_ssize_t)) {
+    return (Py_hash_t) __Pyx_PyIndex_AsSsize_t(o);
+#if PY_MAJOR_VERSION < 3
+  } else if (likely(PyInt_CheckExact(o))) {
+    return PyInt_AS_LONG(o);
+#endif
+  } else {
+    Py_ssize_t ival;
+    PyObject *x;
+    x = PyNumber_Index(o);
+    if (!x) return -1;
+    ival = PyInt_AsLong(x);
+    Py_DECREF(x);
+    return ival;
+  }
+}
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
   return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
 }
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
     return PyInt_FromSize_t(ival);
 }
```

### Comparing `biogeme-3.2.8/src/cbiogeme.pyx` & `biogeme-3.2.9/src/cbiogeme.pyx.work`

 * *Files 10% similar despite different names*

```diff
@@ -43,20 +43,19 @@
 
 		void simulateFormula(vector[string] loglikeSignatures,
 				     double_vector betas, 
 				     double_vector fixedBetas,
 				     double_matrix& data,
 				     double* results) except +
 
-		void simulateSeveralFormulas(vector[string_vector] loglikeSignatures,
-				     double_vector betas, 
-				     double_vector fixedBetas,
-				     unsigned long numberOfThreads,
-				     double_matrix& data,
-				     double* results) except +
+		void simulateSeveralFormulas(vector[string_vector],
+				      	     double_vector betas, 
+				     	     double_vector fixedBetas,
+				     	     double_matrix& data,
+				     	     double* results) except +
 
 		void setExpressions(vector[string] loglikeSignatures, 
 						vector[string] weightSignatures,
 						unsigned long numberOfThreads)
 
 		void setData(double_matrix& d)
 
@@ -133,31 +132,14 @@
 		self.theBiogeme.simulateFormula(formula,
 					        betas, 
    						fixedBetas, 
 						d, 
 						&r_view[0])
 		return r
 	
-	def simulateSeveralFormulas(self, formulas, betas, fixedBetas, d, nThreads):
-		n = d.shape[0]
-		nf = len(formulas)
-		r = np.zeros([nf, n])
-		if not r.flags['C_CONTIGUOUS']:
-			print('r not contiguous')
-			r = np.ascontiguousarray(r)
-		d = np.ascontiguousarray(d)
-
-		cdef double_matrix_view r_view = r
-		self.theBiogeme.simulateSeveralFormulas(formulas,
-					        	      betas, 
-   						      fixedBetas, 
- 						      nThreads,
-						      d, 
-						      &r_view[0,0])
-		return r
 	
 	def setExpressions(self,loglikeFormulas,nbrOfThreads,weightFormulas=None):
 		cdef vector[string] w
 		if (weightFormulas is not None):
 			w = weightFormulas
 		self.theBiogeme.setExpressions(loglikeFormulas,w,nbrOfThreads)
```

### Comparing `biogeme-3.2.8/src/cbiogeme.pyx.ok` & `biogeme-3.2.9/src/cbiogeme.pyx.ok`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/cbiogeme.pyx.work` & `biogeme-3.2.9/src/cexpressions.pyx`

 * *Files 26% similar despite different names*

```diff
@@ -14,154 +14,122 @@
 ctypedef vector[double_matrix] double_tensor
 ctypedef vector[string] string_vector
 
 ctypedef int[::1] uint_vector_view
 ctypedef int[:, ::1] uint_matrix_view
 ctypedef double[::1] double_vector_view
 ctypedef double[:, ::1] double_matrix_view
+ctypedef double[:, :, ::1] double_tensor_view
 
 
-cdef extern from "biogeme.h":
+cdef extern from "evaluateExpressions.h":
 
-	cdef cppclass biogeme:
-		biogeme() except +
+    cdef cppclass evaluateOneExpression:
+        evaluateOneExpression() except +
 
-		double calculateLikelihood(double_vector betas, 
-			double_vector fixedBetas) except +
+        void setExpression(string_vector loglikeSignatures) except +
 
-		double calculateLikeAndDerivatives(double_vector betas,
-			double_vector fixedBetas,
-			uint_vector betaIds,
-			double* g,
-			double* h,
-			double* bhhh,
-			bool_t hessian,
-			bool_t bhhh) except +
-
-		void setPanel(bool_t p)
-
-		void setBounds(double_vector lb, double_vector ub)
-
-		void simulateFormula(vector[string] loglikeSignatures,
-				     double_vector betas, 
-				     double_vector fixedBetas,
-				     double_matrix& data,
-				     double* results) except +
-
-		void simulateSeveralFormulas(vector[string_vector],
-				      	     double_vector betas, 
-				     	     double_vector fixedBetas,
-				     	     double_matrix& data,
-				     	     double* results) except +
-
-		void setExpressions(vector[string] loglikeSignatures, 
-						vector[string] weightSignatures,
-						unsigned long numberOfThreads)
-
-		void setData(double_matrix& d)
-
-		void setDataMap(uint_matrix& dm)
-
-		void setMissingData(double md)
-		
-		void setDraws(double_tensor& draws)
-
-
-cdef class pyBiogeme:
-	cdef biogeme theBiogeme
-
-	def __cinit__(self):
-		self.theBiogeme = biogeme()
-
-
-	def setPanel(self,panel=True):
-		self.theBiogeme.setPanel(panel)
-
-	def calculateLikelihoodAndDerivatives(self,
-	                                      betas,
-					      fixedBetas,
-					      betaIds,
-					      gmem,
-					      hmem,
-					      bmem,
-					      hessian,
-					      bhhh,
-					      draws=None):
-		n = len(betas)
-
-		if not gmem.flags['C_CONTIGUOUS']:
-			print('gmem not contiguous')
-			gmem = np.ascontiguousarray(gmem)
-		if not hmem.flags['C_CONTIGUOUS']:
-			print('hmem not contiguous')
-			hmem = np.ascontiguousarray(hmem)
-		if not bmem.flags['C_CONTIGUOUS']:
-			print('bmem not contiguous')
-			bmem = np.ascontiguousarray(bmem)
-
-		cdef double_vector_view gmem_view = gmem
-		cdef double_matrix_view hmem_view = hmem
-		cdef double_matrix_view bmem_view = bmem
-
-
-		f = self.theBiogeme.calculateLikeAndDerivatives(betas,
-			                                        fixedBetas,
-								betaIds,
-								&gmem_view[0],
-								&hmem_view[0,0],
-								&bmem_view[0,0],
-								hessian,
-								bhhh)
-		return f, gmem, hmem, bmem
-
-	def setBounds(self,lb,ub):
-		self.theBiogeme.setBounds(lb,ub)
-
-	def calculateLikelihood(self, betas,fixedBetas):
-		r = self.theBiogeme.calculateLikelihood(betas, fixedBetas)
-		return r
-
-	def simulateFormula(self, formula, betas, fixedBetas, d):
-		n = d.shape[0]	
-		r = np.empty(n)
-		if not r.flags['C_CONTIGUOUS']:
-			print('r not contiguous')
-			r = np.ascontiguousarray(r)
-		d = np.ascontiguousarray(d)
-
-		cdef double_vector_view r_view = r
-		self.theBiogeme.simulateFormula(formula,
-					        betas, 
-   						fixedBetas, 
-						d, 
-						&r_view[0])
-		return r
-	
-	
-	def setExpressions(self,loglikeFormulas,nbrOfThreads,weightFormulas=None):
-		cdef vector[string] w
-		if (weightFormulas is not None):
-			w = weightFormulas
-		self.theBiogeme.setExpressions(loglikeFormulas,w,nbrOfThreads)
-
-	def setData(self, d):
-		d = np.ascontiguousarray(d)
-		self.theBiogeme.setData(d)
-
-	def setDataMap(self, m):
-		m = np.ascontiguousarray(m)
-		self.theBiogeme.setDataMap(m)
-
-	def setMissingData(self, md):
-		self.theBiogeme.setMissingData(md)
-
-
-	def setDraws(self, draws):
-		draws = np.ascontiguousarray(draws)
-		self.theBiogeme.setDraws(draws)
+        void calculate(bool_t gradient,
+                       bool_t hessian,
+                       bool_t bhhh,
+               bool_t aggregation) except +
 
-				
+        void setNumberOfThreads(unsigned long numberOfThreads)
 
+        void setFreeBetas(double_vector freeBetas)
 
-				
+        void setFixedBetas(double_vector fixedBetas)
 
+        void setData(double_matrix& d)
 
+        void setDataMap(uint_matrix& dm)
+
+        void setMissingData(double md)
+
+        void setDraws(double_tensor& draws)
+
+        void setPanel(bool_t panel)
+
+        void getResults(double* f, double* g, double* h, double* bhhh) except +
+
+        unsigned int getDimension()
+
+        unsigned int getSampleSize()
+
+
+cdef class pyEvaluateOneExpression:
+    cdef evaluateOneExpression theEvaluation
+
+    def __cinit__(self):
+        self.theEvaluation = evaluateOneExpression()
+
+    def setExpression(self, formula):
+        self.theEvaluation.setExpression(formula)
+
+    def setFreeBetas(self, freeBetas):
+        self.theEvaluation.setFreeBetas(freeBetas)
+
+    def setFixedBetas(self, fixedBetas):
+        self.theEvaluation.setFixedBetas(fixedBetas)
+
+    def setNumberOfThreads(self, n):
+        self.theEvaluation.setNumberOfThreads(n)
+
+    def setData(self, d):
+        d = np.ascontiguousarray(d)
+        self.theEvaluation.setData(d)
+
+    def setDraws(self, draws):
+        draws = np.ascontiguousarray(draws)
+        self.theEvaluation.setDraws(draws)
+
+
+    def setDataMap(self, dm):
+        dm = np.ascontiguousarray(dm)
+        self.theEvaluation.setDataMap(dm)
+
+    def setMissingData(self, md):
+        self.theEvaluation.setMissingData(md)
+
+    def calculate(self, gradient, hessian, bhhh, aggregation):
+        self.theEvaluation.calculate(
+            gradient,
+            hessian,
+            bhhh,
+            aggregation,
+        )
+
+
+    def getResults(self):
+        n = self.theEvaluation.getDimension()
+        sample = self.theEvaluation.getSampleSize() ;
+        f = np.empty(sample)
+        if not f.flags['C_CONTIGUOUS']:
+            f = np.ascontiguousarray(f)
+        cdef double_vector_view f_view = f
+
+        if n == 0:
+            self.theEvaluation.getResults(&f_view[0], NULL, NULL, NULL)
+            return f, None, None, None
+
+        g = np.empty([sample, n])
+        if not g.flags['C_CONTIGUOUS']:
+            g = np.ascontiguousarray(g)
+        h = np.empty([sample, n, n])
+        if not h.flags['C_CONTIGUOUS']:
+            h = np.ascontiguousarray(h)
+        bhhh = np.empty([sample, n, n])
+        if not bhhh.flags['C_CONTIGUOUS']:
+            bhhh = np.ascontiguousarray(bhhh)
+
+        cdef double_matrix_view g_view = g
+        cdef double_tensor_view h_view = h
+        cdef double_tensor_view bhhh_view = bhhh
+
+        self.theEvaluation.getResults(
+	    &f_view[0],
+            &g_view[0, 0],
+	    &h_view[0, 0, 0],
+	    &bhhh_view[0, 0, 0],
+	)
+
+        return f, g, h, bhhh
```

### Comparing `biogeme-3.2.8/src/cfsqpusr.h` & `biogeme-3.2.9/src/cfsqpusr.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/main.cc` & `biogeme-3.2.9/src/main.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/mycfsqp.cc` & `biogeme-3.2.9/src/mycfsqp.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/myqld.cc` & `biogeme-3.2.9/src/myqld.cc`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/src/panelbiogeme.h` & `biogeme-3.2.9/src/panelbiogeme.h`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/tests/functions/testBiogeme.py` & `biogeme-3.2.9/tests/functions/test_biogeme.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 """
 Test the biogeme module
 
 :author: Michel Bierlaire
-:data: Wed Apr 29 18:32:42 2020
+:date: Wed Apr 29 18:32:42 2020
 
 """
 # Bug in pylint
 # pylint: disable=no-member
 #
 # Too constraining
 # pylint: disable=invalid-name, too-many-instance-attributes
@@ -15,97 +15,143 @@
 # pylint: disable=missing-function-docstring, missing-class-docstring
 
 import os
 import unittest
 import random as rnd
 import numpy as np
 import biogeme.biogeme as bio
-from biogeme.expressions import Variable, Beta, exp
-from testData import myData1
+from biogeme.expressions import Variable, Beta, exp, bioDraws
+from test_data import getData
 
-class testBiogeme(unittest.TestCase):
+
+class test_biogeme(unittest.TestCase):
     def setUp(self):
         np.random.seed(90267)
         rnd.seed(90267)
 
         Variable1 = Variable('Variable1')
         Variable2 = Variable('Variable2')
         beta1 = Beta('beta1', -1.0, -3, 3, 0)
         beta2 = Beta('beta2', 2.0, -3, 10, 0)
-        likelihood = -beta1**2 * Variable1 - exp(beta2 * beta1) * Variable2 - beta2**4
+        self.likelihood = (
+            -(beta1 ** 2) * Variable1
+            - exp(beta2 * beta1) * Variable2
+            - beta2 ** 4
+        )
         simul = beta1 / Variable1 + beta2 / Variable2
-        dictOfExpressions = {'loglike':likelihood,
-                             'beta1':beta1,
-                             'simul':simul}
+        dictOfExpressions = {
+            'loglike': self.likelihood,
+            'beta1': beta1,
+            'simul': simul,
+        }
 
-        self.myBiogeme = bio.BIOGEME(myData1, dictOfExpressions)
+        self.myData = getData(1)
+        self.myBiogeme = bio.BIOGEME(self.myData, dictOfExpressions)
         self.myBiogeme.generateHtml = False
         self.myBiogeme.generatePickle = False
         self.myBiogeme.modelName = 'simpleExample'
 
-        
+    def test_saveIterationsFileName(self):
+        f = self.myBiogeme._saveIterationsFileName()
+        self.assertEqual(f, '__simpleExample.iter')
+
+    def test_generateDraws(self):
+        self.assertIsNone(self.myData.theDraws)
+        ell = bioDraws('test', 'NORMAL')
+        b = bio.BIOGEME(self.myData, ell, skipAudit=True)
+        b._generateDraws(10)
+        self.assertTupleEqual(self.myData.theDraws.shape, (5, 10, 1))
+        ell2 = bioDraws('test', 'NORMAL') + bioDraws('test2', 'UNIFORM')
+        b2 = bio.BIOGEME(self.myData, ell2, skipAudit=True)
+        b2._generateDraws(20)
+        self.assertTupleEqual(self.myData.theDraws.shape, (5, 20, 2))
+
+    def test_getBoundsOnBeta(self):
+        b = self.myBiogeme.getBoundsOnBeta('beta1')
+        self.assertTupleEqual(b, (-3, 3))
+        b = self.myBiogeme.getBoundsOnBeta('beta2')
+        self.assertTupleEqual(b, (-3, 10))
+
+    def test_calculateNullLoglikelihood(self):
+        null_ell = self.myBiogeme.calculateNullLoglikelihood({1: 1, 2: 1})
+        self.assertAlmostEqual(null_ell, -3.4657359027997265, 2)
+        null_ell_2 = self.myBiogeme.calculateNullLoglikelihood(
+            {1: 1, 2: 1, 3: 1}
+        )
+        self.assertAlmostEqual(null_ell_2, -5.493061443340549, 2)
+
     def test_calculateInitLikelihood(self):
         res = self.myBiogeme.calculateInitLikelihood()
         self.assertAlmostEqual(res, -115.30029248549191, 5)
 
     def test_calculateLikelihood(self):
-        x = self.myBiogeme.betaInitValues
+        x = self.myBiogeme.id_manager.free_betas_values
         xplus = [v + 1 for v in x]
         res = self.myBiogeme.calculateLikelihood(xplus, scaled=False)
         self.assertEqual(res, -555)
 
     def test_calculateLikelihoodAndDerivatives(self):
-        x = self.myBiogeme.betaInitValues
+        x = self.myBiogeme.id_manager.free_betas_values
         xplus = [v + 1 for v in x]
-        f, g, h, bhhh = self.myBiogeme.calculateLikelihoodAndDerivatives(xplus,
-                                                                         scaled=False,
-                                                                         hessian=True,
-                                                                         bhhh=True)
+        f, g, h, bhhh = self.myBiogeme.calculateLikelihoodAndDerivatives(
+            xplus, scaled=False, hessian=True, bhhh=True
+        )
         f_true = -555.0
-        g_true = [-450., -540.]
-        h_true = [[-1350., -150.], [-150., -540.]]
-        bhhh_true = [[49500., 48600.], [48600., 58320.]]
+        g_true = [-450.0, -540.0]
+        h_true = [[-1350.0, -150.0], [-150.0, -540.0]]
+        bhhh_true = [[49500.0, 48600.0], [48600.0, 58320.0]]
         self.assertEqual(f_true, f)
         self.assertListEqual(g_true, g.tolist())
         self.assertListEqual(h_true, h.tolist())
         self.assertListEqual(bhhh_true, bhhh.tolist())
 
     def test_likelihoodFiniteDifferenceHessian(self):
-        x = self.myBiogeme.betaInitValues
+        x = self.myBiogeme.id_manager.free_betas_values
         xplus = [v + 1 for v in x]
         h = self.myBiogeme.likelihoodFiniteDifferenceHessian(xplus)
-        h_true = [[-1380.00020229, -150.], [-150.0000451, -540.00005396]]
+        h_true = [[-1380.00020229, -150.0], [-150.0000451, -540.00005396]]
         for row, row_true in zip(h, h_true):
             for col, col_true in zip(row, row_true):
                 self.assertAlmostEqual(col, col_true, 5)
 
     def test_checkDerivatives(self):
         _, _, _, gdiff, hdiff = self.myBiogeme.checkDerivatives()
         gdiff_true = [-5.42793187e-06, 2.60800035e-05]
-        hdiff_true = [[-8.04552171e-06, 7.36597983e-09], [-1.61387920e-07, 2.22928137e-05]]
+        hdiff_true = [
+            [-8.04552171e-06, 7.36597983e-09],
+            [-1.61387920e-07, 2.22928137e-05],
+        ]
         for col, col_true in zip(gdiff, gdiff_true):
             self.assertAlmostEqual(col, col_true, 5)
         for row, row_true in zip(hdiff, hdiff_true):
             for col, col_true in zip(row, row_true):
                 self.assertAlmostEqual(col, col_true, 5)
 
     def test_estimate(self):
+        self.myBiogeme.numberOfThreads = 1
         results = self.myBiogeme.estimate(bootstrap=10)
         self.assertAlmostEqual(results.data.logLike, -67.0654904797005, 5)
         os.remove(self.myBiogeme._saveIterationsFileName())
 
     def test_simulate(self):
         results = self.myBiogeme.estimate()
         os.remove(self.myBiogeme._saveIterationsFileName())
         s = self.myBiogeme.simulate(results.getBetaValues())
         self.assertAlmostEqual(s.loc[0, 'loglike'], -6.092208083991222, 3)
 
+    def test_changeInitValues(self):
+        self.myBiogeme.changeInitValues({'beta2': -100, 'beta1': 3.14156})
+        self.assertListEqual(self.myBiogeme.id_manager.free_betas_values, [3.14156, -100])
+
     def test_confidenceIntervals(self):
         results = self.myBiogeme.estimate(bootstrap=10)
-        drawsFromBetas = results.getBetasForSensitivityAnalysis(self.myBiogeme.freeBetaNames)
+        drawsFromBetas = results.getBetasForSensitivityAnalysis(
+            self.myBiogeme.id_manager.free_betas.names
+        )
         s = self.myBiogeme.simulate(results.getBetaValues())
         left, right = self.myBiogeme.confidenceIntervals(drawsFromBetas)
         self.assertLess(left.loc[0, 'loglike'], s.loc[0, 'loglike'])
         self.assertGreater(right.loc[0, 'loglike'], s.loc[0, 'loglike'])
 
+
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `biogeme-3.2.8/tests/functions/testDraws.py` & `biogeme-3.2.9/tests/functions/test_draws.py`

 * *Files 16% similar despite different names*

```diff
@@ -13,15 +13,16 @@
 # Not needed in test
 # pylint: disable=missing-function-docstring, missing-class-docstring
 
 import unittest
 import biogeme.draws as dr
 import numpy as np
 
-class testDraws(unittest.TestCase):
+
+class test_draws(unittest.TestCase):
     def setUp(self):
         np.random.seed(90267)
 
     def test_getUniform(self):
         draws = dr.getUniform(sampleSize=5, numberOfDraws=10, symmetric=False)
         r, c = draws.shape
         self.assertEqual(r, 5)
@@ -42,170 +43,178 @@
         r, c = draws.shape
         self.assertEqual(r, 5)
         self.assertEqual(c, 10)
         self.assertTrue(np.min(draws) > 0)
         self.assertTrue(np.max(draws) <= 1)
 
     def test_getLatinHypercubeDrawsSymmetric(self):
-        draws = dr.getLatinHypercubeDraws(sampleSize=5, numberOfDraws=10, symmetric=True)
+        draws = dr.getLatinHypercubeDraws(
+            sampleSize=5, numberOfDraws=10, symmetric=True
+        )
         r, c = draws.shape
         self.assertEqual(r, 5)
         self.assertEqual(c, 10)
         self.assertTrue(np.min(draws) > -1)
         self.assertTrue(np.max(draws) <= 1)
 
     def test_userDefinedDraws(self):
         myUnif = np.random.uniform(size=30)
-        draws = dr.getLatinHypercubeDraws(sampleSize=3,
-                                          numberOfDraws=10,
-                                          symmetric=False,
-                                          uniformNumbers=myUnif)
+        draws = dr.getLatinHypercubeDraws(
+            sampleSize=3,
+            numberOfDraws=10,
+            symmetric=False,
+            uniformNumbers=myUnif,
+        )
         r, c = draws.shape
         self.assertEqual(r, 3)
         self.assertEqual(c, 10)
         self.assertTrue(np.min(draws) > 0)
         self.assertTrue(np.max(draws) <= 1)
 
     def test_halton(self):
         halton = dr.getHaltonDraws(sampleSize=1, numberOfDraws=100, base=3)
-        h = np.array([0.33333333,
-                      0.66666667,
-                      0.11111111,
-                      0.44444444,
-                      0.77777778,
-                      0.22222222,
-                      0.55555556,
-                      0.88888889,
-                      0.03703704,
-                      0.37037037,
-                      0.7037037,
-                      0.14814815,
-                      0.48148148,
-                      0.81481481,
-                      0.25925926,
-                      0.59259259,
-                      0.92592593,
-                      0.07407407,
-                      0.40740741,
-                      0.74074074,
-                      0.18518519,
-                      0.51851852,
-                      0.85185185,
-                      0.2962963,
-                      0.62962963,
-                      0.96296296,
-                      0.01234568,
-                      0.34567901,
-                      0.67901235,
-                      0.12345679,
-                      0.45679012,
-                      0.79012346,
-                      0.2345679,
-                      0.56790123,
-                      0.90123457,
-                      0.04938272,
-                      0.38271605,
-                      0.71604938,
-                      0.16049383,
-                      0.49382716,
-                      0.82716049,
-                      0.27160494,
-                      0.60493827,
-                      0.9382716,
-                      0.08641975,
-                      0.41975309,
-                      0.75308642,
-                      0.19753086,
-                      0.5308642,
-                      0.86419753,
-                      0.30864198,
-                      0.64197531,
-                      0.97530864,
-                      0.02469136,
-                      0.35802469,
-                      0.69135802,
-                      0.13580247,
-                      0.4691358,
-                      0.80246914,
-                      0.24691358,
-                      0.58024691,
-                      0.91358025,
-                      0.0617284,
-                      0.39506173,
-                      0.72839506,
-                      0.17283951,
-                      0.50617284,
-                      0.83950617,
-                      0.28395062,
-                      0.61728395,
-                      0.95061728,
-                      0.09876543,
-                      0.43209877,
-                      0.7654321,
-                      0.20987654,
-                      0.54320988,
-                      0.87654321,
-                      0.32098765,
-                      0.65432099,
-                      0.98765432,
-                      0.00411523,
-                      0.33744856,
-                      0.67078189,
-                      0.11522634,
-                      0.44855967,
-                      0.781893,
-                      0.22633745,
-                      0.55967078,
-                      0.89300412,
-                      0.04115226,
-                      0.3744856,
-                      0.70781893,
-                      0.15226337,
-                      0.48559671,
-                      0.81893004,
-                      0.26337449,
-                      0.59670782,
-                      0.93004115,
-                      0.0781893,
-                      0.41152263])
+        h = np.array(
+            [
+                0.33333333,
+                0.66666667,
+                0.11111111,
+                0.44444444,
+                0.77777778,
+                0.22222222,
+                0.55555556,
+                0.88888889,
+                0.03703704,
+                0.37037037,
+                0.7037037,
+                0.14814815,
+                0.48148148,
+                0.81481481,
+                0.25925926,
+                0.59259259,
+                0.92592593,
+                0.07407407,
+                0.40740741,
+                0.74074074,
+                0.18518519,
+                0.51851852,
+                0.85185185,
+                0.2962963,
+                0.62962963,
+                0.96296296,
+                0.01234568,
+                0.34567901,
+                0.67901235,
+                0.12345679,
+                0.45679012,
+                0.79012346,
+                0.2345679,
+                0.56790123,
+                0.90123457,
+                0.04938272,
+                0.38271605,
+                0.71604938,
+                0.16049383,
+                0.49382716,
+                0.82716049,
+                0.27160494,
+                0.60493827,
+                0.9382716,
+                0.08641975,
+                0.41975309,
+                0.75308642,
+                0.19753086,
+                0.5308642,
+                0.86419753,
+                0.30864198,
+                0.64197531,
+                0.97530864,
+                0.02469136,
+                0.35802469,
+                0.69135802,
+                0.13580247,
+                0.4691358,
+                0.80246914,
+                0.24691358,
+                0.58024691,
+                0.91358025,
+                0.0617284,
+                0.39506173,
+                0.72839506,
+                0.17283951,
+                0.50617284,
+                0.83950617,
+                0.28395062,
+                0.61728395,
+                0.95061728,
+                0.09876543,
+                0.43209877,
+                0.7654321,
+                0.20987654,
+                0.54320988,
+                0.87654321,
+                0.32098765,
+                0.65432099,
+                0.98765432,
+                0.00411523,
+                0.33744856,
+                0.67078189,
+                0.11522634,
+                0.44855967,
+                0.781893,
+                0.22633745,
+                0.55967078,
+                0.89300412,
+                0.04115226,
+                0.3744856,
+                0.70781893,
+                0.15226337,
+                0.48559671,
+                0.81893004,
+                0.26337449,
+                0.59670782,
+                0.93004115,
+                0.0781893,
+                0.41152263,
+            ]
+        )
         diff = halton - h
         norm = np.linalg.norm(diff)
         self.assertAlmostEqual(norm, 0, 7)
-        halton = dr.getHaltonDraws(sampleSize=1, numberOfDraws=10, base=3, skip=10)
-        h = [0.7037037,
-             0.14814815,
-             0.48148148,
-             0.81481481,
-             0.25925926,
-             0.59259259,
-             0.92592593,
-             0.07407407,
-             0.40740741,
-             0.74074074]
+        halton = dr.getHaltonDraws(
+            sampleSize=1, numberOfDraws=10, base=3, skip=10
+        )
+        h = [
+            0.7037037,
+            0.14814815,
+            0.48148148,
+            0.81481481,
+            0.25925926,
+            0.59259259,
+            0.92592593,
+            0.07407407,
+            0.40740741,
+            0.74074074,
+        ]
         diff = halton - h
         norm = np.linalg.norm(diff)
         self.assertAlmostEqual(norm, 0, 7)
 
     def test_antithetic(self):
-        draws = dr.getAntithetic(dr.getHaltonDraws, sampleSize=1, numberOfDraws=10)
-        d = [0.5,
-             0.25,
-             0.75,
-             0.125,
-             0.625,
-             0.5,
-             0.75,
-             0.25,
-             0.875,
-             0.375]
+        draws = dr.getAntithetic(
+            dr.getHaltonDraws, sampleSize=1, numberOfDraws=10
+        )
+        d = [0.5, 0.25, 0.75, 0.125, 0.625, 0.5, 0.75, 0.25, 0.875, 0.375]
         self.assertListEqual(d, draws[0].tolist())
 
     def test_normal(self):
         draws = dr.getNormalWichuraDraws(sampleSize=3, numberOfDraws=1000000)
         mean = np.linalg.norm(np.average(draws, axis=1))
         self.assertAlmostEqual(mean, 0, 2)
-        draws = dr.getNormalWichuraDraws(sampleSize=3, numberOfDraws=1000000, antithetic=True)
+        draws = dr.getNormalWichuraDraws(
+            sampleSize=3, numberOfDraws=1000000, antithetic=True
+        )
         mean = np.linalg.norm(np.average(draws, axis=1))
         self.assertAlmostEqual(mean, 0, 5)
 
+
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `biogeme-3.2.8/tests/functions/testOptimization.py` & `biogeme-3.2.9/tests/functions/test_optimization.py`

 * *Files 1% similar despite different names*

```diff
@@ -21,15 +21,15 @@
 
 import biogeme.biogeme as bio
 from biogeme import models
 import biogeme.algorithms as algo
 import biogeme.optimization as opt
 import biogeme.exceptions as excep
 from biogeme.expressions import Variable, Beta
-from testData import myData1
+from test_data import getData
 
 
 class rosenbrock(algo.functionToMinimize):
     def __init__(self):
         self.x = None
 
     def setVariables(self, x):
@@ -78,30 +78,30 @@
             raise excep.biogemeError('This function is not data driven.')
         return self.f(), self.g(), self.h()
 
     def f_g_bhhh(self, batch=None):
         raise excep.biogemeError('This function is not data driven.')
 
 
-class testOptimization(unittest.TestCase):
+class test_optimization(unittest.TestCase):
     def setUp(self):
         np.random.seed(90267)
         rnd.seed(90267)
         Choice = Variable('Choice')
         Variable1 = Variable('Variable1')
         Variable2 = Variable('Variable2')
         beta1 = Beta('beta1', 0, None, None, 0)
         beta2 = Beta('beta2', 0, None, None, 0)
         V1 = beta1 * Variable1
         V2 = beta2 * Variable2
         V3 = 0
         V = {1: V1, 2: V2, 3: V3}
 
         likelihood = models.loglogit(V, av=None, i=Choice)
-        self.myBiogeme = bio.BIOGEME(myData1, likelihood)
+        self.myBiogeme = bio.BIOGEME(getData(1), likelihood)
         self.myBiogeme.modelName = 'simpleExample'
         self.theFunction = rosenbrock()
         self.myBiogeme.saveIterations = False
         self.myBiogeme.generateHtml = False
         self.myBiogeme.generatePickle = False
 
     def testSchnabelEskow(self):
```

### Comparing `biogeme-3.2.8/tests/latent/optima.dat` & `biogeme-3.2.9/tests/optima/optima.dat`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/tests/swissmetro/swissmetro.dat` & `biogeme-3.2.9/tests/swissmetro/swissmetro.dat`

 * *Files identical despite different names*

### Comparing `biogeme-3.2.8/tests/swissmetro/test_01.py` & `biogeme-3.2.9/tests/swissmetro/test_11bis.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,107 +1,96 @@
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import biogeme.optimization as opt
-import unittest
-from biogeme.expressions import Beta, DefineVariable
+from biogeme import models
+from biogeme.expressions import Beta, Derive
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
-
-V1 = ASC_TRAIN + \
-     B_TIME * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+MU = Beta('MU', 1, 0, 1, 0)
+MU_EXISTING = Beta('MU_EXISTING', 1, 1, None, 1)
+MU_PUBLIC = Beta('MU_PUBLIC', 1, 1, None, 0)
+ALPHA_EXISTING = Beta('ALPHA_EXISTING', 0.5, 0, 1, 0)
+ALPHA_PUBLIC = 1 - ALPHA_EXISTING
+
+
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+TRAIN_TT_SCALED = TRAIN_TT / 100.0
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 
 # Associate the availability conditions with the alternatives
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-class test_01(unittest.TestCase):
-    def testEstimationScipy(self):
-        logprob = models.loglogit(V,av,CHOICE)
-        biogeme  = bio.BIOGEME(database,logprob,seed=10,numberOfThreads=1)
-        biogeme.saveIterations = False
-        biogeme.generateHtml = False
-        biogeme.generatePickle = False
-        biogeme.modelName = "test_01"
-        results = biogeme.estimate(bootstrap=10,algorithm=opt.scipy)
-        self.assertAlmostEqual(results.data.logLike,-5331.252,2)
-        self.assertAlmostEqual(results.data.betas[0].bootstrap_stdErr,0.04773096176427237,2)
-
-    def testEstimationLineSearch(self):
-        logprob = models.loglogit(V,av,CHOICE)
-        biogeme  = bio.BIOGEME(database,logprob,seed=10,numberOfThreads=1)
-        biogeme.saveIterations = False
-        biogeme.generateHtml = False
-        biogeme.generatePickle = False
-        biogeme.modelName = "test_01"
-        results = biogeme.estimate(bootstrap=10,algorithm=opt.newtonLineSearchForBiogeme)
-        self.assertAlmostEqual(results.data.logLike,-5331.252,2)
-        self.assertAlmostEqual(results.data.betas[0].bootstrap_stdErr,0.04773096176427237,2)
-            
-
-    def testEstimationTrustRegion(self):
-        logprob = models.loglogit(V,av,CHOICE)
-        biogeme  = bio.BIOGEME(database,logprob,seed=10,numberOfThreads=1)
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
+
+# Definition of nests:
+alpha_existing = {1: ALPHA_EXISTING, 2: 0.0, 3: 1.0}
+
+alpha_public = {1: ALPHA_PUBLIC, 2: 1.0, 3: 0.0}
+
+nest_existing = MU_EXISTING, alpha_existing
+nest_public = MU_PUBLIC, alpha_public
+nests = nest_existing, nest_public
+
+# The choice model is a cross-nested logit, with availability conditions
+
+logprob = models.logcnlmu(V, av, nests, CHOICE, MU)
+prob1 = models.cnlmu(V, av, nests, 1, MU)
+genelas1 = Derive(prob1, 'TRAIN_TT') * TRAIN_TT / prob1
+simulate = {'Prob. train': prob1, 'Elas. 1': genelas1}
+
+
+class test_11bis(unittest.TestCase):
+    def testEstimationAndSimulation(self):
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
-        biogeme.modelName = "test_01"
-        results = biogeme.estimate(bootstrap=10,algorithm=opt.newtonTrustRegionForBiogeme)
-        self.assertAlmostEqual(results.data.logLike,-5331.252,2)
-        self.assertAlmostEqual(results.data.betas[0].bootstrap_stdErr,0.04773096176427237,2)
-            
-        
+        results = biogeme.estimate()
+        self.assertAlmostEqual(results.data.logLike, -5214.049202307744, 1)
+        biosim = bio.BIOGEME(database, simulate)
+        simresults = biosim.simulate(results.getBetaValues())
+        self.assertAlmostEqual(
+            sum(simresults['Prob. train']), 888.3883902853023, 1
+        )
+        self.assertAlmostEqual(sum(simresults['Elas. 1']), -17897.111326151, 0)
+
+
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_01simul.py` & `biogeme-3.2.9/tests/swissmetro/test_12.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,105 +1,85 @@
-import sys
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable, Elem, Derive
+from biogeme import models
+from biogeme.expressions import (
+    Beta,
+    log,
+    bioDraws,
+    MonteCarlo,
+    PanelLikelihoodTrajectory,
+)
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+database.panel('ID')
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
-ASC_TRAIN = Beta('ASC_TRAIN', -0.701188,None,None,0)
-B_TIME = Beta('B_TIME', -1.27786,None,None,0)
-B_COST = Beta('B_COST', -1.08379,None,None,0)
-ASC_SM = Beta('ASC_SM', 0,None,None,0)
-ASC_CAR = Beta('ASC_CAR', -0.154633,None,None,0)
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-TRAIN_TT_SCALED = TRAIN_TT  / 100.0
-TRAIN_COST_SCALED =  TRAIN_COST / 100
-SM_TT_SCALED = SM_TT / 100.0
-SM_COST_SCALED = SM_COST / 100.0
-CAR_TT_SCALED = CAR_TT / 100.0
-CAR_CO_SCALED = CAR_CO / 100.0
-
-V1 = ASC_TRAIN + \
-     B_TIME * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+B_TIME_S = Beta('B_TIME_S', 0, None, None, 0)
+
+# Define a random parameter, normally distirbuted, designed to be used
+# for Monte-Carlo simulation
+B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL')
+
+
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 
 # Associate the availability conditions with the alternatives
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
-
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-# The choice model is a logit, with availability conditions
-prob1 = Elem({0:0,1:models.logit(V,av,1)},av[1])
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
 
-# Elasticities can be computed. We illustrate below two
-# formulas. Check in the output file that they produce the same
-# result.
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-# First, the general definition of elasticities. This illustrates the
-# use of the Derive expression, and can be used with any model,
-# however complicated it is. Note the quotes in the Derive opertor.
+obsprob = models.logit(V, av, CHOICE)
+condprobIndiv = PanelLikelihoodTrajectory(obsprob)
+logprob = log(MonteCarlo(condprobIndiv))
 
-genelas1 = Derive(prob1,'TRAIN_TT') * TRAIN_TT / prob1
 
-# Second, the elasticity of logit models. See Ben-Akiva and Lerman for
-# the formula
-
-logitelas1 = TRAIN_AV_SP * (1.0 - prob1) * TRAIN_TT_SCALED * B_TIME
-
-simulate = {'P1': prob1,
-            'logit elas. 1':logitelas1,
-            'generic elas. 1':genelas1}
-
-class test_01simul(unittest.TestCase):
-    def testSimulation(self):
-        biogeme  = bio.BIOGEME(database,simulate)
+class test_12(unittest.TestCase):
+    def testEstimation(self):
+        biogeme = bio.BIOGEME(database, logprob, numberOfDraws=5, seed=10)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
-        biogeme.modelName = "01logit_simul"
-        results = biogeme.simulate()
-        self.assertAlmostEqual(sum(results['P1']),907.9992101964821,2)
-        self.assertAlmostEqual(sum(results['logit elas. 1']),-12673.838605478186,2)
-        self.assertAlmostEqual(sum(results['generic elas. 1']),-12673.838605478186,2)
-        
+        results = biogeme.estimate()
+        self.assertAlmostEqual(results.data.logLike, -4845.98507664922, 2)
 
 
 if __name__ == '__main__':
     unittest.main()
-
-
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_02.py` & `biogeme-3.2.9/tests/swissmetro/test_10.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,83 +1,81 @@
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable
-
+from biogeme import models
+from biogeme.expressions import Beta
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+# Here we use the 'biogeme' way for backward compatibility
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
-
-V1 = ASC_TRAIN + \
-     B_TIME * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+MU = Beta('MU', 0.5, 0.0, 1.0, 0)
+
+
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 
 # Associate the availability conditions with the alternatives
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-class test_02(unittest.TestCase):
+# Definition of nests:
+# 1: nests parameter
+# 2: list of alternatives
+existing = 1.0, [1, 3]
+future = 1.0, [2]
+nests = existing, future
+
+# The choice model is a nested logit, with availability conditions
+logprob = models.lognestedMevMu(V, av, nests, CHOICE, MU)
+
+
+class test_10(unittest.TestCase):
     def testEstimation(self):
-        logprob = models.loglogit(V,av,CHOICE)
-        weight = 8.890991e-01 * (1.0 * (GROUP == 2) + 1.2 * (GROUP == 3))
-        formulas = {'loglike':logprob,'weight':weight}
-        biogeme  = bio.BIOGEME(database,formulas)
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5273.743,2)
-    
+        self.assertAlmostEqual(results.data.logLike, -5236.9, 2)
+
+
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_03.py` & `biogeme-3.2.9/tests/swissmetro/test_04.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,87 +1,87 @@
+import os
+import unittest
 import pandas as pd
-import sys
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable
+from biogeme import models
+from biogeme.expressions import Beta, log
+
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+# Here we use the 'biogeme' way for backward compatibility
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+# Biogeme cannot compute the log of 0. Therefore, whenever the cost
+# is 0, the log of 1 computed instead.
+LOG_CAR_COST = database.DefineVariable(
+    'LOG_CAR_COST',
+    (CAR_CO_SCALED != 0) * log(CAR_CO_SCALED + 1 * (CAR_CO_SCALED == 0))
+)
+LOG_TRAIN_COST = database.DefineVariable(
+    'LOG_TRAIN_COST',
+    (TRAIN_COST_SCALED != 0)
+    * log(TRAIN_COST_SCALED + 1 * (TRAIN_COST_SCALED == 0))
+)
+LOG_SM_COST = database.DefineVariable(
+    'LOG_SM_COST',
+    (SM_COST_SCALED != 0) * log(SM_COST_SCALED + 1 * (SM_COST_SCALED == 0))
+)
+
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * LOG_TRAIN_COST
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * LOG_SM_COST
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * LOG_CAR_COST
 
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-Scale_group3 = Beta('Scale_group3',1,0.001,None,0)
-
-
-# Scale
-scale = (GROUP == 2) + (GROUP == 3) * Scale_group3
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
-
-V1 = ASC_TRAIN + \
-     B_TIME * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: scale * V1,
-     2: scale * V2,
-     3: scale * V3}
+V = {1: V1, 2: V2, 3: V3}
 
 
 # Associate the availability conditions with the alternatives
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
 
-class test_03(unittest.TestCase):
+class test_04(unittest.TestCase):
     def testEstimation(self):
-        logprob = models.loglogit(V,av,CHOICE)
-        biogeme  = bio.BIOGEME(database,logprob)
+        logprob = models.loglogit(V, av, CHOICE)
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-4976.691,2)
+        self.assertAlmostEqual(results.data.logLike, -5423.299, 2)
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_04.py` & `biogeme-3.2.9/tests/swissmetro/test_12integral.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,85 +1,88 @@
+import os
+import unittest
 import pandas as pd
-import sys
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable, log
-
+from biogeme import models
+import biogeme.distributions as dist
+from biogeme.expressions import (
+    Beta,
+    log,
+    Integrate,
+    PanelLikelihoodTrajectory,
+    RandomVariable,
+)
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+database.panel('ID')
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
-
-
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
-
-# Biogeme cannot compute the log of 0. Therefore, whenever the cost
-# is 0, the log of 1 computed instead.
-LOG_CAR_COST = DefineVariable('LOG_CAR_COST',(CAR_CO_SCALED != 0) * log( CAR_CO_SCALED + 1 * (CAR_CO_SCALED == 0)),database)
-LOG_TRAIN_COST = DefineVariable('LOG_TRAIN_COST',(TRAIN_COST_SCALED != 0) * log( TRAIN_COST_SCALED + 1 * (TRAIN_COST_SCALED == 0) ),database)
-LOG_SM_COST = DefineVariable('LOG_SM_COST', (SM_COST_SCALED != 0) * log( SM_COST_SCALED + 1 * (SM_COST_SCALED == 0)),database)
-
-V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * LOG_TRAIN_COST
-V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * LOG_SM_COST
-V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * LOG_CAR_COST
-
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+B_TIME_S = Beta('B_TIME_S', 0.1, None, None, 0)
+
+# Define a random parameter, normally distirbuted, designed to be used
+# for Monte-Carlo simulation
+omega = RandomVariable('omega')
+B_TIME_RND = B_TIME + B_TIME_S * omega
+density = dist.normalpdf(omega)
+
+
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 
 # Associate the availability conditions with the alternatives
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
+
+obsprob = models.logit(V, av, CHOICE)
+condprobIndiv = PanelLikelihoodTrajectory(obsprob)
+logprob = log(Integrate(condprobIndiv * density, 'omega'))
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
 
-class test_04(unittest.TestCase):
+class test_12integral(unittest.TestCase):
     def testEstimation(self):
-        logprob = models.loglogit(V,av,CHOICE)
-        biogeme  = bio.BIOGEME(database,logprob)
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5423.299,2)
+        self.assertAlmostEqual(results.data.logLike, -4359.520517074624, 2)
+
 
 if __name__ == '__main__':
     unittest.main()
-
-
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_05.py` & `biogeme-3.2.9/tests/swissmetro/test_05.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,93 +1,93 @@
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable, exp, log, MonteCarlo, bioDraws
-
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+from biogeme import models
+from biogeme.expressions import (
+    Beta,
+    log,
+    MonteCarlo,
+    bioDraws,
+)
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+# Here we use the 'biogeme' way for backward compatibility
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_TIME_S = Beta('B_TIME_S',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_TIME_S = Beta('B_TIME_S', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Define a random parameter, normally distributed, designed to be used
 # for Monte-Carlo simulation
-B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND','NORMAL')
+B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL')
 
 # Utility functions
 
-#If the person has a GA (season ticket) her incremental cost is actually 0 
-#rather than the cost value gathered from the
-# network data. 
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
+# If the person has a GA (season ticket) her incremental cost is actually 0
+# rather than the cost value gathered from the
+# network data.
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # For numerical reasons, it is good practice to scale the data to
-# that the values of the parameters are around 1.0. 
+# that the values of the parameters are around 1.0.
 # A previous estimation with the unscaled data has generated
 # parameters around -0.01 for both cost and time. Therefore, time and
 # cost are multipled my 0.01.
 
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
 
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
 # The choice model is a logit, with availability conditions
-prob = models.logit(V,av,CHOICE)
+prob = models.logit(V, av, CHOICE)
 logprob = log(MonteCarlo(prob))
 
+
 class test_05(unittest.TestCase):
     def testEstimation(self):
-        biogeme = bio.BIOGEME(database,logprob,seed=10,numberOfDraws=5)
+        biogeme = bio.BIOGEME(database, logprob, seed=10, numberOfDraws=5)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5310.590444447898,2)
+        self.assertAlmostEqual(results.data.logLike, -5313.94933896142, 2)
+
 
 if __name__ == '__main__':
     unittest.main()
-
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_05integral.py` & `biogeme-3.2.9/tests/swissmetro/test_17integral.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,98 +1,100 @@
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 import biogeme.distributions as dist
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable, log, RandomVariable, Integrate
+from biogeme import models
+from biogeme.expressions import (
+    Beta,
+    RandomVariable,
+    exp,
+    log,
+    Integrate,
+)
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_TIME_S = Beta('B_TIME_S',1,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Define a random parameter, normally distirbuted, designed to be used
 # for Monte-Carlo simulation
 
 omega = RandomVariable('omega')
-density = dist.normalpdf(omega) 
-B_TIME_RND = B_TIME + B_TIME_S * omega 
+B_TIME_RND = -exp(B_TIME + B_TIME_S * omega)
+density = dist.normalpdf(omega)
 
 
 # Utility functions
 
-#If the person has a GA (season ticket) her incremental cost is actually 0 
-#rather than the cost value gathered from the
-# network data. 
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
+# If the person has a GA (season ticket) her incremental cost is actually 0
+# rather than the cost value gathered from the
+# network data.
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # For numerical reasons, it is good practice to scale the data to
-# that the values of the parameters are around 1.0. 
+# that the values of the parameters are around 1.0.
 # A previous estimation with the unscaled data has generated
 # parameters around -0.01 for both cost and time. Therefore, time and
 # cost are multipled my 0.01.
 
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
 
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
 # The choice model is a logit, with availability conditions
-condprob = models.logit(V,av,CHOICE)
-prob = Integrate(condprob * density,'omega')
+condprob = models.logit(V, av, CHOICE)
+prob = Integrate(condprob * density, 'omega')
 logprob = log(prob)
 
-class test_02(unittest.TestCase):
+
+class test_17(unittest.TestCase):
     def testEstimation(self):
-        biogeme = bio.BIOGEME(database,logprob)
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike, -5214.879,2)
-    
+        self.assertAlmostEqual(results.data.logLike, -5231.419418346811, 2)
+
+
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_06.py` & `biogeme-3.2.9/tests/swissmetro/test_06integral.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,95 +1,102 @@
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.draws as draws
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable, exp, log, MonteCarlo, bioDraws
-
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+from biogeme import models
+from biogeme.expressions import (
+    Beta,
+    RandomVariable,
+    Integrate,
+    log,
+    exp,
+)
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+# Here we use the 'biogeme' way for backward compatibility
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_TIME_S = Beta('B_TIME_S',1,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Define a random parameter, normally distirbuted, designed to be used
 # for Monte-Carlo simulation
-B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND','UNIFORMSYM')
+
+omega = RandomVariable('omega')
+a = -1
+b = 1
+x = a + (b - a) / (1 + exp(-omega))
+dx = (b - a) * exp(-omega) * (1 + exp(-omega)) ** (-2)
+B_TIME_RND = B_TIME + B_TIME_S * x
+
 
 # Utility functions
 
-#If the person has a GA (season ticket) her incremental cost is actually 0 
-#rather than the cost value gathered from the
-# network data. 
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
+# If the person has a GA (season ticket) her incremental cost is actually 0
+# rather than the cost value gathered from the
+# network data.
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # For numerical reasons, it is good practice to scale the data to
-# that the values of the parameters are around 1.0. 
+# that the values of the parameters are around 1.0.
 # A previous estimation with the unscaled data has generated
 # parameters around -0.01 for both cost and time. Therefore, time and
 # cost are multipled my 0.01.
 
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
 
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
 # The choice model is a logit, with availability conditions
-prob = exp(models.loglogit(V,av,CHOICE))
-logprob = log(MonteCarlo(prob))
+condprob = models.logit(V, av, CHOICE)
+prob = Integrate(condprob * dx / (b - a), 'omega')
+logprob = log(prob)
 
 
-class test_06(unittest.TestCase):
+class test_06integral(unittest.TestCase):
     def testEstimation(self):
-        biogeme = bio.BIOGEME(database,logprob,seed=10,numberOfDraws=5)
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5308.187022430414,2)
+        self.assertAlmostEqual(results.data.logLike, -5215.072, 2)
+
 
 if __name__ == '__main__':
     unittest.main()
-
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_06integral.py` & `biogeme-3.2.9/tests/swissmetro/test_05integral.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,102 +1,99 @@
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
 import biogeme.distributions as dist
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable, RandomVariable, Integrate, log, exp
-
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+from biogeme import models
+from biogeme.expressions import (
+    Beta,
+    log,
+    RandomVariable,
+    Integrate,
+)
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+# Here we use the 'biogeme' way for backward compatibility
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_TIME_S = Beta('B_TIME_S',1,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
 
 # Define a random parameter, normally distirbuted, designed to be used
 # for Monte-Carlo simulation
 
 omega = RandomVariable('omega')
-a = -1
-b = 1
-x = a + (b-a) / ( 1 + exp(-omega))
-dx = (b-a) * exp(-omega) * (1+exp(-omega))**(-2) 
-B_TIME_RND = B_TIME + B_TIME_S * x
+density = dist.normalpdf(omega)
+B_TIME_RND = B_TIME + B_TIME_S * omega
 
 
 # Utility functions
 
-#If the person has a GA (season ticket) her incremental cost is actually 0 
-#rather than the cost value gathered from the
-# network data. 
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
+# If the person has a GA (season ticket) her incremental cost is actually 0
+# rather than the cost value gathered from the
+# network data.
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
 
 # For numerical reasons, it is good practice to scale the data to
-# that the values of the parameters are around 1.0. 
+# that the values of the parameters are around 1.0.
 # A previous estimation with the unscaled data has generated
 # parameters around -0.01 for both cost and time. Therefore, time and
 # cost are multipled my 0.01.
 
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
 
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
 # The choice model is a logit, with availability conditions
-condprob = models.logit(V,av,CHOICE)
-prob = Integrate(condprob * dx /(b-a),'omega')
+condprob = models.logit(V, av, CHOICE)
+prob = Integrate(condprob * density, 'omega')
 logprob = log(prob)
 
-class test_06integral(unittest.TestCase):
+
+class test_02(unittest.TestCase):
     def testEstimation(self):
-        biogeme = bio.BIOGEME(database,logprob)
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5215.072,2)
+        self.assertAlmostEqual(results.data.logLike, -5214.879, 2)
+
 
 if __name__ == '__main__':
     unittest.main()
-
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_08.py` & `biogeme-3.2.9/tests/swissmetro/test_09.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,88 +1,81 @@
+import os
+import unittest
 import pandas as pd
-import sys
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable
+from biogeme import models
+from biogeme.expressions import Beta
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+# Here we use the 'biogeme' way for backward compatibility
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-LAMBDA = Beta('LAMBDA',1.5,0.0001,5,0)
-
-
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
-
-V1 = ASC_TRAIN + \
-     B_TIME * models.boxcox(TRAIN_TT_SCALED,LAMBDA) + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * models.boxcox(SM_TT_SCALED,LAMBDA) + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * models.boxcox(CAR_TT_SCALED,LAMBDA) + \
-     B_COST * CAR_CO_SCALED
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+MU = Beta('MU', 2.05, 1, 10, 0)
+
+
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 
 # Associate the availability conditions with the alternatives
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-logprob = models.loglogit(V,av,CHOICE)
+# Definition of nests:
+# 1: nests parameter
+# 2: list of alternatives
+existing = MU, [1, 3]
+future = 1.0, [2]
+nests = existing, future
 
-class test_08(unittest.TestCase):
+# The choice model is a nested logit, with availability conditions
+logprob = models.lognested(V, av, nests, CHOICE)
+
+
+class test_09(unittest.TestCase):
     def testEstimation(self):
-        biogeme  = bio.BIOGEME(database,logprob)
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5292.095410794698,2)
-    
-if __name__ == '__main__':
-    unittest.main()
+        self.assertAlmostEqual(results.data.logLike, -5236.9, 2)
 
 
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_09.py` & `biogeme-3.2.9/tests/swissmetro/test_14.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,95 +1,86 @@
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable
+from biogeme import models
+from biogeme.expressions import Beta
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-MU = Beta('MU',2.05,1,10,0)
-
-
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
-
-V1 = ASC_TRAIN + \
-     B_TIME * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+MU = Beta('MU', 2.05, 1, None, 0)
+
+# Additional parameter designed to estimate the bias due to choice
+# based sampling
+SB_TRAIN = Beta('SB_TRAIN', 0, None, None, 0)
+
+correction = {1: SB_TRAIN, 2: 0, 3: 0}
+
+
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 
 # Associate the availability conditions with the alternatives
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-#Definition of nests:
+# Definition of nests:
 # 1: nests parameter
 # 2: list of alternatives
-existing = MU , [1,3]
-future = 1.0 , [2]
-nests = existing,future
+existing = MU, [1, 3]
+future = 1.0, [2]
+nests = existing, future
+# The choice model is a nested logit, with corrections for endogenous sampling
+Gi = models.getMevForNested(V, av, nests)
+logprob = models.logmev_endogenousSampling(V, Gi, av, correction, CHOICE)
 
-# The choice model is a nested logit, with availability conditions
-logprob = models.lognested(V,av,nests,CHOICE)
 
-class test_09(unittest.TestCase):
+class test_14(unittest.TestCase):
     def testEstimation(self):
-        biogeme  = bio.BIOGEME(database,logprob)
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5236.9,2)
-    
-if __name__ == '__main__':
-    unittest.main()
+        self.assertAlmostEqual(results.data.logLike, -5169.641517407234, 2)
 
 
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_10.py` & `biogeme-3.2.9/tests/swissmetro/test_08.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,90 +1,85 @@
+import os
+import unittest
 import pandas as pd
-
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable
+from biogeme import models
+from biogeme.expressions import Beta
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+# Here we use the 'biogeme' way for backward compatibility
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-MU = Beta('MU',0.5,0.0,1.0,0)
-
-
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
-
-V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
-V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+LAMBDA = Beta('LAMBDA', 1.5, 0.0001, 5, 0)
+
+
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = (
+    ASC_TRAIN
+    + B_TIME * models.boxcox(TRAIN_TT_SCALED, LAMBDA)
+    + B_COST * TRAIN_COST_SCALED
+)
+V2 = (
+    ASC_SM
+    + B_TIME * models.boxcox(SM_TT_SCALED, LAMBDA)
+    + B_COST * SM_COST_SCALED
+)
+V3 = (
+    ASC_CAR
+    + B_TIME * models.boxcox(CAR_TT_SCALED, LAMBDA)
+    + B_COST * CAR_CO_SCALED
+)
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 
 # Associate the availability conditions with the alternatives
-CAR_AV_SP = DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP = DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-#Definition of nests:
-# 1: nests parameter
-# 2: list of alternatives
-existing = 1.0 , [1,3]
-future = 1.0 , [2]
-nests = existing,future
+logprob = models.loglogit(V, av, CHOICE)
 
-# The choice model is a nested logit, with availability conditions
-logprob = models.lognestedMevMu(V,av,nests,CHOICE,MU)
 
-class test_10(unittest.TestCase):
+class test_08(unittest.TestCase):
     def testEstimation(self):
-        biogeme  = bio.BIOGEME(database,logprob)
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5236.9,2)
-    
-if __name__ == '__main__':
-    unittest.main()
+        self.assertAlmostEqual(results.data.logLike, -5292.095410794698, 2)
 
 
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_11.py` & `biogeme-3.2.9/tests/swissmetro/test_11.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,114 +1,96 @@
+import os
+import unittest
 import pandas as pd
-
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable, Derive
+from biogeme import models
+from biogeme.expressions import Beta, Derive
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-MU_EXISTING = Beta('MU_EXISTING',1,1,None,0)
-MU_PUBLIC = Beta('MU_PUBLIC',1,1,None,0)
-ALPHA_EXISTING = Beta('ALPHA_EXISTING',0.5,0,1,0)
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+MU_EXISTING = Beta('MU_EXISTING', 1, 1, None, 0)
+MU_PUBLIC = Beta('MU_PUBLIC', 1, 1, None, 0)
+ALPHA_EXISTING = Beta('ALPHA_EXISTING', 0.5, 0, 1, 0)
 ALPHA_PUBLIC = 1 - ALPHA_EXISTING
 
 
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
 
 TRAIN_TT_SCALED = TRAIN_TT / 100.0
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
-
-V1 = ASC_TRAIN + \
-     B_TIME * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 
 # Associate the availability conditions with the alternatives
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-#Definition of nests:
-alpha_existing = {1: ALPHA_EXISTING,
-                  2:0.0,
-                  3:1.0}
-
-alpha_public = {1: ALPHA_PUBLIC,
-                2: 1.0,
-                3: 0.0}
+# Definition of nests:
+alpha_existing = {1: ALPHA_EXISTING, 2: 0.0, 3: 1.0}
+
+alpha_public = {1: ALPHA_PUBLIC, 2: 1.0, 3: 0.0}
 
 nest_existing = MU_EXISTING, alpha_existing
 nest_public = MU_PUBLIC, alpha_public
 nests = nest_existing, nest_public
 
 # The choice model is a cross-nested logit, with availability conditions
-logprob = models.logcnl_avail(V,av,nests,CHOICE)
-prob1 = models.cnl_avail(V,av,nests,1)
-genelas1 = Derive(prob1,'TRAIN_TT') * TRAIN_TT / prob1
-simulate = {'Prob. train': prob1,
-            'Elas. 1':genelas1}
+logprob = models.logcnl_avail(V, av, nests, CHOICE)
+prob1 = models.cnl_avail(V, av, nests, 1)
+genelas1 = Derive(prob1, 'TRAIN_TT') * TRAIN_TT / prob1
+simulate = {'Prob. train': prob1, 'Elas. 1': genelas1}
+
 
 class test_11(unittest.TestCase):
     def testEstimationAndSimulation(self):
-        biogeme  = bio.BIOGEME(database,logprob,numberOfThreads=1)
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5214.049,2)
-        biosim  = bio.BIOGEME(database,simulate)
+        self.assertAlmostEqual(results.data.logLike, -5214.049, 2)
+        biosim = bio.BIOGEME(database, simulate)
         simresults = biosim.simulate(results.getBetaValues())
-        self.assertAlmostEqual(sum(simresults['Prob. train']),888.3883902853023,1)
-        self.assertAlmostEqual(sum(simresults['Elas. 1']),-17897.702976576973, 0)
-    
-        
-if __name__ == '__main__':
-    unittest.main()
-
+        self.assertAlmostEqual(
+            sum(simresults['Prob. train']), 888.3883902853023, 1
+        )
+        self.assertAlmostEqual(
+            sum(simresults['Elas. 1']), -17897.702976576973, 0
+        )
 
 
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_12.py` & `biogeme-3.2.9/tests/swissmetro/test_17.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,94 +1,93 @@
-import pandas as pd
-import biogeme.database as db
-import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable, log, bioDraws, MonteCarlo, PanelLikelihoodTrajectory
-
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
-
-database.panel("ID")
-
-# The Pandas data structure is available as database.data. Use all the
-# Pandas functions to invesigate the database
-#print(database.data.describe())
-
-globals().update(database.variables)
-
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
-database.remove(exclude)
-
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-B_TIME_S = Beta('B_TIME_S',0,None,None,0)
-
-# Define a random parameter, normally distirbuted, designed to be used
-# for Monte-Carlo simulation
-B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND','NORMAL')
-
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
-
-V1 = ASC_TRAIN + \
-     B_TIME_RND * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME_RND * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME_RND * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
-
-# Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
-
-
-# Associate the availability conditions with the alternatives
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
-
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-obsprob = models.logit(V,av,CHOICE)
-condprobIndiv = PanelLikelihoodTrajectory(obsprob)
-logprob = log(MonteCarlo(condprobIndiv))
-
-class test_12(unittest.TestCase):
-    def testEstimation(self):
-        biogeme  = bio.BIOGEME(database,logprob,numberOfDraws=5,seed=10)
-        biogeme.saveIterations = False
-        biogeme.generateHtml = False
-        biogeme.generatePickle = False
-        results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-4705.638407401872,2)
-    
-if __name__ == '__main__':
-    unittest.main()
-
-
-
-
+import os
+import unittest
+import pandas as pd
+import biogeme.database as db
+import biogeme.biogeme as bio
+from biogeme import models
+from biogeme.expressions import (
+    Beta,
+    exp,
+    log,
+    bioDraws,
+    MonteCarlo,
+)
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
+
+# The Pandas data structure is available as database.data. Use all the
+# Pandas functions to invesigate the database
+# print(database.data.describe())
+
+globals().update(database.variables)
+
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
+database.remove(exclude)
+
+
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_TIME_S = Beta('B_TIME_S', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+# Define a random parameter, log normally distributed, designed to be used
+# for Monte-Carlo simulation
+B_TIME_RND = -exp(B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL'))
+
+# Utility functions
+
+# If the person has a GA (season ticket) her incremental cost is actually 0
+# rather than the cost value gathered from the
+# network data.
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+# For numerical reasons, it is good practice to scale the data to
+# that the values of the parameters are around 1.0.
+# A previous estimation with the unscaled data has generated
+# parameters around -0.01 for both cost and time. Therefore, time and
+# cost are multipled my 0.01.
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
+V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+
+# Associate utility functions with the numbering of alternatives
+V = {1: V1, 2: V2, 3: V3}
+
+# Associate the availability conditions with the alternatives
+
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
+
+# The choice model is a logit, with availability conditions
+prob = models.logit(V, av, CHOICE)
+logprob = log(MonteCarlo(prob))
+
+
+class test_17(unittest.TestCase):
+    def testEstimation(self):
+        biogeme = bio.BIOGEME(database, logprob, numberOfDraws=5, seed=10)
+        biogeme.saveIterations = False
+        biogeme.generateHtml = False
+        biogeme.generatePickle = False
+        results = biogeme.estimate()
+        self.assertAlmostEqual(results.data.logLike, -5316.3758171905365, 2)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_12integral.py` & `biogeme-3.2.9/tests/swissmetro/test_21.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,96 +1,70 @@
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import biogeme.distributions as dist
-import unittest
-from biogeme.expressions import Beta, DefineVariable, log, Integrate, PanelLikelihoodTrajectory, RandomVariable
+from biogeme.expressions import Beta, bioNormalCdf, Elem, log
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
 
-database.panel("ID")
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
+# As we estimate a binary model, we remove observations where
+# Swissmetro was chosen (CHOICE == 2). We also remove observations
+# where one of the two alternatives is not available.
+
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+exclude = (TRAIN_AV_SP == 0) + (CAR_AV_SP == 0) + (CHOICE == 2) + (
+    (PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)
+) > 0
+
 
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
 database.remove(exclude)
 
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-B_TIME_S = Beta('B_TIME_S',0.1,None,None,0)
-
-# Define a random parameter, normally distirbuted, designed to be used
-# for Monte-Carlo simulation
-omega = RandomVariable('omega')
-B_TIME_RND = B_TIME + B_TIME_S * omega
-density = dist.normalpdf(omega) 
-
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
-
-V1 = ASC_TRAIN + \
-     B_TIME_RND * TRAIN_TT_SCALED + \
-     B_COST * TRAIN_COST_SCALED
-V2 = ASC_SM + \
-     B_TIME_RND * SM_TT_SCALED + \
-     B_COST * SM_COST_SCALED
-V3 = ASC_CAR + \
-     B_TIME_RND * CAR_TT_SCALED + \
-     B_COST * CAR_CO_SCALED
-
-# Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
-
-
-# Associate the availability conditions with the alternatives
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
-
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-obsprob = models.logit(V,av,CHOICE)
-condprobIndiv = PanelLikelihoodTrajectory(obsprob)
-logprob = log(Integrate(condprobIndiv * density,'omega'))
 
-class test_12integral(unittest.TestCase):
+ASC_CAR = Beta('ASC_CAR', 1, None, None, 0)
+B_TIME = Beta('B_TIME', 1, None, None, 0)
+B_COST = Beta('B_COST', 1, None, None, 0)
+
+
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+# We estimate a binary probit model. There are only two alternatives.
+V1 = B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
+V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
+
+# Associate choice probability with the numbering of alternatives
+
+P = {1: bioNormalCdf(V1 - V3), 3: bioNormalCdf(V3 - V1)}
+
+
+prob = Elem(P, CHOICE)
+
+
+class test_02(unittest.TestCase):
     def testEstimation(self):
-        biogeme  = bio.BIOGEME(database,logprob)
+        biogeme = bio.BIOGEME(database, log(prob))
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-4359.520517074624,2)
-    
-if __name__ == '__main__':
-    unittest.main()
-
+        self.assertAlmostEqual(results.data.logLike, -986.1888, 2)
 
 
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_13.py` & `biogeme-3.2.9/tests/swissmetro/test_13.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,94 +1,95 @@
+import os
+import unittest
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable, bioDraws, log, MonteCarlo, PanelLikelihoodTrajectory
+from biogeme import models
+from biogeme.expressions import (
+    Beta,
+    bioDraws,
+    log,
+    MonteCarlo,
+    PanelLikelihoodTrajectory,
+)
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
-
-database.panel("ID")
+database.panel('ID')
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-SIGMA_CAR = Beta('SIGMA_CAR',0,None,None,0)
-SIGMA_SM = Beta('SIGMA_SM',0,None,None,1)
-SIGMA_TRAIN = Beta('SIGMA_TRAIN',0,None,None,0)
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+SIGMA_CAR = Beta('SIGMA_CAR', 0, None, None, 0)
+SIGMA_SM = Beta('SIGMA_SM', 0, None, None, 1)
+SIGMA_TRAIN = Beta('SIGMA_TRAIN', 0, None, None, 0)
 
 
 # Define a random parameter, normally distirbuted, designed to be used
 # for Monte-Carlo simulation
-EC_CAR = SIGMA_CAR * bioDraws('EC_CAR','NORMAL')
-EC_SM = SIGMA_SM * bioDraws('EC_SM','NORMAL')
-EC_TRAIN = SIGMA_TRAIN * bioDraws('EC_TRAIN','NORMAL')
-
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
-
-V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED + EC_TRAIN
+EC_CAR = SIGMA_CAR * bioDraws('EC_CAR', 'NORMAL')
+EC_SM = SIGMA_SM * bioDraws('EC_SM', 'NORMAL')
+EC_TRAIN = SIGMA_TRAIN * bioDraws('EC_TRAIN', 'NORMAL')
+
+
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = (
+    ASC_TRAIN
+    + B_TIME * TRAIN_TT_SCALED
+    + B_COST * TRAIN_COST_SCALED
+    + EC_TRAIN
+)
 V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED + EC_SM
 V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED + EC_CAR
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 
 # Associate the availability conditions with the alternatives
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-obsprob = models.logit(V,av,CHOICE)
+obsprob = models.logit(V, av, CHOICE)
 condprobIndiv = PanelLikelihoodTrajectory(obsprob)
 logprob = log(MonteCarlo(condprobIndiv))
 
+
 class test_13(unittest.TestCase):
     def testEstimation(self):
-        biogeme  = bio.BIOGEME(database,logprob,numberOfDraws=5,seed=10)
+        biogeme = bio.BIOGEME(database, logprob, numberOfDraws=5, seed=10)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-4557.1998156795935,2)
-    
-if __name__ == '__main__':
-    unittest.main()
-
-
-
+        self.assertAlmostEqual(results.data.logLike, -4634.307424865441, 2)
 
 
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_17.py` & `biogeme-3.2.9/examples/swissmetro/05normalMixture.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,94 +1,119 @@
+"""File 05normalMixture.py
+
+:author: Michel Bierlaire, EPFL
+:date: Sat Sep  7 18:23:01 2019
+
+ Example of a mixture of logit models, using Monte-Carlo integration.
+ Three alternatives: Train, Car and Swissmetro
+ SP data
+"""
+
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.draws as draws
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable, exp, log, bioDraws, MonteCarlo
-
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+from biogeme import models
+import biogeme.messaging as msg
+from biogeme.expressions import Beta, Variable, bioDraws, log, MonteCarlo
+
+# Read the data
+df = pd.read_csv('swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
-# Pandas functions to invesigate the database
-#print(database.data.describe())
+# Pandas functions to investigate the database. For example:
+# print(database.data.describe())
 
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
+# remove = (((database.data.PURPOSE != 1) &
+#           (database.data.PURPOSE != 3)) |
+#          (database.data.CHOICE == 0))
+# database.data.drop(database.data[remove].index,inplace=True)
 
 # Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
+# Parameters to be estimated
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_COST = Beta('B_COST', 0, None, None, 0)
 
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_TIME_S = Beta('B_TIME_S',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-# Define a random parameter, log normally distributed, designed to be used
+# Define a random parameter, normally distributed, designed to be used
 # for Monte-Carlo simulation
-B_TIME_RND = -exp(B_TIME + B_TIME_S * bioDraws('B_TIME_RND','NORMAL'))
-
-# Utility functions
+B_TIME = Beta('B_TIME', 0, None, None, 0)
 
-#If the person has a GA (season ticket) her incremental cost is actually 0 
-#rather than the cost value gathered from the
-# network data. 
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-# For numerical reasons, it is good practice to scale the data to
-# that the values of the parameters are around 1.0. 
-# A previous estimation with the unscaled data has generated
-# parameters around -0.01 for both cost and time. Therefore, time and
-# cost are multipled my 0.01.
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
+# It is advised not to use 0 as starting value for the following parameter.
+B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
+B_TIME_RND = B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL')
+
+# Definition of new variables
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+# Definition of new variables: adding columns to the database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
+# Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+# Conditional to B_TIME_RND, we have a logit model (called the kernel)
+prob = models.logit(V, av, CHOICE)
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-# The choice model is a logit, with availability conditions
-prob = models.logit(V,av,CHOICE)
+# We integrate over B_TIME_RND using Monte-Carlo
 logprob = log(MonteCarlo(prob))
 
-
-class test_17(unittest.TestCase):
-    def testEstimation(self):
-        biogeme = bio.BIOGEME(database,logprob,numberOfDraws=5,seed=10)
-        biogeme.saveIterations = False
-        biogeme.generateHtml = False
-        biogeme.generatePickle = False
-        results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5312.735685567558,2)
-    
-if __name__ == '__main__':
-    unittest.main()
+# Define level of verbosity
+logger = msg.bioMessage()
+# logger.setSilent()
+# logger.setWarning()
+logger.setGeneral()
+# logger.setDetailed()
+
+# These notes will be included as such in the report file.
+userNotes = (
+    'Example of a mixture of logit models with three alternatives, '
+    'approximated using Monte-Carlo integration.'
+)
+
+# Create the Biogeme object
+biogeme = bio.BIOGEME(
+    database, logprob, numberOfDraws=100000, userNotes=userNotes
+)
+biogeme.modelName = '05normalMixture'
+
+# Estimate the parameters
+results = biogeme.estimate()
+pandasResults = results.getEstimatedParameters()
+print(pandasResults)
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_17integral.py` & `biogeme-3.2.9/examples/swissmetro/17lognormalMixture.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,102 +1,123 @@
+"""File 17lognormalMixture.py
+
+:author: Michel Bierlaire, EPFL
+:date: Sat Sep  7 18:23:01 2019
+
+ Example of a mixture of logit models, using Monte-Carlo integration.
+ The mixing distribution is distributed as a log normal.
+ Three alternatives: Train, Car and Swissmetro
+ SP data
+"""
+
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.distributions as dist
-import biogeme.models as models
-import biogeme.optimization as opt
-import unittest
-from biogeme.expressions import Beta, DefineVariable, RandomVariable, exp, log, Integrate
-
-
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+from biogeme import models
+import biogeme.messaging as msg
+from biogeme.expressions import (
+    Beta,
+    Variable,
+    exp,
+    log,
+    MonteCarlo,
+    bioDraws,
+)
+
+# Read the data
+df = pd.read_csv('swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
-globals().update(database.variables)
+PURPOSE = Variable('PURPOSE')
+CHOICE = Variable('CHOICE')
+GA = Variable('GA')
+TRAIN_CO = Variable('TRAIN_CO')
+CAR_AV = Variable('CAR_AV')
+SP = Variable('SP')
+TRAIN_AV = Variable('TRAIN_AV')
+TRAIN_TT = Variable('TRAIN_TT')
+SM_TT = Variable('SM_TT')
+CAR_TT = Variable('CAR_TT')
+CAR_CO = Variable('CAR_CO')
+SM_CO = Variable('SM_CO')
+SM_AV = Variable('SM_AV')
 
 # Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
+# remove = (((database.data.PURPOSE != 1) &
+#           (database.data.PURPOSE != 3)) |
+#          (database.data.CHOICE == 0))
+# database.data.drop(database.data[remove].index,inplace=True)
 
 # Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_TIME_S = Beta('B_TIME_S',1,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
+# Parameters to be estimated
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_COST = Beta('B_COST', 0, None, None, 0)
 
-# Define a random parameter, normally distirbuted, designed to be used
+# Define a random parameter, normally distributed, designed to be used
 # for Monte-Carlo simulation
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+
+# It is advised not to use 0 as starting value for the following parameter.
+B_TIME_S = Beta('B_TIME_S', 1, None, None, 0)
 
-omega = RandomVariable('omega')
-B_TIME_RND = -exp(B_TIME + B_TIME_S * omega)
-density = dist.normalpdf(omega) 
-
-
-# Utility functions
-
-#If the person has a GA (season ticket) her incremental cost is actually 0 
-#rather than the cost value gathered from the
-# network data. 
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-# For numerical reasons, it is good practice to scale the data to
-# that the values of the parameters are around 1.0. 
-# A previous estimation with the unscaled data has generated
-# parameters around -0.01 for both cost and time. Therefore, time and
-# cost are multipled my 0.01.
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
+# Define a random parameter, log normally distributed, designed to be used
+# for Monte-Carlo simulation.
+B_TIME_RND = -exp(B_TIME + B_TIME_S * bioDraws('B_TIME_RND', 'NORMAL'))
+
+# Definition of new variables
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+# Definition of new variables: adding columns to the database
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
 
+# Definition of the utility functions
 V1 = ASC_TRAIN + B_TIME_RND * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 V2 = ASC_SM + B_TIME_RND * SM_TT_SCALED + B_COST * SM_COST_SCALED
 V3 = ASC_CAR + B_TIME_RND * CAR_TT_SCALED + B_COST * CAR_CO_SCALED
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 # Associate the availability conditions with the alternatives
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
-
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
-
-# The choice model is a logit, with availability conditions
-condprob = models.logit(V,av,CHOICE)
-prob = Integrate(condprob * density,'omega')
-logprob = log(prob)
-
+# Conditional to B_TIME_RND, we have a logit model (called the kernel)
+prob = models.logit(V, av, CHOICE)
 
+# We integrate over B_TIME_RND using Monte-Carlo
+logprob = log(MonteCarlo(prob))
 
-class test_17(unittest.TestCase):
-    def testEstimation(self):
-        biogeme = bio.BIOGEME(database,logprob)
-        biogeme.saveIterations = False
-        biogeme.generateHtml = False
-        biogeme.generatePickle = False
-        results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5231.419418346811,2)
-    
-if __name__ == '__main__':
-    unittest.main()
+# Define level of verbosity
+logger = msg.bioMessage()
+# logger.setSilent()
+# logger.setWarning()
+logger.setGeneral()
+# logger.setDetailed()
+
+# Create the Biogeme object
+biogeme = bio.BIOGEME(database, logprob, numberOfDraws=100000)
+biogeme.modelName = '17lognormalMixture'
+
+# Estimate the parameters
+results = biogeme.estimate()
+pandasResults = results.getEstimatedParameters()
+print(pandasResults)
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_18.py` & `biogeme-3.2.9/tests/swissmetro/test_18.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,68 +1,65 @@
+import os
+import unittest
 import pandas as pd
-import sys
 import biogeme.database as db
 import biogeme.biogeme as bio
 import biogeme.distributions as dist
-import unittest
-from biogeme.expressions import Beta, DefineVariable, log, Elem
+from biogeme.expressions import Beta, log, Elem
 
 
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+myPath = os.path.dirname(os.path.abspath(__file__))
+df = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', df)
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
 
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
 
-tau1	 = Beta('tau1',-1,None,0,0)
-delta2	 = Beta('delta2',2,0,None,0)
+tau1 = Beta('tau1', -1, None, 0, 0)
+delta2 = Beta('delta2', 2, 0, None, 0)
 
 tau2 = tau1 + delta2
 
 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
+TRAIN_COST = TRAIN_CO * (GA == 0)
 
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
 
 #  Utility
 
-U = B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED 
+U = B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED
 
 
 ChoiceProba = {
-    1: 1-dist.logisticcdf(U-tau1),
-    2: dist.logisticcdf(U-tau1)- dist.logisticcdf(U-tau2),
-    3: dist.logisticcdf(U-tau2) }
+    1: 1 - dist.logisticcdf(U - tau1),
+    2: dist.logisticcdf(U - tau1) - dist.logisticcdf(U - tau2),
+    3: dist.logisticcdf(U - tau2),
+}
+
+logprob = log(Elem(ChoiceProba, CHOICE))
 
-logprob = log(Elem(ChoiceProba,CHOICE))
 
 class test_18(unittest.TestCase):
     def testEstimation(self):
-        biogeme  = bio.BIOGEME(database,logprob)
+        biogeme = bio.BIOGEME(database, logprob)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-5789.309,2)
-    
-if __name__ == '__main__':
-    unittest.main()
+        self.assertAlmostEqual(results.data.logLike, -5789.309, 2)
 
 
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `biogeme-3.2.8/tests/swissmetro/test_26.py` & `biogeme-3.2.9/tests/swissmetro/test_26.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,101 +1,111 @@
+import os
+import unittest
 import numpy as np
 import pandas as pd
 import biogeme.database as db
 import biogeme.biogeme as bio
-import biogeme.models as models
-import unittest
-from biogeme.expressions import Beta, DefineVariable, bioDraws, PanelLikelihoodTrajectory, MonteCarlo, log
-
-pandas = pd.read_csv("swissmetro.dat",sep='\t')
-database = db.Database("swissmetro",pandas)
+from biogeme import models
+from biogeme.expressions import (
+    Beta,
+    bioDraws,
+    PanelLikelihoodTrajectory,
+    MonteCarlo,
+    log,
+)
+
+myPath = os.path.dirname(os.path.abspath(__file__))
+pandas = pd.read_csv(f'{myPath}/swissmetro.dat', sep='\t')
+database = db.Database('swissmetro', pandas)
 
-database.panel("ID")
+database.panel('ID')
 
 # The Pandas data structure is available as database.data. Use all the
 # Pandas functions to invesigate the database
-#print(database.data.describe())
+# print(database.data.describe())
 
 globals().update(database.variables)
 
-# Removing some observations can be done directly using pandas.
-#remove = (((database.data.PURPOSE != 1) & (database.data.PURPOSE != 3)) | (database.data.CHOICE == 0))
-#database.data.drop(database.data[remove].index,inplace=True)
-
-# Here we use the "biogeme" way for backward compatibility
-exclude = (( PURPOSE != 1 ) * (  PURPOSE   !=  3  ) +  ( CHOICE == 0 )) > 0
+# Here we use the 'biogeme' way for backward compatibility
+exclude = ((PURPOSE != 1) * (PURPOSE != 3) + (CHOICE == 0)) > 0
 database.remove(exclude)
 
-ASC_CAR = Beta('ASC_CAR',0,None,None,0)
-ASC_TRAIN = Beta('ASC_TRAIN',0,None,None,0)
-ASC_SM = Beta('ASC_SM',0,None,None,1)
-B_TIME = Beta('B_TIME',0,None,None,0)
-B_COST = Beta('B_COST',0,None,None,0)
-
-SIGMA_CAR = Beta('SIGMA_CAR',0,None,None,0)
-SIGMA_SM = Beta('SIGMA_SM',0,None,None,0)
-SIGMA_TRAIN = Beta('SIGMA_TRAIN',0,None,None,0)
+ASC_CAR = Beta('ASC_CAR', 0, None, None, 0)
+ASC_TRAIN = Beta('ASC_TRAIN', 0, None, None, 0)
+ASC_SM = Beta('ASC_SM', 0, None, None, 1)
+B_TIME = Beta('B_TIME', 0, None, None, 0)
+B_COST = Beta('B_COST', 0, None, None, 0)
+
+SIGMA_CAR = Beta('SIGMA_CAR', 0, None, None, 0)
+SIGMA_SM = Beta('SIGMA_SM', 0, None, None, 0)
+SIGMA_TRAIN = Beta('SIGMA_TRAIN', 0, None, None, 0)
 
 
 # Provide my own random number generator to the database.
 # See the numpy.random documentation to obtain a list of other distributions.
 def theTriangularGenerator(sampleSize, numberOfDraws):
-    return np.random.triangular(-1,0,1,(sampleSize,numberOfDraws))
+    return np.random.triangular(-1, 0, 1, (sampleSize, numberOfDraws))
 
-myRandomNumberGenerators = {'TRIANGULAR':(theTriangularGenerator,'Triangulart distribution T(-1,0,1)')}
-database.setRandomNumberGenerators(myRandomNumberGenerators)
 
-# Define a random parameter,  with a triangular distribution, designed to be used
-# for Monte-Carlo simulation
-EC_CAR = SIGMA_CAR * bioDraws('EC_CAR','TRIANGULAR')
-EC_SM = SIGMA_SM * bioDraws('EC_SM','TRIANGULAR')
-EC_TRAIN = SIGMA_TRAIN * bioDraws('EC_TRAIN','TRIANGULAR')
-
-
-SM_COST =  SM_CO   * (  GA   ==  0  ) 
-TRAIN_COST =  TRAIN_CO   * (  GA   ==  0  )
-
-TRAIN_TT_SCALED = DefineVariable('TRAIN_TT_SCALED',\
-                                 TRAIN_TT / 100.0,database)
-TRAIN_COST_SCALED = DefineVariable('TRAIN_COST_SCALED',\
-                                   TRAIN_COST / 100,database)
-SM_TT_SCALED = DefineVariable('SM_TT_SCALED', SM_TT / 100.0,database)
-SM_COST_SCALED = DefineVariable('SM_COST_SCALED', SM_COST / 100,database)
-CAR_TT_SCALED = DefineVariable('CAR_TT_SCALED', CAR_TT / 100,database)
-CAR_CO_SCALED = DefineVariable('CAR_CO_SCALED', CAR_CO / 100,database)
+myRandomNumberGenerators = {
+    'TRIANGULAR': (
+        theTriangularGenerator,
+        'Triangulart distribution T(-1,0,1)',
+    )
+}
+database.setRandomNumberGenerators(myRandomNumberGenerators)
 
-V1 = ASC_TRAIN + B_TIME * TRAIN_TT_SCALED + B_COST * TRAIN_COST_SCALED + EC_TRAIN
+# Define a random parameter, with a triangular distribution, designed
+# to be used for Monte-Carlo simulation
+EC_CAR = SIGMA_CAR * bioDraws('EC_CAR', 'TRIANGULAR')
+EC_SM = SIGMA_SM * bioDraws('EC_SM', 'TRIANGULAR')
+EC_TRAIN = SIGMA_TRAIN * bioDraws('EC_TRAIN', 'TRIANGULAR')
+
+
+SM_COST = SM_CO * (GA == 0)
+TRAIN_COST = TRAIN_CO * (GA == 0)
+
+TRAIN_TT_SCALED = database.DefineVariable('TRAIN_TT_SCALED', TRAIN_TT / 100.0)
+TRAIN_COST_SCALED = database.DefineVariable(
+    'TRAIN_COST_SCALED', TRAIN_COST / 100
+)
+SM_TT_SCALED = database.DefineVariable('SM_TT_SCALED', SM_TT / 100.0)
+SM_COST_SCALED = database.DefineVariable('SM_COST_SCALED', SM_COST / 100)
+CAR_TT_SCALED = database.DefineVariable('CAR_TT_SCALED', CAR_TT / 100)
+CAR_CO_SCALED = database.DefineVariable('CAR_CO_SCALED', CAR_CO / 100)
+
+V1 = (
+    ASC_TRAIN
+    + B_TIME * TRAIN_TT_SCALED
+    + B_COST * TRAIN_COST_SCALED
+    + EC_TRAIN
+)
 V2 = ASC_SM + B_TIME * SM_TT_SCALED + B_COST * SM_COST_SCALED + EC_SM
 V3 = ASC_CAR + B_TIME * CAR_TT_SCALED + B_COST * CAR_CO_SCALED + EC_CAR
 
 # Associate utility functions with the numbering of alternatives
-V = {1: V1,
-     2: V2,
-     3: V3}
+V = {1: V1, 2: V2, 3: V3}
 
 
 # Associate the availability conditions with the alternatives
-CAR_AV_SP =  DefineVariable('CAR_AV_SP',CAR_AV  * (  SP   !=  0  ),database)
-TRAIN_AV_SP =  DefineVariable('TRAIN_AV_SP',TRAIN_AV  * (  SP   !=  0  ),database)
+CAR_AV_SP = database.DefineVariable('CAR_AV_SP', CAR_AV * (SP != 0))
+TRAIN_AV_SP = database.DefineVariable('TRAIN_AV_SP', TRAIN_AV * (SP != 0))
 
-av = {1: TRAIN_AV_SP,
-      2: SM_AV,
-      3: CAR_AV_SP}
+av = {1: TRAIN_AV_SP, 2: SM_AV, 3: CAR_AV_SP}
 
-obsprob = models.logit(V,av,CHOICE)
+obsprob = models.logit(V, av, CHOICE)
 condprobIndiv = PanelLikelihoodTrajectory(obsprob)
 logprob = log(MonteCarlo(condprobIndiv))
 
+
 class test_26(unittest.TestCase):
     def testEstimation(self):
-        biogeme = bio.BIOGEME(database,logprob,seed=10,numberOfDraws=5)
+        biogeme = bio.BIOGEME(database, logprob, seed=10, numberOfDraws=5)
         biogeme.saveIterations = False
         biogeme.generateHtml = False
         biogeme.generatePickle = False
         results = biogeme.estimate()
-        self.assertAlmostEqual(results.data.logLike,-4536.7702705004685,2)
+        self.assertAlmostEqual(results.data.logLike, -4601.85730376285, 2)
+
 
 if __name__ == '__main__':
     unittest.main()
-
-
-
```

